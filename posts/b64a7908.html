<!DOCTYPE html><html lang="ZH-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>Operating System | Artemis`s Blog</title><meta name="keywords" content="操作系统"><meta name="author" content="Artemis"><meta name="copyright" content="Artemis"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="Operating System"><meta name="application-name" content="Operating System"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="Operating System"><meta property="og:url" content="http://sukhoigit.github.io/posts/b64a7908.html"><meta property="og:site_name" content="Artemis`s Blog"><meta property="og:description" content="操作系统1 计算机系统概述1.1 操作系统的基本概念 定义  操作系统（Operating System，OS）是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配；以提供给用户和其他软件方便的接口和环境；它是计算机系统中最基本的系统软件。  特征  并发 并发指两"><meta property="og:locale" content="ZH-CN"><meta property="og:image" content="https://bu.dusays.com/2024/12/09/67566a877214f.png"><meta property="article:author" content="Artemis"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://bu.dusays.com/2024/12/09/67566a877214f.png"><meta name="description" content="操作系统1 计算机系统概述1.1 操作系统的基本概念 定义  操作系统（Operating System，OS）是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配；以提供给用户和其他软件方便的接口和环境；它是计算机系统中最基本的系统软件。  特征  并发 并发指两"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://sukhoigit.github.io/posts/b64a7908"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: '',
  enable_page_level_ads: 'true'
});</script><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: undefined,
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: '',
  commentBarrageConfig:{"enable":true,"maxBarrage":1,"barrageTime":4000,"accessToken":"","mailMd5":""},
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":["🤖️ 数码科技爱好者","🔍 分享与热心帮助","🤝 军事发烧友","🏃 脚踏实地行动派","🚀 航空航天爱好者"]},
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: Artemis","link":"链接: ","source":"来源: Artemis`s Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'Artemis`s Blog',
  title: 'Operating System',
  postAI: '',
  pageFillDescription: '操作系统, 1 计算机系统概述, 1.1 操作系统的基本概念, 1.2 操作系统发展历程, 1.3 操作系统运行环境, 1.3.1 处理器运行模型, 1.3.2 中断和异常的概念, 1.3.3 系统调用, 1.4 操作系统结构, 1.5 操作系统引导, 1.6 虚拟机, 2 进程与线程, 2.1 进程与线程, 2.1.1 进程的概念和特征, 2.1.2 进程的状态与转换, 2.1.3 进程的组织方式, 2.1.4 进程控制, 2.1.5 进程的通信, 2.1.6 线程和多线程模型, 2.2 处理机调度, 2.2.1 调度的概念, 2.2.2 调度的目标, 2.2.3 调度的实现, 2.2.4 典型的调度算法, 2.3 同步与互斥, 2.3.1 同步与互斥的基本概念, 2.3.2 实现临界区互斥的基本方法, 2.3.3 互斥锁, 2.3.4 信号量, 2.3.5 管程, 2.3.6 经典同步问题, 2.4 死锁, 2.4.1 死锁的概念, 2.4.2 死锁预防, 2.4.3 死锁避免, 2.4.4 死锁检测和解除, 3 内存管理, 3.1 内存管理概念, 3.1.1 内存管理的基本原理和要求, 3.1.2 覆盖与交换, 3.1.3 连续分配管理方式, 3.1.4 基本分页存储管理, 3.1.5 基本分段式存储管理, 3.1.6 段页式管理, 3.2 虚拟内存管理, 3.2.1 虚拟内存的基本概念, 3.2.2 请求分页管理方式, 3.2.3 页框分配, 3.2.4 页面置换算法, 3.2.5 抖动和工作集, 3.2.6 内存映射文件, 3.2.7 虚拟存储器性能影响因素, 3.2.8 地址翻译, 4 文件管理, 4.1 文件系统基础, 4.1.1 文件的基本概念, 4.1.2 文件控制块和索引结点, 4.1.3 文件的操作, 4.1.4 文件保护, 4.1.5 文件的逻辑结构, 4.1.6 文件的物理结构, 4.2 目录, 4.2.1 目录的基本概念, 4.2.2 目录结构, 4.2.3 目录的操作, 4.2.4 目录实现, 4.2.5 文件共享, 4.3 文件系统, 4.3.1 文件系统结构, 4.3.2 文件系统布局, 4.3.3 外存空闲空间管理, 4.3.4 虚拟文件系统, 4.3.5 分区和安装, 5 输入x2F输出（Ix2FO）管理, 5.1 Ix2FO管理概述, 5.1.1 Ix2FO设备, 5.1.2 Ix2FO控制方式, 5.1.4 Ix2FO软件层次结构, 5.1.4 应用程序Ix2FO接口, 5.2 设备独立性软件, 5.2.1 与设备无关的软件, 5.2.2 高速缓存与缓冲区, 5.2.3 设备的分配与回收, 5.2.4 SPOOLing技术（假脱机技术）, 5.2.5 设备驱动程序接口, 5.3 磁盘和固态硬盘, 5.3.1 磁盘, 5.3.2 磁盘管理, 5.3.3 磁盘调度算法, 5.3.4 固态硬盘操作系统计算机系统概述操作系统的基本概念定义操作系统是指控制和管理整个计算机系统的硬件和软件资源并合理地组织调度计算机的工作和资源的分配以提供给用户和其他软件方便的接口和环境它是计算机系统中最基本的系统软件特征并发并发指两个或多个事件在同一时间间隔内发生这些事件宏观上是同时发生的但微观上是交替发生的的并发性是通过分时实现的单核同一时刻只能执行一个程序各个程序只能并发地执行多核同一时刻可以同时执行多个程序多个程序可以并行地执行并发性两个或多个事件在同一时间间隔内发生并行性两个或多个事件在同一时刻发生需要硬件支持如多流水线或多处理机硬件环境多道程序环境下一段时间宏观上多道程序同时执行某一时刻单处理机环境下实际仅有一道程序执行微观上程序分时交替执行共享共享即资源共享是指系统中的资源可供内存中多个并发执行的进程共同使用互斥共享方式系统中的某些资源虽然可以提供给多个进程使用但一个时间段内只允许一个进程访问该资源应用使用和微信视频同一时间段内摄像头只能分配给其中一个进程同时共享方式系统中的某些资源允许一个时间段内由多个进程同时对它们进行访问应用使用发送文件同时使用微信发送文件宏观上看两边都在同时读取并发送文件说明两个进程都在访问硬盘资源从中读取数据微观上看两个进程是交替着访问硬盘的所谓的同时往往是宏观上的而在微观上这些进程可能是交替地对该资源进行访问的即分时共享并发和共享是操作系统两个最基本的特征两者之间互为存在的条件资源共享是以程序的并发为条件的若系统不允许程序并发执行则自然不存在资源共享问题若系统不能对资源共享实施有效的管理则必将影响到程序的并发执行甚至根本无法并发执行虚拟虚拟是指把一个物理上的实体变为若干个逻辑上的对应物物理实体前者是实际存在的而逻辑上对应物后者是用户感受到的虚拟处理器通过时分复用技术让多道程序并发执行的方法来分时使用一个处理器的虽然只有一个处理器但它能同时为多个用户服务使每个终端用户都感觉有一个中央处理器在专门为它服务虚拟存储器通过空分复用技术将一台机器的物理存储器变为虚拟存储器以便从逻辑上扩充存储器的容量当然这时用户所感觉到的内存容量是虚的虚拟设备采用虚拟设备技术将一台物理设备虚拟为多台逻辑上的设备并允许每个用户占用一台逻辑上的设备使原来仅允许在一段时间内由一个用户访问的设备即临界资源变为在一段时间内允许多个用户同时访问的共享设备异步在多道程序环境下允许多个程序并发执行但由于资源有限进程的执行不是一贯到底的而是走走停停以不可预知的速度向前推进这就是进程的异步性功能为了给多道程序提供良好的运行环境操作系统应具有以下几方面的功能处理机管理存储器管理设备管理和文件管理为了方便用户使用操作系统还必须向用户提供接口同时操作系统可用来扩充机器以提供更方便的服务更高的资源利用率操作系统是系统资源的管理者处理机管理即对进程的管理包括进程控制进程同步进程通信死锁处理处理机调度等存储器管理方便程序运行用户使用及提高内存的利用率包括内存分配与回收地址映射内存保护与共享和内存扩充等功能文件管理计算机中的信息都是以文件的形式存在的操作系统中负责文件管理的部分称为文件系统文件管理包括文件存储空间的管理目录管理及文件读写管理和保护等设备管理设备管理的主要任务是完成用户的请求方便用户使用各种设备并提高设备的利用率主要包括缓冲管理设备分配设备处理和虚拟设备等功能向上层提供方便易用的服务命令接口用户利用这些操作命令来组织和控制作业的执行联机命令接口即交互式命令接口适用于分时或实时系统雇主说一句话工人做一件事并做出反馈这就强调了交互性脱机命令接口即批处理命令接口适用于批处理系统雇主把要工人做的事写在清单上工人按照清单命令逐条完成这些事这就是批处理程序接口程序接口由一组系统调用也称广义指令组成是为编程人员提供的接口普通用户不能直接使用程序接口只能通过程序代码间接使用用户通过在程序中使用系统调用命令请求为其提供服务系统调用命令又称广义指令图形化用户接口用户可以使用形象的图形界面进行操作而不再需要记忆复杂的命令参数是最接近硬件的一层软件裸机没有任何软件支持的计算机称为裸机它仅构成计算机系统的物质基础在裸机上安装的操作系统可以提供资源管理功能和方便用户的服务功能将裸机改造成功能更强使用更方便的机器通常把覆盖了软件的机器成为扩充机器又称之为虚拟机例操作系统发展历程手工操作阶段此阶段无操作系统用户在计算机上算题的所有工作都要人工干预如程序的装入运行结果的输出等缺点用户独占全机等待手工操作利用不充分人机矛盾和速度不匹配的矛盾批处理阶段操作系统开始出现单道批处理系统引入脱机输入输出技术特征自动性在顺利的情况下磁带上的一批作业能自动地逐个运行而无须人工干预顺序性磁带上的各道作业顺序地进入内存各道作业的完成顺序与它们进入内存的顺序在正常情况下应完全相同亦即先调入内存的作业先完成单道性内存中仅有一道程序运行即监督程序每次从磁带上只调入一道程序进入内存运行当该程序完成或发生异常情况时才换入其后继程序进入内存运行优点缓解人机速度矛盾缺点资源利用率仍低高速等待低速多道批处理系统多道程序设计技术操作系统开始出现多道程序设计允许多个程序同时进入内存并允许它们在中交替地运行这些程序共享系统中的各种硬软件资源当一道程序因请求而暂停运行时便立即转去运行另一道程序特点多道计算机内存中同时存放多道相互独立的程序宏观上并行同时进入系统的多道程序都处于运行过程中即它们先后开始各自的运行但都未运行完毕微观上串行内存中的多道程序轮流占有交替执行间断性由于多道程序之间需要共享和竞争系统资源因此每个程序的执行过程不是连续的而是有间断的共享性多道程序之间需要共享系统的各种资源如内存外设等制约性多道程序之间存在相互制约的关系如同步互斥优先级等技术实现如何分配处理器多道程序的内存分配问题设备如何分配如何组织和存放大量的程序和数据以方便用户使用并保证其安全性与一致性优点资源利用率高多道程序并发执行共享计算机资源系统吞叶量大和其他资源保持忙碌缺点用户响应时间长无人机交互能力分时操作系统分时技术计算机以时间片为单位轮流为各个用户作业服务各个用户可通过终端与计算机进行交互多个用户通过终端同时共享一台主机用户可以同时与主机进行交互操作而互不干扰特点同时性同时性也称多路性指允许多个终端用户同时使用一台计算机即一台计算机与若干台终端相连接终端上的这些用户可以同时或基本同时使用计算机交互性用户能够方便地与系统进行人机对话即用户通过终端采用人机对话的方式直接控制程序运行与同程序进行交互独立性系统中多个用户可以彼此独立地进行操作互不干扰单个用户感觉不到别人也在使用这台计算机好像只有自己单独使用这台计算机一样及时性用户请求能在很短时间内获得响应分时系统采用时间片轮转方式使一台计算机同时为多个终端服务使用户能够对系统的及时响应感到满意优点用户请求可以被即时响应解决了人机交互问题允许多个用户同时使用一台计算机并且用户对计算机的操作相互独立感受不到别人的存在缺点无法优先处理紧急任务实时操作系统能在某个时间限制内完成某些紧急任务而不需要时间片排队分类软实时系统能够接受偶尔违反时间规定且不会引起永久性的损害如飞机订票系统银行管理系统硬实时系统某个动作必须绝对地在规定的时刻或规定的时间范围发生如飞行器的飞行自动控制系统特点及时性可靠性优点能够优先处理紧急任务网络操作系统和分布式计算机系统网络操作系统把计算机网络中的各台计算机有机地结合起来提供一种统一经济而有效的使用各台计算机的方法实现各台计算机之间数据的互相传送特点网络中各种资源的共享各台计算机之间的通信分布式计算机系统由多台计算机组成并满足下列条件的系统主要特点是分布性和并行性系统中任意两台计算机通过通信方式交换信息系统中的每台计算机都具有同等的地位即没有主机也没有从机每台计算机上的资源为所有用户共享系统中的任意台计算机都可以构成一个子系统并且还能重构任何工作都可以分布在几台计算机上由它们并行工作协同完成分布式操作系统与网络操作系统的本质不同分布式操作系统中的若干计算机相互协同完成同一任务个人计算机操作系统个人计算机操作系统是目前使用最广泛的操作系统它广泛应用于文字处理电子表格游戏中常见的有和等操作系统发展历程如下图所示此外还有嵌入式操作系统服务器操作系统智能手机操作系统等例操作系统运行环境处理器运行模型在计算机系统中通常执行两种不同性质的程序操作系统内核程序是用户自编程序的管理者管理程序即内核程序要执行一些特权指令用户自编程序即系统外层的应用程序或简称应用程序被管理程序即用户自编程序出于安全考虑不能执行这特权指令特权指令和非特权指令特权指令是指不允许用户直接使用的指令如指令置中断指令存取用于内存保护的寄存器送程序状态字到程序状态字寄存器等的指令非特权指令是指允许用户直接使用的指令它不能直接访问系统中的软硬件资源仅限于访问用户的地址空间这也是为了防止用户程序对系统造成破坏的运行模式用户态目态处于用户态此时只能执行非特权指令核心态又称管态内核态处于核心态此时可以执行特权指令切换到用户态的指令也是特权指令应用程序运行在用户态操作系统内核程序运行在核心态内核态一用户态一条修改的特权指令用户态一内核态应用程序向操作系统请求服务时通过使用访管指令从而产生一个中断事件将操作系统转换为核心态分层管理一些与硬件关联较紧密的模块如时钟管理中断处理设备驱动等处于最低层其次是运行频率较高的程序如进程管理存储器管理和设备管理等这两部分内容构成了操作系统的内核这部分内容的指令操作工作在核心态操作系统内核功能内核是计算机上配置的底层软件它管理着系统的各种资源可以看作是连接应用程序和硬件的一座桥梁由很多内核程序组成操作系统内核时钟管理计时是时钟的第一功能操作系统需要通过时钟管理向用户提供标准的系统时间进程切换通过时钟中断的管理实现例如在分时操作系统中采用时间片轮转调度在实时系统中按截止时间控制运行在批处理系统中通过时钟管理来衡量一个作业的运行程度等中断机制中断作用让操作系统内核强行夺回的控制权使从用户态变为内核态引入原因提高多道程序运行环境中的利用率现代操作系统是靠中断驱动的软件原语由若干条指令组成的用于完成一定功能的一个过程特点处于操作系统的最底层是最接近硬件的部分这些程序的运行具有原子性其操作只能一气呵成出于系统安全性和便于管理考虑这些程序的运行时间都较短而且调用频繁定义原语的直接方法是关闭中断让其所有动作不可分割地完成后再打开中断系统中的设备驱动切换进程通信等功能中的部分操作都可定义为原语使它们成为内核的组成部分系统控制的数据结构及处理系统中用来登记状态信息的数据结构很多如作业控制块进程控制块设备控制块各类链表消息队列缓冲区空闲区登记表内存分配表等为了实现有效的管理系统需要一些基本的操作常见的操作有以下种进程管理进程状态管理进程调度和分派创建与撤销进程控制块等存储器管理存储器的空间分配和回收内存信息保护程序代码对换程序等设备管理缓冲区管理设备分配和回收等核心态指令实际上包括系统调用类指令和一些针对时钟中断和原语的操作指令中断和异常的概念中断作用让操作系统内核强行夺回的控制权使从用户态变为内核态中断和异常的分类异常又称内中断指来自执行指令内部的事件如程序的非法操作码地址越界运算溢出虚存系统的缺页及专门的陷入指令等引起的事件故障通常是由指令执行引起的异常如非法操作码缺页故障除数为运算溢出等自陷是一种事先安排的异常事件用于在用户态下调用操作系统内核程序如条件陷阱指令终止是指出现了使得无法继续执行的硬件故障如控制器出错存储器校验错等中断又称外中断指来自执行指令外部的事件通常用于信息输入输出如中断时钟中断可屏蔽中断指通过线发出的中断请求通过改变屏蔽字可以实现多重中断从而使得中断处理更加灵活不可屏蔽中断指通过线发出的中断请求通常是紧急的硬件故障如电源掉电等此外异常也是不能被屏蔽的故障异常和自陷异常属于软件中断程序性异常终止异常和外部中断属于硬件中断异常不能被屏蔽一旦出现就应立即处理中断和异常的处理过程当在执行用户程序的第条指令时检测到一个异常事件或在执行第条指令后发现一个中断请求信号则打断当前的用户程序然后转到相应的中断或异常处理程序去执行若中断或异常处理程序能够解决相应的问题则在中断或异常处理程序的最后通过执行中断或异常返回指令回到被打断的用户程序的第条指令或第条指令继续执行返回第条指令由自陷引起的内中断如系统调用由外部设备引起的外中断如键盘返回第条指令由故障引起的内中断如缺页等若中断或异常处理程序发现是不可恢复的致命错误则终止用户程序通常情况下对中断和异常的具体处理过程由操作系统和驱动程序完成系统调用定义操作系统作为用户和计算机硬件之间的接口需要向上提供一些简单易用的服务系统调用可视为特殊的公共子程序又称广义指令程序接口由一组系统调用组成目的为解决资源分配问题分类设备管理完成设备的请求或释放以及设备启动等功能文件管理完成文件的读写创建及删除等功能进程控制完成进程的创建撤销阻塞及唤醒等功能进程通信完成进程之间的消息传递或信号传递等功能内存管理完成内存的分配回收以及获取作业占用内存区大小及始址等功能系统调用过程系统调用的处理需要由操作系统内核程序负责完成要运行在核心态用户程序可以执行陷入指令又称访管指令或指令来发起系统调用请求操作系统提供服务访管指令不是特权指令访管指令是在用户态使用的所以它不可能是特权指令系统调用执行过程传递系统调用参数执行陷入指令执行相应的服务程序返回用户态当需要管理程序服务时系统则通过硬件中断机制进入核心态运行管理程序也可能是程序运行出现异常情况被动地需要管理程序的服务这时就通过异常处理来进入核心态管理程序运行结束时用户程序需要继续运行此时通过相应的保存的程序现场退出中断处理程序或异常处理程序返回断点处继续执行用户态转向核心态的例子用户程序要求操作系统的服务即系统调用发生一次中断用户程序中产生了一个错误状态用户程序中企图执行一条特权指令从核心态转向用户态由一条指令实现这条指令也是特权命令一般是中断返回指令只能在核心态下执行的指令特权指令开关中断指令用于允许或禁止中断控制中断屏蔽位设置时钟日期指令用于修改系统时钟改变存储映像图指令用于修改主存保护机制启动指令用于控制设备的工作状态和动作加载指令用于修改程序状态字包括中断标志位运算结果标志位等置特殊寄存器指令用于存取中断寄存器时钟寄存器等特殊寄存器停机指令用于停止一个中央处理器的工作注意由用户态进入核心态不仅状态需要切换而且所用的堆栈也可能需要由用户堆栈切换为系统堆栈但这个系统堆栈也是属于该进程的与库函数的区别有的库函数是对系统调用的进一步封装如创建一个新文件的函数有的库函数没有使用系统调用如的取绝对值的函数例操作系统结构分层法分层法是将操作系统分为若干层最底层层为硬件最高层层为用户接口每层只能调用紧邻它的低层的功能和服务单向依赖优点便于系统的调试和验证简化了系统的设计和实现只需调试每层功能无需考虑其他层易扩充和易维护在系统中修改添加某层不改变接口就不影响其他层缺点合理定义各层比较困难因为依赖关系固定后往往就显得不够灵活效率较差执行一个功能要穿梭多层每层通信增大开销模块化模块化是将操作系统按功能划分为若干具有一定独立性的模块每个模块具有某方面的管理功能并规定好各模块间的接口使各模块之间能够通过接口进行通信各模块还可划分成子模块子模块之间也规定好接口模块划分应考虑其划分大小及独立性衡量独立性有两个标准内聚性模块内部各部分间联系的紧密程度内聚性越高模块独立性越好耦合度模块间相互联系和相互影响的程度耦合度越低模块独立性越好优点提高了操作系统设计的正确性可理解性和可维护性增强了操作系统的可适应性加速了操作系统的开发过程缺点模块间的接口规定很难满足对接口的实际需求各模块设计者齐头并进每个决定无法建立在上一个已验证的正确决定的基础上因此无法找到一个可靠的决定顺序宏内核又称大内核或单内核是指将系统的主要功能模块都作为一个紧密联系的整体运行在核心态从而为用户程序提供高性能的系统服务优点高性能缺点内核代码庞大结构混乱难以维护应用等架构但其都广泛吸取微内核的优点进行改进微内核微内核构架是指将内核中最基本的功能保留在内核而将那些不需要在核心态执行的功能移到用户态执行从而降低内核的设计复杂性那些移出内核的操作系统代码根据分层的原则被划分成若干服务程序它们的执行相互独立交互则都借助于微内核进行通信微内核架构微内核多个服务器微内核内容与硬件处理紧密相关的部分一些较基本的功能客户和服务器之间的通信服务器进程用于提供对进程线程进行管理的进程线程服务器提供虚拟存储器管理功能的虚拟存储器服务器等它们都是作为进程来实现的运行在用户态客户与服务器之间是借助微内核提供的消息传递机制来实现交互的下图为单机环境下的客户服务器模式微内核基本功能进程线程管理如进程线程之间通信切换调度以及多处理机之间的同步低级存储器管理如用于实现将逻辑地址变换为物理地址等的页表机制和地址变换机制这一部分是依赖于硬件的因此放入微内核中断和陷入处理捕获所发生的中断和陷入事件并进行中断响应处理在识别中断或陷入的事件后再发送给相关的服务器来处理微内核特点扩展性和灵活性增添新的功能无需改变内核代码只需在相应服务器中修改添加新功能可靠性和安全性某个模块崩溃时只会使该进程崩溃不会使整个系统崩溃可移植性与和硬件有关的代码均放在内核中移植代码无需考虑硬件差异分布式计算采用消息传递机制使微内核系统能很好地支持分布式系统和网络系统微内核缺点需要频繁地在核心态和用户态之间切换性能低应用鸿蒙实时工业航空及军事应用外核内核负责进程调度进程通信等功能外核在内核态运行负责为用户进程分配未经抽象的硬件资源且由外核负责保证资源使用安全任务为虚拟机分配资源并检查使用这些资源的企图以确保没有机器会使用他人的资源每个用户层的虚拟机可以运行自己的操作系统但限制只能使用已经申请并且获得分配的那部分资源优点外核可直接给用户进程分配不虚拟不抽象的硬件资源使用户进程可以更灵活的使用硬件资源减少了虚拟硬件资源的映射层提升效率缺点降低了系统的一致性使系统变得更复杂操作系统引导概念程序是固化在主板上的基本输入输出系统是计算机启动第一个运行的软件存放在中它会进行硬件初始化和自检然后查找引导程序并执行引导程序引导程序是存储在主存中的一段小程序它的作用是将操作系统的内核文件从硬盘中读取到内存中并跳转到内核入口点开始执行主引导记录是硬盘的主引导记录位于硬盘的第一个扇区它包含了磁盘引导程序和分区表该引导程序会找到活动分区并读取其分区引导记录完成硬盘的引导分区引导记录是分区引导记录位于每个分区的第一个扇区中包含了一个引导程序可以寻找并激活分区根目录下的启动管理器完成分区的引导过程引导过程引导过程从一个特定主存地址开始取指令执行中的引导程序先进行硬件自检再开机初始化并执行引导程序进行自检确保硬件工作正常查找可引导设备通常是安装有操作系统的硬盘读取主引导记录将磁盘的第一块一一主引导记录读入内存执行磁盘引导程序扫描分区表执行识别活动分区查找并执行该分区的分区引导记录从活动分区又称主分区即安装了操作系统的分区读入分区引导记录执行其中的程序找到分区中操作系统的启动管理器程序并加载执行从根目录下找到完整的操作系统初始化程序即启动管理器并执行完成开机的一系列动作启动管理器进一步加载操作系统内核和关键组件到内存操作系统内核接管硬件控制权初始化系统启动操作系统注操作系统最终被加载到中虚拟机定义使用虚拟化技术将一台物理机器虚拟化为多台虚拟机器每个虚拟机器都可以独立运行一个操作系统分类第一类虚拟机程序第一类虚拟机管理程序就像一个操作系统因为它是唯一一个运行在最高特权级的程序它在裸机上运行并且具备多道程序功能虚拟机管理程序向上层提供若干台虚拟机这些虚拟机是裸机硬件的精确复制品由于每台虚拟机都与裸机相同所以在不同的虚拟机上可以运行任何不同的操作系统虚拟内核态虚拟机作为用户态的一个进程运行不允许执行敏感指令然而虚拟机上的操作系统认为自己运行在内核态实际上不是称为虚拟内核态第二类虚拟机程序它是一个依赖于等操作系统分配和调度资源的程序很像一个普通的进程如对于第二类虚拟机管理程序运行在底层硬件上的操作系统称为宿主操作系统运行在虚拟机管理程序上的操作系统称为客户操作系统首次启动时第二类虚拟机管理程序像一台刚启动的计算机那样运转期望找到的驱动器可以是虚拟设备然后将操作系统安装到虚拟磁盘上其实只是宿主操作系统中的一个文件客户操作系统安装完成后就能启动并运行对比第一类第二类对物理资源的控制权直接运行在硬件之上能直接控制和分配物理资源运行在之上依赖于为其分配物理资源资源分配方式在安装时要在原本的硬盘上自行分配存储空间类似于外核的分配方式分配未经抽象的物理硬件拥有自己的虚拟磁盘该盘实际上是文件系统中的一个大文件分配到的内存是虚拟内存性能性能更好性能更差需要作为中介可支持的虚拟机数量更多不需要和竞争资源相同的硬件资源可以支持更多的虚拟机更少本身需要使用物理资源上运行的其他进程也需要物理资源虚拟机的可迁移性更差更好只需导出虚拟机镜像文件即可迁移到另一台上商业化应用更广泛运行模式第一类运行在最高特权级可以执行最高特权的指令第二类部分运行在用户态部分运行在内核态发出的系统调用会被截获并转化为对的系统调用例进程与线程进程与线程进程的概念和特征进程的概念进程是进程实体的运行过程是系统进行资源分配和调度的一个独立单位进程实现操作系统的并发性和共享性程序是静态的就是个存放在磁盘里的可执行文件如进程是动态的是程序的一次执行过程或者是一个正在运行的程序如可同时启动多次程序进程实体即进程映像是静态的可理解为进程的一次时刻的状态作业用户向计算机提交的一项任务是静态的它通常是一个批处理程序或一个后台程序进程实体的组成程序控制块是进程存在的唯一标志当进程被创建时操作系统为其创建当进程结束时会回收其进程描述信息进程标识符当进程被创建时操作系统会为该进程分配一个唯一的不重复的身份证号进程用户标识符进程控制和管理信息磁盘网络流量使用情况统计进程当前状态就绪态阻塞态运行态资源分配清单正在使用哪些文件正在使用哪些内存区域正在使用哪些设备处理机相关信息现场信息如等等各种寄存器的值用于实现进程切换即进程控制块操作系统需要对各个并发运行的进程进行管理但凡管理时所需要的信息都会被放在中是进程存在的唯一标志存于内存的内核区注意内存的内核区和的内核态的区别内核程序运行在内核态程序段程序的代码指令序列数据段运行过程中产生的各种数据如程序中定义的变量是给操作系统用的程序段和数据段是给进程自己用的引入进程实体的概念后可把进程定义为是进程实体的运行过程是系统进行资源分配和调度的一个独立单位进程的特征动态性进程是程序的一次执行过程是动态地产生变化和消亡的动态性是进程最基本的特征并发性内存中有多个进程实体各进程可并发执行独立性进程是能独立运行独立获得资源独立接受调度的基本单位异步性各进程按各自独立的不可预知的速度向前推进异步性会导致并发程序执行结果的不确定性结构性每个进程都会配置一个结构上看进程由程序段数据段组成进程的状态与转换基本状态运行态占有并在上运行其他所需资源就绪态已具有运行条件但无空闲暂时不能运行其他所需资源系统中处于就绪状态的进程可能有多个通常将它们排成一个队列称为就绪队列阻塞态又称等待态因等待某一事件暂时不能运行其他所需资源系统通常将处于阻塞态的进程也排成一个队列甚至根据阻塞原因的不同设置多个阻塞队列创建态进程正在被创建尚未转到就绪态为进程分配系统资源初始化首先申请一个空白并向中填写用于控制和管理进程的信息然后为该进程分配运行时所必须的资源最后把该进程转入就绪态并插入就绪队列但是如果进程所需的资源尚不能得到满足如内存不足则创建工作尚未完成进程此时所处的状态称为创建态终止态进程正从系统中消失进程正常结束或其他原因退出运行回收进程拥有的资源撤销进程状态的转换就绪态一运行态进程被调度运行态一就绪态时间片到被其他进程抢占运行态一阻塞态等待系统资源分配等待某事件发生主动行为阻塞态一就绪态资源分配到位等待的事件发生被动行为创建态一就绪态系统完成创建进程相关的工作运行态一终止态进程运行结束运行过程中遇到不可修复的错误进程的组织方式链接方式链接方式是将同一状态的进程的组成一个双向链表称为进程队列结构每个队列的队首和队尾都有一个指针指向第一个和最后一个每个中也有两个指针分别指向前一个和后一个这样就可以方便地在队列中插入或删除优点简单灵活缺点查找效率低需要遍历链表索引方式索引方式是将所有的存放在一张索引表中每个表项包含一个的地址和状态信息结构索引表可以是顺序表或散列表可以按照进程号或其他关键字进行排序或散列优点查找效率高可以快速定位到某个缺点需要额外的空间存储索引表且索引表的大小受限于内存容量进程控制进程控制就是要实现进程状态的转换通过原语实现进程的创建创建原语操作系统创建一个进程时使用的原语其操作如下创建态就绪态申请空白为新进程分配所需资源初始化将插入就绪队列引起进程创建的事件用户登录分时系统中用户登录成功系统会建立为其建立一个新的进程作业调度多道批处理系统中有新的作业放入内存时会为其建立一个新的进程提供服务用户向操作系统提出某些请求时会新建一个进程处理该请求应用请求由用户进程主动请求创建一个子进程父子进程允许一个进程创建另一个进程此时创建者称为父进程被创建的进程称为子进程进程可以继承父进程所拥有的资源当子进程被撤销时应将其从父进程那里获得的资源归还给父进程在撤销父进程时通常也会同时撤销其所有的子进程进程的终止撤销原语其操作如下就绪态阻塞态运行态终止态无从集合中找到终止进程的若进程正在运行立即剥夺将分配给其他进程终止其所有子进程将该进程拥有的所有资源归还给父进程或操作系统删除引起进程终止的事件正常结束进程自已请求终止系统调用异常结束整数除以非法使用特权指令然后被操作系统强行杀掉外界干预用户选择杀掉进程进程的阻塞阻塞原语其操作如下运行态阻塞态找到要阻塞的进程对应的保护进程运行现场将状态信息设置为阻塞态暂时停止进程运行将插入相应事件的等待队列引起进程阻塞的事件需要等待系统分配某种资源需要等待相互合作的其他进程完成工作进程的唤醒唤醒原语其操作如下阻塞态就绪态在事件等待队列中找到将从等待队列移除设置进程为就绪态将插入就绪队列等待被调度引起进程唤醒的事件等待的事件发生因何事阻塞就应由何事唤醒阻塞原语唤醒原语必须成对使用进程的切换切换原语其操作如下运行态就绪态就绪态运行态将运行环境信息存入移入相应队列选择另一个进程执行并更新其根据恢复新进程所需的运行环境引起进程切换的事件当前进程时间片到有更高优先级的进程到达当前进程主动阻塞当前进程终止进程的通信低级通信方式操作高级通信方式共享存储消息传递管道通信共享存储设置一个共享空间通过对其进行读写操作实现信息交换在对共享空间进行写读操作时需要使用同步互斥工具如操作共享存储分为两种低级方式基于数据结构的共享比如共享空间里只能放一个长度为的数组这种共享方式速度慢限制多是一种低级通信方式高级方式基于存储区的共享操作系统在内存中划出一块共享存储区数据的形式存放位置都由通信进程控制而不是操作系统这种共享方式速度很快是一种高级通信方式进程之间共享空间需要通过特殊的系统调用实现进程内线程共享进程空间消息传递在消息传递系统中进程间的数据交换以格式化的消息为单位进程通过操作系统提供的发送消息接收消息两个原语进行数据交换在微内核操作系统中微内核与服务器之间的通信就采用了消息传递机制消息格式消息头发送进程接受进程消息长度等格式化的信息消息体通信方式直接通信方式发送进程直接把消息发送给接收进程并将它挂在接收进程的消息缓冲队列上接收进程从消息缓冲队列中取得消息间接通信方式送进程通过信箱间接地通信将消息发送到某个中间实体接收进程从中间实体取得消息该通信方式广泛应用于计算机网络中注可以多个进程往同一个信箱消息也可以多个进程从同一个信箱中消息用发送原语和接收原语实现基于信箱的进程间通信管道通信管道是一个特殊的共享文件又名文件其实就是在内存中开辟一个大小固定的内存缓冲区管道通信允许两个进程按生产者消费者方式进行通信各进程要互斥访问管道写满时不能再写读空时不能再读没写满时不能读没读空时不能写一个管道只能实现半双工通信实现双向同时通信要建立两个管道管道本质上是一种特殊的文件相比于普通的文件通信其区别如下限制管道的大小管道文件是一个固定大小的缓冲区使得它的大小不像普通文件那样不加检验地增长读进程也可能工作得比写进程快读空时再读管道会被阻塞而不是调用返回文件结束管道中的数据一旦被读出就彻底消失因此当多个进程读同一个管道时可能会错乱对此通常有两种解决方案一个管道允许多个写进程一个读进程年真题高教社官方答案允许有多个写进程多个读进程但系统会让各个读进程轮流从管道中读数据的方案管道只能由创建进程所访问当父进程创建一个管道后由于管道是一种特殊文件子进程会继承父进程的打开文件因此子进程也继承父进程的管道并使用它来与父进程进进行通信线程和多线程模型线程的基本概念线程可理解为轻量级进程它是一个基本的执行单元也是程序执行流的最小单位线程由线程程序计数器寄存器集合和堆栈组成引入进程的目的是更好地使多道程序并发执行提高资源利用率和系统吞吐量而引入线程的目的则是减小程序在并发执行时所付出的时空开销提高操作系统的并发性能引入线程后进程只作为除外的系统资源的分配单位线程则作为处理机的分配单元线程与进程的比较传统进程机制引入线程后资源分配调度进程是资源分配调度基本单位进程是资源分配基本单位线程是资源调度基本单位并发性进程间并发线程间也能并发拥有资源拥有资源的基本单位不拥有系统资源独立性进程间独立地址空间和资源同进程下的线程共享地址空间和资源系统开销需要切换进程运行环境开销大同一进程内线程不需切换进程环境开销小支持多处理机系统进程只能运行在一个处理机上进程中多个线程可以分配到多个处理机执行线程的属性多线程操作系统中的进程已不再是一个基本的执行实体但它仍具有与执行相关的状态所谓进程处于执行状态实际上是指该进程中的某线程正在执行线程是处理机调度的单位多计算机中各个线程可占用不同的每个线程都有一个线程线程控制块线程也有就绪阻塞运行三种基本状态线程几乎不拥有系统资源同一进程的不同线程间共享进程的资源由于共享内存地址空间同一进程中的线程间通信甚至无需系统干预同一进程中的线程切换不会引起进程切换不同进程中的线程切换会引起进程切换切换同进程内的线程系统开销很小切换进程系统开销较大注线程是处理机调度的单位这里的线程指的是操作系统看得见的内核级线程内核级线程是处理机分配的单位同进程的线程之间可以共享进程的代码段全局变量打开的文件不共享线程各自的栈指针等内容线程的实现方式线程的实现可以分为两类用户级线程和内核级线程内核级线程又称内核支持的线程用户级线程在用户级线程中有关线程管理创建撤销和切换等的所有工作都由应用程序在用户空间中完成内核意识不到线程的存在因此说用户级线程对操作系统透明用户级线程由应用程序通过线程库实现所有的线程管理工作都由应用程序负责包括线程切换用户级线程中线程切换可以在用户态下即可完成无需操作系统干预在用户看来是有多个线程但是在操作系统内核看来并意识不到线程的存在用户级线程就是从用户视角看能看到的线程若系统中只有用户级线程则处理机的调度对象是进程优点用户级线程的切换在用户空间即可完成不需要切换到核心态线程管理的系统开销小效率高缺点当一个用户级线程被阻塞后整个进程都会被阻塞并发度不高多个线程不可在多核处理机上并行运行内核级线程内核级线程是在内核的支持下运行的线程管理的所有工作也是在内核空间内实现的内核级线程的管理工作由操作系统内核完成线程调度切换等工作都由内核负责因此内核级线程的切换必然需要在核心态下才能完成操作系统会为每个内核级线程建立相应的线程控制块通过对线程进行管理内核级线程就是从操作系统内核视角看能看到的线程优点当一个线程被阻塞后别的线程还可以继续执行并发能力强多线程可在多核处理机上并行执行缺点一个用户进程会占用多个内核级线程线程切换由操作系统内核完成需要切换到核心态因此线程管理的成本高开销大用户级线程内核级线程线程的管理工作由谁来完成由应用程序通过线程库实现所有的线程管理工作包括线程切换线程管理工作由操作系统内核完成线程切换是否需要变态用户级线程切换可以在用户态下即可完成无需操作系统干预线程调度切换等工作都由内核负责因此内核级线程的切换必然需要在核心态下才能完成是否能意识到用户级线程的存在内核意识不到用户级线程的存在用户级线程就是从用户视角看能看到的线程会为每个内核级线程建立相应的线程控制块通过对线程进行管理内核级线程就是从操作系统内核视角看能看到的线程优点用户级线程的切换在用户空间即可完成不需要切换到核心态线程管理的系统开销小效率高当一个线程被阻塞后其他线程还可以继续执行并发能力强多线程可在多核处理机上并行执行缺点当一个用户级线程被阻塞后整个进程都会被阻塞并发度不高因为进程是处理机调度的基本单位同一进程的多个线程不可在多核处理机上并行运行一个用户进程会占用多个内核级线程线程切换由操作系统内核完成需要切换到核心态因此线程管理的开销大效率低成本高组合方式有些系统使用组合方式的多线程实现在组合实现方式中内核支持多个内核级线程的建立调度和管理同时允许用户程序建立调度和管理用户级线程一些内核级线程对应多个用户级线程这是用户级线程通过时分多路复用内核级线程实现的同一进程中的多个线程可以同时在多处理机上并行执行且在阻塞一个线程时不需要将整个进程阻塞线程库线程库是为程序员提供创建和管理线程的实现方式有以下两种在用户空间中提供一个没有内核支持的库这种库的所有代码和数据结构都位于用户空间中这意味着调用库内的一个函数只导致用户空间中的一个本地函数的调用实现由操作系统直接支持的内核级的一个库对于这种情况库内的代码和数据结构位于内核空间调用库中的一个函数通常会导致对内核的系统调用多线程模型一对一模型一个用户级线程映射到一个内核级线程每个用户进程有与用户级线程同数量的内核级线程优点当一个线程被阻塞后别的线程还可以继续执行并发能力强多线程可在多核处理机上并行执行内核级线程优点缺点一个用户进程会占用多个内核级线程线程切换由操作系统内核完成需要切换到核心态因此线程管理的成本高开销大内核级线程缺点多对一模型多个用户级线程映射到一个内核级线程且一个进程只被分配一个内核级线程优点用户级线程的切换在用户空间即可完成不需要切换到核心态线程管理的系统开销小效率高用户级线程优点缺点当一个用户级线程被阻塞后整个进程都会被阻塞并发度不高多个线程不可在多核处理机上并行运行用户级线程缺点多对多模型用户及线程映射到个内核级线程每个用户进程对应个内核级线程克服了多对一模型并发度不高的缺点一个阻塞全体阻塞又克服了一对一模型中一个用户进程占用太多内核级线程开销太大的缺点还拥有上述两种模型各自的优点线程的状态与转换线程的组织与控制线程控制块与进程类似系统也为每个线程配置一个线程控制块用于记录控制和管理线程的信息线程控制块通常包括线程标识符一组寄存器包括程序计数器状态寄存器和通用寄存器线程运行状态用于描述线程正处于何种状态优先级线程专有存储区线程切换时用于保存现场等堆栈指针用于过程调用时保存局部变量及返回地址等同一进程中的所有线程都完全共享进程的地址空间和全局变量各个线程都可以访问进程地址空间的每个单元所以一个线程可以读写或甚至清除另一个线程的堆栈线程的创建用户程序启动时通常仅有一个称为初始化线程的线程正在执行其主要功能是用于创建新线程在创建新线程时需要利用一个线程创建函数并提供相应的参数如指向线程主程序的入口指针堆栈的大小线程优先级等线程创建函数执行完后将返回一个线程标识符线程的终止当一个线程完成自己的任务后或线程在运行中出现异常而要被强制终止时由终止线程调用相应的函数执行终止操作但是有些线程主要是系统线程一旦被建立便一直运行而不会被终止通常线程被终止后并不立即释放它所占有的资源只有当进程中的其他线程执行了分离函数后被终止线程才与资源分离此时的资源才能被其他线程利用被终止但尚未释放资源的线程仍可被其他线程调用以使被终止线程重新恢复运行例进程之间独立地址空间独立资源但也可以通过通信机制交换资源这些线程属于内核进程它们在内核空间中运行不受用户进程的影响因此库中的系统线程是唯一的不会因为被不同的进程调用而产生多个副本处理机调度调度的概念调度的基本概念处理机调度是对处理机进行分配即从就绪队列中按照一定的算法公平高效的原则去选择一个进程并将处理机分配给它运行以实现进程并发地执行调度对层次一个作业从提交开始直到完成要经历以下三级调度如下图所示高级调度作业调度内存空间有限时无法将用户提交的作业全部放入内存需要按一定的原则从外存的作业后备队列中挑选一个作业调入内存并创建进程每个作业只调入一次调出一次作业调入时会建立调出时才撤销作业一个具体的任务多道批处理系统中大多配有作业调度而其他系统中通常不需要配置作业调度发生频率最低外存内存面向作业中级调度内存调度内存不够时可将某些进程的数据调出外存等内存空闲或者进程需要运行时按照某种策略从挂起队列中选择合适的进程重新调入内存暂时调到外存等待的进程状态为挂起状态被挂起的进程会被组织成挂起队列外存内存面向进程低级调度进程调度在内存中的按照某种策略从就绪队列中选取一个进程将处理机分配给它发生频率高内存三级调度的联系七状态模型挂起和阻塞的区别两种状态都不获得服务但挂起状态将进程调到外存而阻塞态还在内存中三层调度对比要做什么在哪调度发生频率对进程状态影响高级调度作业调度从后备队列中选择合适的作业将其调入内存并为其创建进程外存内存面向作业最低无创建态就绪态中级调度内存调度从挂起队列中选择合适的进程将其数据调回内存外存内存面向进程中等挂起态就绪态阻塞挂起阻塞态低级调度进程调度从就绪队列中选择一个进程为其分配处理机内存最高就绪态运行态三层调度联系作业调度为进程活动做准备进程调度使进程正常活动起来中级调度将暂时不能运行的进程挂起中级调度处于作业调度和进程调度之间作业调度次数少中级调度次数略多进程调度频率最高进程调度是最基本的不可或缺调度的目标不同的调度算法具有不同的特性在选择调度算法时必须考虑算法的特性评价标准如下利用率指忙碌的时间占总时间的比例利用率忙碌的时间总时间系统吞吐率单位时间内完成作业的数量系统吞吐率总共完成了多少道作业总共花了多少时间周转时间指从作业被提交给系统开始到作业完成为止的这段时间间隔周转时间作业完成时间作业提交时间平均周转时间指多个作业周转时间的平均值平均周转时间各个作业周转时间之和作业数带权周转时间作业周转时间与作业实际运行时间的比值带权周转时间必然带权周转时间作业周转时间作业实际运行时间作业完成时间作业提交时间作业实际运行时间平均带权周转时间多个作业带权周转时间的平均值平均带权周转时间各个作业带权周转时间之和作业数等待时间等待时间指进程作业处于等待处理机状态时间之和等待时间越长用户满意度越低等待时间周转时间运行时间对于进程来说等待时间就是指进程建立后等待被服务的时间之和对于作业来说不仅要考虑建立进程后的等待时间还要加上作业在外存后备队列中等待的时间平均等待时间各个进程作业等待时间的平均值平均等待时间各个进程作业等待时间之和进程作业数响应时间从用户提交请求到首次产生响应所用的时间调度的实现调度程序调度器用于调度和分派的组件称为调度程序它通带由三部分组成如图所示排队器将系统中的所有就绪进程按照一定的策略排成一个或多个队列以便于调度程序选择每当有一个进程转变为就绪态时排队器便将它插入到相应的就绪队列中分派器依据调度程序所选的进程将其从就绪队列中取出将分配给新进程上下文切换器在对处理机进行切换时会发生两对上下文的切换操作第一对将当前进程的上下文保存到其中再装入分派程序的上下文以便分派程序运行第二对移出分派程序的上下文将新选进程的现场信息装入处理机的各个相应寄存器调度的时机需要调度主动放弃进程正常终止运行过程中发生异常而终止主动阻塞比如等待被动放弃时间片用完有更紧急的事情处理中断有更高优先级的进程进入就结队列不能调度处理中断的过程中进程在操作系统内核程序临界区中原子操作过程中临界资源一个时间段内只允许一个进程使用的资源各进程需要互斥地访问临界资源临界区访问临界资源的那段代码内核程序临界区一般是用来访问某种内核数据结构的比如进程的就绪队列由各就绪进程的组成进程调度方式非剥夺调度方式又称非抢占方式即只允许进程主动放弃处理机在运行过程中即便有更紧迫的任务到达当前进程依然会继续使用处理机直到该进程终止或主动要求进入阻塞态实现简单系统开销小但是无法及时处理紧急任务适合于早期的批处理系统剥夺调度方式又称抢占方式当一个进程正在处理机上执行时如果有一个更重要或更紧迫的进程需要使用处理机则立即暂停在执行的进程将处理机分配给更重要紧迫的那个进程可以优先处理更紧急的进程也可实现让各进程按时间片轮流执行的功能通过时钟中断适合于分时操作系统实时操作系统进程切换上下文切换切换到另一个进程需要保存当前进程状态并恢复另一个进程的状态对原来运行进程各种数据的保存对新的进程各种数据的恢复如程序计数器程序状态字各种数据寄存器等处理机现场信息这些信息一保存在进程控制块上下文某一时刻寄存器和程序计数器的内容切换流程挂起一个进程保存上下文包括程序计数器和其他寄存器更新信息把进程的移入相应的队列如就绪在某事件阻塞等队列选择另一个进程执行并更新其跳转到新进程中的程序计数器所指向的位置执行恢复处理机上下文上下文切换的消耗上下文切换需要消耗大量时间有些处理器有多个寄存器组则切换只需改变指针进程切换是有代价的因此如果过于频繁的进行进程调度切换必然会使整个系统的效率降低使系统大部分时间都花在了进程切换上而真正用于执行进程的时间减少上下文切换与模式切换模式切换是用户态和内核态之间的切换逻辑上可能还在执行同一进程用户进程最开始都运行在用户态若进程因中断或异常进入核心态运行执行完后又回到用户态刚被中断的进程运行上下文切换切换了进程只能发生在内核态它是多任务操作系统中的一个必需的特性闲逛进程调度程序永远的备胎没有其他就绪进程时运行闲逛进程特性优先级最低可以是地址指令占一个完整的指令周期指令周期末尾例行检查中断能耗低闲逛进程不需要之外的资源它不会被阻塞两种线程的调度用户级线程调度由于内核并不知道线程的存在所以内核还是和以前一样选择一个进程并给予时间控制由进程中的调度程序决定哪个线程运行内核级线程调度内核选择一个特定线程运行通常不用考虑该线程属于哪个进程对被选择的线程赋予一个时间片如果超过了时间片就会强制挂起该线程用户级线程的线程切换在同一进程中进行仅需少量的机器指令内核级线程的线程切换需要完整的上下文切换修改内存映像使高速缓存失效这就导致了若干数量级的延迟典型的调度算法先来先服务算法思想主要从公平的角度考虑类似于我们生活中排队买东西的例子算法规则按照作业进程到达的先后顺序进行服务用于作业进程调度用于作业调度时考虑是哪作业先达后备队列用于进程调度时考虑的是哪个进程先到达就绪队列优缺点优点公平算法实现简单缺点排在长作业进程后面的短作业需要等待很长时间带权周转时间很大对短作业来说用户体验不好即算法对长作业有利对作排队非抢占式的算法不会导致饥饿短作业优先算法思想追求最少的平均等待时间最少的平均周转时间最少的平均平均带权周转时间算法规则最短的作业进程优先得到服务所谓最短是指要求服务时间最短用于作业进程调度即可用于作业调度也可用于进程调度用于进程调度时为短进程优先优缺点优点最短的平均等待时间平均周转时间在所有进程都几乎同时到达时采用调度算法的平均等待时间平均周转时间最少抢占式的短作业进程优先调度算法最短剩余时间优先算法的平均等待时间平均周转时间最少缺点不公平对短作业有利对长作业不利可能产生饥饿现象另外作业进程的运行时间是由用户提供的并不一定真实不一定能做到真正的短作业优先抢占式的算法会导致饥饿和是非抢占式的算法但是也有抢占式的版本最剩间优先算法每当有进程加入就绪队列改变时就需要调度如果新到达的进程剩余时间比当前运行的进程剩余时间更短则由新进程抢占处理机当前运行进程重新回到就绪队列另外当一个进程完成时也需要调度高响应比优先算法思想要综合考虑作业进程的等待时间和要求服务的时间算法规则在每次调度时先计算各个作业进程的响应比选择响应比最高的作业进程为其服务响应比等待时间要求服务时间要求服务时间高响应比优先算法非抢占式的调度算法只有当前运行的进程主动放常常成主动阻塞需行调度调度时计算所有就绪进程的响应比选响应比最高的进程上处理机用于作业进程调度即可用于作业调度也可用于进程调度优缺点综合考虑了等待时间和运行时间要求服务时间等待时间相同时要求服务时间短的优先的优点要求服务时间相同时等待时间长的优先的优点对于长作业来说随着等待时间越来越久其响应比也会越来越大从而避免了长作业饥饿的问题非抢占式的算法不会导致饥饿非抢占式的算法因此只有当前运行的作业进程主动放弃处理机时才需要调度计算响应比时间片轮转调度算法算法思想公平地轮流地为各个进程服务让每个进程在一定时间间隔内都可以得到响应算法规则按照各进程到达就绪队列的顺序轮流让各个进程执行一个时间片如若进程未在一个时间片内执行完则剥夺处理机将进程重新放到就绪队列队尾重新排队用于作业进程调度用于进程调度只有作业放入内存建立了相应的进程后才能被分配处理机时间片优缺点优点公平响应快适用于分时操作系统缺点由于高频率的进程切换因此有一定开销不区分任务的紧急程度抢占式的算法不会导致饥饿若进程未能在时间片内运行完将被强行剥夺处理机使用权因此时间片轮转调度算法属于抢占式的算法由时钟装置发出时钟中断来通知时间片已到优先级调度算法算法思想随着计算机的发展特别是实时操作系统的出现越来越多的应用场景需要根据任务的紧急程度来决定处理顺序算法规则每个作业进程有各自的优先级调度时选择优先级最高的作业进程用于作业进程调度既可用于作业调度也可用于进程调度甚至还会用于在之后会学习的调度中优缺点优点用优先级区分紧急程度重要程度适用于实时操作系统可灵活地调整对各种作业进程的偏好程度缺点若源源不断地有高优先级进程到来则可能导致饥饿抢占式非抢占式的算法会导致饥饿抢占式非抢占式都有做题时的区别在于非抢占式只需在进程主动放弃处理机时进行调度即可而抢占式还需在就绪队列变化时检查是否会发生抢占优先级排序系统进程优先级高于用户进程前台进程优先级高于后台进程操作系统更偏好型进程或称繁忙型进程注与型进程相对的是计算型进程或称繁忙型程优先级分类根据优先级是否可以动态改变可将优先级分为静态优先级和动态优先级两种静态优先级创建进程时确定之后一直不变动态优先级创建进程时有一个初始值之后会根据情况动态地调整优先级就绪队列未必只有一个可以按照不同优先级来组织另外也可以把优先级高的进程排在更靠近队头的位置多级队列调度算法系统中按进程类型设置多个队列进程创建成功后插入某个队列队列之间可采取固定优先级或时间片划分固定优先级高优先级空时低优先级进程才能被调度时间片划分如三个队列分配时间各队列可采用不同的调度策略如系统进程队列采用优先级调度交互式队列采用批处理队列采用多级反馈队列调度算法算法思想对其他调度算法的折中权衡算法规则设置多级就绪队列各级队列优先级从高到低时间片从小到大新进程到达时先进入第级队列按原则排队等待被分配时间片若用完时间片进程还未结束则进程进入下一级队列队尾如果此时已经是在最下级的队列则重新放回该队列队尾只有第级队列为空时才会为级队头的进程分配时间片用于作业进程调度用于进程调度优缺点对各类型进程相对公平的优点每个新到达的进程都可以很快就得到响应优点短进程只用较少的时间就可完成优点不必实现估程运时间避用户作假可灵活地调整对各类进程的偏好程度比如密集型进程密集型进程拓展可以将因而阻塞的进程重新放回原队列这样型进程就可以保持较高优先级抢占式的算法会导致饥饿在级队列的进程运行过程中若更上级的队列级中进入了一个新进程则由于新进程处于优先级更高的队列中因此新进程会抢占处理机原来运行的进程放回级队列队尾例年第题系统采用二级反馈队列调度算法进行进程调度就绪队列采用时间片轮转调度算法时间片为就绪队列采用短进程优先调度算法系统优先调度队列中的进程当为空时系统才会调度中的进程新创建的进程首先进入中的进程执行一个时间片后若未结束则转入若当前为空系统依次创建进程后即开始进程调度需要的时间分别为和则进程在系统中的平均等待时间为等待时间周转时间运行时间等待时间周转时间运行时间在系统中的平均等待时间等待时间等待时间先来先服务短作业优先高响应比优先时间片轮转多级反馈队列能否是可抢占否能能能队列内算法不一定能否是非抢占能能能否队列内算法不一定优点公平实现简单平均等待时间最少效率最高兼顾长短作业兼顾长短作业兼顾长短作业有较好的的响应时间可行性强缺点不利于短作业长作业会饥饿估计时间不易确定计算响应比的开销大平均等待时间较长上下文切换浪费时间无适用于无作业调度批处理系统无分时系统相当通用默认决策模式非抢占非抢占非抢占抢占抢占同步与互斥同步与互斥的基本概念临界资源一次仅允许一个进程使用的资源类型物理设备如打印机等可被进程共享的许多变量数据等临界区访问临界资源的那段代码为了保证临界资源的正确使用可把临界资源的访问过程分成个部分进入区为了进入临界区使用临界资源在进入区要检查可否进入临界区若能进入临界区则应设置正在访问临界区的标志以阻止其他进程同时进入临界区临界区进程中访问临界资源的那段代码又称临界段退出区将正在访问临界区的标志清除剩余区代码中的其余部分进入区临界区退出区剩余区同步同步亦称直接制约关系它是指为完成某种任务而建立的两个或多个进程这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系进程间的直接制约关系就是源于它们之间的相互合作读进程和写进程并发地运行由于并发必然导致异步性因此写数据和读数据两个操作执行的先后顺序是不确定的而实际应用中又必须按照写数据读数据的顺序来执行的如何解决这种异步问题就是进程同步所讨论的内容互斥互斥也称间接制约关系当一个进程进入临界区使用临界资源另一进程必须等待当占用临界资源的进程退出临界区后另一进程才能访问此临界资源遵循原则空闲让进临界区空闲时可以允许一个请求进入临界区的进程立即进入临界区忙则等待当已有进程进入临界区时其他图进入临界区进必须等待有限等待对请求访问的进程应保证能在有限时间内进入临界区保证不会饥饿让权等待当进程不能进入临界区时应立即释放处理机防止进程忙等待实现临界区互斥的基本方法软件实现方法单标志法违背空闲让进原则两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程也就是说每个进程进入临界区的权限只能被另一个进程赋予该算法设置一个公用整型变量用于指示被允许进入临界区的进程编号若某个进程不再进入临界区则另一个进程也将无法进入临界区违背空闲让进双标志法先检查违背忙则等待原则在每一个进程访问临界区资源之前先查看一下临界区资源是否正被访问若正被访问该进程需等待否则进程才进入自己自己的临界区设置一个布尔型数组数组中各个元素用来标记各进程想进入临界区的意愿比如意味着号进程现在想要进入临界区每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区如果没有则把自身对应的标志设为之后开始访问临界区优点不用交替进入可连续使用缺点按序列执行时会同时进入临界区违背忙则等待进程和进程可能同时进入临界区检查和修改操作不能一次进行双标志法后检查双标志先检查法的改版前一个算法的问题是先检查后上锁但是这两个操作又无法一气呵成因此导致了两个进程同时进入临界区的问题因此人们又想到先上锁后检查的方法来避免上述问题缺点当两个进程几乎同时都想进入临界区时它们分别将自己的标志值设置为并且同时检测对方的状态发现对方也要进入临界区于是双方互相谦让结果谁也进不了临界区从而导致饥饿现象违背了空闲让进和有限等待产生饥饿算法结合双标志法单标志法的思想如果双方都争着想进入临界区那可以让进程尝试孔融让梨谦让做一个有礼貌的进程为了防止两个进程为进入临界区而无限期等待又设置了变量每个进程在先设置自己的标志后再设置标志这时再同时检测另一个进程状态标志和允许进入标志以便保证两个进程同时要求进入临界区时只允许一个进程进入临界区进程在进入区要做的步骤主动争取主动谦让检查对方是否也想使用且最后一次是不是自己说了客气话存在问题算法用软件方法解决了进程互斥问题遵循空闲让进忙则等待有限等待三个原则但是依然未遵循让权等待的原则软件方法总结单标志法双标志先检查双标志后检查算法算法在进入区只做检查不上锁在退出区把临界区的使用权转交给另一个进程相当于在退出区既给另一进程解锁又给自己上锁在进入区先检查后上锁退出区解锁在进入区先加锁后检查退出区解锁在进入区主动争取一主动谦让一检查对方是否想进已方是否谦让问题不遵循空闲让进不遵循忙则等待不遵循空闲让进有限等待可能导致饥饿不遵循让权等待会发生忙等硬件实现方法中断屏蔽方法当一个进程正在使用处理机执行它的临界区代码时要防止其他进程再进入其临界区访问的最简单的方法是禁止一切中断发生或称之为屏蔽中断关中断关中断临界区开中断优点简单高效缺点不适用于多处理机只适用于操作系统内核进程不适用于用户进程因为开关中断指令只能运行在内核态这组指令如果能让用户随意使用会很危险硬件指令法指令简称指令也有地方称为指令或指令指令是用硬件实现的是原子操作执行的过程不允许被中断只能一气呵成以下是用语言描述的逻辑相比软件实现方法指令把上锁和检查操作用硬件的方式变成了一气呵成的原子操作优点实现简单无需像软件实现方法那样严格检查是否会有逻辑漏洞适用于多处理机环境缺点不满足让权等待原则暂时无法进入临界区的进程会占用并循环执行指令从而导致忙等指令有的地方也叫指令或简称指令指令是用硬件实现的是原子操作执行的过程不允许被中断只能一气呵成逻辑上来看和并无太大区别都是先记录下此时临界区是否已经被上锁记录在变量上再将上锁标记设置为最后检查如果为则说明之前没有别的进程对临界区上锁则可跳出循环进入临界区指令优点缺点和指令相同硬件方法的优点适用于任意数目的进程不管是单处理机还是多处理机简单容易验证其正确性可以支持进程内有多个临界区只需为每个临界区设立一个布尔变量硬件方法的缺点进程等待进入临界区时要耗费处理时间不能实现让权等待从等待进程中随机选择一个进入临界区有进程可能一直选不上从而导致饥饿现象互斥锁解决临界区最简单的工具就是互斥锁一个进程在进入临界区时获得锁在退出临界区时释放锁函数获得锁而函数释放锁和是原子操作由硬件机制完成每个互斥锁有一个布尔变量表示锁是否可用如果锁是可用的调用会成功且锁不再可用当一个进程试图获取不可用的锁时会被阻塞直到锁被释放忙等待获得锁释放锁优点等待期间不用切换进程上下文多处理器系统中若上锁的时间短则等待代价很低缺点需忙等进程时间片用完才下处理机违反让权等待不太适用于单处理机系统忙等的过程中不可能解锁信号量信号量机制是一种功能较强的机制可用来解决互斥与同步问题它只能被两个标准的原语和访问也可记为操作和操作信号量其实就是一个变量可以是一个整数也可以是更复杂的记录型变量可以用一个信号量来表示系统中某种资源的数量比如系统中只有一台打印机就可以设置一个初值为的信号量原语是一种特殊的程序段其执行只能一气呵成不可被中断原语是由关中断开中断指令实现的软件解决方案的主要问题是由进入区的各种操作无法一气呵成因此如果能把进入区退出区的操作都用原语实现使这些操作能一气呵成就能避免问题整型信号量用一个整数型的变量作为信号量用来表示系统中某种资源的数量可描述为与普通整数变量的区别对信号量的操作只有三种即初始化操作操作原语检查和上锁一气呵成避免了并发异步导致的问题以申请使用打印机举例存在的问题不满足让权等待原则会发生忙等记录型信号量整型信号量存在忙等问题因此人们又提出了记录型信号量即用记录型数据结构表示的信号量除了需要用于代表资源数目的整型变量外再增加一个进程链表用于链接所有等待该资源的进程如果剩余资源数不够使用原语使进程从运行态进入阻塞态并把挂到信号量的等待队列即阻塞队列中释放资源后若还有别的进程在等待这种资源则使用原语唤醒等待队列中的一个进程该进程从阻塞态变为就绪态的初值表示系统中某种资源的数目操作对信号量的一次操作意味着进程请求一个单位的该资源因此需要执行表示资源数减当时表示该类资源已分配完毕因此进程应调用原语进行自我阻塞当前运行的进程从运行态阻塞态主动放弃处理机并插入该类资源的等待队列中可见该机制遵循了让权等待原则不会出现忙等现象操作对信号量的一次操作意味进程释放一个单位的该资源因此需要执行表示资源数加若加后仍是表示依然有进程在等待该类资源因此应调用原语唤醒等待队列中的第一个进程被唤醒进程从阻塞态就绪态例某计算机系统中有台打印机则可在初始化信号量时将的值设为队列设置为空为服务值为开始使用打印机为服务值为无资源执行原语原语阻塞队列说明有个进程在等待资源为服务值为无资源执行原语阻塞队列说明有个进程在等待资源为服务说明有进程在等待该资源因此应调用原语原语唤醒等待队列中的第一个进程将释放资源给从阻塞态变为就绪态等待被服务顺序执行阻塞队列为服务使用完打印机调用原语唤醒阻塞队列为服务是用完打印机信号量机制实现进程互斥伪代码如下所示设为实现进程互斥的信号量由于只允许一个进程进入临界区所以的初值应设为然后把临界区置于和之间进入区之前申请资源操作退出区之前释放资源操作即可实现两个进程对临界资源的互斥访问操作分析并发进程的关键活动划定临界区如对临界资源打印机的访问就应放在临界区设置互斥信号量初值为在进入区一一申请资源在退出区一一释放资源注意对不同的临界资源需要设置不同的互斥信号量操作必须成对出现缺少就不能保证临界资源的互斥访问缺少会导致资源永不被释放等待进程永不被唤醒信号量机制实现进程同步进程同步要让各并发进程按要求有序地推进程序保证了代码一定是在代码之后执行步骤先后后前分析什么地方需要实现同步关系即必须保证一前一后执行的两个操作或两句代码设置同步信号量初始为在前操作之后执行在后操作之前执行注意若先执行到操作则后之后当执行到操作时由于表示有可用资源会执行的值变回进程不会执行原语而是继续往下执行代码若先执行到操作由于后表示此时没有可用资源因此操作中会执行原语主动请求阻塞当执行完代码继而执行操作使变回由于此时有进程在该信号量对应的阻塞队列中因此会在操作中执行原语唤醒进程这样就可以继续执行代码信号量机制实现前驱关系分析问题画出前驱图把每一对前驱关系都看成一个同步问题问题下图是一个前驱图其中是进程中的程序段这些程序段要求按如下前驱图所示的顺序来执行代码操作要为每一对前驱关系各设置一个同步信号量在前操作之后对相应的同步信号量执行操作在后操作之前对相应的同步信号量执行操作同步互斥信号量总结注互斥信号量初值一般为同步信号量的初始值要看对应资源的初始值是多少管程引入管程原因管程的引入让程序员写程序时不需要再关注复杂的操作从而避免了传统信号量机制存在的很多问题定义由一组数据及定义在这组数据之上的对这组数据的操作组成的软件模块这组操作能初始化并改变管程中的数据和同步进程管程的组成局部于管程的共享数据结构说明对该数据结构进行操作的一组过程函数对局部于管程的共享数据设置初始值的语句管程的名字定义一个名称为的管程定义共享数据结构对应系统中的某种共享资源共享数据结构对共享数据结构初始化的语句初始资源数等于过程申请一个资源对共享数据结构的一系列处理可用资源过程归还一个资源对共享数据结构的一系列处理可用资源管程的基本特征局部于管程的数据只能被局部于管程的过程所访问一个进程只有通过调用管程内的过程才能进入管程访问共享数据每次仅允许一个进程在管程内执行某个内部过程注过程其实就是函数如下面这个类是管程的名字和是局部于管程的共享数据结构方法是该数据结构进行操作的过程用户名密码登录成功条件变量条件变量是表示管程阻塞原因的变量通常一个进程被阻塞的原因可以有多个因此在管程中设置了多个条件变量每个条件变量保存了一个等待队列用于记录因该条件变量而阻塞的所有进程对条件变量只能进行两种操作即和当对应的条件不满足时正在调用管程的进程调用将自己插入条件的等待队列并释放管程此时其他进程可以使用该管程对应的条件发生了变化则调用唤醒一个因条件而阻塞的进程共享数据结构定义一个条件变量资源不够在条件变量上阻塞等待资源足够分配资源做一系列处理归还资源做一系列相应处理有进程在等待唤醒一个阻塞进程条件变量和信号量的比较相似点条件变量的操作类似于信号量的操作可以实现进程的阻塞唤醒不同点条件变量是没有值的仅实现了排队等待功能而信号量是有值的信号量的值反映了剩余资源数而在管程中剩余资源数用共享数据结构记录经典同步问题生产者消费者问题问题描述系统中有一组生产者进程和一组消费者进程生产者进程每次生产一个产品放入缓冲区消费者进程每次从缓冲区中取出一个产品并使用注这里的产品理解为某种数据生产者消费者共享一个初始为空大小为的缓冲区只有缓冲区没满时生产者才能把产品放入缓冲区否则必须等待只有缓冲区不空时消费者才能从中取出产品否则必须等待缓冲区是临界资源各进程必须互斥地访问问题分析关系分析找出题目中描述的各个进程分析它们之间的同步互斥关系同步关系缓冲区没满生产者生产缓冲区没空消费者消费互斥关系各进程互斥访问缓冲区整理思路根据各进程的操作流程确定操作的大致顺序设置信号量并根据题目条件确定信号量初值互斥信号量初值一般为同步信号量的初始值要看对应资源的初始值是多少互斥信号量实现对缓冲区的互斥访问同步信号量表示空闲缓冲区的数量同步信号量表示产品的数量也即非空缓冲区的数量进程描述能否改变相邻操作的顺序不能会发生死锁若此时缓冲区内已经放满产品则则生产者进程执行使变为再执行由于已没有空闲缓冲区因此生产者被阻塞由于生产者阻塞因此切换回消费者进程消费者进程执行由于为即生产者还没释放对临界资源的锁因此消费者也被阻塞生产者和消费者循环等待被对方唤醒出现死锁因此实现互斥的操作一定要在实现同步的操作之后操作不会导致进程阻塞因此两个操作顺序可以交换能否只设置一个同步信号量不能原因在于两个信号量和其中用于制约生产者生产用于制约消费者消费如果只设置一个信号量如那么生产者会无限的生产起不到制约作用多生产者多消费者问题问题描述桌子上有一只盘子每次只能向其中放入一个水果爸爸专向盘子中放苹果妈妈专向盘子中放橘子儿子专等着吃盘子中的橘子女儿专等着吃盘子中的苹果只有盘子空时爸爸或妈妈才可向盘子中放一个水果仅当盘子中有自己需要的水果时儿子或女儿可以从盘子中取出水果问题分析关系分析同步关系父亲将苹果放入盘子女儿才能取苹果母亲将句子放入盘子儿子才能取橘子只有盘子为空父亲或者母亲才能放水果互斥关系对缓冲区盘子的访问要互斥的进行整理思路注盘子为空这个事件可由儿子或者女儿触发发生后父亲或母亲才可放水果分析同步要以事件的角度分析不要以进程的角度分析信号量的设置实现互斥访问盘子缓冲区盘子中有几个苹果盘子中有几个橘子盘子中还可以放多少个水果进程描述能否不用互斥信号量如果缓冲区大小为在任何时刻三个信号量中最多只有一个是因此在任何时刻最多只有一个进程的操作不会被阻塞并顺利地进入临界区如果缓冲区大小大于数据可能存在相互覆盖的情况如父亲在向盘子放橘子的同时母亲也可以往盘子里放橘子有可能导致两个进程写入缓冲区的数据相互覆盖的情况因此当缓冲区大小等于有可能不设置互斥变量当缓冲区大小大于必须设置互斥变量是否不用设置互斥信号量主要观察同一时刻信号量是否最多一个建议设置互斥信号量但需要注意的是实现互斥的操作一定要在实现同步的操作之后否则可能引起死锁分析在分析同步问题一前一后问题的时候不能从单个进程行为的角度来分析要把一前一后发生的事看做是两种事件的前后关系如果从单个进程的角度来考虑的话会有以下结论如果盘子里装有苹果那么一定要女儿取走苹果后父亲或母亲才能再放入水果如果盘子里装有橘子那么一定要儿子取走橘子后父亲或母亲才能再放入水果这就意味着要设置四个同步信号量分别实现这四个一前一后的关系较为复杂若从事件的角度来考虑我们可以把上述四对进程行为的前后关系抽象为一对事件的前后关系即盘子变空事件放入水果事件读者写者问题问题描述有读者和写者两组并发进程共享一个文件当两个或两个以上的读进程同时访问共享数据时不会产生副作用但若某个写进程和其他进程读进程或写进程同时访问共享数据时则可能导致数据不一致的错误因此要求允许多个读者可以同时对文件执行读操作只允许一个写者往文件中写信息任一写者在完成写操作之前不允许其他读者或写者工作写者执行写操作前应让已有的读者和写者全部退出问题分析两类进程写进程读进程互斥关系写进程一写进程写进程一读进程读进程与读进程不存在互斥问题进程描述方案方案设置和两个信号量信号量用于实现读进程与写进程写进程与写进程对共享文件的互斥访问信号量用于保证对变量的互斥访问若没有设置信号量两个读进程并发执行到条件且都满足都会执行会造成其中一个读进程阻塞的情况设置信号量使得信号量的检查和赋值操作一气呵成保证了对信号量访问的互斥性方案存在的问题只要有读进程还在读写进程就要一直阻塞等待可能饿死因此这种算法中读进程是优先的方案方案是对方案问题的修正添加了信号量保证了读写公平如假设对共享文件的访问顺序是读者读者写者读者读者执行完后写者将会进行写文件读者进程将会被阻塞待写者写完文件后读者进行读写者访问后的文件算法核心思想在于设置了一个计数器用来记录当前正在访问共享文件的读进程数我们可以用的值来判断当前进入的进程是否是第一个最后一个读进程从而做出不同的处理另外还需考虑变量的互斥性结论在这种算法中连续进入的多个读者可以同时读文件写者和其他进程不能同时访问文件写者不会饥饿但也并不是真正的写优先而是相对公平的先来先服务原则有的书上把这种算法称为读写公平法哲学家进餐问题问题描述一张圆桌上坐着名哲学家每两个哲学家之间的桌上摆一根筷子桌子的中间是一碗米饭哲学家们倾注毕生的精力用于思考和进餐哲学家在思考时并不影响他人只有当哲学家饥饿时才试图拿起左右两根筷子一根一根地拿起如果筷子已在他人手上则需等待饥饿的哲学家只有同时拿起两根筷子才可以开始进餐当进餐完毕后放下筷子继续思考问题分析关系分析系统中有个哲学家进程位哲学家与左右邻居对其中间筷子的访问是互斥关系整理思路哲学家进餐问题中只有互斥关系但与之前遇到的问题不同点在于每个哲学家进程需要同时持有两个临界资源才能开始吃饭如何避免临界资源分配不当造成的死锁现象是哲学家问题的关键信号量的设置定义互斥信号量数组用于实现对个筷子的互斥访问并对哲学家按编号哲学家左边的筷子编号为右边的筷子编号为此外还需要设置互斥信号量用以保证哲学家进程左右两支筷子都可用进程描述算法保证一个哲学家再拿到筷子拿到一半时被阻塞也不会有别的哲学家尝试拿筷子即至少有一个哲学家进程不阻塞其他方案对哲学家进程施加一些限制条件如最多允许四个哲学家同时进餐这样可以保证至少有一个哲学家是可以拿到左右两只筷子的要求奇数号哲学家先拿左边的筷子然后再拿右边的筷子而偶数号哲学家刚好相反用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭那么只会有其中一个可以拿起第一只筷子另一个会直接阻塞这就避免了占有一支后再等待另一只的情况吸烟者问题问题描述假设一个系统有三个抽烟者进程和一个供应者进程每个抽烟者不停地卷烟并抽掉它但是要卷起并抽掉一支烟抽烟者需要有三种材料烟草纸和胶水三个抽烟者中第一个拥有烟草第二个拥有纸第三个拥有胶水供应者进程无限地提供三种材料供应者每次将两种材料放桌子上拥有剩下那种材料的抽烟者卷一根烟并抽掉它并给供应者进程一个信号告诉完成了供应者就会放另外两种材料在桌上这个过程一直重复让三个抽烟者轮流地抽烟问题分析关系分析同步关系桌上有组合一第一个抽烟者取走东西桌上有组合二第二个抽烟者取走东西桌上有组合三第三个抽烟者取走东西抽烟者抽完发出完成信号供应者将下一个组合放到桌上互斥关系对缓冲区的访问要互斥的进行整理思路注由于缓冲区大小为任意时刻同步信号量和互斥信号量最多只有一个因此互斥信号量可以不设置信号量的设置桌上组合一的数量桌上组合二的数量桌上组合三的数量抽烟是否完成用于实现三个抽烟者轮流抽烟进程描述能否从进程角度思考不可以同多生产者多消费者问题假设从进程角度思考那么第一个抽烟者抽完后供应者再将第一个组合放到桌上第二个抽烟者抽完后供应者再将第二个组合放到桌上第三个抽烟者抽完后供应者再将第三个组合放到桌上这样相比于从事件考虑的一个一前一后的关系多出了多个关系并且较为复杂因此要从事件的角度思考关系死锁死锁的概念死锁的定义在并发环境下各进程因竞争资源而造成的一种互相等待对方手里的资源导致各进程都阻塞都无法向前推进的现象就是死锁发生死锁后若无外力干涉这些进程都将无法向前推进死锁饥饿死循环的区别共同点都是进程无法顺利向前推进的现象故意设计的死循环除外区别死锁各进程互相等待对方手里的资源导致各进程都阻塞无法向前推进的现象两个以上程序饥饿由于长期得不到想要的资源某进程无法向前推进的现象单个程序比如在短进程优先算法中若有源源不断的短进程到来则长进程将一直得不到处理机从而发生长进程饥饿死循环某进程执行过程中一直跳不出某个循环的现象有时是因为程序逻辑导致的有时是程序员故意设计的死锁产生原因对系统资源的竞争各进程对不可剥夺的资源如打印机的竞争可能引起死锁对可剥夺的资源的竞争是不会引起死锁的进程推进顺序非法请求和释放资源的顺序不当也同样会导致死锁例如并发执行的进程分别申请并占有了资源之后进程又紧接着申请资源而进程又申请资源两者会因为申请的资源被对方占有而阻塞从而发生死锁信号量的使用不当也会造成死锁如生产者消费者问题中如果实现互斥的操柞在实现同步的操作之前就有可能导致死锁可以把互斥信号量同步信号量也看做是一种抽象的系统资源死锁产出的必要条件产生死锁必须同时满足以下四个条件只要其中任一条件不成立死锁就不会发生互斥条件只有对必须互斥使用的资源的争抢才会导致死锁如哲学家的筷子打印机设备像内存扬声器这样可以同时让多个进程使用的资源是不会导致死锁的因为进程不用阻塞等待这种资源不剥夺条件进程所获得的资源在未使用完之前不能由其他进程强行夺走只能主动释放请求和保持条件进程已经保持了至少一个资源但又提出了新的资源请求而该资源又被其他进程占有此时请求进程被阻塞但又对自己已有的资源保持不放循环等待条件存在一种进程资源的循环等待链链中的每一个进程已获得的资源同时被下一个进程所请求注发生死锁时一定有循环等待但是发生循环等待时未必死锁即循环等待是死锁的必要不充分条件如果同类资源数大于则即使有循环等待也未必发生死锁如上图可以同时请求或者的资源得到资源后不会发生死锁但如果系统中每类资源都只有一个那循环等待就是死锁的充分必要条件了死锁处理策略死锁预防设置某些限制条件破坏产生死锁的个必要条件中的一个或几个避免死锁在资源的动态分配过程中用某种方法防止系统进入不安全状态死锁的检测及解除无须采取任何限制性措施允许进程在运行过程中发生死锁通过系统的检测机构及时地检测出死锁的发生然后采取某种措施解除死锁死锁的几种处理策略的比较见下表资源分配策略各种可能模式主要优点主要缺点死锁预防保守宁可资源闲置一次请求所有资源资源剥夺资源按序分配适用于突发式处理的进程不必进行剥夺效率低进程初始化时间延长剥夺次数过多不便灵活申请新资源死锁避免是预防和检测的折中在运行时判断是否可能死锁寻找可能的安全允许顺序不必进行剥夺必须知道将来的资源需求进程不能被长时间阻塞死锁检测宽松只要允许就分配资源定期检查死锁是否已经发生不延长进程初始化时间允许对死锁进行现场处理通过剥夺解除死锁造成损失死锁预防死锁的产生必须满足四个必要条件只要其中一个或者几个条件不满足死锁不会发生破坏互斥条件把只能互斥使用的资源改造为允许共享使用则系统不会进入死锁状态如技术使用技术可以把独占设备在逻辑上改造成共享设备比如用技术将打印机改造为共享设备破坏不剥夺条件提供两种方案申请资源得不到时主动释放所占有资源申请资源被其他进程占用时由协助剥夺策略的缺点实现起来比较复杂释放已获得的资源可能造成前一阶段工作的失效因此这种方法一般只适用于易保存和恢复状态的资源如反复地申请和释放资源会增加系统开销降低系统吞吐量方案可能导致进程饥饿破坏请求和保持条件采用静态分配方法即进程在运行前一次申请完它所需要的全部资源在它的资源未满足前不让它投入运行一旦投入运行后这些资源就一直归它所有该进程就不会再请求别的任何资源了策略的缺点进程在整个运行期间都一直保持着所有资源就会造成严重的资源浪费资源利用率极低另外该策略也有可能导致某些进程饥饿破坏循环等待条件采用顺序资源分配法首先给系统中的资源编号要求进程只能按编号递增顺序请求资源原理分析一个进程只有已占有小编号的资源时才有资格申请更大编号的资源按此规则已持有大编号资源的进程不可能逆向地回来申请小编号的资源从而就不会产生循环等待的现象类比拓扑排序策略的缺点不方便增加新的设备因为可能需要重新分配所有的编号进程实际使用资源的顺序可能和编号递增顺序不一致会导致资源浪费必须按规定次序申请资源用户编程麻烦死锁避免死锁的避免是在资源动态分配过程中防止系统进入不安全状态以避免发生死锁系统安全状态安全序列是指如果系统按照这种序列分配资源则每个进程都能顺利完成安全状态系统如果存在安全序列则处于安全状态安全状态一定不发生死锁安全序列可能有多个不安全状态如果分配了资源之后系统中找不出任何一个安全序列系统就进入了不安全状态可能发生死锁处于不安全状态未必就是发生了死锁但发生死锁时一定是在不安全状态安全序列的计算方法已知现有三个进程的资源分配表如下可用代表系统还剩有个资源现假设可用资源每次分配都是全部分配并且分配给进程的资源总数应满足进程最多还需求的资源数目如可用资源有个由于进程还需要个资源因此只能满足分配完后回收该进程所拥有的全部资源计算步骤如下因此得到安全序列是如果计算到时可用资源无法满足的最大需求即还需要的资源数目多于可用资源数目那么就不存在安全序列注死锁状态一定是不安全状态不安全状态不一定是死锁状态即死锁状态不安全状态如进程需个资源而可用资源有个若还未提出申请则不会进入死锁状态系统进入不安全状态后便可能进入死锁状态反之只要系统处于安全状态系统变可避免进入死锁银行家算法核心思想在分配资源前预先判断这次分配是否会导致系统进入不安全状态以此来决定是否答应资源分配请求从而使得系统避免死锁数据结构描述可利用资源向量一维数据最大需求矩阵分配矩阵需求矩阵其中注代表可用的类资源数目有个类资源数目有个类资源数目有个银行家算法描述设是进程的请求向量表示进程需要类资源个若检查此次申请是否超过最多还需求数若检查系统的可用资源是否还能满足此次需求系统试探着把资源分配给并修改下面数据结构的数值修改进程剩余可用资源数进程已分配资源数加上本次请求资源数进程还需的资源数减去本次请求的资源数执行安全性算法检查系统是否处于安全状态即检查当前系统是否存在安全序列若系统安全才正式将资源分配给否则此次试探分配作废恢复原来分配状态注安全性算法是银行家算法的核心安全性算法描述设置工作向量表示系统中剩余可用资源数目算法执行开始时初始时安全序列为空检查当前的剩余资源是否能满足某个进程的最大需求如果可以就将它加入安全序列若找不到执行步骤把该进程持有资源全部回收返回步骤若此时安全序列中已有所有进程则系统处于安全状态否则处于不安全状态例题假设当前系统中资源分配和剩余情况如下表所示现发出请求向量判断此次请求是否分配成功系统按银行家算法进行检查此次申请未超过进程最多还需求数并且当前可用资源数可满足此次申请则可试探的为分配资源并修改系统执行安全性算法检查安全状态令执行安全性算法如下表所示由安全性检查而知可以找到一个安全序列因此系统是安全的可以将所申请的资源分配给他王道书解法死锁检测和解除如果系统既不采取预防死锁的措施也不采取避免死锁的措施系统就很可能发生死锁在这种情况下系统应当提供死锁检测和解除的手段资源分配图系统死锁可利用资源分配图来描述圆代表一个进程框代表一类资源框中一个圆代表一类资源中的一个资源两种结点进程结点对应一个进程资源结点对应一类资源一类资源可能有多个两种边请求边表示进程想申请几个资源每条边代表一个分配边表示已经为进程分配了几个资源每条边代表一个死锁定理简化资源分配图可检测系统状态是否为死锁状态简化方法如下在资源分配图中找出既不阻塞又不是孤点的进程不阻塞表示进程申请的资源可以被满足如进程由于资源除分配给进程一个资源外还剩有一个资源因此进程申请的资源可以被满足相反进程申请资源则不会被满足由于资源全部被分配完不是孤点表示与该进程节点至少一个边相连消去进程所有的请求边和分配边使之成为孤点重复以上步骤若能消去图中所有的边则称该图是可完全简化的注并不是系统中所有的进程都是死锁状态用死锁检测算法化简资源分配图后还连着边的那些进程就是死锁进程死锁定理如果某时刻系统的资源分配图是不可完全简化的那么此时系统死锁死锁解除一旦检测出死锁的发生就应该立即解除死锁解除死锁的主要方法有资源剥夺法挂起暂时放到外存上某些死锁进程并抢占它的资源将这些资源分配给其他的死锁进程但是应防止被挂起的进程长时间得不到资源而饥饿撤销进程法或称终止进程法强制撤销部分甚至全部死锁进程并剥夺这些进程的资源这种方式的优点是实现简单但所付出的代价可能会很大因为有些进程可能已经运行了很长时间已经接近结束了一旦被终止可谓功亏一篑以后还得从头再来撤销的原则可以按进程优先级和撤销进程代价的高低进行进程回退法让一个或多个死锁进程回退到足以避免死锁的地步进程回退时自愿释放资源而非剥夺这就要求系统要记录进程的历史信息设置还原点注撤销进程法中参考的优先级应考虑进程优先级已执行多长时间还要多久能完成进程已经使用了多少资源进程是交互式的还是批处理式的等因素内存管理内存管理概念内存管理的基本原理和要求内存管理的概念虽然计算机技术飞速发展内存容量也在不断扩大但仍然不可能将所有用户进程和系统所需的全部程序与数据放入内存因此操作系统对内存空间进行合理的划分和有效的动态分配操作系统对内存的划分和动态分配就是内存管理的概念内存空间的主要功能有内存空间的分配与回收要怎么记录哪些内存区域已经被分配出去了哪些又还空闲当进程运行结束之后如何将进程占用的内存空间回收内存空间的扩充利用虚拟内存技术或自动覆盖技术使得系统运行很大的程序从逻辑上扩充内存地址转换为了使编程更方便程序员写程序时应该只需要关注指令数据的逻辑地址而逻辑地址到物理地址的转换这个过程称为地址重定位应该由操作系统负责其中地址重定位有三种方式内存保护保证各进程在各自存储空间内运行互不干扰程序执行过程创建进程首先要将程序和数据装入内存将用户源程序变为可在内存中执行的程序通常需要以下几个步骤编译由编译程序将用户源代码编译成若干目标模块编译就是把高级语言翻译为机器语言链接由链接程序将编译后形成的一组目标模块及它们所需的库函数链接在一起形成一个完整的装入模块装入由装入程序将装入模块装入内存运行编译后每个目标模块都是从号单元开始编址这称为该目标模块的逻辑地址或相对地址当链接程序将各个模块连接成一个完整的可执行目标程序时链接程序顺序依次按各个模块的相对地址构成统一的从号单元开始编制的逻辑地址空间用户程序和程序员只需知道逻辑地址而内存管理的具体机制则是完全透明的只有系统编程人员才会涉及内存管理的具体机制不同进程可以有相同的逻辑地址因为这些相同的逻辑地址可以映射到内存的不同位置物理地址空间是指内存中物理单元的集合它是地址转换的最终地址进程在运行时执行指令和访问数据最后都要通过物理地址从主存中存取当装入程序将可执行代码装入内存时必须通过地址转换将逻辑地址转换成物理地址动态重定位是地址转换推迟到程序真正要执行时才进行这个过程称为地址重定位程序的链接静态链接在程序运行之前先将各目标模块及它们所需的库函数连接成一个完整的可执行文件装入模块之后不再拆开装入时动态链接将各目标模块装入内存时边装入边链接的链接方式运行时动态链接在程序执行中需要该目标模块时才对它进行链接其优点是便于修改和更新便于实现对目标模块的共享程序的装入绝对装入在编译与链接后得到的装入模块指定直接使用了绝对地址可重定位装入装入时对地址进行重定位即将逻辑地址变换为物理地址地址变换是在装入时一次完成的静态重定位的特点在一个作业装入内存时必须分配其要求的全部内存空间如果没有足够的内存就不能装入该作业作业一旦进入内存后在运行期间就不能再移动也不能再申请内存空间动态运行时装入装入程序把装入模块装入内存后并不会立即把逻辑地址转换为物理地址装入时依然保持使用逻辑地址而是把地址转换推迟到程序真正要执行时才进行因此装入内存后所有的地址依然是逻辑地址这种方式需要一个重定位寄存器的支持动态重定位特点可以将程序分配到不连续的存储区中在程序运行前只需装入它的部分代码即可投入运行然后在程序运行期间根据需要动态申请分配内存便于程序段的共享可以向用户提供一个比存储空间大得多的地址空间采用动态重定位时允许程序在内存中发生移动注链接的作用是形成了完整的装入模块与逻辑地址但逻辑地址到物理地址的转换过程是重定位而不是装入内存映像不同于存放在硬盘上的可执行程序文件当一个程序调入内存运行时就构成了进程的内存映像一个进程的内存映像一般有几个要素代码段即程序的二进制代码代码段是只读的可以被多个进程共享数据段即程序运行时加工处理的对象包括全局变量和静态变量进程控制块存放在系统区操作系统通过来控制和管理进程堆用来存放动态分配的变量通过调用函数动态地向高地址分配空间栈用来实现函数调用从用户空间的最大地址往低地址方向增长代码段和数据段在程序调入内存时就指定了大小而堆和栈不一样当调用像和这样的标准库函数时堆可以在运行时动态地扩展和收缩用户栈在程序运行期间也可以动态地扩展和收缩每次调用一个函数栈就会增长从一个函数返回时栈就会收缩上图是一个进程在内存中的映像其中共享库用来存放进程用到的共享函数库代码如函数等在只读代码段中是程序初始化时调用的函数是用户程序的机器代码是只读数据在读写数据段中是已初始化的全局变量和静态变量是未初始化及所有初始化为的全局变量和静态变量内存保护确保每个进程都有一个单独的内存空间内存分配前需要保护操作系统不受用户进程的影响同时保护用户进程不受其他用户进程的影响内存保护可采取两种方法在中设置一对上下限寄存器存放用户作业在主存中的下限和上限地址每当要访问一个地址时分别和两个寄存器的值相比判断有无越界采用重定位寄存器又称基地址寄存器和界地址寄存器又称限长寄存器来实现这种保护重定位寄存器含最小的物理地址值界地址寄存器含逻辑地址的最大值内存管理机构动态地将逻辑地址与界地址寄存器进行比较若未发生地址越界则加上重定位寄存器的值后映射成物理地址再送交内存单元如下图所示重定位寄存器是用来加的逻辑地址加上重定位寄存器中的值就能得到物理地址界地址寄存器是用来比的通过比较界地址寄存器中的值与逻辑地址的值来判断是否越界加载重定位寄存器和界地址寄存器时必须使用特权指令只有操作系统内核才可以加载这两个存储器这种方案允许操作系统内核修改这两个寄存器的值而不允许用户程序修改内存共享并不是所有的进程内存空间都适合共享只有那些只读的区域才可以共享可重入代码又称纯代码是一种允许多个进程同时访问但不允许被任何进程修改的代码在实际运行时每个进程有自己的私有数据段可以更改自己私有的数据区数据不可改变共享的代码例考虑一个可以同时容纳个用户的多用户系统他们同时执行一个文本编辑程序若该程序有代码区和数据区则共需的内存空间来支持个用户如果代码是可分享的纯代码则不论是在分页系统中还是在分段系统中整个系统只需保留一份副本即可此时所需的内存空间仅为对于分页系统假设页面大小为则代码区占用个页面数据区占用个页面为实现代码共享应在每个进程的页表中都建立个页表项它们都指向共享代码区的物理页号此外每个进程还要为自己的数据区建立个页表项指向私有数据区的物理页号对于分段系统由于是以段为分配单位的不管该段有多大都只需为该段设置一个段表项指向共享代码段始址以及段长由此可见段的共享非常简单易行内存分配与回收在操作系统由单道向多道发展时存储管理方式便由单一连续分配发展为固定分区分配为了能更好地适应不同大小的程序要求又从固定分区分配发展到动态分区分配为了更好地提高内存的利用率进而从连续分配方式发展到离散分配方式一一页式存储管理引入分段存储管理的目的主要是为了满足用户在编程和使用方面的要求其中某些要求是其他几种存储管理方式难以满足的覆盖与交换覆盖与交换技术是在多道程序环境下用来扩充内存的两种方法覆盖基本思想由于程序运行时并非任何时候都要访问程序及数据的各个部分尤其是大程序因此可把用户空间分成一个固定区和若干覆盖区将经常活跃的部分放在固定区其余部分按调用关系分段首先将那些即将要访问的段放入覆盖区其他段放在外存中在需要调用前系统再将其调入覆盖区替换覆盖区中原有的段特点打破了必须将一个进程的全部信息装入主存后才能运行的限制但当同时运行程序的代码量大于主存时仍不能运行内存中能够更新的地方只有覆盖区的段不在覆盖区中的段会常驻内存覆盖技术对用户和程序员不透明交换基本思想把处于等待状态或在调度原则下被剥夺运行权利的程序从内存移到辅存把内存空间腾出来这一过程又称换出把准备好竞争运行的程序从辅存移到内存这一过程又称换入交换过程例如有一个采用时间片轮转调度算法的多道程序环境时间片到内存管理器将刚刚执行过的进程换出将另一进程换入刚刚释放的内存空间同时调度器可以将时间片分配给其他已在内存中的进程每个进程用完时间片都与另一进程交换在理想情况下内存管理器的交换过程速度足够快总有进程在内存中可以执行问题交换需要备份存储通常是磁盘它必须足够大并提供对这些内存映像的直接访问为了有效使用需要使每个进程的执行时间比交换时间长若换出进程则必须确保该进程完全处于空闲状态交换空间通常作为磁盘的一整块且独立于文件系统因此使用起来可能很快交换通常在有许多进程运行且内存空间吃紧时开始启动而在系统负荷降低时就暂停普通的交换使用不多但交换策略的某些变体在许多系统如中仍发挥作用区别交换技术主要在不同进程或作业之间进行而覆盖则用于同一个程序或进程中对于主存无法存放用户程序的矛盾现代操作系统是通过虚拟内存技术来解决的覆盖技术则已成为历史而交换技术在现代操作系统中仍具有较强的生命力连续分配管理方式连续分配方式是指为一个用户程序分配一个连续的内存空间包括单一连续分配固定分区分配和动态分区分配单一连续分配在单一连续分配方式中内存被分为系统区和用户区系统区通常位于内存的低地址部分用于存放操作系统相关数据用户区用于存放用户进程相关数据内存中只能有一道用户程序用户程序独占整个用户区空间优点实现简单无外部碎片可以采用覆盖技术扩充内存无需采取内存保护因为内存中永远只有一道程序缺点只能用于单用户单任务的操作系统中有内部碎片存储器利用率极低内部碎片分配给某进程的内存区域中如果有些部分没有用上外部碎片是指内存中的某些空闲分区由于太小而难以利用固定分区分配固定分区分配是最简单的一种多道程序存储管理方式它将整个用户空间划分为若干个固定大小的分区在每个分区中只装入一道作业当有空闲分区时便可从外存的后备作业队列中选择适当大小的作业装入该分区如此循环划分分区有两种方法分区大小相等程序太小会造成浪费程序太大又无法装入缺乏灵活性分区大小不等划分为多个较小的分区适量的中等分区和少量大分区增加了灵活性为了便于分配建立一张分区使用表通常按分区大小排队各表项包括每个分区的起始地址大小及状态是否已分配如下图所示分配内存时便检索该表以找到一个能满足要求且尚未分配的分区分配给装入程序并将对应表项的状态置为已分配若找不到这样的分区则拒绝分配回收内存时只需将对应表项的状态置为未分配即可优点实现简单无外部碎片缺点当用户程序太大时可能所有的分区都不能满足需求此时不得不采用覆盖技术来解决但这又会降低性能会产生内部碎片内存利用率低动态分区分配动态分区分配又称为可变分区分配这种分配方式不会预先划分内存分区而是在进程装入内存时根据进程的大小动态地建立分区并使分区的大小正好适合进程的需要因此系统分区的大小和数目是可变的例如图所示系统有内存空间其中低固定分配给操作系统其余为用户可用内存开始时装入前三个进程它们分别分配到所需的空间后内存仅剩进程无法装入在某个时刻内存中没有一个就绪进程出现空闲操作系统就换出进程换入进程由于进程比进程小这样在主存中就产生了一个的内存块之后又出现空闲需要换入进程而主存无法容纳进程操作系统就换出进程换入进程紧凑技术动态分区在开始时是很好的但随着时间的推移内存中会产生越来越多的外部碎片需要通过紧凑技术来解决即操作系统不时地对进程进行移动和整理但这需要动态重定位寄存器的支持且相对费时在进程装入或换入主存时若内存中有多个足够大的空闲块则操作系统必须确定分配哪个内存块给进程使用这就是动态分区的分配策略考虑以下几种算法首次适应算法算法思想每次都从低地址开始查找找到第一个能满足大小的空闲分区如何实现空闲分区以地址递增的次序链接分配内存时从链首开始顺序查找找到大小能满足要求的第一个空闲分区分配给作业算法简单最好最快回收分区后一般不需要对空闲分区队列重新排序最佳适应算法算法思想优先使用更小的分区以保留更多大分区如何实现空闲分区按容量递增的次序形成空闲分区链找到第一个能满足要求且最小的空闲分区分配给作业避免大材小用缺点产生大量小的难以利用的外部碎片最坏适应算法最大适应算法算法思想优先使用更大的分区以防止产生太小的不可用的碎片如何实现空闲分区以容量递减的次序链接找到第一个能满足要求的即最大的分区从中分割一部分存储空间给作业缺点如果之后有大进程到达无足够大连续内存空间分配邻近适应算法循环首次适应算法算法思想由首次适应演变而来每次从上次查找结束位置开始查找如何实现空闲分区以地址递增的顺序排列可排成一个循环链表每次分配内存时从上次查找结束的位置开始查找空闲分区链或空闲分区表找到大小能满足要求的第一个空闲分区缺点导致无论低地址高地址部分的空闲分区都有相同的概率被使用也就导致了高地址部分的大分区更可能被使用划分为小分区最后导致无大分区可用算法算法思想分区排列顺序优点缺点首次适应从头到尾找适合的分区空闲分区以地址递增次序排列性能最好算法开销小最佳适应优先使用更小的分区空闲分区以容量递增次序排列保留更大分区产生大量碎小的外部碎片算法开销大最坏适应优先使用更大的分区空闲分区以容量递减次序排列减少难以利用的碎片大分区容易被用完算法开销大邻近适应每次从上次查找结束位置开始查找空闲分区以地址递增次序排列可排列成循环链表空闲分区有相同概率被使用算法开销小使高地址大分区也被用完注动态分区分配没有内部碎片但是有外部碎片分区的分配与回收回收内存分区时有可能遇到四种情况回收区的后面有一个相邻的空闲分区回收区的前面有一个相邻的空闲分区回收区的前后各有一个相邻的空闲分区回收区的前后都没有相邻的空闲分区无论那种情况都要遵循相邻的空闲分区要合并的原则基本分页存储管理固定分区会产生内部碎片动态分区会产生外部碎片这两种技术对内存的利用率都比较低为了避免碎片的产出引出了分页的思想分页的思想把主存空间划分为大小相等且固定的块块相对较小作为主存的基本单位每个进程也以块为单位进行划分进程在执行时以块为单位逐个申请主存中的块空间分页管理与固定分区类似不会产生外部碎片进程运行按块申请主存空间只会在最后一块有内部碎片每个进程平均只有半个块的内部碎片页内碎片基本概念页面和页面大小进程中的块称为页或页面内存中的块称为页框或页帧外存也以同样的单位进行划分直接称为块或盘块进程在执行时需要为每个页面分配主存中的可用页框这就产生了页和页框的一一对应将内存空间分为一个个大小相等的分区每个分区就是一个页框每个页框有一个编号即页框号页框号从开始将进程的逻辑地址空间也分为与页框大小相等的一个个部分每个部分称为一个页或页面每个页面也有一个编号即页号页号也是从开始页框页帧内存块物理块物理页面为方便地址转换页面大小应是的整数幂同时页面大小应该适中页面太小会使进程的页面数过多这样页表就会过长占用大量内存而且也会增加硬件地址转换的开销降低页面换入换出的效率页面过大又会使页内碎片增多降低内存的利用率地址结构地址结构决定了虚拟内存的寻址空间有多大分页存储管理的逻辑地址结构如下所示地址结构包含两个部分前一部分为页号后一部分为页内偏移量在上图所示的例子中地址长度为位其中位为页内偏移量或称页内地址即每页大小为位为页号进程地址空间最多允许页页表为了能知道进程的每个页面在内存中存放的位置操作系统要为每个进程建立一张页表页表通常存在进程控制块在操作系统的内核地址空间中页表记录进程页面和实际存放的内存块之间的映射关系一个进程对应一张页表进程的每个页面对应一个页表项每个页表项由页号和块号组成每个页表项的长度是相同的例假设某系统物理内存大小为页面大小为则每个页表项至少应该为多少字节内存块大小页面大小的内存总共会被分为个内存块内存块号的范围应该是内存块号至少要用来表示至少要用来表示块号页表项在内存中是连续存放因此页号是可以隐藏的不占内存空间页表项占个字节注如果未特别强调默认计算机按字节编址地址转换分页存储特点虽然进程的各个页面是离散存放的但是页面内部是连续存放的页号逻辑地址页面长度页内偏移量逻辑地址页面长度如果要访问逻辑地址的物理块则确定逻辑地址对应的页号找到号页面在内存中的起始地址需要查页表确定逻辑地址的页内偏移量基本地址变换机构基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址变换机构如下图所示通常会在系统中设置一个页表寄存器存放页表在内存中的起始地址和页表长度进程未执行时页表的始址和页表长度放在进程控制块中当进程被调度时操作系统内核会把它们放到页表寄存器中设页面大小为逻辑地址到物理地址的变换过程如下计算页号和页内偏移量如果用十进制数手算则但是在计算机实际运行时逻辑地址结构是固定不变的因此计算机硬件可以更快地得到二进制表示的页号页内偏移量判断页号是否越界比较页号和页表长度若则产生越界中断否则继续执行注意页号是从开始的而页表长度至少是因此时也会越界查页表找页号对应的页表项确定内存块号页表中页号对应的页表项地址页表起始地址页号页表项长度取出该页表项内容即为内存块号注意区分页表项长度页表长度页面大小的区别页表长度指的是这个页表中总共有几个页表项即总共有几个页页表项长度指的是每个页表项占多大的存储空间页面大小指的是一个页面占多大的存储空间用内存块号和偏移量得到物理地址计算用得到的物理地址去访存如果内存块号页面偏移量是用二进制表示的那么把二者拼接起来就是最终的物理地址了访问目标内存单元在分页存储管理页式管理的系统中页是信息的物理单位分页完全是系统行为因此页的大小由系统决定逻辑地址在计算机的视角很好确定所以页式管理中地址是一维的即只要给出一个逻辑地址系统就可以自动地算出页号页内偏移量两个部分并不需要显式地告诉系统这个逻辑地址中页内偏移量占多少位具有快表的地址变换机构快表又称联想寄存器是一种访问速度比内存快很多的高速缓存器用来存放最近访问的页表项的副本可以加速地址变换的速度与此对应内存中的页表常称为慢表注不是内存快表与高速缓冲器的区别在于块表中只有页表项的副本而普通中可能有其他各种数据的副本可以把快表理解为一种特殊的设某进程执行过程中要访问这个逻辑地址访问过程如下给出逻辑地址由硬件进行地址转换将页号与快表中的所有页号进行比较如果找到匹配的页号说明要访问的页表项在快表中有副本则直接从中取出该页对应的内存块号再将内存块号与页内偏移量拼接形成物理地址最后再访存因此若快表命中存取数据仅一次访存如果没有找到匹配的页号则需要访问内存中的页表找到对应页表项得到页面存放的内存块号再将内存块号与页内偏移量拼接形成物理地址最后再访存因此若快表未命中存取数据需两次访存注在找到页表项后应同时将其存入快表以便后面可能的再次访问但若快表已满则必须按照一定算法对旧的页表项进行替换局部性原理两级页表两级页表的分配管理方式属于基本分页存储管理范畴其用于解决页表项占据连续页框的问题单级页表存在的问题问题一页表必须连续存放因此当页表很大时需要占用很多个连续的页框解决可建立两级页表一级页表为页目录表二级页表离散存储问题二没有必要让整个页表常驻内存因为进程在一段时间内可能只需要访问某几个特定的页面解决可以在需要访问页面时才把页面调入内存虚拟存储技术可以在页表项中增加一个标志位用于表示该页面是否已经调入内存两级页表的原理地址结构二级页表实际上是在原有页表结构上再加上一层页表如下图所示建立多级页表的目的在于建立索引以便不用浪费主存空间去存储无用的页表项也不用盲目地顺序式查找页表项例某系统按字节寻址支持位的逻辑地址采用分页存储管理页面大小为页表项长度为试问逻辑地址的结构页面大小为则页内偏移量要用位表示则顷号用位表示即进程最多有个页面一共需要个页表项来记录这些页面与物理块的映射关系且页号范围是页表项长度是一个内存块页框最多存储个页表项个页表项则需要个内存块才能存储即需要专门给进程分配个连续的物理块页框来存放它的页表为避免连续占用内存块问题可以设置个二级页表并用一级页表来记录这些二级页表因此一级页号占位地址变换例将逻辑地址转换为物理地址用十进制表示首先按照地址结构将逻辑地址拆分成三部分从中读出页目录表始址再根据一级页号查页目录表找到下一级页表在内存中的存放位置根据二级页号查二级页表找到最终想访问的内存块号结合页内偏移量得到物理地址最终要访问的内存块号为该内存块的起始地址为页内偏移量为最终的物理地址为两次页表若采用快表需要次访存第一次访问页目录表第二次访问内存中的二级页表第三次访问目标内存单元多级页表若分为两级页表后页表依然很长则可以采用更多级页表并且若采用多级页表机制则各级页表的大小不能超过一个页面例某系统按字节编址采用位逻辑地址页面大小为页表项大小为假设采用纯页式存储则要采用级页表页内偏移量为位页面大小按字节编址因此页内偏移量为位页号位页面大小页表项大小则每个页面可存放个页表项因此各级页表最多包含个页表项需要位二进制位才能映射到个页表项因此每一级的页表对应页号应为位总共位的页号至少要分为级此外若未用快表级页表机制需要次访问内存基本分段式存储管理分页管理方式是从计算机的角度考虑设计的目的是提高内存的利用率提升计算机的性能分页通过硬件机制实现对用户完全透明分段管理方式的提出则考虑了用户和程序员以满足方便编程信息保护和共享动态增长及动态链接等多方面的需要分段段式管理方式按照用户进程中的自然段划分逻辑空间例如用户进程由主程序段两个子程序段栈段和数据段组成于是可以把这个用户进程划分为段每段从开始编址并分配一段连续的地址空间段内要求连续段间不要求连续因此整个作业的地址空间是二维的其逻辑地址由段号与段内偏移量两部分组成如下图所示分段系统中的逻辑地址结构其中段号为位段内偏移量为位因此一个作业最多有段最大段长为在页式系统中逻辑地址的页号和页内偏移量对用户是透明的但在段式系统中段号和段内偏移量必须由用户显式提供在高级程序设计语言中这个工作由编译程序完成段表程序分多个段各段离散地装入内存为了保证程序能正常运行就必须能从物理内存中找到各个逻辑段的存放位置为此需为每个进程建立一张段映射表简称段表段表用于实现从逻辑段到物理内存区的映射特点每个段对应一个段表项其中记录了该段在内存中的起始位置又称基址和段的长度各个段表项的长度是相同的由于段表项长度相同在内存中是连续存放因此段号可以是隐含的不占存储空间段内要求连续段间不要求连续因此整个作业的地址空间是二维的地址变换机构分段系统的地址变换过程如图所示为了实现进程从逻辑地址到物理地址的变换功能在系统中设置了段表寄存器用于存放段表始址和段表长度从逻辑地址到物理地址之间的地址变换过程如下根据逻辑地址得到段号段内地址从逻辑地址中取出前几位为段号后几位为段内偏移量判断段号是否越界比较段号和段表长度若段号段表长度则产生越界中断否则继续执行查询段表找到对应段表项段表中段号对应的段表项地址段表始址段号段表项长度检查段内地址是否超过段长取出该段表项的前几位得到段长若段内偏移量段长则产生越界中断否则继续执行计算得到物理地址取出段表项中该段的始址计算物理地址段基址偏移量得到物理地址访问目标内存单元用得到的物理地址去访问内存段的共享与保护共享在分段系统中段的共享是通过两个作业的段表中相应表项指向被共享的段的同一个物理副本来实现的不能修改的代码称为纯代码或可重入代码它不属于临界资源这样的代码和不能修改的数据可以共享而可修改的代码和数据不能共享保护分段管理的保护方法主要有两种一种是存取控制保护另一种是地址越界保护存取控制保护指在段表的每个表项中设置存取控制字段规定对该段的访问方式地址越界保护指在进行存储访问时要检查逻辑地址是否超出了进程的地址空间分段分页管理的对比存储信息地址空间信息保护访存次数分页管理页是信息的物理单位对用户透明系统行为一维记忆符不易分页单级页表需两次访问页表目标内存单元分段管理段是信息的逻辑单位对用户可见用户需求二维段名段内地址容易纯代码分段需两次访问段表目标内存单元段页式管理段页式管理结构分页存储管理能有效地提高内存利用率而分段存储管理能反映程序的逻辑结构并有利于段的共享和保护将这两种存储管理方法结合起来便形成了段页式存储管理方式段页式存储管理方式将作业的地址空间首先被分成若干逻辑段每段都有自己的段号然后将每个段分成若干大小固定的页内存空间分为大小一个个大小相等的分区如下图所示在段页式系统中作业的逻辑地址分为三部分段号页号和页内偏移量如下图所示段号的位数决定了每个进程最多可以分几个段页号位数决定了每个段最大有多少页页内偏移量决定了页面大小内存块大小是多少在一个进程中段表只有一个而页表可能有多个例如下图所示的段页式格式段号位因此进程中最多有个段页号位因此每个段最多有页页内偏移量有位因此每个内存块大小为分段对用户是可见的程序员编程时需要显式地给出段号段内地址而将各段分页对用户是不可见的系统会根据段内地址自动划分页号和页内偏移量因此段页式管理的地址结构是二维的地址转换在进行地址变换时首先通过段表查到页表始址然后通过页表找到页号最后形成物理地址如下图所示进行一次访问实际需要三次访问主存这里同样可以使用快表来加快查找速度其关键字由段号页号组成值是对应的页帧号和保护码根据逻辑地址得到段号页号页内偏移量判断段号是否越界若则产生越界中断否则继续执行查询段表找到对应的段表项段表项的存放地址为段表顶长度检查页号是香越界若页号页表长度则发生越界中断否则继续执行根据页表存放块号页号查询页表找到对应页表项根据内存块号页内偏移量得到最终的物理地址访问目标内存单元虚拟内存管理虚拟内存的基本概念传统存储管理方式的特征传统存储管理方式连续分配单一连续分配固定分区分配动态分区分配非连续分配基本分页存储管理基本分段存储管理基本段页式存储管理特征一次性作业必须一次性全部装入内存后才能开始运行这会导致两种情况当作业很大而不能全部被装入内存时将使该作业无法运行当大量作业要求运行时由于内存不足以容纳所有作业只能使少数作业先运行导致多道程序度的下降驻留性作业被装入内存后就一直驻留在内存中其任何部分都不会被换出直至作业运行结束运行中的进程会因等待而被阻塞可能处于长期等待状态由以上分析可知许多在程序运行中不用或暂时不用的程序数据占据了大量的内存空间而一些需要运行的作业又无法装入运行显然浪费了宝贵的内存资源局部性原理快表页高速缓存及虚拟内存技术都属于高速缓存技术这个技术所依赖的原理就是局部性原理时间局部性程序中的某条指令一且执行不久后该指令可能再次执行某数据被访问过不久后该数据可能再次被访问产生的原因是程序中存在着大量的循环操作空间局部性一旦程序访问了某个存储单元在不久后其附近的存储单元也将被访问即程序在一段时间内所访问的地址可能集中在一定的范围之内因为指令通常是顺序存放顺序执行的数据也一般是以向量数组表等形式聚存储的虚拟存储器的定义和特征程序不需全部装入即可运行运行时根据需要动态调入数据若内存不够还需换出一些数据系统好像为用户提供了一个比实际内存容量大得多的存储器称为虚拟存储器多次性无需在作业运行时一次性全部装入内存而是允许被分成多次调入内存对换性无需在作业运行时一直常驻内存而是允许在作业运行过程中将作业换入换出虚拟性从逻辑上扩充了内存的容量使用户看到的内存容量远大于实际的容量虚拟内存技术的实现虚拟内存的实现需要建立在离散分配的内存管理方式的基础上访问的信息不在内存时由操作系统负责将所需信息从外存调入内存请求调页功能内存空间不够时将内存中暂时用不到的信息换出到外存页面置换功能虚拟内存的实现方式请求分页存储管理请求分段存储管理请求段页式存储管理所需要的硬件支持一定容量的内存和外存页表机制或段表机制作为主要的数据结构中断机构当用户程序要访问的部分尚未调入内存时则产生中断地址变换机构逻辑地址到物理地址的变换请求分页管理方式请求分页系统建立在基本分页系统基础之上为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能请求分页是目前最常用的一种实现虚拟存储器的方法页表机制请求分页系统在一个作业运行之前不要求全部一次性调入内存因此在作业的运行过程中必然会出现要访问的页面不在内存中的情况因此在请求页表项中增加了个字段如下图所示状态位用于指示该页是否已调入内存供程序访问时参考访问字段用于记录本页在一段时间内被访问的次数或记录本页最近已有多长时间未被访问供置换算法换出页面时参考修改位标识该页在调入内存后是否被修改过以确定页面置换时是否写回外存外存地址用于指出该页在外存上的地址通常是物理块号供调入该页时参考缺页中断机构在请求分页系统中每当所要访问的页面不在内存中时便产生一个缺页中断请求操作系统将所缺的页调入内存缺页中断执行过程先将缺页的进程阻塞调页完成唤醒若内存中有空闲块则分配一个块将要调入的页装入该块并修改页表中的相应页表项若此时内存中没有空闲块则要淘汰某页若被淘汰页在内存期间被修改过则要将其写回外存缺页中断和一般中断的区别在指令执行期间而非一条指令执行完后产生和处理中断信号属于内部异常一条指令在执行期间可能产生多次缺页中断地址变换机构请求分页系统中的地址变换机构是在分页系统地址变换机构的基础上为实现虚拟内存又增加了某些功能而形成的如产生和处理缺页中断及从内存中换出一页的功能等等新增步骤请求调页查到页表项时进行判断新增步骤页面置换需要调入页面但没有空闲内存块时进行新增步骤需要修改请求页表中新增的表项请求分页管理的地址变换过程如下图所示红框部分为新增步骤只有写指令才需要修改修改位并且一般来说只需修改快表中的数据只有要将快表项删除时才需要写回内存中的慢表这样可以减少访存次数和普通的中断处理一样缺页中断处理依然需要保留现场需要用某种页面置换算法来决定一个换出页面下节内容换入换出页面都需要启动慢速的操作可见如果换入换出太频繁会有很大的开销页面调入内存后需要修改慢表同时也需要将表项复制到快表中页框分配驻留集大小给一个进程分配的物理页框的集合就是这个进程的驻留集分配给一个进程的页框越少驻留在主存中的进程就越多从而可提高的利用率若一个进程在主存中的页面过少则尽管有局部性原理缺页率仍相对较高若分配的页框过多则由于局部性原理对该进程的缺页率没有太明显的影响内存分配策略在请求分页系统中可采取两种内存分配策略即固定和可变分配策略在进行置换时也可采取两种策略即全局置换和局部置换固定分配操作系统为每个进程分配一组固定数目的物理块在进程运行期间不再改变即驻留集大小不变可变分配先为每个进程分配一定数目的物理块在进程运行期间可根据情况做适当的增加或减少即驻留集大小可变局部置换发生缺页时只能选进程自己的物理块进行置换全局置换可以将操作系统保留的空闲物理块分配给缺页进程也可以将别的进程持有的物理块置换到外存再分配给缺页进程固定分配可变分配区别在于进程运行期间驻留集大小是否可变局部置换全局置换区别在于发生缺页时是否只能从进程自己的页面中选择一个换出三种组合方案固定分配局部置换它为每个进程分配一定数目的物理块在整个运行期间都不改变若进程在运行中发生缺页则只能从该进程在内存中的页面中选出一页换出然后再调入需要的页面可变分配全局置换为系统中的每个进程分配一定数目的物理块操作系统自身也保持一个空闲物理块队列当某进程发生缺页时系统从空闲物理块队列中取出物理块分配给该进程井将欲调入的页装入其中可变分配局部置换它为每个进程分配一定数目的物理块当某进程发生缺页时只允许从该进程在内存的页面中选出一页换出动态变换频繁缺页分配物理块缺页率低减少物理块物理块调入算法采用固定分配策略时将系统中的空闲物理块分配给各个进程可采用下述几种算法平均分配算法将系统中所有可供分配的物理块平均分配给各个进程按比例分配算法根据进程的大小按比例分配物理块优先权分配算法为重要和紧迫的进程分配较多的物理块通常采取的方法是把所有可分配的物理块分成两部分一部分按比例分配给各个进程一部分则根据优先权分配调入页面的时机为确定系统将进程运行时所缺的页面调入内存的时机可采取以下两种调页策略预调页策略将预计在不久后便会被访问的页面预先调入内存主要用于进程的首次调入由程序员指出应先调入哪些页请求调页策略进程在运行中需要访问的页面不再内存而提出请求由系统将所需页面调入内存每次仅调入一页增加了磁盘开销从何处调入页面请求分页系统中的外存分为两部分用于存放文件的文件区和用于存放对换页面的对换区对换区采用连续分配方式而文件区采用离散分配方式因此对换区的磁盘速度比文件区的更快这样当发生缺页请求时系统从何处将缺页调入内存就分为三种情况系统拥有足够的对换区空间可以全部从对换区调入所需页面以提高调页速度为此在进程运行前需将与该进程有关的文件从文件区复制到对换区系统缺少足够的对换区空间凡是不会被修改的文件都直接从文件区调入而当换出这些页面时由于它们未被修改而不必再将它们换出但对于那些可能被修改的部分在将它们换出时须调到对换区以后需要时再从对换区调入因为读比写的速度快方式运行之前进程有关的数据全部放在文件区故未使用过的页面都可从文件区调入若被使用过的页面需要换出则写回对换区下次需要时从对换区调入进程请求的共享页面若被其他进程调入内存则无须再从对换区调入如何调入页面当进程所访问的页面不在内存中时存在位为便向发出缺页中断中断响应后便转入缺页中断处理程序该程序通过查找页表得到该页的物理块此时如果内存未满则启动磁盘将所缺页调入内存并修改页表如果内存已满则先按某种置换算法从内存中选出一页准备换出如果该页未被修改过修改位为则无须将该页写回磁盘如果该页已被修改修改位为则必须将该页写回磁盘然后将所缺页调入内存并修改页表中的相应表项置其存在位为调入完成后进程就可利用修改后的页表形成所要访问数据的内存地址页面置换算法进程运行时若其访问的页面不在内存中而需将其调入但内存已无空闲空间时就需要从内存中调出一页程序或数据送入磁盘的对换区选择调出页面的算法就称为页面置换算法最佳置换算法选择的被淘汰页面将是以后永不使用的或者是在最长时间内不再被访问的页面这样可以保证获得最低的缺页率但由于人们目前无法预知进程在内存下的页面中哪个是未来最长时间内不再被访问的因而该算法无法实现先进先出置换算法优先淘汰最早进入内存的页面即在内存中驻留时间最久的页面该算法实现简单只需把调入内存的页面根据先后次序链接成队列设置一个指针总指向最早的页面异常一一当为进程分配的物理块数增大时缺页次数不减反增的异常现象只有算法回产生异常算法性能差该算法与进程实际运行时的规律不适应因为在进程中有的页面经常被访问最近最久未使用置换算法选择最近最长时间未访问过的页面予以淘汰它认为过去一段时间内未访问过的页面在最近的将来可能也不会被访问该算法为每个页面设置一个访问字段来记录页面自上次被访问以来所经历的时间淘汰页面时选择现有页面中值最大的予以淘汰该算法的实现需要专门的硬件支持虽然算法性能好但是实现困难开销大时钟置换算法最近未用算法简单的算法实现方法为每个页面设置一个访问位再将内存中的页面都通过链接指针链接成一个循环队列当某页被访问时其访问位置为当需要淘汰一个页面时只需检查页的访问位如果是就选择该页换出如果是则将它置为暂不换出继续检查下一个页面若第一轮扫描中所有页面都是则将这些页面的访问位依次置为后再进行第二轮扫描第二轮扫描中一定会有访问位为的页面因此简单的算法选择一个淘汰页面最多会经过两轮扫描改进型的时钟置换算法简单时钟问题简单的时钟置换算法仅考虑到一个页面最近是否被访问过事实上如果被淘汰的页面没有被修改过就不需要执行操作写回外存只有被淘汰的页面被修改过时才需要写回外存因此除了考虑一个页面最近有没有被访问过之外操作系统还应考虑页面有没有被修改过在其他条件都相同时应优先淘汰没有修改过的页面避免操作这就是改进型的时钟置换算法的思想修改位表示页面没有被修改过修改位表示页面被修改过算法规则将所有可能被置换的页面排成一个循环队列用访问位修改位表示各页面状态替换帧优先级类最近未被访问且未被修改是最佳淘汰页类最近未被访问但已被修改不是很好的淘汰页类最近已被访问但未被修改可能再被访问类最近已被访问且已被修改可能再被访问第一轮第一优先级最近设访问且没修改的页面从当前位置开始扫描到第一个的帧用于替换本轮扫描不修改任何标志位第二轮第二优先级最近没访问但修改过的页面若第一轮扫描失败则重新扫描查找第一个的帧用于替换本轮将所有扫描过的帧访问位设为第三轮第三优先级最近访问过但没修改的页面若第二轮扫描失败则重新扫描查找第一个的帧用于替换本轮扫描不修改任何标志位第四轮第四优先级最近访问过且修改过的页面若第三轮扫描失败则重新扫描查找第一个的帧用于替换由于第二轮己将所有帧的访问位设为因此经过第三轮第四轮扫描定会有一个帧被选中因此改进型置换算法选择一个淘汰页面最多会进行四轮扫描性能算法开销较小性能也不错抖动和工作集抖动定义抖动又称颠簸指在页面置换过程中刚刚换出的页面马上又要换入主存刚刚换入的页面马上又要换出主存抖动发生的原因系统中同时运行的进程太多由此分配给每个进程的物理块太少不能满足进程正常运行的基本要求致使每个进程在运行时频繁地出现缺页必须请求系统将所缺页面调入内存抖动的危害使得在系统中排队等待页面调入调出的进程数目增加对磁盘的有效访问时间也随之急剧增加造成每个进程的大部分时间都用于页面的换入换出而几乎不能再去做任何有效的工作进而导致发生处理机的利用率急剧下降并趋于零的情况工作集由于抖动的发生与系统为进程分配物理块的多少有关于是又提出了关于进程工作集的概念工作集是指在某段时间间隔内进程要访问的页面集合基于局部性原理可以用最近访问过的页面来确定工作集一般来说工作集可由时间和工作集窗口大小来确定例如某进程对页面的访问次序如下假设系统为该进程设定的工作集窗口大小为则在时刻进程的工作集为在时刻进程的工作集为工作集大小一般会比窗口小很多工作集反映了进程在接下来的一段时间内很有可能会频繁访问的页面集合因此若分配给进程的物理块小于工作集大小则该进程就很有可能频繁缺页一般来说分配给进程的物理块数即驻留集大小要大于工作集大小内存映射文件内存映射文件与虚拟内存有些相似将磁盘文件的全部或部分内容与进程虚拟地址空间的某个区域建立映射关系便可以直接访问被映射的文件而不必执行文件操作也无须对文件内容进行缓存处理这种特性非常适合用来管理大尺寸文件特性进程可使用系统调用请求操作系统将文件映射到进程的虚拟地址空间以访问内存的方式读写文件进程关闭文件时操作系统负责将文件数据写回磁盘并解除内存映射多个进程可以映射同一个文件方便共享优点程序员编程更简单已建立映射的文件只需按访问内存的方式读写即可文件数据的读入写出完全由操作系统负责效率可以由操作系统负责优化虚拟存储器性能影响因素页面大小根据局部性原理页面较大则缺页率较低页面较小则缺页率较高页面较小时一方面减少了内存碎片有利于提高内存利用率另一方面也会使每个进程要求较多的页面导致页表过长占用大量内存页面较大时虽然可以减少页表长度但会使页内碎片增大分配给进程的物理块分配给进程的物理块数越多缺页率就越低但是当物理块超过某个数目时再为进程增加一个物理块对缺页率的改善是不明显的页面置换算法好的页面置换算法可使进程在运行过程中具有较低的缺页率选择等置换算法将未来有可能访问的页面尽量保留在内存中从而提高页面的访问速度写回磁盘的频率换出已修改过的页面时应当写回磁盘如果每当一个页面被换出时就将它写回磁盘那么每换出一个页面就需要启动一次磁盘效率极低建立一个已修改换出页面的链表对每个要被换出的页面已修改可以暂不将它们写回磁盘而将它们挂在该链表上仅当被换出页面数达到给定值时才将其写回磁盘局部化程度编写程序的局部化程度越高执行时的缺页率就越低如果存储采用的是按行存储访问时就要尽量采用相同的访问方式避免按列访问造成缺页率过高的现象地址翻译设某系统满足以下条件有一个与一个存储器以字节为编址单位虚拟地址位物理地址位页面大小为为四路组相联共有个条目是物理寻址直接映射的行大小为共有组写出访问地址为和的过程写出其地址结构根据页面大小求页内偏移量与页号长度本系统以字节编址页面大小为则页内偏移量为位所以虚拟页号为位物理页号为位根据结构求虚拟页号地址结构因为为四路组相联共有个条目则有组因此虚拟页号低位就为组索引高位为标记根据机构求物理页号地址结构因为行大小为因此物理地址中低位为块索引共有组可知接下来位为组索引剩下高位作为标记根据页表寻找物理页号先把十六进制的虚拟地址和转化为二进制形式如下表所示得到每个地址的组索引和标记接下来就要找出每个地址的页面在不在主存中若在主存中则还要找出物理地址查得到物理块号对于组索引为标记为查表第组中有标记为的项且有效位为找到物理块拼接页内地址得到物理地址为查未得到物理块号查页表得到物理块号对于组索引为标记为查表第组未找到有标记为的项访存查页表根据虚拟页号找到物理块号且有有效位为拼接页内地址得到物理地址为查未得到物理块号查页表也未得到物理块号对于组索引为标记为查表第组未找到有标记为的项访存查页表根据虚拟页号页表项有效位为页面不在主存中产生缺页中断根据寻找内存地址找出在主存中的页面的物理地址后就要通过物理地址访问数据接下来要找该物理地址的内容在不在中物理地址结构如下表所示块命中对于索引为标记为查询索引为的行标记为有效位为则该块在中偏移为即块可得虚拟地址的内容为块未命中对于索引为标记为查询索引为的行标记为有效位为则该块不在中需去访问主存查找物理页号为偏移为的内容虚拟地址寻址总流程文件管理文件系统基础文件的基本概念定义文件是以计算机硬盘为载体的存储在计算机上的信息集合在用户进行的输入输出中以文件位基本单位文件管理系统是实现的文件的访问修改和保存对文件维护管理的系统文件的组成存储空间用于存储数据标签便于对数据的分类和索引访问权限不同用户对数据有不同的访问权限文件的结构数据项是文件系统中最低级的数据组织形式可分为以下两种类型基本数据项用于描述一个对象的某种属性的一个值是数据中的最小逻辑单位组合数据项由多个基本数据项组成记录是一组相关的数据项的集合用于描述一个对象在某方面的属性文件是指由创建者所定义的具有文件名的一组相关元素的集合分为有结构文件和无结构文件两种在有结构的文件中文件由若干个相似的记录组成如一个班的学生记录无结构文件则被视为一个字符流比如一个二进制文件或字符文件文件控制块和索引结点文件的属性文件名由创建文件的用户决定文件名主要是为了方便用户找到文件同一目录下不允许有重名文件标识符一个系统内的各文件标识符唯一对用户来说毫无可读性因此标识符只是操作系统用于区分各个文件的一种内部名称类型指明文件的类型位置文件存放的路径让用户使用在外存中的地址操作系统使用对用户不可见大小指明文件大小保护信息对文件进行保护的访问控制信息创建时间最后一次修改时间和最后一次存取时间文件创建上次修改和上次访问的相关信息用于保护和跟踪文件的使用文件控制块文件控制块是用来存放控制文件需要的各种信息的数据结构以实现按名存取操作系统通过文件控制块来维护文件元数据的有序集合称为文件目录一个就是一个文件目录项下图为一个典型的包含以下信息基本信息如文件名文件的物理位置文件的逻辑结构文件的物理结构等存取控制信息包括文件主的存取权限核准用户的存取权限以及一般用户的存取权限使用信息如文件建立时间上次修改时间等一个文件目录也被视为一个文件称为目录文件索引结点在检索目录时只用到了文件名因此有的系统采用文件名与文件描述分开的方法使文件描述信息单独形成一个称为索引结点的数据结构简称结点在文件目录中的每个目录项仅由文件名和指向该文件所对应的结点的指针构成假设一个为盘块大小是则每个盘块中可以存放个必须连续存放若一个文件目录共有个则查找文件平均需要启动磁盘次而在系统中一个目录项仅占其中是文件名是结点指针在的盘块中可存放个目录项这样可使查找文件的平均启动磁盘次数减少到原来的大大节省了系统开销磁盘索引结点它是指存放在磁盘上的索引结点每个文件有一个唯一的磁盘索引结点主要包括以下内容文件主标识符拥有该文件的个人或小组的标识符文件类型包括普通文件目录文件或特别文件文件存取权限各类用户对该文件的存取权限文件物理地址每个索引结点中含有个地址项即它们以直接或间接方式给出数据文件所在盘块的编号文件长度指以字节为单位的文件长度文件链接计教在本文件系统中所有指向该文件的文件名的指针计数文件存取时间本文件最近被进程存取的时间最近被修改的时间及索引结点最近被修改的时间内存索引结点它是指存放在内存中的索引结点当文件被打开时要将磁盘索引结点复制到内存的索引结点中便于以后使用在内存索引结点中增加了以下内容索引结点编号用于标识内存索引结点状态指示结点是否上锁或被修改访问计数每当有一进程要访问此结点时计数加访问结束减逻辑设备号文件所属文件系统的逻辑设备号链接指针设置分别指向空闲链表和散列队列的指针文件的操作文件的基本操作文件属于抽象数据类型为了正确地定义文件需要考虑可以对文件执行的操作操作系统提供系统调用它对文件进行创建写读重定位删除和截断等操作创建文件系统调用为新文件分配必要的外存空间在目录中为之创建一个目录项目录项记录了新文件名在外存中的地址及其他可能的信息删除文件系统调用先从目录中检索指定文件名的目录项然后释放该文件所占的存储空间以便可被其他文件重复使用并删除目录条目读文件系统调用对于给定文件名搜索目录以查找文件位置系统维护一个读位置的指针每当发生读操作时更新读指针写文件系统调用对于给定文件名搜索目录以查找文件位置系统必须为该文件维护一个写位置的指针每当发生写操作时便更新写指针一个进程通常只对一个文件读或写因此当前操作位置可作为每个进程当前文件位置的指针由于读和写操作都使用同一指针因此节省了空间也降低了系统复杂度重新定位文件也称文件定位搜索目录以找到适当的条目并将当前文件位置指针重新定位到给定值重新定位文件不涉及读写文件截断文件允许文件所有属性不变并删除文件内容将其长度置为并释放其空间这个基本操作可以组合起来执行其他文件操作例如一个文件的复制可以创建新文件从旧文件读出并写入新文件文件的打开与关闭打开文件系统调用过程调用根据文件名搜索目录将指明文件的属性包括该文件在外存上的物理位置从外存复制到内存打开文件表的一个表目中并将该表目的编号也称索引返回给用户打开文件时并不会把文件数据直接读入内存索引号也称文件描述符打开文件之后对文件的操作不再需要每次都查询目录可以根据内存中的打开文件表进行操作如上图所示在多个不同进程同时打开文件的操作系统中通常采用两级表整个系统表和每个进程表整个系统的打开文件表包含的副本及其他信息每个进程的打开文件表根据它打开的所有文件包含指向系统表中适当条目的指针一旦有进程打开了一个文件系统表就包含该文件的条目当另一个进程执行调用时只不过是在其文件打开表中增加一个条目并指向系统表的相应条目关闭文件系统调用将进程的打开文件表相应表项删除回收分配给该文件的内存空间等资源系统打开文件表的打开计数器减若则删除对应表项系统打开文件表为每个文件关联一个打开计数器以记录多少进程打开了该文件文件名不必是打开文件表的一部分因为一且完成对在磁盘上的定位系统就不再使用文件名对于访问打开文件表的索引称之为文件描述符而称之为文件句柄因此只要文件未被关闭所有文件操作就通过打开文件表来进行打开文件信息文件指针系统跟踪上次的读写位置作为当前文件位置的指针这种指针对打开文件的某个进程来说是唯一的因此必须与磁盘文件属性分开保存文件打开计数计数器跟踪当前文件打开和关闭的数量因为多个进程可能打开同一个文件所以系统在删除打开文件条目之前必须等待最后一个进程关闭文件文件磁盘位置大多数文件操作要求系统修改文件数据查找磁盘上的文件所需的信息保存在内存中以便系统不必为每个操作都从磁盘上读取该信息访问权限每个进程打开文件都需要有一个访问模式创建只读读写添加等该信息保存在进程的打开文件表中以便操作系统能够允许或拒绝后续的请求文件保护文件保护通过口令保护加密保护和访问控制等方式实现其中口令和加密是为了防止用户文件被他人存取或窃取而访问控制则用于控制用户对文件的访问方式口令保护为文件设置一个口令用户想要访问文件时需要提供口令由系统验证口令是否正确实现开销小但口令一般存放在或索引结点中也就是存放在系统中因此不太安全加密保护用一个密码对文件加密用户想要访问文件时需要提供相同的密码才能正确的解密安全性高但加密解密需要耗费一定的时间异或加密访问控制访问类型对文件的保护可从限制对文件的访问类型中出发可加以控制的访问类型主要有以下几种读从文件中读写向文件中写执行将文件装入内存并执行添加将新信息添加到文件结尾部分删除删除文件释放空间列表清单列出文件名和文件属性此外还可以对文件的重命名复制编辑等加以控制这些高层的功能可以通过系统程序调用低层系统调用来实现保护可以只在低层提供访问控制解决访问控制最常用的方法是根据用户身份进行控制而实现基于身份访问的最为普通的方法是为每个文件和目录增加一个访问控制列表以规定每个用户名及其所允许的访问类型优点可以使用复杂的访问方法缺点长度无法预计并且可能导致复杂的空间管理使用精简的访问列表可以解决这个问题精简的访问列表采用拥有者组和其他三种用户类型拥有者创建文件的用户组一组需要共享文件且具有类似访问的用户其他系统内的所有其他用户文件主在创建文件时说明创建者用户名及所在的组名系统在创建文件时也将文件主的名字所属组名列在该文件的中用户访问该文件时若用户是文件主按照文件主所拥有的权限访问文件若用户和文件主在同一个用户组则按照同组权限访问否则只能按其他用户权限访问文件的逻辑结构文件的逻辑结构是从用户观点出发看到的文件的组织形式文件的物理结构存储结构是从实现观点出发看到的文件在外存上的存储组织形式文件的逻辑结构与存储介质特性无关它实际上是指在文件的内部数据逻辑上是如何组织起来的无结构文件流式文件无结构文件将数据按顺序组织成记录并积累保存它是有序相关信息项的集合以字节为单位只能通过穷举搜索的方式访问记录其管理简单用户操作方便对基本信息单位操作不多的文件适于采用字符流的无结构文件例如源程序文件目标代码文件等有结构文件记录式文件顺序文件文件中的记录一个接一个地顺序排列逻辑上记录可以是定长的或可变长的各个记录在物理上可以顺序存储或链式存储链式存储无论是定长何变长记录都无法实现随机存取每次只能从第一个记录开始依次往后查找顺序存储可实现随机存取记录长度为则第个记录存放的相对位置是若采用串结构记录之间的顺序与关键字无关无法快速找到某关键字对应的记录若采用顺序结构可以快速找到某关键字对应的记录如折半查找定长记录的顺序文件若物理上采用顺序存储则可实现随机存取若能再保证记录的顺序结构则可实现快速检索即根据关键字快速找到对应记录优点读写一大批文件时效率最高适用于顺序存储设备磁带缺点不方便增加删除记录索引文件索引表高效查询变长记录文件索引表本身是定长记录的顺序文件因此可以快速找到第个记录对应的索引项方式可将关键字作为索引号内容若按关键字顺序排列则还可以支持按照关键字折半查找每当要增加删除一个记录时需要对索引表进行修改由于索引文件有很快的检索速度因此主要用于对信息处理的及时性要求比较高的场合索引顺序文件索引顺序文件是索引文件和顺序文件思想的结合索引顺序文件中同样会为文件建立一张索引表但不同的是并不是每个记录对应一个索引表项而是一组记录对应一个索引表项将记录分组每组对应一个素引表项检素记录时先顺序查索引表找到分组再顺序查找分组当记录过多时可建立多级素引表如上图所示主文件名包含姓名和其他数据项姓名为关键字索引表中为每组的第一条记录不是每条记录的关键字值用指针指向主文件中该记录的起始位置索引表只包含关键字和指针两个数据项所有姓名关键字递增排列主文件中记录分组排列同一个组中的关键字可以无序但组与组之间的关键字必须有序查找一条记录时首先通过索引表找到其所在的组然后在该组中使用顺序查找就能很快地找到记录直接文件或散列文件给定记录的键值或通过散列函数转换的键值直接决定记录的物理地址这种映射结构不同于顺序文件或索引文件没有顺序的特性散列文件有很高的存取速度但是会引起冲突即不同关键字的散列函数值相同文件的物理结构文件的物理结构就是研究文件的实现即文件数据在物理存储设备上是如何分布和组织的文件分配对应于文件的物理结构是指如何为文件分配磁盘块常用的磁盘空间分配方法有三种连续分配链接分配和索引分配连续分配连续分配方法要求每个文件在磁盘上占有一组连续的块磁盘地址定义了磁盘上的一个线性排序这种排序使作业访问磁盘时需要的寻道数和寻道时间最小物理块号起始块号逻辑块号优点支持顺序访问和直接访问即随机访问连续分配的文件在顺序访问时速度最快缺点不方便文件拓展存储空间利用率低会产生磁盘碎片外部碎片文件长度不宜动态增加因为一个文件末尾后的盘块可能已分配给其他文件一旦需要增加就需要大量移动盘块为保持文件的有序性删除和插入记录时需要对相邻的记录做物理上的移动还会动态改变文件的长度反复增删文件后会产生外部碎片与内存管理分配方式中的碎片相似很难确定一个文件需要的空间大小因而只适用于长度固定的文件访存次数访问第条记录需访问磁盘次链接分配链接分配采取离散分配的方式可以为文件分配离散的磁盘块分为隐式链接和显式链接两种访问第条记录需访问磁盘次隐式链接除文件的最后一个盘块之外每个盘块中都存有指向下一个盘块的指针文件目录包括文件第一块的指针和最后一块的指针优点很方便文件拓展不会有碎片问题外存利用率高缺点只支持顺序访问不支持随机访问查找效率低指向下一个盘块的指针也需要耗费少量的存储空间结论采用隐式链接的链接分配方式很方便文件拓展另外所有的空闲磁盘块都可以被利用不会有碎片问题外存利用率高显式链接把用于链接文件各物理块的指针显式地存放在文件分配表中一个磁盘只会建立一张文件分配表开机时文件分配表放入内存并常驻内存优点很方便文件拓展不会有碎片问题外存利用率高并且支持随机访问相比于隐式链接来说地址转换时不需要访问磁盘因此文件的访问效率更高缺点文件分配表的需要占用一定的存储空间结论采用链式分配显式链接方式的文件支持顺序访问也支持随机访问想访问号逻辑块时并不需要依次访问之前的号逻辑块由于块号转换的过程不需要访问磁盘因此相比于隐式链接来说访问速度快很多文件分配表不仅记录了文件分配信息显示链接还兼职做了空闲块管理索引分配索引分配允许文件离散地分配在各个磁盘块中系统会为每个文件建立一张索引表索引表中记录了文件的各个逻辑块对应的物理块索引表存放的磁盘块称为索引块文件数据存放的磁盘块称为数据块索引表的逻辑块号可以是隐含的进一步节约空间链接方案如果索引表太大一个索引块装不下那么可以将多个索引块链接起来存放缺点需要顺序访问当文件很大时查我效率低下多层索引建立多层索引原理类似于多级页表使第一层索引块指向第二层的索引块还可根据文件大小的要求再建立第三层第四层索引块采用层索引结构且顶级索引表未调入内存则访问一个数据块只需要次读磁盘操作缺点即使是小文件访问数据块也需受次读磁盘混合索引多种索引分配方式的结合例如一个文件的顶级索引表中既包含直接地址索引直接指向数据块又包含一级间接索引指向单层索引表还包含两级间接索引指向两层索引表所允许的文件最大长度设有个直接地址项个一次间接地址项个二次间接地址项每个盘块大小字节盘块号占个字节公式如下文件最大长度优点对于小文件只需较少的读磁盘次数就可以访问目标数据块一般计算机中小文件更多总结目录目录的基本概念文件目录指的有序集合一个就是一个文件的目录项与文件管理系统和文件集合相关联的是文件目录它包含有关文件的属性位置和所有权等目录管理的基本要求从用户的角度看目录在用户应用程序所需要的文件名和文件之间提供一种映射所以目录管理要实现按名存取目录存取的效率直接影响到系统的性能所以要提高对目录的检索速度在多用户系统中应允许多个用户共享一个文件因此目录还需要提供用于控制访问文件的信息此外应允许不同用户对不同文件采用相同的名字以便于用户按自己的习惯给文件命名目录管理通过树形结构来解决和实现目录结构单级目录结构在整个文件系统中只建立一张目录表每个文件占一个目录项不允许文件重名如下图所示当访问一个文件时先按文件名在该目录中查找到相应的经合法性检查后执行相应的操作当建立一个新文件时必须先检索所有目录项以确保没有重名的情况然后在该目录中增设一项把新文件的属性信息填入到该项中两级目录结构将文件目录分成主文件目录和用户文件目录两级不同用户的文件可以重名但不能对文件分类主文件目录项记录用户名及相应用户文件目录所在的存储位置用户文件目录项记录该用户文件的信息树形目录结构不同目录下的文件可以重名可以对文件进行分类不方便共享根据文件路径找到目标文件用户或用户进程要访问某个文件时要用文件路径名标识文件文件路径名是个字符串各级日录之间用隔开从根目录出发的路径称为绝对路径例如自拍的绝对路径是照片自拍系统根据绝对路径一层一层地找到下一级目录刚开始从外存读入根目录的目录表找到照片目录的存放位置后从外存读入对应的目录表再找到目录的存放位置再从外存读入对应目录表最后才找到文件自拍的存放位置整个过程需要次读磁盘操作引入当前目录和相对路径后磁盘的次数减少了这就提升了访问文件的效率从根目录出发是绝对路径从当前目录出发是相对路径无环图目录结构在树形目录的基础上增加一些指向同一结点的有向边使整个目录成为一个有向无环图实现文件的共享为共享结点设置一个共享计数器计数器为时才真正删除该结点对于共享文件只存在一个真正的文件任何改变都会为其他用户所见目录的操作搜索当用户使用一个文件时需要搜索目录以找到该文件的对应目录项创建文件当创建一个新文件时需要在目录中增加一个目录项删除文件当删除一个文件时需要在目录中删除相应的目录项创建目录在树形目录结构中用户可创建自己的用户文件目录并可再创建子目录删除目录有两种方式不删除非空目录删除时要先删除目录中的所有文件并递归地删除子目录可删除非空目录目录中的文件和子目录同时被删除移动目录将文件或子目录在不同的父目录之间移动文件的路径名也会随之改变显示目录用户可以请求显示目录的内容如显示该用户目录中的所有文件及属性修改目录某些文件属性保存在目录中因而这些属性的变化需要改变相应的目录项目录实现目录实现有线性列表和哈希表两种方式线性列表实现对应线性查找哈希表的实现对应散列查找线性列表最简单的目录实现方法是采用文件名和数据块指针的线性列表当创建新文件时必须首先搜索目录以确定没有同名的文件存在然后在目录中增加一个新的目录项当删除文件时则根据给定的文件名搜索目录然后释放分配给它的空间当要重用目录项时有许多种方法可以将目录项标记为不再使用或将它加到空闲目录项的列表上还可以将目录的最后一个目录项复制到空闲位置并减少目录的长度采用链表结构可以减少删除文件的时间线性列表的优点在于实现简单不过由于线性表的特殊性查我比较费时哈希表哈希表根据文件名得到一个值并返回一个指向线性列表中元素的指针优点查找非常迅速插入和删除也较简单问题需要一些措施来避免冲突两个文件名称哈希到同一位置为了减少操作把当前使用的文件目录复制到内存以后要使用该文件时只需在内存中操作因此降低了磁盘操作次数提高了系统速度文件共享文件共享使多个用户共享同一个文件系统中只需保留该文件的一个副本基于索引结点的共享方式硬链接各个用户的目录项指向同一个索引结点索引结点中需要链接计数用于表示链接到本索引结点上的用户目录项数某用户删除文件只是删除该用户的目录项只有才能真正删除文件数据和索引结点利用符号链实现文件共享软链接为使用户能共享用户的一个文件可以由系统创建一个类型的新文件也取名为并将该文件写入用户的目录中以实现用户的目录与文件的链接在一个型的文件中记录共享文件的存放路径快捷方式操作系统根据路径一层层查找目录最终找到共享文件当访问时操作系统判断文件属于类型文件于是会根据其中记录的路径层层查找目录最终找到的目录表中的表项于是就找到了文件的索引结点即使软链接指向的共享文件已被删除型文件依然存在只是通过型文件中的路径去查找共享文件会失败找不到对应目录项由于用软链接的方式访问共享文件时要查询多级目录会有多次磁盘因此用软链接访问的速度要比硬链接更慢硬链接和软链接都是文件系统中的静态共享方法在文件系统中还存在着另外的共享需求即两个进程同时对同一个文件进行操作这样的共享称为动态共享文件系统文件系统结构文件系统提供高效和便捷的磁盘访问以便允许存储定位提取数据用一个例子来辅助记忆文件系统的层次结构假设某用户请求删除文件工作目录学生信息的最后条记录用户需要通过操作系统提供的接口发出上述请求一一用户接口由于用户提供的是文件的存放路径因此需要操作系统一层一层地查找目录找到对应的目录项一一文件目录系统不同的用户对文件有不同的操作权限因此为了保证安全需要检查用户是否有访问权限一一存取控制模块存取控制验证层验证了用户的访问权限之后需要把用户提供的记录号转变为对应的逻辑地址一一逻辑文件系统与文件信息缓冲区知道了标记录对应的逻辑地址后还需要转换成实际的物理地址一一物理文件系统要删除这条记录必定要对磁盘设备发出请求一一设备管理程序模块删除这些记录后会有一些盘块空闲因此要将这些空闲盘块回收一一辅助分配模块文件系统布局文件系统在磁盘中的结构文件系统存放在磁盘上多数磁盘划分为一个或多个分区每个分区中有一个独立的文件系统文件系统可能包括如下信息启动存储在那里的操作系统的方式总的块数空闲块的数量和位置目录结构以及各个具体文件等如下图所示主引导记录位于磁盘的号扇区用来引导计算机后面是分区表该表给出每个分区的起始和结束地址表中的一个分区被标记为活动分区当计算机启动时读入并执行做的第一件事是确定活动分区读入它的第一块即引导块引导块执行引导块中的程序后该程序负责启动该分区中的操作系统为统一起见每个分区都从一个引导块开始即使它不含有一个可启动的操作系统也不排除以后会在该分区安装一个操作系统系统称之为分区引导扇区除了从引导块开始磁盘分区的布局是随着文件系统的不同而变化的文件系统经常包含有如上图所列的一些项目超级块包含文件系统的所有关键信息在计算机启动时或者在该文件系统首次使用时超级块会被读入内存超级块中的典型信息包括分区的块的数量块的大小空闲块的数量和指针空闲的数量和指针等文件系统中空闲块的信息可以使用位示图或指针链接的形式给出结点索引结点连续存放每个文件对应一个结点可以把结点区看成一个大数组根目录它存放文件系统目录树的根部其他部分存放了其他所有的目录和文件文件系统在内存中的结构内存中的信息用于管理文件系统并通过缓存来提高性能这些数据在安装文件系统时被加载在文件系统操作期间被更新在卸载时被丢弃这些结构的类型可能包括内存中的安装表包含每个己安装文件系统分区的有关信息内存中的目录结构的缓存包含最近访问目录的信息对安装分区的目录它可以包括一个指向分区表的指针整个系统的打开文件表包含每个打开文件的副本及其他信息每个进程的打开文件表包含一个指向整个系统的打开文件表中的适当条目的指针以及其他信息进程创建为了创建新的文件应用程序调用逻辑文件系统逻辑文件系统知道目录结构的格式它将为文件分配一个新的然后系统将相应的目录读入内存使用新的文件名和进行更新并将它写回磁盘一旦文件被创建它就能用于不过首先要打开文件系统调用将文件名传递给逻辑文件系统调用首先搜索整个系统的打开文件表以确定这个文件是否已被其他进程使用如果已被使用则在单个进程的打开文件表中创建一个条目让其指向现有整个系统的打开文件表的相应条目该算法在文件已打开时能节省大量开销如果这个文件尚未打开则根据给定文件名来搜索目录结构部分目录结构通常缓存在内存中以加快目录操作找到文件后它的会复制到整个系统的打开文件表中该表不但存储而且跟踪打开该文件的进程的数量然后在单个进程的打开文件表中创建一个条目并且通过指针将整个系统打开文件表的条目与其他域如文件当前位置的指针和文件访问模式等相连调用返回的是一个指向单个进程的打开文件表中的适当条自的指针以后所有文件操作都通过该指针执行一旦文件被打开内核就不再使用文件名来访问文件而使用文件描述符称之为文件句柄进程关闭当进程关闭一个文件时就会删除单个进程打开文件表中的相应条目整个系统的打开文件表的文件打开数量也会递减当所有打开某个文件的用户都关闭该文件后任何更新的元数据将复制到磁盘的目录结构中并且整个系统的打开文件表的对应条目也会被删除外存空闲空间管理一个存储设备可以按整体用于文件系统也可以细分例如一个磁盘可以划分为个分区每个分区都可以有单独的文件系统包含文件系统的分区通常称为卷卷可以是磁盘的一部分也可以是整个磁盘还可以是多个磁盘组成集如图所示在一个卷中存放文件数据的空间文件区和的空间目录区是分离的文件存储设备分成许多大小相同的物理块并以块为单位交换信息因此文件存储设备的管理实质上是对空闲块的组织和管理它包括空闲块的组织分配与回收等问题空闲表法空闲表法属于连续分配方式它与内存的动态分配方式类似为每个文件分配一块连续的存储空间盘块的分配与内存管理中的动态分区分配很类似为一个文件分配连续的存储空间同样可采用首次适应最佳适应最坏适应等算法来决定要为文件分配哪个区间盘块的回收与内存管理中的动态分区分配很类似当回收某个存储区时需要有四种情况回收区的前后都没有相邻空闲区回收区的前后都是空闲区回收区前面是空闲区回收区后面是空闲区总之回收时需要注意表项的合并问题空闲链表法将所有空闲盘区拉成一条空闲链根据构成链所用基本元素的不同分为两种形式空闲盘块链将磁盘上的所有空闲空间以盘块为单位拉成一条链操作系统保存着链头链尾指针如何分配若某文件申请个盘块则从链头开始依次摘下个盘块分配并修改空闲链的链头指针如何回收回收的盘块依次挂到链尾并修改空闲链的链尾指针适用于离散分配的物理结构为文件分配多个盘块时可能要重复多次操作空闲盘区链将磁盘上的所有空闲盘区每个盘区可包含若干个盘块拉成一条链操作系统保存着链头链尾指针如何分配若某文件申请个盘块则可以采用首次适应最佳适应等算法从链头开始检索按照算法规则找到一个大小符合要求的空闲盘区分配给文件若没有合适的连续空闲块也可以将不同盘区的盘块同时分配给一个文件注意分配后可能要修改相应的链指针盘区大小等数据如何回收若回收区和某个空闲盘区相邻则需要将回收区合并到空闲盘区中若回收区没有和任何空闲区相邻将回收区作为单独的一个空闲盘区挂到链尾离散分配连续分配都适用为一个文件分配多个盘块时效率更高位示图法位示图是利用二进制的一位来表示磁盘中一个盘块的使用情况磁盘上所有的盘块都有一个二进制位与之对应当其值为时表示对应的盘块空闲为时表示已分配这样一个位组成的位示图就可用来表示个盘块的使用情况如图所示行为位号列为字号注意盘块号字号位号到底是从开始还是从开始两者计算盘块号方式不同盘块的分配顺序扫描位示图从中找出一个或一组其值为的二进制位将找到的一个或一组二进制位转换成与之对应的盘块号若找到的其值为的二进制位位于位示图的第行第列则其相应的盘块号应按下式计算为每行位数字位盘块号从开始字位盘块号从开始修改位示图令盘块的回收将回收盘块的盘块号转换成位示图中的行号和列号转换公式为字位盘块号从开始字位盘块号从开始修改位示图令空闲表法和空闲链表法都不适用于大型文件系统因为这会使空闲表或空闲链表太大成组链接法在系统中采用的是成组链接法这种方法结合了空闲表和空闲链表两种方法它具有上述两种方法的优点克服了两种方法均有的表太长的缺点文件卷的目录区中专门用一个磁盘块作为超级块当系统启动时需要将超级块读入内存并且要保证内存与外存中的超级块数据一致用来存放一组空闲盘块号空闲盘块的块号的盘块称为成组链块成组链接思想把顺序的个空闲盘块号保存在第一个成组链块中其最后一个空闲盘块作为成组链块则用于保存另一组空闲盘块号如此继续直至所有空闲盘块均予以链接盘块的分配分配个空闲块检查第一个分组的块数是否足够是足够的分配第一个分组中的个空闲块并修改相应数据分配个空闲块检查第一个分组的块数是否足够是足够的分配第一个分组中的个空闲块但是由于号块内存放了再下一组的信息因此号块的数据需要复制到超级块中盘块的回收需要将超级块中的数据复制到新回收的块中并修改超级块的内容让新回收的块成为第一个分组虚拟文件系统虚拟文件系统为用户程序提供了文件系统操作的统一接口屏蔽了不同文件系统的差异和操作细节普通文件系统下图普通的文件系统不同的外部存储设备它的文件系统可能是不相同的对于同一个操作的函数方法定义也许也各不相同虚拟文件系统下图为虚拟文件系统用户程序可以通过提供的统一调用函数如等来操作不同文件系统的文件而无须考虑具体的文件系统和实际的存储介质虚拟文件系统采用了面向对象的思想它抽象出一个通用的文件系统模型定义了通用文件系统都支持的接口新的文件系统只要支持并实现这些接口即可安装和使用为了实现主要抽象了四种对象类型每个对象都存放在一个适当的数据结构中其中包括对象的属性和指向对象方法函数表的指针超级块对象表示一个已安装或称挂载的特定文件系统索引结点对象表示一个特定的文件目录项对象表示一个特定的目录项文件对象表示一个与进程相关的已打开文件进程与对象之间的交互如下图所示三个不同的进程已打开了同一个文件其中两个进程使用同一个硬链接在这种情况下每个进程都使用自己的文件对象但只需要两个目录项对象每个硬链接对应一个目录项对象这两个目录项对象指向同一个索引结点对象这个索引结点对象标识的是超级块对象及随后的普通磁盘文件对于不同文件系统的数据结构在每打开一个文件就在主存建立一个用统一的数据结构表示文件打开文件后创建并将文件信息复制到中的功能指针指向具体文件系统的函数功能只存在于主存中而既会被调入主存也会在外存中存储特点向上层用户进程提供统一标准的系统调用接口屏蔽底层具体文件系统的实现差异要求下层的文件系统必须实现某些规定的函数功能如一个新的文件系统想要在某操作系统上被使用就必须满足该操作系统的要求每打开一个文件就在主存中新建一个用统一的数据结构表示文件无论该文件存储在哪个文件系统分区和安装分区物理格式化低级格式化划分扇区检测坏扇区用备用扇区替换坏扇区当要访问某一块坏扇区时会使用备用扇区默默完成替换工作逻辑格式化高级格式化磁盘分区每个区的大小地址范围等信息会使用分区表来记录在每个区里可以建立各自独立的文件系统例如在盘里建立文件系统分区的第一部分是引导块里面存储着引导信息它有自身的格式因为在引导时系统并未加载文件系统代码因此不能解释文件系统的格式下图为一个典型的分区安装文件系统在进程使用前必须先安装也称挂载任务是将一个文件系统挂载到操作系统中功能在中注册新挂载的文件系统内存中的挂载表包含每个文件系统的相关信息包括文件系统类型容量大小等新挂载的文件系统要向提供一个函数地址列表将新文件系统加到挂载点也就是将新文件系统挂载在某个父目录下本身是一个固定的目录树只要安装就有但是如果不给它分配存储空间就不能对它进行操作所以首先要给根目录分配空间这样才能操作这个目录树输入输出管理管理概述设备设备是将数据输入到计算机中或者可以接收计算机输出数据的外部设备属于计算机中的硬件部件设备的分类按使用特性分类人机交互类外部设备鼠标键盘打印机等用于人机交互数据传输速度慢存储设备移动硬盘光盘等用于数据存储数据传输速度快网络通信设备调制解调器等用于网络通信数据传输速度介于上述二者之间按信息交换的单位分类块设备信息交换以数据块为单位它属于有结构设备如磁盘等磁盘设备的基本特征是传输速率较高可寻址即对它可随机地读写任意一块字符设备信息交换以字符为单位它属于无结构类型如交互式终端机打印机等按传输速率分类低速设备传输速率仅为每秒几字节到数百字节的一类设备如键盘鼠标等中速设备传输速率为每秒数千字节至数万字节的一类设备如激光打印机等高速设备传输速率在数百千字节至千兆字节的一类设备如磁盘机光盘机等接口接口设备控制器位于与设备之间它既要与通信又要与设备通信还要具有按发来的命令去控制设备工作的功能主要由三部分组成如下图所示组成部分设备控制器与的接口实现控制器与之间的通信该接口有三类信号线数据线地址线和控制线数据线与两类寄存器相连数据寄存器存放从设备送来的输入数据或从送来的输出数据和控制状态寄存器存放从送来的控制信息或设备的状态信息设备控制器与设备的接口实现控制器与设备之间的通信一个设备控制器可以连接一个或多个设备因此控制器中有一个或多个设备接口每个接口中都存在数据控制和状态三种类型的信号逻辑负责识别发出的命令并向设备发出命令用于实现对设备的控制它通过一组控制线与交互对从收到的命令进行译码启动设备时将启动命令发送给控制器同时通过地址线把地址发送给控制器由控制器的逻辑对地址进行译码并相应地对所选设备进行控制主要功能接受和识别发出的指令控制寄存器向报告设备的状态状态寄存器数据交换数据寄存器暂存数据地址识别由逻辑实现数据缓冲差错控制端口端口是指设备控制器中可被直接访问的寄存器主要有以下三类寄存器寄存器类型数据寄存器实现和外设之间的数据缓冲状态寄存器获取执行结果和设备的状态信息以让知道是否准备好控制寄存器由写入以便启动命令或更改设备模式实现端口通信有两种编址方法独立编址为每个端口分配一个端口号所有端口形成端口空间普通用户程序不能对其进行访问只有操作系统使用特殊的指令才能访问端口统一编址又称内存映射每个端口被分配唯一的内存地址且不会有内存被分配这地址通常分配给端口的地址靠近地址空间的顶端控制方式设备管理的主要任务之一是控制设备和内存或之间的数据传送外围设备与内存之间的输入输出控制方式有以下种程序直接控制方式如下图所示计算机从外部设备读取的每个字需要对外设状态进行循环检查直到确定该字已经在控制器的数据寄存器中工作流程干预的频率很频繁操作开始之前完成之后需要介入并且在等待完成的过程中需要不断地轮询检查数据传送的单位每次读写一个字数据的流向读操作数据输入设备内存写操作数据输出内存设备每个字的读写都需要的帮助优点实现简单在读写指令之后加上实现循环检查的一系列指令即可缺点和设备只能串行工作需要一直轮询检查长期处于忙等状态利用率低中断驱动方式中断驱动方式的思想是允许设备主动打断的运行并请求服务从而解放使得其向控制器发送读命令后可以继续做其他有用的工作工作流程引入中断机制由于设备速度很慢因此在发出读写命令后可将等待的进程阻塞先切换到别的进程执行当完成后控制器会向发出一个中断信号检测到中断信号后会保存当前进程的运行环境信息转去执行中断处理程序处理该中断处理中断的过程中从控制器读一个字的数据传送到寄存器再写入主存接着恢复等待的进程或其他进程的运行环境然后继续执行会在每个指令周期的末尾检查中断中断处理过程中需要保存恢复进程的运行环境这个过程是需要一定时间开销的可见如果中断发生的须率太高也会降低系统性能干预的频率每次操作开始之前完成之后需要介入等待完成的过程中可以切换到别的进程执行数据传送单位每次读写一个字数据流向读操作数据输入设备内存写操作数据输出内存设备优点与程序直接控制方式相比在中断驱动方式中控制器会通过中断信号主动报告已完成不再需要不停地轮询和设备可并行工作利用率得到明显提升缺点每个字在设备与内存之间的传输都需要经过而频繁的中断处理会消耗较多的时间方式直接存储器存取方式的基本思想是在设备和内存之间开辟直接的数据交换通路彻底解放下图为工作流程与中断驱动方式相比方式有这样几个改进数据的传送单位是块不再是一个字一个字的传送数据的流向是从设备直接放入内存或者从内存直接到设备不再需要作为快递小哥仅在传送一个或多个数据块的开始和结束时才需要干预数据传送通过控制器完成控制器组成下图为控制器的组成控制器中设置如下类寄存器数据寄存器暂存从设备到内存或从内存到设备的数据内存地址寄存器在输入时它存放把数据从设备传送到内存的起始目标地址在输出时它存放由内存到设备的内存源地址数据计数器存放本次要传送的字节数剩余要读写的字节数命令状态寄存器接收从发来的命令有关控制信息或设备的状态干预的频率仅在传送一个或多个数据块的开始和结束时才需要干预数据传送单位每次读写一个或多个块注意每次读写的只能是连续的多个块且这些块读入内存后在内存中也必须是连续的数据流向读操作数据输入设备内存写操作数据输出内存设备优点数据传输以块为单位介入频率进一步降低数据的传输不再需要先经过再写入内存数据传输效率进一步增加和设备的并行性得到提升缺点每发出一条指令只能读写一个或多个连续的数据块如果要读写多个离散存储的数据块或者要将数据分别写到不同的内存区域时要发出多条指令进行多次中断处理才能完成通道控制方式通道通道是指专门负责输入输出的处理机是一种硬件可以理解为是弱鸡版的通道可以识别并执行一系列通道指令与相比通道可以执行的指令很单一并且通道程序是放在主机内存中的也就是说通道与共享内存完成一次读写流程干预的频率极低通道会根据的指示执行相应的通道程序只有完成一组数据块的读写后才需要发出中断信号请求干预数据传送的单位每次读写一组数据块数据的流向在通道的控制下进行读操作数据输入设备内存写操作数据输出内存设备缺点实现复杂需要专门的通道硬件支持优点通道设备可并行工作资源利用率很高软件层次结构为了更好地设计软件采用层次式结构的软件一个比较合理的层次划分如上图所示整个软件可以视为具有个层次的系统结构各层次功能如下用户层软件实现了与用户交互的接口用户可直接使用该层提供的与操作相关的库函数对设备进行操作用户层软件将用户请求翻译成格式化的请求并通过系统调用请求操作系统内核的服务设备独立性软件设备独立性软件又称设备无关性软件与设备的硬件特性无关的功能几乎都在这一层实现功能向上层提供统一的调用接口如系统调用设备的保护差错处理设备的分配与可收数据缓冲区管理建立逻辑设备名到物理设备名的映射关系根据设备类型选择调用相应的驱动程序逻辑设备为实现设备独立性而引入了逻辑设备和物理设备这两个概念在应用程序中使用逻辑设备名来请求使用某类设备而在系统实际执行时必须将逻辑设备名映射成物理设备名使用使用逻辑设备名好处增加设备分配的灵活性易于实现重定向指用于操作的设备可以更换即重定向而不必改变应用程序设备独立性软件需要通过逻辑设备表来确定逻辑设备对应的物理设备并找到该设备对应的设备驱动程序设备被当做一种特殊的文件不同类型的设备需要有不同的驱动程序处理操作系统系统可以采用两种方式管理逻辑设备表第一种方式整个系统只设置一张这就意味着所有用户不能使用相同的逻辑设备名因此这种方式只适用于单用户操作系统第二种方式为每个用户设置一张各个用户使用的逻辑设备名可以重复适用于多用户操作系统系统会在用户登录时为其建立一个用户管理进程而就存放在用户管理进程的中设备驱动程序与硬件直接相关负责具体实现系统对设备发出的操作指令驱动设备工作的驱动程序将上层发出的一系列命令如转化成特定设备能听得懂的一系列操作不同设备的内部硬件特性也不同这些特性只有厂家才知道因此厂家须提供与设备相对应的驱动程序执行驱动程序的指令序列来完成设置设备寄存器检查设备状态等工作为内核子系统隐藏设备控制器之间的差异中断处理程序当任务完成时控制器会发送一个中断信号系统会根据中断信号类型找到相应的中断处理程序并执行中断处理程序的处理流程如下中断处理层的任务进行进程上下文的切换对处理中断信号源进行测试读取设备状态和修改进程状态等由于中断处理与硬件紧密相关对用户而言应尽量加以屏蔽因此应放在操作系统的底层系统的其余部分尽可能少地与之发生联系总结说明用户对设备的一次命令过程如下所示当用户要读取某设备的内容时通过操作系统提供的命令接口这就经过了用户层操作系统提供给用户使用的接口一般是统一的通用接口也就是几乎每个设备都可以响应的统一命令如命令用户发出的命令首先经过设备独立层进行解析然后交往下层接下来不同类型的设备对命令的行为会有所不同如磁盘接收命令后的行为与打印机接收命令后的行为是不同的因此需要针对不同的设备把命令解析成不同的指令这就经过了设备驱动层命令解析完毕后需要中断正在运行的进程转而执行命令这就需要中断处理程序最后命令真正抵达硬件设备硬件设备的控制器按照上层传达的命令操控硬件设备完成相应的功能直接涉及到硬件其体细节且与中断无关的操作肯定是在设备驱动程序层完成的没有涉及硬件的对各种设备都需要进行的管理工作都是在设备独立性软件层完成的应用程序接口在系统与高层之间的接口中根据设备类型的不同又进一步分为若干接口字符设备接口字符设备是指数据的存取和传输是以字符为单位的设备如键盘打印机等基本特征是传输速率较低不可寻址并且在输入输出时通常采用中断驱动方式字符设备的操作和操作由于字符设备不可寻址只能采取顺序存取方式通常为字符设备建立一个字符缓冲区用户程序通过操作从缓冲区获取字符通过操作将字符输出到缓冲区指令字符设备类型繁多差异甚大因此在接口中提供一种通用的指令来处理它们包含了许多参数每个参数表示一个与具体设备相关的特定功能字符设备都属于独占设备为此接口中还需要提供打开和关闭操作以实现互斥共享块设备接口块设备是指数据的存取和传输是以数据块为单位的设备典型的块设备是磁盘基本特征是传输速率较高可寻址磁盘设备的常采用方式隐藏了磁盘的二维结构在二维结构中每个扇区的地址需要用磁道号和扇区号来表示块设备接口将磁盘的所有扇区从到依次编号这样就将二维结构变为一种线性序列将抽象命令映射为低层操作块设备接口支持上层发来的对文件或设备的打开读写和关闭等抽象命令该接口将上述命令映射为设备能识别的较低层的具体操作内存映射接口内存映射接口通过内存的字节数组来访问磁盘而不提供读写磁盘操作映射文件到内存的系统调用返回包含文件副本的一个虚拟内存地址只在需要访问内存映像时才由虚拟存储器实际调页内存映射文件的访问如同内存读写一样简单极大地方便了程序员网络设备接口许多操作系统提供的网络接口为网络套接字接口套接字接口的系统调用使应用程序创建的本地套接字连接到远程应用程序创建的套接字通过此连接发送和接收数据阻塞非阻塞阻塞当用户进程调用操作时进程就被阻塞需要等待操作完成进程才被唤醒继续执行字符设备接口一一从键盘读一个字符非阻塞用户进程调用操作时不阻塞该进程该调用返回一个错误返回值通常进程需要通过轮询的方式来查询操作是否完成块设备接口一一往磁盘写数据设备独立性软件与设备无关的软件与设备无关的软件是系统的最高层软件它的下层是设备驱动程序设备保护操作系统需要实现文件保护功能不同的用户对各个文件有不同的访问权限如只读读和写等在系统中设备被看做是一种特殊的文件每个设备也会有对应的当用户请求访问某个设备时系统根据中记录的信息来判断该用户是否有相应的访问权限以此实现设备保护的功能高速缓存与缓冲区磁盘高速缓存操作系统中使用磁盘高速缓存技术来提高磁盘的速度对访问高速缓存要比访问原始磁盘数据更为高效磁盘高速缓存技术不同于通常意义下的介于与内存之间的小容量高速存储器而是指利用内存中的存储空间来暂存从磁盘中读出的一系列盘块中的信息因此磁盘高速缓存逻辑上属于磁盘物理上则是驻留在内存中的盘块高速缓存在内存中分为两种形式一种是在内存中开辟一个单独的空间作为磁盘高速缓存大小固定另一种是把未利用的内存空间作为一个缓冲池供请求分页系统和磁盘时共享缓冲区概念缓冲区是一个存储区域可以由专门的硬件寄存器组成也可利用内存作为缓冲区硬件做缓冲区使用硬件作为缓冲区的成本较高容量也较小一般仅用在对速度要求非常高的场合如存储器管理中所用的联想寄存器由于对页表的访问频率极高因此使用速度很快的联想寄存器来存放页表项的副本内存做缓冲区一般情况下更多的是利用内存作为缓冲区设备独立性软件的缓冲区管理就是要组织管理好这些缓冲区作用缓和与设备之间速度不匹配的矛盾减少对的中断频率放宽对中断相应时间的限制解决数据粒度不匹配的问题提高与设备之间的并行性单缓冲若采用单缓冲的策略操作系统会在主存中为其分配一个缓冲区若题目中没有特别说明一个缓冲区的大小就是一个块注意当缓冲区数据非空时不能往缓冲区冲入数据只能从缓冲区把数据传出当缓冲区为空时可以往缓冲区冲入数据但必须把缓冲区充满以后才能从缓冲区把数据传出设块设备输入缓冲区时间为缓冲区传送至工作区时间为处理工作区时间为若从初始状态到下一个开始状态整个过程用时为若从初始状态到下一个开始状态整个过程用时为结论故单缓冲区处理每块数据的用时为若两个相互通信的机器只设置单缓冲区在任一时刻只能实现数据的单向传输双缓冲若采用双缓冲的策略操作系统会在主存中为其分配两个缓冲区双缓冲题目中假设初始状态为工作区空其中一个缓冲区满另一个缓冲区空若则处理一块数据的平均用时为若意味着输入数据块速度要比处理机处理数据块速度更快处理一个数据块的平均耗时为结论采用双缓冲策略处理一个数据块的平均耗时为若两个相互通信的机器只设置单缓冲区在任一时刻只能实现数据的单向传输若两个相互通信的机器设置双缓冲区则同一时刻可以实现双向的数据传输循环缓冲将多个大小相等的缓冲区链接成一个循环队列注上图中橙色表示已充满数据的缓冲区绿色表示空缓冲区缓冲池缓冲池由系统中共用的缓冲区组成这些缓冲区按使用状况可以分为空缓冲队列装满输入数据的缓冲队列输入队列装满输出数据的缓冲队列输出队列根据一个缓冲区在实际运算中扮演的功能不同又设置了四种工作缓冲区用于收容输入数据的工作缓冲区用于提取输入数据的工作缓冲区用于收容输出教据的工作绥冲区用于提取输出数据的工作缓冲区工作过程输入进程请求输入数据从空缓冲队列中取出一块作为收容输入数据的工作缓冲区冲满数据后将缓冲区挂到输入队列队尾计算进程想要取得一块输入数据从输入队列中取得一块冲满输入数据的缓冲区作为提取输入数据的工作缓冲区缓冲区读空后挂到空缓冲区队列计算进程想要将准备好的数据冲入缓冲区从空缓冲队列中取出一块作为收容输出数据的工作缓冲区数据冲满后将缓冲区挂到输出队列队尾输出进程请求输出数据从输出队列中取得一块冲满输出数据的缓冲区作为提取输出数据的工作缓冲区缓冲区读空后挂到空缓冲区队列设备的分配与回收设备分配概述设备分配是指根据用户的请求分配所需的设备分配的总原则是充分发挥设备的使用效率尽可能地让设备忙碌又要避免由于不合理的分配方法造成进程死锁从设备特性来看分为以下三种设备独占式使用设备进程分配到独占设备后便由其独占直至该进程释放该设备分时式共享使用设备对于共享设备可同时分配给多个进程通过分时共享使用以方式使用外部设备技术实现了虚拟设备功能可以将设备同时分配给多个进程这种技术实质上就是实现了对设备的操作的批处理设备分配的数据结构设备分配依据的主要数据结构有设备控制表控制器控制表通道控制表和系统设备表各数据结构功能如下设备控制表系统为每个设备配置一张用于记录设备情况控制器控制表每个设备控制器都会对应一张操作系统根据的信息对控制器进行操作和管理通道控制表每个通道都会对应一张操作系统根据的信息对通道进行操作和管理系统设备表记录了系统中全部设备的情况每个设备对应一个表目设备分配的策略设备分配原则设备分配应根据设备特性用户要求和系统配置情况既要充分发挥设备的使用效率又要避免造成进程死锁还要将用户程序和具体设备隔离开设备分配方式设备分配方式有静态分配和动态分配两种静态分配进程运行前为其分配全部所需资源运行结束后归还资源主要用于对独占设备的分配它在用户作业开始执行前由系统一次性分配该作业所要求的全部设备控制器静态分配方式不会出现死锁但设备的使用效率低动态分配进程运行过程中动态申请设备资源在进程执行过程中根据执行需要进行这种方式有利于提高设备利用率但若分配算法使用不当则有可能造成进程死锁设备分配算法常用的动态设备分配算法有先请求先分配优先级高者优先等设备分配的安全性设备分配的安全性是指设备分配中应防止发生进程死锁安全分配方式为进程分配一个设备后就将进程阻塞本次完成后才将进程唤醒一个时段内每个进程只能使用一个设备优点破坏了请求和保持条件不会死锁缺点对于一个进程来说和设备只能串行工作不安全分配方式进程发出请求后系统为其分配设备进程可继续执行之后还可以发出新的请求只有某个请求得不到满足时才将进程阻塞一个进程可以同时使用多个设备优点进程的计算任务和任务可以并行处理使进程迅速推进缺点有可能发生死锁死锁避免死锁的检测和解除设备分配的步骤步骤根据进程请求的物理设备名查找注物理设备名是进程请求分配设备时提供的参数根据找到若设备忙碌则将进程挂到设备等待队列中不忙碌则将设备分配给进程根据找到若控制器忙碌则将进程挂到控制器等待队列中不忙碌则将控制器分配给进程根据找到若通道忙碌则将进程挂到通道等待队列中不忙碌则将通道分配给进程注只有设备控制器通道三者都分配成功时这次设备分配才算成功之后便可启动设备进行数据传送缺点用户编程时必须使用物理设备名底层细节对用户不透明不方便编程若换了一个物理设备则程序无法运行若进程请求的物理设备正在忙碌则即使系统中还有同类型的设备进程也必须阻塞等待设备分配步骤的改进改进方法建立逻辑设备名与物理设备名的映射机制用户编程时只需提供逻辑设备名逻辑设备表逻辑设备表建立了逻辑设备名与物理设备名之间的映射关系某用户进程第一次使用设备时使用逻辑设备名向操作系统发出请求操作系统根据用户进程指定的设备类型逻辑设备名查找系统设备表找到一个空闲设备分配给进程并在中增加相应表项如果之后用户进程再次通过相同的逻辑设备名请求使用设备则操作系统通过表即可知道用户进程实际要使用的是哪个物理设备了并且也能知道该设备的驱动程序入口地址整个系统只有一张各用户所用的逻辑设备名不允许重复适用于单用户操作系统每个用户一张不同用户的逻辑设备名可重复适用于多用户操作系统步骤根据进程请求的逻辑设备名查找注用户编程时提供的逻辑设备名其实就是设备类型查找找到用户进程指定类型的并且空闲的设备将其分配给该进程操作系统在逻辑设备表中新增一个表项根据找到若控制器忙碌则将进程挂到控制器等待队列中不忙碌则将控制器分配给进程根据找到若通道忙碌则将进程挂到通道等待队列中不忙碌则将通道分配给进程技术假脱机技术概念脱机技术脱离主机的控制进行的输入输出操作批处理阶段引入了脱机输入输出技术用磁带完成在外围控制机的控制下慢速输入设备的数据先被输入到更快速的磁带上之后主机可以从快速的磁带上读入数据从而缓解了速度矛盾技术假脱机技术又称技术用软件的方式模拟脱机技术要实现技术必须要有多道程序技术的支持系统会建立输入进程和输出进程原理输入井和输出井在磁盘上开辟出两个存储区域一一输入井和输出井输入井模拟脱机输入时的磁带用于收容设备输入的数据输出井模拟脱机输出时的磁带用于收容用户进程输出的数据输入进程和输出进程输入进程模拟脱机输入时的外围控制机输出进程模拟脱机输出时的外围控制机输入缓冲区和输出缓冲区在输入进程的控制下输入缓冲区用于暂存从输入设备输入的数据之后再转存到输入井中在输出进程的控制下输出缓冲区用于暂存从输出井送来的数据之后再传送到输出设备上注意输入缓冲区和输出缓冲区是在内存中的缓冲区预读和滞后写预读提前读如果采用的顺序访问方式对文件进行访问便可预知下一次要读的盘块此时可采用预读策略即在读当前块的同时也将下一个盘块提前读入内存缓冲区这样在访问下一个盘块时就不需要再启动磁盘从而提升磁盘速度滞后写延迟写滞后写是指缓冲区中的数据本应立即写回磁盘但考虑到其中的数据在不久之后有可能再次被访问因此并不会立即把中的数据写回磁盘而是将缓冲区挂到空闲缓冲区队列如果有别的进程申请使用该缓冲区时才把中的数据写回磁盘这样做的好处是只要缓冲区仍在队列中任何访问该数据的进程都可以直接读出其中的数据而不必访问磁盘因而这种方式也可以减少磁盘次数改善性能共享打印机的原理分析技术可以把一台物理设备虚拟成逻辑上的多台设备可将独占式设备改造成共享设备当多个用户进程提出输出打印的请求时系统会答应它们的请求但是并不是真正把打印机分配给他们而是由假脱机管理进程为每个进程做两件事在磁盘输出井中为进程申请一个空闲缓冲区也就是说这个缓冲区是在磁盘上的并将要打印的数据送入其中为用户进程申请一张空白的打印请求表并将用户的打印请求填入表中其实就是用来说明用户的打印数据存放位置等信息的再将该表挂到假脱机文件队列上当打印机空闲时输出进程会从文件队列的队头取出一张打印请求表并根据表中的要求将要打印的数据从输出井传送到输出缓冲区再输出到打印机进行打印用这种方式可依次处理完全部的打印任务虽然系统中只有一个台打印机但每个进程提出打印请求时系统都会为在输出井中为其分配一个存储区相当于分配了一个逻辑设备使每个用户进程都觉得自己在独占一台打印机从而实现对打印机的共享设备驱动程序接口要求每个设备驱动程序与操作系统之间都有着相同或相近的接口这样会使得添加一个新设备驱动程序变得很容易同时也便于开发人员编制设备驱动程序对于每种设备类型例如磁盘操作系统都要定义一组驱动程序必须支持的函数与设备无关的软件还要负责将符号化的设备名映射到适当的驱动程序上在和中设备是作为命名对象出现在文件系统中的因此针对文件的常规保护规则也适用于设备系统管理员可以为每个设备设置适当的访问权限磁盘和固态硬盘磁盘磁盘结构磁盘磁盘的表面由一些磁性物质组成可以用这些磁性物质来记录二进制数据磁道磁盘的盘面被划分成一个个磁道这样的一个圈就是一个磁道扇区一个磁道又被划分成一个个扇区每个扇区就是一个磁盘块各个扇区存放的数据量相同最内侧磁道上的扇区面积最小因此数据密度最大盘面磁盘有多个盘片摞起来每个盘片有两个盘面柱面所有盘面中相对位置相同的磁道组成柱面如何在磁盘中读写数据需要把磁头移动到想要读写的扇区所在的磁道磁盘会转起来让目标扇区从磁头下面划过才能完成对扇区的读写操作磁盘的物理地址磁盘地址用柱面号盘面号扇区号表示可根据该地址读取一个块根据柱面号移动磁臂让磁头指向指定柱面激活指定盘面对应的磁头磁盘旋转的过程中指定的扇区会从磁头下面划过这样就完成了对指定扇区的读写磁盘读写时间寻找时间在读写数据前将磁头移动到指定磁道所花的时间启动磁头臂是需要时间的假设耗时为移动磁头也是需要时间的假设磁头匀速移动每跨越一个磁道耗时为总共需要跨越条磁道则寻道时间延迟时间通过旋转磁盘使磁头定位到目标扇区所需要的时间设磁盘转速为单位转秒或转分则平均所需的延迟时间硬盘的典型转速为转分或转分传输时间从磁盘读出或向磁盘写入数据所经历的时间假设磁盘转速为此次读写的字节数为每个磁道上的字节数为则传输时间平均存取时间总的平均存取时间延迟时间和传输时间都与磁盘转速相关且为线性相关而转速是硬件的固有属性因此操作系统也无法优化延迟时间和传输时间磁盘的分类磁头是否移动磁头可以移动的称为活动头磁盘磁臂可以来回伸缩来带动磁头定位磁道磁头不可移动的称为固定头磁盘这种磁盘中每个磁道有一个磁头根据盘片是否可更换固定盘磁盘可换盘磁盘磁盘管理磁盘初始化一个新的磁盘只是一个磁性记录材料的空白盘在磁盘可以存储数据之前必须将它分成扇区以便磁盘控制器能够进行读写操作这个过程称为低级格式化或称物理格式化低级格式化为每个扇区使用特殊的数据结构填充磁盘每个扇区的数据结构通常由头部数据区域通常为大小和尾部组成头部和尾部包含了一些磁盘控制器的使用信息分区在可以使用磁盘存储文件之前操作系统还要将自己的数据结构记录到磁盘上分为两步第一步是将磁盘分为由一个或多个柱面组成的分区即我们熟悉的盘盘等形式的分区每个分区的起始扇区和大小都记录在磁盘主引导记录的分区表中第二步是对物理分区进行逻辑格式化创建文件系统操作系统将初始的文件系统数据结构存储到磁盘上这些数据结构包括空闲空间和已分配的空间以及一个初始为空的目录因扇区的单位太小为了提高效率操作系统将多个相邻的扇区组合在一起形成一簇在中称为块为了更高效地管理磁盘一簇只能存放一个文件的内容文件所占用的空间只能是簇的整数倍如果文件大小小于一簇甚至是字节也要占用一簇的空间引导块计算机启动时需要运行一个初始化程序自举程序它初始化寄存器设备控制器和内存等接着启动操作系统为此自举程序找到磁盘上的操作系统内核将它加载到内存并转到起始地址从而开始操作系统的运行自举程序通常存放在中为了避免改变自举代码而需要改变硬件的问题通常只在中保留很小的自举装入程序而将完整功能的引导程序保存在磁盘的启动块上启动块位于磁盘的固定位置具有启动分区的磁盘称为启动磁盘或系统磁盘允许将磁盘分为多个分区有一个分区为引导分区它包含操作系统和设备驱动程序系统将引导代码存储在磁盘的第号扇区它称为主引导记录引导首先运行中的代码这个代码指示系统从中读取引导代码除了包含引导代码还包含一个磁盘分区表和一个标志以指示从哪个分区引导系统当系统找到引导分区时读取分区的第一个扇区称为引导扇区并继续余下的引导过程包括加载各种系统服务坏块由于磁盘有移动部件且容错能力弱因此容易导致一个或多个扇区损坏对于简单磁盘如采用控制器的磁盘坏块可手动处理如的命令执行逻辑格式化时会扫描磁盘以检查坏块坏块在表上会标明因此程序不会使用它们对于复杂的磁盘控制器维护磁盘内的坏块列表这个列表在出厂低级格式化时就已初始化并在磁盘的使用过程中不断更新低级格式化将一些块保留作为备用操作系统看不到这些块控制器可以采用备用块来逻辑地替代坏块这种方案称为扇区备用对坏块的处理实质上就是用某种机制使系统不去使用坏块减少磁盘延迟时间的方法磁盘地址结构的设计为什么磁盘的物理地址是柱面号盘面号扇区号而不是盘面号柱面号扇区号答读取地址连续的磁盘块时采用这样的的地址结构可以减少磁头移动消耗的时间方法交替编号具体做法让编号相邻的扇区在物理上不相邻原理磁头读入一个扇区数据后需要一小段时间处理如果逻辑上相邻的扇区在物理上也相邻则读入几个连续的逻辑扇区可能需要很长的延迟时间错位命名具体做法让相邻盘面的扇区编号错位原理与交替编号的原理相同错位命名法可降低延迟时间磁盘调度算法先来先服务根据进程请求访问磁盘的先后顺序进行调度优点公平如果请求访问的磁道比较集中的话算法性能还算过的去缺点如果有大量进程竞争使用磁盘请求访问的磁道很分散则在性能上很差寻道时间长最短寻找时间优先算法会优先处理的磁道是与当前磁头最近的磁道可以保证每次的寻道时间最短但是并不能保证总的寻道时间最短其实就是贪心算法的思想只是选择眼前最优但是总体未必最优优点性能较好平均寻道时间短缺点可能产生饥饿现象磁头有可能在一个小区域内来回来去地移动本例中如果在处理号磁道的访问请求时又来了一个号磁道的访问请求处理号磁道的访问请求时又来了一个号磁道的访问请求如果有源源不断的号号磁道的访问请求到来的话号磁道的访问请求就永远得不到满足从而产生饥饿现象扫描算法又称电梯算法只有磁头移动到最外侧磁道的时候才能往内移动移动到最内侧磁道的时候才能往外移动优点性能较好平均寻道时间较短不会产生饥饿现象缺点只有到达最边上的磁道时才能改变磁头移动方向事实上处理了号磁道的访问请求之后就不需要再往右移动磁头了算法对于各个位置磁道的响应频率不平均如假设此时磁头正在往右移动且刚处理过号磁道那么下次处理号磁道的请求就需要等磁头移动很长一段距离而响应了号磁道的请求之后很快又可以再次响应号磁道的请求了调度算法如果在磁头移动方向上已经没有别的请求就可以立即改变磁头移动方向边移动边观察因此叫优点比起算法来不需要每次都移动到最外侧或最内侧才改变磁头方向使寻道时间进一步缩短循环扫描算法只有磁头朝某个特定方向移动时才处理磁道访问请求而返回时直接快速移动至起始端而不处理任何请求优点比起来对于各个位置磁道的响应频率很平均缺点只有到达最边上的磁道时才能改变磁头移动方向事实上处理了号磁道的访问请求之后就不需要再往右移动磁头了并且磁头返回时其实只需要返回到号磁道即可不需要返回到最边缘的磁道另外比起算法来平均寻道时间更长调度算法如果磁头移动的方向上已经没有磁道访问请求了就可以立即让磁头返回并且磁头只需要返回到有磁道访问请求的位置即可优点比起算法不需要每次都移动到最外侧或最内侧才改变磁头方向使寻道时间进一步缩短固态硬盘固态硬盘的特性原理固态硬盘是基于闪存技术属于电可擦除即组成闪存翻译层负责翻译逻辑块号找到对应页存储介质多个闪存芯片每个芯片包含多个块每个块包含多个页读写性能特性数据是以页为单位读写的相当于磁盘的扇区以块为单位擦除擦干净的块其中的每页都可以写一次读无限次支持随机访问系统给定一个逻辑地址闪存翻译层可通过电路迅速定位到对应的物理地址读快写慢要写的页如果有数据则不能写入需要将块内其他页全部复制到一个新的擦除过的块中再写入新的页与机械硬盘对比读写速度快随机访问性能高用电路控制访问位置机诚硬盘通过移动磁臂旋转磁盘控制访问位置有寻道时间和旋转延迟安静无噪音耐摔抗震能耗低造价更贵的一个块被擦除次数过多重复写同一个块可能会坏掉而机械硬盘的扇区不会因为写的次数太多而坏掉磨碎均衡思想将擦除平均分布在各个块上以提升使用寿命动态磨损均衡写入数据时优先选择累计擦除次数少的新闪存块静态磨损均衡监测并自动进行数据分配迁移让老旧的闪存块承担以读为主的储存任务让较新的闪存块承担更多的写任务例某固态硬盘采用磨损均衡技术大小为闪存块的擦写寿命只有次某男子平均每天会对该固态硬盘写数据在最理想的情况下这个固态硬盘可以用多久采用磨损均衡技术最理想情况下中每个块被擦除的次数都是完全均衡的因此平均天每个闪存块需要擦除一次每个闪存块可以被擦除次因此经过天约年固态使用到寿命',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-12-09 11:57:44',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="/img/freecompress-girl.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://7bu.top/user/dashboard" title="图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="图床"/><span class="back-menu-item-text">图床</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://origin.eqing.tech/" title="AI"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="AI"/><span class="back-menu-item-text">AI</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">Artemis`s Blog</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 链接</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 网页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=9852413331&amp;server=netease"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://bu.dusays.com/2024/11/16/6738094119d8b.png" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/11/16/6738094119d8b.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://bu.dusays.com/2024/11/16/67380940f10d9.jpg" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/11/16/67380940f10d9.jpg"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/API/" style="font-size: 1.05rem;">API<sup>1</sup></a><a href="/tags/Class/" style="font-size: 1.05rem;">Class<sup>1</sup></a><a href="/tags/Collection%E9%9B%86%E5%90%88/" style="font-size: 1.05rem;">Collection集合<sup>1</sup></a><a href="/tags/IO/" style="font-size: 1.05rem;">IO<sup>1</sup></a><a href="/tags/Interface/" style="font-size: 1.05rem;">Interface<sup>1</sup></a><a href="/tags/JS/" style="font-size: 1.05rem;">JS<sup>1</sup></a><a href="/tags/List/" style="font-size: 1.05rem;">List<sup>1</sup></a><a href="/tags/Mybatis/" style="font-size: 1.05rem;">Mybatis<sup>2</sup></a><a href="/tags/Object-Oriented/" style="font-size: 1.05rem;">Object Oriented<sup>1</sup></a><a href="/tags/SpringBoot/" style="font-size: 1.05rem;">SpringBoot<sup>1</sup></a><a href="/tags/String/" style="font-size: 1.05rem;">String<sup>1</sup></a><a href="/tags/Vue/" style="font-size: 1.05rem;">Vue<sup>1</sup></a><a href="/tags/java%E5%9F%BA%E7%A1%80/" style="font-size: 1.05rem;">java基础<sup>1</sup></a><a href="/tags/maven/" style="font-size: 1.05rem;">maven<sup>1</sup></a><a href="/tags/springboot/" style="font-size: 1.05rem;">springboot<sup>1</sup></a><a href="/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/" style="font-size: 1.05rem;">动态代理<sup>1</sup></a><a href="/tags/%E5%8F%8D%E5%B0%84/" style="font-size: 1.05rem;">反射<sup>1</sup></a><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 1.05rem;">多线程<sup>3</sup></a><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 1.05rem;">操作系统<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 1.05rem;">数据结构<sup>2</sup></a><a href="/tags/%E6%B3%A8%E8%A7%A3/" style="font-size: 1.05rem;">注解<sup>1</sup></a><a href="/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/" style="font-size: 1.05rem;">红黑树<sup>1</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" style="font-size: 1.05rem;">网络编程<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/12/"><span class="card-archive-list-date">十二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/11/"><span class="card-archive-list-date">十一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/10/"><span class="card-archive-list-date">十月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/09/"><span class="card-archive-list-date">九月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">七月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/05/"><span class="card-archive-list-date">五月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/04/"><span class="card-archive-list-date">四月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/03/"><span class="card-archive-list-date">三月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/CS%E6%A0%B8%E5%BF%83/" itemprop="url">CS核心</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>操作系统</span></a></span></div></div><h1 class="post-title" itemprop="name headline">Operating System</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2024-12-09T03:38:11.000Z" title="发表于 2024-12-09 11:38:11">2024-12-09</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-12-09T03:57:44.661Z" title="更新于 2024-12-09 11:57:44">2024-12-09</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">76.5k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>228分钟</span></span><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="Operating System"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为NanChang-CN"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>NanChang-CN</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://bu.dusays.com/2024/12/09/67566a877214f.png"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://sukhoigit.github.io/posts/b64a7908.html"><header><a class="post-meta-categories" href="/categories/CS%E6%A0%B8%E5%BF%83/" itemprop="url">CS核心</a><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" tabindex="-1" itemprop="url">操作系统</a><h1 id="CrawlerTitle" itemprop="name headline">Operating System</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">Artemis</span><time itemprop="dateCreated datePublished" datetime="2024-12-09T03:38:11.000Z" title="发表于 2024-12-09 11:38:11">2024-12-09</time><time itemprop="dateCreated datePublished" datetime="2024-12-09T03:57:44.661Z" title="更新于 2024-12-09 11:57:44">2024-12-09</time></header><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="1-计算机系统概述"><a href="#1-计算机系统概述" class="headerlink" title="1 计算机系统概述"></a>1 计算机系统概述</h2><h3 id="1-1-操作系统的基本概念"><a href="#1-1-操作系统的基本概念" class="headerlink" title="1.1 操作系统的基本概念"></a>1.1 操作系统的基本概念</h3><ol>
<li><p>定义</p>
<p> 操作系统（Operating System，OS）是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配；以提供给用户和其他软件方便的接口和环境；它是计算机系统中最基本的系统软件。</p>
</li>
<li><p>特征</p>
<ul>
<li><p>并发</p>
<p>并发指两个或多个事件在同一时间间隔内发生。这些事件<strong>宏观上是同时发生的，但微观上是交替发生</strong>的。</p>
<p>OS的并发性是通过分时实现的。</p>
<ul>
<li>单核CPU同一时刻只能执行一个程序，各个程序只能并发地执行</li>
<li>多核CPU同一时刻可以同时执行多个程序，多个程序可以并行地执行</li>
</ul>
<blockquote>
<p><strong>并发性</strong>：两个或多个事件在同一时间间隔内发生。</p>
<p><strong>并行性</strong>：两个或多个事件在同一时刻发生，需要硬件支持，如多流水线或多处理机硬件环境。</p>
</blockquote>
<p>多道程序环境下，一段时间，宏观上，多道程序同时执行某一时刻，单处理机环境下实际仅有一道程序执行，微观上程序分时交替执行</p>
</li>
<li><p>共享</p>
<p>共享即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。</p>
<ul>
<li><p><strong>互斥共享方式</strong>：系统中的某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源。</p>
<p>应用：使用QQ和微信视频。同一时间段内摄像头只能分配给其中一个进程。</p>
</li>
<li><p><strong>同时共享方式</strong>：系统中的某些资源，允许一个时间段内由多个进程“同时”对它们进行访问。</p>
<p>应用：使用QQ发送文件A，同时使用微信发送文件B。宏观上看，两边都在同时读取并发送文件说明两个进程都在访问硬盘资源，从中读取数据。微观上看，两个进程是交替着访问硬盘的。</p>
</li>
</ul>
<blockquote>
<p>所谓的“同时”往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问的（即分时共享）</p>
</blockquote>
<p>并发和共享是操作系统两个最基本的特征，两者之间互为存在的条件：</p>
<ul>
<li>①资源共享是以程序的并发为条件的，若系统不允许程序并发执行，则自然不存在资源共享问题；</li>
<li>②若系统不能对资源共享实施有效的管理，则必将影响到程序的并发执行，甚至根本无法并发执行。</li>
</ul>
</li>
<li><p>虚拟</p>
<p>虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的。</p>
<ul>
<li><p><strong>虚拟处理器</strong>：通过<strong>时分复用</strong>技术，让多道程序并发执行的方法，来分时使用一个处理器的。</p>
<p>虽然只有一个处理器，但它能同时为多个用户服务，使每个终端用户都感觉有一个中央处理器（CPU）在专门为它服务。</p>
</li>
<li><p><strong>虚拟存储器</strong>：通过<strong>空分复用</strong>技术，将一台机器的物理存储器变为虚拟存储器，以便从逻辑上扩充存储器的容量。当然，这时用户所感觉到的内存容量是虚的。</p>
</li>
<li><p>虚拟I&#x2F;O设备：采用虚拟设备技术将一台物理I&#x2F;O设备虚拟为多台逻辑上的I&#x2F;O设备，并允许每个用户占用一台逻辑上的I&#x2F;O设备，使原来仅允许在一段时间内由一个用户访问的设备（即临界资源）变为在一段时间内允许多个用户同时访问的<strong>共享设备</strong>。</p>
</li>
</ul>
</li>
<li><p>异步</p>
<p>在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是<strong>进程的异步性</strong>。</p>
</li>
</ul>
</li>
<li><p>功能</p>
<p> 为了给多道程序提供良好的运行环境，操作系统应具有以下几方面的功能：处理机管理、存储器管理、设备管理和文件管理。为了方便用户使用操作系统，还必须向用户提供接口。同时，操作系统可用来扩充机器，以提供更方便的服务、更高的资源利用率。</p>
<ul>
<li><p>操作系统是系统资源的管理者</p>
<ul>
<li><p><strong>处理机管理</strong></p>
<p>即<strong>对进程的管理</strong>，包括进程控制、进程同步、进程通信、死锁处理、处理机调度等。</p>
</li>
<li><p><strong>存储器管理</strong></p>
<p>方便程序运行、用户使用及提高内存的利用率，包括内存分配与回收、地址映射、内存保护与共享和内存扩充等功能。</p>
</li>
<li><p><strong>文件管理</strong></p>
<p>计算机中的信息都是以文件的形式存在的，操作系统中负责文件管理的部分称为<strong>文件系统</strong>。</p>
<p>文件管理包括文件存储空间的管理、目录管理及文件读写管理和保护等。</p>
</li>
<li><p><strong>设备管理</strong></p>
<p>设备管理的主要任务是完成用户的I&#x2F;O请求，方便用户使用各种设备，并提高设备的利用率，主要包括缓冲管理、设备分配、设备处理和虚拟设备等功能。</p>
</li>
</ul>
</li>
<li><p>向上层提供方便易用的服务</p>
<ul>
<li><p><strong>命令接口</strong></p>
<p><strong>用户</strong>利用这些操作命令来组织和控制作业的执行。</p>
<ul>
<li><p><strong>联机命令接口</strong>：即交互式命令接口，适用于分时或实时系统。</p>
<p>“雇主”说一句话，“工人”做一件事，并做出反馈，这就强调了交互性。</p>
</li>
<li><p><strong>脱机命令接口</strong>：即批处理命令接口，适用于批处理系统</p>
<p>“雇主”把要“工人”做的事写在清单上，“工人”按照清单命令逐条完成这些事，这就是批处理。</p>
</li>
</ul>
</li>
<li><p><strong>程序接口</strong></p>
<p>程序接口由一组<strong>系统调用</strong>（也称广义指令）组成。是为编程人员提供的接口。普通用户不能直接使用程序接口，只能通过程序代码间接使用。</p>
<p>用户通过在程序中使用<strong>系统调用命令</strong>请求OS为其提供服务。系统调用命令又称广义指令。</p>
</li>
<li><p><strong>GUl：图形化用户接口</strong>（Graphical User Interface）</p>
<p>用户可以使用形象的图形界面进行操作，而不再需要记忆复杂的命令、参数。</p>
</li>
</ul>
</li>
<li><p>是最接近硬件的一层软件</p>
<p><strong>裸机</strong>：没有任何软件支持的计算机称为裸机，它仅构成计算机系统的物质基础。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230906161936845.png" alt="image-20230906161936845"></p>
<p>在裸机上安装的操作系统，可以提供资源管理功能和方便用户的服务功能，将裸机改造成功能更强、使用更方便的机器。</p>
<p>通常把覆盖了软件的机器成为<strong>扩充机器</strong>，又称之为<strong>虚拟机</strong>。</p>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>例：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230906162625137.png" alt="image-20230906162625137"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230906162652164.png" alt="image-20230906162652164"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230906162907975.png" alt="image-20230906162907975"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230906162925001.png" alt="image-20230906162925001"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230906163023486.png" alt="image-20230906163023486"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230906163041909.png" alt="image-20230906163041909"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230906163257516.png" alt="image-20230906163257516"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230906163342210.png" alt="image-20230906163342210"></p>
</blockquote>
<h3 id="1-2-操作系统发展历程"><a href="#1-2-操作系统发展历程" class="headerlink" title="1.2 操作系统发展历程"></a>1.2 操作系统发展历程</h3><ol>
<li><p>手工操作阶段（此阶段无操作系统）</p>
<p>用户在计算机上算题的所有工作都要人工干预，如程序的装入、运行、结果的输出等。</p>
<ul>
<li>缺点：<ul>
<li>用户独占全机</li>
<li>CPU等待手工操作，CPU利用不充分</li>
</ul>
</li>
<li>人机矛盾：CPU和I&#x2F;O速度不匹配的矛盾。</li>
</ul>
</li>
<li><p>批处理阶段（操作系统开始出现）</p>
<ul>
<li><p><strong>单道批处理系统</strong>：引入脱机输入输出技术</p>
<ul>
<li><strong>特征</strong>：<ul>
<li><strong>自动性</strong>。在顺利的情况下，磁带上的一批作业能自动地逐个运行，而无须人工干预。</li>
<li><strong>顺序性</strong>。磁带上的各道作业顺序地进入内存，各道作业的完成顺序与它们进入内存的顺序在正常情况下应完全相同，亦即先调入内存的作业先完成。</li>
<li><strong>单道性</strong>。内存中仅有一道程序运行，即监督程序每次从磁带上只调入一道程序进入内存运行，当该程序完成或发生异常情况时，才换入其后继程序进入内存运行。</li>
</ul>
</li>
<li><strong>优点</strong>：缓解人机速度矛盾。</li>
<li><strong>缺点</strong>：资源利用率仍低，高速CPU等待低速I&#x2F;O。</li>
</ul>
</li>
<li><p><strong>多道批处理系统</strong>：多道程序设计技术操作系统开始出现</p>
<p><strong>多道程序设计</strong>：允许<strong>多个程序同时进入内存</strong>并允许它们<strong>在CPU中交替地运行</strong>，这些程序共享系统中的各种硬&#x2F;软件资源。当一道程序因I&#x2F;O请求而暂停运行时，CPU便立即转去运行另一道程序。</p>
<ul>
<li><strong>特点</strong>：<ul>
<li><strong>多道</strong>。计算机内存中同时存放多道相互独立的程序。</li>
<li><strong>宏观上并行</strong>。同时进入系统的多道程序都处于运行过程中，即它们先后开始各自的运行，但都未运行完毕。</li>
<li><strong>微观上串行</strong>。内存中的多道程序轮流占有CPU，交替执行。</li>
<li><strong>间断性</strong>：由于多道程序之间需要共享和竞争系统资源，因此每个程序的执行过程不是连续的，而是有间断的。</li>
<li><strong>共享性</strong>：多道程序之间需要共享系统的各种资源，如CPU、内存、外设等。</li>
<li><strong>制约性</strong>：多道程序之间存在相互制约的关系，如同步、互斥、优先级等。</li>
</ul>
</li>
<li>技术实现：<ul>
<li>如何分配处理器。</li>
<li>多道程序的内存分配问题。</li>
<li>I&#x2F;O设备如何分配。</li>
<li>如何组织和存放大量的程序和数据，以方便用户使用并保证其安全性与一致性。</li>
</ul>
</li>
<li><strong>优点</strong>：<ul>
<li>资源利用率高，多道程序并发执行，共享计算机资源</li>
<li>系统吞叶量大，CPU和其他资源保持”忙碌”</li>
</ul>
</li>
<li><strong>缺点</strong>：用户响应时间长、无人机交互能力</li>
</ul>
</li>
</ul>
</li>
<li><p>分时操作系统</p>
<p><strong>分时技术</strong>：计算机以<strong>时间片为单位</strong>轮流为各个用户&#x2F;作业服务，各个用户可通过终端与计算机进行交互。</p>
<p>多个用户通过终端同时共享一台主机，用户可以同时与主机进行交互操作而互不干扰。</p>
<ul>
<li><strong>特点</strong><ul>
<li><strong>同时性</strong>。同时性也称多路性，指允许多个终端用户同时使用一台计算机，即一台计算机与若干台终端相连接，终端上的这些用户可以同时或基本同时使用计算机。</li>
<li><strong>交互性</strong>。用户能够方便地与系统进行人机对话，即用户通过终端采用人机对话的方式直接控制程序运行，与同程序进行交互。</li>
<li><strong>独立性</strong>。系统中多个用户可以彼此独立地进行操作，互不干扰，单个用户感觉不到别人也在使用这台计算机，好像只有自己单独使用这台计算机一样。</li>
<li><strong>及时性</strong>。用户请求能在很短时间内获得响应。分时系统采用时间片轮转方式使一台计算机同时为多个终端服务，使用户能够对系统的及时响应感到满意。</li>
</ul>
</li>
<li>优点<ul>
<li>用户请求可以被即时响应，解决了人机交互问题。</li>
<li>允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。</li>
</ul>
</li>
<li>缺点：无法优先处理紧急任务</li>
</ul>
</li>
<li><p>实时操作系统</p>
<p>能在某个时间限制内完成某些紧急任务而不需要时间片排队。</p>
<ul>
<li><p>分类：</p>
<ul>
<li><p>软实时系统：能够接受偶尔违反时间规定且不会引起永久性的损害。</p>
<p>如飞机订票系统、银行管理系统。</p>
</li>
<li><p>硬实时系统：某个动作必须绝对地在规定的时刻（或规定的时间范围）发生。</p>
<p>如飞行器的飞行自动控制系统。</p>
</li>
</ul>
</li>
<li><p>特点</p>
<ul>
<li>及时性</li>
<li>可靠性</li>
</ul>
</li>
<li><p>优点：能够优先处理紧急任务</p>
</li>
</ul>
</li>
<li><p>网络操作系统和分布式计算机系统</p>
<ul>
<li>网络操作系统：把计算机网络中的各台计算机有机地结合起来，提供一种统一、经济而有效的使用各台计算机的方法，实现各台计算机之间数据的互相传送。<ul>
<li>特点<ul>
<li>网络中各种资源的共享</li>
<li>各台计算机之间的通信</li>
</ul>
</li>
</ul>
</li>
<li>分布式计算机系统：由多台计算机组成并满足下列条件的系统，主要特点是分布性和并行性。<ul>
<li>系统中任意两台计算机通过通信方式交换信息</li>
<li>系统中的每台计算机都具有同等的地位，即没有主机也没有从机</li>
<li>每台计算机上的资源为所有用户共享</li>
<li>系统中的任意台计算机都可以构成一个子系统，并且还能重构</li>
<li>任何工作都可以分布在几台计算机上，由它们并行工作、协同完成</li>
</ul>
</li>
<li>分布式操作系统与网络操作系统的本质不同：分布式操作系统中的若干计算机<strong>相互协同完成同一任务</strong>。</li>
</ul>
</li>
<li><p>个人计算机操作系统</p>
<p>个人计算机操作系统是目前使用最广泛的操作系统，它广泛应用于文字处理、电子表格、游戏中。</p>
<p>常见的有Windows、Linux和MacOS等。</p>
</li>
</ol>
<p> 操作系统发展历程如下图所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230906170455342.png" alt="image-20230906170455342"></p>
<p> 此外，还有嵌入式操作系统、服务器操作系统、智能手机操作系统等。</p>
<blockquote>
<p>例</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230906172127304.png" alt="image-20230906172127304"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230906172205744.png" alt="image-20230906172205744"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230906172222270.png" alt="image-20230906172222270"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230906172239874.png" alt="image-20230906172239874"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230906172347580.png" alt="image-20230906172347580"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230906172651255.png" alt="image-20230906172651255"></p>
</blockquote>
<h3 id="1-3-操作系统运行环境"><a href="#1-3-操作系统运行环境" class="headerlink" title="1.3 操作系统运行环境"></a>1.3 操作系统运行环境</h3><h4 id="1-3-1-处理器运行模型"><a href="#1-3-1-处理器运行模型" class="headerlink" title="1.3.1 处理器运行模型"></a>1.3.1 处理器运行模型</h4><ol>
<li><p>在计算机系统中，通常CPU执行两种不同性质的程序：</p>
<ul>
<li>操作系统<strong>内核程序</strong>：是用户自编程序的管理者，“管理程序”（即内核程序）要执行一些特权指令。</li>
<li>用户自编程序：即系统外层的应用程序，或简称“应用程序”，“被管理程序”（即用户自编程序）出于安全考虑不能执行这特权指令。</li>
</ul>
</li>
<li><p>特权指令和非特权指令</p>
<ul>
<li><strong>特权指令</strong>：是指不允许用户直接使用的指令，如&#x2F;O指令、置中断指令，存取用于内存保护的寄存器、送程序状态字到程序状态字寄存器等的指令。</li>
<li><strong>非特权指令</strong>：是指允许用户直接使用的指令，它不能直接访问系统中的软硬件资源，仅限于访问用户的地址空间，这也是为了防止用户程序对系统造成破坏。</li>
</ul>
</li>
<li><p>CPU的运行模式</p>
<ul>
<li><strong>用户态（目态）</strong>：CPU处于用户态，此时CPU只能执行非特权指令。</li>
<li><strong>核心态（又称管态、内核态）</strong>：CPU处于核心态，此时CPU可以执行特权指令，切换到用户态的指令也是特权指令。</li>
</ul>
<p>应用程序运行在用户态，操作系统内核程序运行在核心态。</p>
<blockquote>
<p>内核态一&gt;用户态：一条修改PSW的特权指令</p>
<p>用户态一&gt;内核态：应用程序向操作系统请求服务时通过使用访管指令，从而产生一个中断事件将操作系统转换为核心态。</p>
</blockquote>
</li>
<li><p>分层管理</p>
<ul>
<li>一些与硬件关联较紧密的模块，如时钟管理、中断处理、设备驱动等处于最低层。</li>
<li>其次是运行频率较高的程序，如进程管理、存储器管理和设备管理等。</li>
</ul>
<p>这两部分内容构成了操作系统的内核。这部分内容的指令操作工作在核心态。</p>
</li>
<li><p>操作系统内核功能</p>
<p><strong>内核</strong>（Kernel）是计算机上配置的底层软件，它管理着系统的各种资源，可以看作是连接应用程序和硬件的一座桥梁。由很多内核程序组成操作系统内核。</p>
<ul>
<li><p><strong>时钟管理</strong></p>
<ul>
<li><p>计时：是时钟的第一功能，操作系统需要通过时钟管理，向用户提供标准的系统时间。</p>
</li>
<li><p>进程切换：通过时钟中断的管理实现。</p>
<p>例如，在分时操作系统中采用时间片轮转调度，在实时系统中按截止时间控制运行，在批处理系统中通过时钟管理来衡量一个作业的运行程度等。</p>
</li>
</ul>
</li>
<li><p><strong>中断机制</strong></p>
<p><strong>中断作用</strong>：</p>
<ul>
<li>让操作系统内核强行夺回CPU的控制权</li>
<li>使CPU从用户态变为内核态</li>
</ul>
<p>引入原因：提高多道程序运行环境中CPU的利用率。</p>
<p>现代操作系统是靠中断驱动的软件</p>
</li>
<li><p><strong>原语</strong></p>
<p>由若干条指令组成的，用于完成一定功能的一个过程。</p>
<p><strong>特点</strong>：</p>
<ul>
<li>1）处于操作系统的最底层，是最接近硬件的部分。</li>
<li>2）这些程序的运行具有原子性，其操作只能一气呵成（出于系统安全性和便于管理考虑）。</li>
<li>3）这些程序的运行时间都较短，而且调用频繁。</li>
</ul>
<p>定义原语的直接方法是关闭中断，让其所有动作不可分割地完成后再打开中断。</p>
<p>系统中的设备驱动、CPU切换、进程通信等功能中的部分操作都可定义为原语，使它们成为内核的组成部分。</p>
</li>
<li><p><strong>系统控制的数据结构及处理</strong></p>
<p>系统中用来登记状态信息的<strong>数据结构</strong>很多，如作业控制块、进程控制块（PCB）、设备控制块、各类链表、消息队列、缓冲区、空闲区登记表、内存分配表等。</p>
<p>为了实现有效的管理，系统需要一些基本的操作，常见的操作有以下3种：</p>
<ul>
<li>1）进程管理。进程状态管理、进程调度和分派、创建与撤销进程控制块等。</li>
<li>2）存储器管理。存储器的空间分配和回收、内存信息保护程序、代码对换程序等。</li>
<li>3）设备管理。缓冲区管理、设备分配和回收等。</li>
</ul>
</li>
</ul>
<p><strong>核心态指令</strong>实际上包括<strong>系统调用类指令</strong>和一些针对<strong>时钟、中断</strong>和<strong>原语</strong>的操作指令。</p>
</li>
</ol>
<h4 id="1-3-2-中断和异常的概念"><a href="#1-3-2-中断和异常的概念" class="headerlink" title="1.3.2 中断和异常的概念"></a>1.3.2 中断和异常的概念</h4><ol>
<li><p>中断作用</p>
<p>让操作系统内核强行夺回CPU的控制权；使CPU从用户态变为内核态。</p>
</li>
<li><p>中断和异常的分类</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230907103043486.png" alt="image-20230907103043486"></p>
<ul>
<li><strong>异常</strong>：又称内中断，指来自CPU执行指令内部的事件，如程序的非法操作码、地址越界、运算溢出、虚存系统的缺页及专门的陷入指令等引起的事件。<ul>
<li>故障（Fault）通常是由指令执行引起的异常，如非法操作码、缺页故障、除数为0、运算溢出等。</li>
<li>自陷（Trap）是一种事先安排的“异常”事件，用于在用户态下调用操作系统内核程序，如条件陷阱指令。</li>
<li>终止（Abort）是指出现了使得CPU无法继续执行的硬件故障，如控制器出错、存储器校验错等。</li>
</ul>
</li>
<li><strong>中断</strong>：又称外中断，指来自CPU执行指令外部的事件，通常用于信息输入&#x2F;输出，如I&#x2F;O中断，时钟中断。<ul>
<li><strong>可屏蔽中断</strong>：指通过INTR线发出的中断请求，通过改变屏蔽字可以实现多重中断，从而使得中断处理更加灵活。</li>
<li><strong>不可屏蔽中断</strong>：指通过NMI线发出的中断请求，通常是紧急的硬件故障，如电源掉电等。此外，异常也是不能被屏蔽的。</li>
</ul>
</li>
</ul>
<p>故障异常和自陷异常属于<strong>软件中断（程序性异常）</strong>，终止异常和外部中断属于<strong>硬件中断</strong>。</p>
<p>异常不能被屏蔽，一旦出现，就应立即处理。</p>
</li>
<li><p>中断和异常的处理过程</p>
<ul>
<li><p>当CPU在执行用户程序的第i条指令时检测到一个异常事件，或在执行第i条指令后发现一个中断请求信号，</p>
</li>
<li><p>则CPU打断当前的用户程序，然后转到相应的中断或异常处理程序去执行。</p>
</li>
<li><p>若中断或异常处理程序能够解决相应的问题，则在中断或异常处理程序的最后，CPU通过执行中断或异常返回指令，回到被打断的用户程序的第i条指令或第i+1条指令继续执行</p>
<blockquote>
<p>返回第i+1条指令：由自陷（Trap）引起的内中断；如系统调用。由外部设备引起的外中断，如键盘</p>
<p>返回第i条指令：由故障（Fault）引起的内中断；如缺页等。</p>
</blockquote>
</li>
<li><p>若中断或异常处理程序发现是不可恢复的致命错误，则终止用户程序。</p>
</li>
</ul>
<p>通常情况下，对中断和异常的具体处理过程由操作系统（和驱动程序）完成。</p>
</li>
</ol>
<h4 id="1-3-3-系统调用"><a href="#1-3-3-系统调用" class="headerlink" title="1.3.3 系统调用"></a>1.3.3 系统调用</h4><ol>
<li><p>定义</p>
<p>操作系统作为用户和计算机硬件之间的接口，需要向上提供一些简单易用的服务，系统调用可视为特殊的公共子程序。又称<strong>广义指令</strong>。<strong>程序接口</strong>由一组系统调用组成。目的为解决资源分配问题</p>
</li>
<li><p>分类</p>
<ul>
<li><strong>设备管理</strong>：完成设备的请求或释放，以及设备启动等功能。</li>
<li><strong>文件管理</strong>：完成文件的读、写、创建及删除等功能。</li>
<li><strong>进程控制</strong>：完成进程的创建、撤销、阻塞及唤醒等功能。</li>
<li><strong>进程通信</strong>：完成进程之间的消息传递或信号传递等功能。</li>
<li><strong>内存管理</strong>：完成内存的分配、回收以及获取作业占用内存区大小及始址等功能。</li>
</ul>
</li>
<li><p>系统调用过程</p>
<p>系统调用的处理需要由操作系统内核程序负责完成，要运行在<strong>核心态</strong>。</p>
<p>用户程序可以执行陷入指令（又称访管指令或trap指令）来发起系统调用，请求操作系统提供服务。</p>
<blockquote>
<p>访管指令不是特权指令，访管指令是在用户态使用的，所以它不可能是特权指令。</p>
</blockquote>
<ul>
<li><p><strong>系统调用执行过程：</strong></p>
<p>传递系统调用参数→执行陷入（trap）指令→执行相应的服务程序→返回用户态</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230907104615415.png" alt="image-20230907104615415"></p>
<ul>
<li>当需要管理程序服务时，系统则通过硬件中断机制进入核心态，运行管理程序；</li>
<li>也可能是程序运行出现异常情况，被动地需要管理程序的服务，这时就通过异常处理来进入核心态。</li>
<li>管理程序运行结束时，用户程序需要继续运行，此时通过相应的保存的程序现场退出中断处理程序或异常处理程序，返回断点处继续执行</li>
</ul>
</li>
<li><p><strong>用户态转向核心态的例子：</strong></p>
<ul>
<li>用户程序要求操作系统的服务，即系统调用。</li>
<li>发生一次中断。</li>
<li>用户程序中产生了一个错误状态。</li>
<li>用户程序中企图执行一条特权指令。</li>
<li>从核心态转向用户态由一条指令实现，这条指令也是特权命令，一般是中断返回指令。</li>
</ul>
</li>
<li><p><strong>只能在核心态下执行的指令（特权指令）：</strong></p>
<ul>
<li>开关中断指令，用于允许或禁止中断，控制中断屏蔽位</li>
<li>设置时钟日期指令，用于修改系统时钟</li>
<li>改变存储映像图指令，用于修改主存保护机制</li>
<li>启动I&#x2F;O指令，用于控制I&#x2F;O设备的工作状态和动作</li>
<li>加载PSW指令，用于修改程序状态字（PSW），包括中断标志位、运算结果标志位等</li>
<li>置特殊寄存器指令，用于存取中断寄存器、时钟寄存器等特殊寄存器</li>
<li>停机指令，用于停止一个中央处理器的工作</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意：由用户态进入核心态，不仅状态需要切换，而且所用的堆栈也可能需要由用户堆栈切换为系统堆栈，但这个系统堆栈也是属于该进程的。</p>
</blockquote>
</li>
<li><p>与库函数的区别</p>
<ul>
<li>有的库函数是对系统调用的进一步封装：如“创建一个新文件”的函数</li>
<li>有的库函数没有使用系统调用：如的“取绝对值”的函数</li>
</ul>
</li>
</ol>
<blockquote>
<p>例：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230907110731631.png" alt="image-20230907110731631"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230907110712402.png" alt="image-20230907110712402"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230907111326699.png" alt="image-20230907111326699"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230907111012720.png" alt="image-20230907111012720"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230907112051407.png" alt="image-20230907112051407"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230907112105166.png" alt="image-20230907112105166"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230907112801641.png" alt="image-20230907112801641"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230907112817415.png" alt="image-20230907112817415"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230907113824708.png" alt="image-20230907113824708"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230907113836680.png" alt="image-20230907113836680"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230907114514637.png" alt="image-20230907114514637"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230907114540607.png" alt="image-20230907114540607"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230907124502957.png" alt="image-20230907124502957"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230907124527899.png" alt="image-20230907124527899"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230907134939200.png" alt="image-20230907134939200"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230907135000007.png" alt="image-20230907135000007"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230907135104614.png" alt="image-20230907135104614"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230907135130034.png" alt="image-20230907135130034"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230907141021682.png" alt="image-20230907141021682"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230907141044338.png" alt="image-20230907141044338"></p>
</blockquote>
<h3 id="1-4-操作系统结构"><a href="#1-4-操作系统结构" class="headerlink" title="1.4 操作系统结构"></a>1.4 操作系统结构</h3><ol>
<li><p>分层法</p>
<p> 分层法是将操作系统分为若干层，最底层（层0）为<strong>硬件</strong>，最高层（层N）为<strong>用户接口</strong>，每层只能调用紧邻它的低层的功能和服务（<strong>单向依赖</strong>）。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230907141834858.png" alt="image-20230907141834858"></p>
<ul>
<li>优点：<ul>
<li>①便于系统的调试和验证，简化了系统的设计和实现。只需调试每层功能，无需考虑其他层。</li>
<li>②易扩充和易维护。在系统中修改添加某层，不改变接口就不影响其他层。</li>
</ul>
</li>
<li>缺点：<ul>
<li>①合理定义各层比较困难。因为依赖关系固定后，往往就显得不够灵活。</li>
<li>②效率较差。执行一个功能要穿梭多层，每层通信增大开销。</li>
</ul>
</li>
</ul>
</li>
<li><p>模块化</p>
<p>模块化是将操作系统按功能划分为若干具有一定独立性的模块。每个模块具有某方面的管理功能，并规定好各模块间的接口，使各模块之间能够通过接口进行通信。各模块还可划分成子模块，子模块之间也规定好接口。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230907142713472.png" alt="image-20230907142713472"></p>
<ul>
<li>模块划分应考虑其划分大小，及独立性，衡量独立性有两个标准：<ul>
<li>内聚性，模块内部各部分间联系的紧密程度。内聚性越高，模块独立性越好。</li>
<li>耦合度，模块间相互联系和相互影响的程度。耦合度越低，模块独立性越好。</li>
</ul>
</li>
<li>优点：<ul>
<li>①提高了操作系统设计的正确性、可理解性和可维护性；</li>
<li>②增强了操作系统的可适应性；</li>
<li>③加速了操作系统的开发过程。</li>
</ul>
</li>
<li>缺点：<ul>
<li>①模块间的接口规定很难满足对接口的实际需求。</li>
<li>②各模块设计者齐头并进，每个决定无法建立在上一个已验证的正确决定的基础上，因此无法找到一个可靠的决定顺序。</li>
</ul>
</li>
</ul>
</li>
<li><p>宏内核</p>
<p>又称<strong>大内核</strong>或<strong>单内核</strong>，是指将系统的<strong>主要功能模块</strong>都作为一个紧密联系的整体运行在核心态，从而为用户程序提供高性能的系统服务。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230907143626843.png" alt="image-20230907143626843"></p>
<ul>
<li>优点：高性能</li>
<li>缺点：内核代码庞大，结构混乱，难以维护</li>
<li>应用：Windows、Linux、Android、IOS、macOS等架构；但其都广泛吸取微内核的优点进行改进。</li>
</ul>
</li>
<li><p>微内核</p>
<p>微内核构架，是指将内核中<strong>最基本的功能</strong>保留在内核，而将那些不需要在核心态执行的功能移到用户态执行，从而降低内核的设计复杂性。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230907143857739.png" alt="image-20230907143857739"></p>
<p>那些移出内核的操作系统代码根据分层的原则被划分成若干服务程序，它们的执行相互独立，交互则都借助于微内核进行通信。</p>
<p>微内核架构&#x3D;微内核+多个服务器</p>
<ul>
<li><p>微内核内容</p>
<ul>
<li>①与硬件处理紧密相关的部分</li>
<li>②一些较基本的功能</li>
<li>③客户和服务器之间的通信。</li>
</ul>
</li>
<li><p>服务器（进程）</p>
<ul>
<li>用于提供对进程（线程）进行管理的进程（线程）服务器、</li>
<li>提供虚拟存储器管理功能的虚拟存储器服务器等，</li>
</ul>
<p>它们都是作为进程来实现的，运行在用户态，客户与服务器之间是借助微内核提供的消息传递机制来实现交互的。下图为单机环境下的客户&#x2F;服务器模式。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230907144344712.png" alt="image-20230907144344712"></p>
</li>
<li><p>微内核基本功能</p>
<ul>
<li><p>①进程（线程）管理。</p>
<p>如进程（线程）之间通信、切换、调度以及多处理机之间的同步。</p>
</li>
<li><p>②低级存储器管理。</p>
<p>如用于实现将逻辑地址变换为物理地址等的页表机制和地址变换机制，这一部分是依赖于硬件的，因此放入微内核。</p>
</li>
<li><p>③中断和陷入处理。</p>
<p>捕获所发生的中断和陷入事件，并进行中断响应处理，在识别中断或陷入的事件后，再发送给相关的服务器来处理</p>
</li>
</ul>
</li>
<li><p>微内核特点</p>
<ul>
<li>①扩展性和灵活性。增添新的功能无需改变内核代码，只需在相应服务器中修改添加新功能。</li>
<li>②可靠性和安全性。某个模块崩溃时，只会使该进程崩溃，不会使整个系统崩溃。</li>
<li>③可移植性。与CPU和I&#x2F;O硬件有关的代码均放在内核中，移植代码无需考虑硬件差异。</li>
<li>④分布式计算。采用消息传递机制，使微内核系统能很好地支持分布式系统和网络系统。</li>
</ul>
</li>
<li><p>微内核缺点：需要频繁地在核心态和用户态之间切换，性能低</p>
</li>
<li><p>应用：鸿蒙OS、实时、工业、航空及军事应用。</p>
</li>
</ul>
</li>
<li><p>外核（exokernel）</p>
<p> 内核负责进程调度、进程通信等功能；外核在内核态运行，负责为用户进程分配未经抽象的硬件资源，且由外核负责保证资源使用安全。</p>
<ul>
<li>任务：为虚拟机分配资源，并检查使用这些资源的企图，以确保没有机器会使用他人的资源。每个用户层的虚拟机可以运行自己的操作系统，但限制只能使用已经申请并且获得分配的那部分资源。</li>
<li>优点<ul>
<li>外核可直接给用户进程分配“不虚拟、不抽象的硬件资源，使用户进程可以更灵活的使用硬件资源</li>
<li>减少了虚拟硬件资源的“映射层”，提升效率</li>
</ul>
</li>
<li>缺点<ul>
<li>降低了系统的一致性</li>
<li>使系统变得更复杂</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="1-5-操作系统引导"><a href="#1-5-操作系统引导" class="headerlink" title="1.5 操作系统引导"></a>1.5 操作系统引导</h3><ol>
<li><p>概念</p>
<ul>
<li><p>BIOS 程序（Basic Input&#x2F;Output System）</p>
<p>BIOS 是固化在主板上的<strong>基本输入输出系统</strong>，是计算机启动第一个运行的软件，存放在ROM中。它会进行硬件初始化和自检，然后查找引导程序并执行。</p>
</li>
<li><p>引导程序（Boot）</p>
<p>引导程序是存储在主存ROM中的一段小程序，它的作用是将操作系统的内核文件从硬盘中读取到内存中，并跳转到内核入口点开始执行。</p>
</li>
<li><p>主引导记录(MBR)</p>
<p>MBR是硬盘的主引导记录，位于硬盘的第一个扇区。它包含了磁盘引导程序和分区表。该引导程序会找到<strong>活动分区</strong>并读取其分区引导记录，完成硬盘的引导。</p>
</li>
<li><p>分区引导记录(PBR)</p>
<p>PBR是分区引导记录，位于每个分区的第一个扇区。PBR中包含了一个引导程序，可以寻找并激活分区根目录下的启动管理器，完成分区的引导过程。</p>
</li>
</ul>
</li>
<li><p>引导过程</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230907152457354.png" alt="image-20230907152457354"></p>
<p>引导过程：</p>
<ul>
<li><p>①CPU从一个特定主存地址开始，取指令，执行ROM中的引导程序（先进行硬件自检，再开机）</p>
<ul>
<li>BIOS初始化并执行引导程序进行自检,确保硬件工作正常。</li>
<li>BIOS查找可引导设备(通常是安装有操作系统的硬盘),读取主引导记录(MBR)。</li>
</ul>
</li>
<li><p>②将磁盘的第一块一一</p>
<p>主引导记录</p>
<p>读入内存，执行磁盘引导程序，扫描分区表</p>
<ul>
<li>MBR执行,识别活动分区,查找并执行该分区的分区引导记录(PBR)。</li>
</ul>
</li>
<li><p>③从</p>
<p>活动分区</p>
<p>（又称主分区，即安装了操作系统的分区）读入分区引导记录，执行其中的程序</p>
<ul>
<li>PBR找到分区中操作系统的启动管理器程序并加载执行。</li>
</ul>
</li>
<li><p>④从根目录下找到完整的操作系统初始化程序（即启动管理器）并执行，完成“开机”的一系列动作</p>
<ul>
<li>启动管理器进一步加载操作系统内核和关键组件到内存。</li>
<li>操作系统内核接管硬件控制权,初始化系统,启动操作系统。</li>
</ul>
</li>
</ul>
<blockquote>
<p>注：操作系统最终被加载到 RAM 中。</p>
</blockquote>
</li>
</ol>
<h3 id="1-6-虚拟机"><a href="#1-6-虚拟机" class="headerlink" title="1.6 虚拟机"></a>1.6 虚拟机</h3><ol>
<li><p>定义</p>
<p>使用虚拟化技术，将一台物理机器虚拟化为多台虚拟机器（Virtual Machine，VM），每个虚拟机器都可以独立运行一个操作系统。</p>
</li>
<li><p>分类</p>
<ul>
<li><p>第一类虚拟机程序</p>
<p>第一类虚拟机管理程序就像一个<strong>操作系统</strong>，因为它是唯一一个运行在最高特权级的程序。</p>
<p>它在裸机上运行并且具备多道程序功能。虚拟机管理程序向上层提供若干台虚拟机，这些虚拟机是裸机硬件的精确复制品。由于每台虚拟机都与裸机相同，所以在不同的虚拟机上可以<strong>运行任何不同的操作系统</strong>。</p>
<p>虚拟内核态：虚拟机作为用户态的一个进程运行，不允许执行敏感指令。然而，虚拟机上的操作系统认为自己运行在内核态（实际上不是），称为虚拟内核态。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/babb5d7bec774542a42669e1fd185de3.png" alt="babb5d7bec774542a42669e1fd185de3"></p>
</li>
<li><p>第二类虚拟机程序</p>
<p>它是一个依赖于Windows、Linux等操作系统分配和调度资源的程序，很像一个<strong>普通的进程</strong>。</p>
<p>如VMware Workstation。</p>
<p>对于第二类虚拟机管理程序，运行在底层硬件上的操作系统称为<strong>宿主操作系统</strong>；运行在虚拟机管理程序上的操作系统称为<strong>客户操作系统</strong>。</p>
<p>首次启动时，第二类虚拟机管理程序像一台刚启动的计算机那样运转，期望找到的驱动器可以是虚拟设备。然后将操作系统安装到虚拟磁盘上（其实只是宿主操作系统中的一个文件）。客户操作系统安装完成后，就能启动并运行。</p>
</li>
</ul>
</li>
<li><p>对比</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">第一类VMM</th>
<th align="center">第二类VMM</th>
</tr>
</thead>
<tbody><tr>
<td align="center">对物理资源的控制权</td>
<td align="center">直接运行在硬件之上，能直接控制和分配物理资源</td>
<td align="center">运行在Host OS之上，依赖于Host OS为其分配物理资源</td>
</tr>
<tr>
<td align="center">资源分配方式</td>
<td align="center">在安装Guest OS时，VMM要在原本的硬盘上自行分配存储空间，类似于”外核“的分配方式，分配未经抽象的物理硬件</td>
<td align="center">GuestOs拥有自己的虚拟磁盘，该盘实际上是HostOs文件系统中的一个大文件。GuestOs分配到的内存是虚拟内存</td>
</tr>
<tr>
<td align="center">性能</td>
<td align="center">性能更好</td>
<td align="center">性能更差，需要Host Os作为”中介”</td>
</tr>
<tr>
<td align="center">可支持的虚拟机数量</td>
<td align="center">更多，不需要和Host OS竞争资源，相同的硬件资源可以支持更多的虚拟机</td>
<td align="center">更少，Host Os本身需要使用物理资源，Host OS上运行的其他进程也需要物理资源</td>
</tr>
<tr>
<td align="center">虚拟机的可迁移性</td>
<td align="center">更差</td>
<td align="center">更好，只需导出虚拟机镜像文件即可迁移到另一台Host Os上，商业化应用更广泛</td>
</tr>
<tr>
<td align="center">运行模式</td>
<td align="center">第一类VMM运行在最高特权级（Ring 0），可以执行最高特权的指令。</td>
<td align="center">第二类VMM部分运行在用户态、部分运行在内核态。GuestOs发出的系统调用会被VMM截获，并转化为VMM对Hostos的系统调用</td>
</tr>
</tbody></table>
</li>
</ol>
<blockquote>
<p>例<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230907162533481.png" alt="image-20230907162533481"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230907162545296.png" alt="image-20230907162545296"></p>
</blockquote>
<h2 id="2-进程与线程"><a href="#2-进程与线程" class="headerlink" title="2 进程与线程"></a>2 进程与线程</h2><h3 id="2-1-进程与线程"><a href="#2-1-进程与线程" class="headerlink" title="2.1 进程与线程"></a>2.1 进程与线程</h3><h4 id="2-1-1-进程的概念和特征"><a href="#2-1-1-进程的概念和特征" class="headerlink" title="2.1.1 进程的概念和特征"></a>2.1.1 进程的概念和特征</h4><ol>
<li><p>进程的概念</p>
<p>进程是进程实体的<strong>运行过程</strong>，是系统进行<strong>资源分配和调度</strong>的一个独立单位。</p>
<blockquote>
<p>进程实现操作系统的并发性和共享性。</p>
</blockquote>
<p>程序：是<strong>静态</strong>的，就是个存放在磁盘里的<strong>可执行文件</strong>，如：QQ.exe。</p>
<p>进程：是<strong>动态</strong>的，是程序的一次<strong>执行过程</strong>，或者是一个<strong>正在运行的程序</strong>，如：可同时启动多次QQ程序。</p>
<p>进程实体：即<strong>进程映像</strong>，是<strong>静态</strong>的，可理解为进程的一次时刻的状态。</p>
<p>作业：用户向计算机提交的一项<strong>任务</strong>，是<strong>静态</strong>的，它通常是一个批处理程序或一个后台程序。</p>
</li>
<li><p>进程实体的组成</p>
<ul>
<li><p><strong>程序控制块PCB</strong></p>
<p>PCB是进程存在的唯一标志，当进程被创建时，操作系统为其创建PCB，当进程结束时，会回收其PCB。</p>
<ul>
<li>进程描述信息<ul>
<li>进程标识符PID：当进程被创建时，操作系统会为该进程分配一个唯一的、不重复的“身份证号”–PID（Process ID，进程ID）</li>
<li>用户标识符UID</li>
</ul>
</li>
<li>进程控制和管理信息<ul>
<li>CPU、磁盘、网络流量使用情况统计…</li>
<li>进程当前状态：就绪态&#x2F;阻塞态&#x2F;运行态.…</li>
</ul>
</li>
<li>资源分配清单<ul>
<li>正在使用哪些文件</li>
<li>正在使用哪些内存区域</li>
<li>正在使用哪些I&#x2F;O设备</li>
</ul>
</li>
<li><strong>处理机相关信息（CPU现场信息）</strong>：如PSW、PC等等各种寄存器的值（用于实现进程切换）</li>
</ul>
</li>
</ul>
<blockquote>
<p>① PCB，即<strong>进程控制块</strong>，操作系统需要对各个并发运行的进程进行管理， 但凡管理时所需要的信息，都会被放在 PCB 中。<br>② PCB 是进程存在的唯一标志。<br>③ PCB 存于内存的内核区，注意内存的内核区和 OS 的内核态的区别，内核程序运行在内核态。</p>
</blockquote>
<ul>
<li>程序段：程序的代码（指令序列）</li>
<li>数据段：运行过程中产生的各种数据（如：程序中定义的变量）</li>
</ul>
<blockquote>
<p>①PCB 是给操作系统用的，程序段和数据段是给进程自己用的。</p>
<p>②引入进程实体的概念后，可把进程定义为是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</p>
</blockquote>
</li>
<li><p>进程的特征</p>
<ul>
<li>动态性：进程是程序的一次执行过程，是动态地产生、变化和消亡的；动态性是进程最基本的特征。</li>
<li>并发性：内存中有多个进程实体，各进程可<strong>并发执行</strong></li>
<li>独立性：进程是能独立运行、独立获得资源、独立接受调度的基本单位</li>
<li>异步性：各进程按<strong>各自独立的</strong>、不可预知的速度向前推进，异步性会导致并发程序执行结果的不确定性。</li>
<li>结构性：每个进程都会配置一个PCB。结构上看，进程由程序段、数据段、PCB组成</li>
</ul>
</li>
</ol>
<h4 id="2-1-2-进程的状态与转换"><a href="#2-1-2-进程的状态与转换" class="headerlink" title="2.1.2 进程的状态与转换"></a>2.1.2 进程的状态与转换</h4><ol>
<li><p>基本状态</p>
<ul>
<li><p><strong>运行态</strong>。占有CPU，并在CPU上运行；√CPU√其他所需资源</p>
</li>
<li><p><strong>就绪态</strong>。已具有运行条件，但无空闲CPU，暂时不能运行；×CPU√其他所需资源</p>
<blockquote>
<p>系统中处于就绪状态的进程可能有多个，通常将它们排成一个队列，称为就绪队列。</p>
</blockquote>
</li>
<li><p><strong>阻塞态</strong>，又称等待态。因等待某一事件暂时不能运行；×CPU×其他所需资源</p>
<blockquote>
<p>系统通常将处于阻塞态的进程也排成一个队列，甚至根据阻塞原因的不同，设置多个阻塞队列。</p>
</blockquote>
</li>
<li><p><strong>创建态</strong>。进程正在被创建，尚未转到就绪态。OS为进程分配系统资源、初始化PCB</p>
<ul>
<li>首先申请一个空白PCB，并向PCB中填写用于控制和管理进程的信息</li>
<li>然后为该进程分配运行时所必须的资源</li>
<li>最后把该进程转入就绪态并插入就绪队列</li>
</ul>
<p>但是，如果进程所需的资源尚不能得到满足，如内存不足，则创建工作尚未完成，进程此时所处的状态称为创建态。</p>
</li>
<li><p><strong>终止态</strong>。进程正从系统中消失，进程正常结束或其他原因退出运行。OS回收进程拥有的资源，撤销PCB</p>
</li>
</ul>
</li>
<li><p>进程状态的转换</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img-blog.csdnimg.cn/ee76634e0d554449b9c693e9c069a655.png" alt="img"></p>
<ul>
<li>就绪态一&gt;运行态：进程被调度</li>
<li>运行态一&gt;就绪态：时间片到 or CPU被其他进程抢占</li>
<li>运行态一&gt;阻塞态：等待系统资源分配or等待某事件发生（主动行为）</li>
<li>阻塞态一&gt;就绪态：资源分配到位，等待的事件发生（被动行为）</li>
<li>创建态一&gt;就绪态：系统完成创建进程相关的工作</li>
<li>运行态一&gt;终止态：进程运行结束 or 运行过程中遇到不可修复的错误</li>
</ul>
</li>
</ol>
<h4 id="2-1-3-进程的组织方式"><a href="#2-1-3-进程的组织方式" class="headerlink" title="2.1.3 进程的组织方式"></a>2.1.3 进程的组织方式</h4><ol>
<li><p>链接方式</p>
<p>链接方式是将同一状态的进程的PCB组成一个双向链表，称为进程队列。</p>
<ul>
<li>结构：每个队列的队首和队尾都有一个指针，指向第一个和最后一个PCB。每个PCB中也有两个指针，分别指向前一个和后一个PCB。这样，就可以方便地在队列中插入或删除PCB。</li>
<li>优点：简单、灵活</li>
<li>缺点：查找效率低，需要遍历链表</li>
</ul>
</li>
<li><p>索引方式</p>
<p>索引方式是将所有的PCB存放在一张索引表中，每个表项包含一个PCB的地址和状态信息。</p>
<ul>
<li>结构：索引表可以是顺序表或散列表，可以按照进程号或其他关键字进行排序或散列。</li>
<li>优点：查找效率高，可以快速定位到某个PCB</li>
<li>缺点：需要额外的空间存储索引表，且索引表的大小受限于内存容量</li>
</ul>
</li>
</ol>
<h4 id="2-1-4-进程控制"><a href="#2-1-4-进程控制" class="headerlink" title="2.1.4 进程控制"></a>2.1.4 进程控制</h4><p> 进程控制就是要实现进程状态的转换，通过原语实现。</p>
<ol>
<li><p>进程的创建</p>
<ul>
<li><p>创建原语：操作系统创建一个进程时使用的原语，其操作如下；创建态→就绪态</p>
<ul>
<li>申请空白PCB</li>
<li>为新进程分配所需资源</li>
<li>初始化PCB</li>
<li>将PCB插入就绪队列</li>
</ul>
</li>
<li><p>引起进程创建的事件</p>
<ul>
<li>用户登录：分时系统中，用户登录成功，系统会建立为其建立一个新的进程</li>
<li>作业调度：多道批处理系统中，有新的作业放入内存时，会为其建立一个新的进程</li>
<li>提供服务：用户向操作系统提出某些请求时，会新建一个进程处理该请求</li>
<li>应用请求：由用户进程主动请求创建一个子进程</li>
</ul>
</li>
<li><p>父子进程</p>
<p>允许一个进程创建另一个进程，此时创建者称为<strong>父进程</strong>，被创建的进程称为<strong>子进程</strong>。</p>
<ul>
<li>进程可以继承父进程所拥有的资源。</li>
<li>当子进程被撤销时，应将其从父进程那里获得的资源归还给父进程。</li>
<li>在撤销父进程时，通常也会同时撤销其所有的子进程。</li>
</ul>
</li>
</ul>
</li>
<li><p>进程的终止</p>
<ul>
<li><p>撤销原语：其操作如下；</p>
<p>就绪态&#x2F;阻塞态&#x2F;运行态→终止态→无</p>
<ul>
<li>从PCB集合中找到终止进程的PCB</li>
<li>若进程正在运行，立即剥夺CPU，将CPU分配给其他进程</li>
<li>终止其所有子进程</li>
<li>将该进程拥有的所有资源归还给父进程或操作系统</li>
<li>删除PCB</li>
</ul>
</li>
<li><p>引起进程终止的事件</p>
<ul>
<li>正常结束：进程自已请求终止（exit系统调用）</li>
<li>异常结束：整数除以0、非法使用特权指令，然后被操作系统强行杀掉</li>
<li>外界干预：Ctrl+Alt+delete，用户选择杀掉进程</li>
</ul>
</li>
</ul>
</li>
<li><p>进程的阻塞</p>
<ul>
<li><p>阻塞原语：其操作如下；</p>
<p>运行态→阻塞态</p>
<ul>
<li>找到要阻塞的进程对应的PCB</li>
<li>保护进程运行现场，将PCB状态信息设置为“阻塞态，暂时停止进程运行</li>
<li>将PCB插入相应事件的等待队列</li>
</ul>
</li>
<li><p>引起进程阻塞的事件</p>
<ul>
<li>需要等待系统分配某种资源</li>
<li>需要等待相互合作的其他进程完成工作</li>
</ul>
</li>
</ul>
</li>
<li><p>进程的唤醒</p>
<ul>
<li><p>唤醒原语：其操作如下；</p>
<p>阻塞态→就绪态</p>
<ul>
<li>在事件等待队列中找到PCB</li>
<li>将PCB从等待队列移除，设置进程为就绪态</li>
<li>将PCB插入就绪队列，等待被调度</li>
</ul>
</li>
<li><p>引起进程唤醒的事件</p>
<ul>
<li>等待的事件发生：因何事阻塞，就应由何事唤醒</li>
</ul>
</li>
</ul>
<p>阻塞原语唤醒原语必须成对使用</p>
</li>
<li><p>进程的切换</p>
<ul>
<li><p>切换原语：其操作如下；</p>
<p>运行态→就绪态，就绪态→运行态</p>
<ul>
<li>将运行环境信息存入PCB</li>
<li>PCB移入相应队列选择</li>
<li>另一个进程执行，并更新其PCB</li>
<li>根据PCB恢复新进程所需的运行环境</li>
</ul>
</li>
<li><p>引起进程切换的事件</p>
<ul>
<li>当前进程时间片到</li>
<li>有更高优先级的进程到达</li>
<li>当前进程主动阻塞</li>
<li>当前进程终止</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="2-1-5-进程的通信"><a href="#2-1-5-进程的通信" class="headerlink" title="2.1.5 进程的通信"></a>2.1.5 进程的通信</h4><p> <strong>低级通信方式</strong>：PV操作。<strong>高级通信方式</strong>：共享存储、消息传递、管道通信。</p>
<ol>
<li><p>共享存储</p>
<p>设置一个共享空间，通过对其进行读&#x2F;写操作实现信息交换</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230908090734034.png" alt="image-20230908090734034"></p>
<p>在对共享空间进行写&#x2F;读操作时，需要使用同步互斥工具（如PV操作）。</p>
<p>共享存储分为两种：</p>
<ul>
<li><p>低级方式：基于数据结构的共享</p>
<p>比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种低级通信方式</p>
</li>
<li><p>高级方式：基于存储区的共享</p>
<p>操作系统在内存中划出一块共享存储区，数据的形式、存放位置都由通信进程控制，而不是操作系统。这种共享方式速度很快，是一种高级通信方式。</p>
</li>
</ul>
<blockquote>
<p>进程之间共享空间需要通过特殊的系统调用实现；进程内线程共享进程空间。</p>
</blockquote>
</li>
<li><p>消息传递</p>
<p>在消息传递系统中，进程间的数据交换以格式化的消息（Message）为单位。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230908091456671.png" alt="image-20230908091456671"></p>
<p>进程通过操作系统提供的“发送消息&#x2F;接收消息”两个原语进行数据交换。</p>
<blockquote>
<p>在<strong>微内核操作系统</strong>中，微内核与服务器之间的通信就采用了消息传递机制。</p>
</blockquote>
<p><strong>消息格式</strong>：</p>
<ul>
<li>消息头：发送进程ID、接受进程ID、消息长度等格式化的信息</li>
<li>消息体</li>
</ul>
<p><strong>通信方式</strong>：</p>
<ul>
<li><p><strong>直接通信方式</strong>：发送进程直接把消息发送给接收进程，并将它挂在接收进程的消息缓冲队列上，接收进程从消息缓冲队列中取得消息。</p>
</li>
<li><p><strong>间接通信方式</strong>：送进程通过信箱间接地通信，将消息发送到某个中间实体，接收进程从中间实体取得消息。该通信方式广泛应用于计算机网络中。</p>
<blockquote>
<p>注：可以多个进程往同一个信箱 send 消息，也可以多个进程从同一个信箱中 receive 消息。</p>
<p>用发送原语和接收原语实现基于信箱的进程间通信</p>
</blockquote>
</li>
</ul>
</li>
<li><p>管道通信</p>
<p>管道是一个特殊的共享文件，又名pipe文件。其实就是在内存中开辟一个大小固定的内存缓冲区。</p>
<p>管道通信允许两个进程按生产者-消费者方式进行通信。各进程要互斥访问管道。</p>
<ul>
<li>写满时，不能再写，读空时，不能再读</li>
<li>没写满时，不能读，没读空时，不能写</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230908101047933.png" alt="image-20230908101047933"></p>
<blockquote>
<p>一个管道只能实现半双工通信；实现<strong>双向同时通信</strong>要建立两个管道</p>
</blockquote>
<ul>
<li>管道本质上是一种特殊的文件。相比于普通的文件通信，其区别如下：<ul>
<li><strong>限制管道的大小</strong>。管道文件是一个固定大小的缓冲区，使得它的大小不像普通文件那样不加检验地增长。</li>
<li><strong>读进程也可能工作得比写进程快</strong>。读空时再读管道会被阻塞，而不是调用返回文件结束。</li>
</ul>
</li>
<li><strong>管道中的数据一旦被读出，就彻底消失</strong>。因此，当多个进程读同一个管道时，可能会错乱。对此，通常有两种解决方案：<ul>
<li>①一个管道允许多个写进程，一个读进程（2014年408真题高教社官方答案）；</li>
<li>②允许有多个写进程，多个读进程，但系统会让各个读进程轮流从管道中读数据（Liux的方案）。</li>
</ul>
</li>
</ul>
<p>管道只能由<strong>创建进程</strong>所访问，当父进程创建一个管道后，由于管道是一种特殊文件，子进程会继承父进程的打开文件，因此子进程也继承父进程的管道，并使用它来与父进程进进行通信。</p>
</li>
</ol>
<h4 id="2-1-6-线程和多线程模型"><a href="#2-1-6-线程和多线程模型" class="headerlink" title="2.1.6 线程和多线程模型"></a>2.1.6 线程和多线程模型</h4><ol>
<li><p>线程的基本概念</p>
<p>线程可理解为轻量级进程，它是一个基本的CPU执行单元，也是程序执行流的最小单位。</p>
<p>线程由线程ID、程序计数器、寄存器集合和堆栈组成。</p>
<blockquote>
<p>引入进程的目的是更好地使多道程序并发执行，提高资源利用率和系统吞吐量；</p>
<p>而引入线程的目的则是减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能。</p>
</blockquote>
<p>引入线程后，<strong>进程</strong>只作为除CPU外的系统资源的分配单位，线程则作为处理机的分配单元</p>
</li>
<li><p>线程与进程的比较</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">传统进程机制</th>
<th align="center">引入线程后</th>
</tr>
</thead>
<tbody><tr>
<td align="center">资源分配、调度</td>
<td align="center">进程是资源分配、调度基本单位</td>
<td align="center">进程是资源分配基本单位 线程是资源调度基本单位</td>
</tr>
<tr>
<td align="center">并发性</td>
<td align="center">进程间并发</td>
<td align="center">线程间也能并发</td>
</tr>
<tr>
<td align="center">拥有资源</td>
<td align="center">拥有资源的基本单位</td>
<td align="center">不拥有系统资源</td>
</tr>
<tr>
<td align="center">独立性</td>
<td align="center">进程间独立地址空间和资源</td>
<td align="center">同进程下的线程共享地址空间和资源</td>
</tr>
<tr>
<td align="center">系统开销</td>
<td align="center">需要切换进程运行环境，开销大</td>
<td align="center">同一进程内线程，不需切换进程环境，开销小</td>
</tr>
<tr>
<td align="center">支持多处理机系统</td>
<td align="center">进程只能运行在一个处理机上</td>
<td align="center">进程中多个线程可以分配到多个处理机执行</td>
</tr>
</tbody></table>
</li>
<li><p>线程的属性</p>
<p>多线程操作系统中的进程已不再是一个基本的执行实体，但它仍具有与执行相关的状态。所谓进程处于“执行”状态，实际上是指该进程中的某线程正在执行。</p>
<ul>
<li>线程是处理机调度的单位</li>
<li>多CPU计算机中，各个线程可占用不同的CPU</li>
<li>每个线程都有一个线程ID、线程控制块（TCB）</li>
<li>线程也有就绪、阻塞、运行三种基本状态</li>
<li>线程几乎不拥有系统资源</li>
<li>同一进程的不同线程间共享进程的资源</li>
<li>由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预</li>
<li>同一进程中的线程切换，不会引起进程切换</li>
<li>不同进程中的线程切换，会引起进程切换</li>
<li>切换同进程内的线程，系统开销很小</li>
<li>切换进程，系统开销较大</li>
</ul>
<blockquote>
<p>注：线程是处理机调度的单位，这里的线程指的是 操作系统看得见的内核级线程，<strong>内核级线程是处理机分配的单位</strong> 。</p>
<p>同进程的线程之间可以共享进程的代码段、全局变量、打开的文件，不共享线程各自的栈指针等TCB内容</p>
</blockquote>
</li>
<li><p>线程的实现方式</p>
<p>线程的实现可以分为两类：用户级线程 和 内核级线程。内核级线程又称内核支持的线程。</p>
<ul>
<li><p><strong>用户级线程</strong></p>
<p>在用户级线程中，有关线程管理(创建、撤销和切换等)的所有工作都由应用程序在<strong>用户空间</strong>中完成，内核意识不到线程的存在，因此说用户级线程对操作系统透明。</p>
<ul>
<li>用户级线程由应用程序通过线程库实现，所有的线程管理工作都由应用程序负责（包括线程切换）</li>
<li>用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预。</li>
<li>在<strong>用户</strong>看来，是有多个线程。但是在<strong>操作系统内核</strong>看来，并意识不到线程的存在。“用户级线程”就是“从用户视角看能看到的线程</li>
</ul>
<blockquote>
<p>若系统中只有用户级线程，则处理机的调度对象是进程</p>
</blockquote>
<p><strong>优点</strong>：</p>
<ul>
<li>用户级线程的切换在用户空间即可完成，不需要切换到核心态，</li>
<li>线程管理的系统开销小，效率高</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。</li>
<li>多个线程不可在多核处理机上并行运行</li>
</ul>
</li>
<li><p><strong>内核级线程</strong></p>
<p>内核级线程是在内核的支持下运行的，线程管理的所有工作也是在内核空间内实现的。</p>
<ul>
<li>内核级线程的管理工作由操作系统内核完成。</li>
<li>线程调度、切换等工作都由内核负责，因此<strong>内核级线程的切换</strong>必然需要在<strong>核心态</strong>下才能完成。</li>
<li>操作系统会为每个内核级线程建立相应的TCB（Thread Control Block，线程控制块）通过TCB对线程进行管理。“内核级线程”就是“从操作系统内核视角看能看到的线程”</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。</li>
<li>多线程可在多核处理机上并行执行。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。</li>
</ul>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">用户级线程</th>
<th align="center">内核级线程</th>
</tr>
</thead>
<tbody><tr>
<td align="center">线程的管理工作由谁来完成</td>
<td align="center">由 应用程序 通过线程库实现所有的线程管理工作 ，包括线程切换</td>
<td align="center">线程管理工作由 操作系统内核完成</td>
</tr>
<tr>
<td align="center">线程切换是否需要 CPU 变态</td>
<td align="center">用户级线程切换 可以在用户态下即可完成 ，无需操作系统干预</td>
<td align="center">线程调度、切换等工作都由内核负责，因此 内核级线程的切换 必然需要在 核心态 下才能完成。</td>
</tr>
<tr>
<td align="center">OS 是否能意识到用户级线程的存在</td>
<td align="center">OS 内核意识不到用户级线程的存在 用户级线程就是从用户视角看能看到的线程</td>
<td align="center">OS 会为每个内核级线程建立相应的 TCB（线程控制块） 通过TCB对线程进行管理 内核级线程就是从操作系统内核视角看能看到的线程</td>
</tr>
<tr>
<td align="center">优点</td>
<td align="center">用户级线程的切换在用户空间即可完成， 不需要切换到核心态，线程管理的系统开销小，效率高</td>
<td align="center">当一个线程被阻塞后，其他线程还可以继续执行，并发能力强 多线程可在多核处理机上并行执行</td>
</tr>
<tr>
<td align="center">缺点</td>
<td align="center">当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高 因为进程是处理机调度的基本单位，同一进程的多个线程不可在多核处理机上并行运行</td>
<td align="center">一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成 需要切换到核心态，因此线程管理的开销大，效率低，成本高</td>
</tr>
</tbody></table>
</li>
<li><p>组合方式</p>
<p>有些系统使用组合方式的多线程实现。在组合实现方式中，内核支持多个内核级线程的建立、调度和管理，同时允许用户程序建立、调度和管理用户级线程。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230908113303239.png" alt="image-20230908113303239"></p>
<ul>
<li>一些内核级线程对应多个用户级线程，这是用户级线程通过时分多路复用内核级线程实现的。</li>
<li>同一进程中的多个线程可以同时在多处理机上并行执行，</li>
<li>且在阻塞一个线程时不需要将整个进程阻塞，</li>
</ul>
</li>
<li><p>线程库</p>
<p>线程库是为程序员提供创建和管理线程的API。实现方式有以下两种。</p>
<ul>
<li>①在用户空间中提供一个没有内核支持的库。这种库的所有代码和数据结构都位于用户空间中。这意味着，调用库内的一个函数只导致用户空间中的一个本地函数的调用。</li>
<li>②实现由操作系统直接支持的内核级的一个库。对于这种情况，库内的代码和数据结构位于内核空间。调用库中的一个API函数通常会导致对内核的系统调用。</li>
</ul>
</li>
</ul>
</li>
<li><p>多线程模型</p>
<ul>
<li><p>一对一模型</p>
<p>一个用户级线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。</p>
<ul>
<li><strong>优点</strong>：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。（内核级线程优点）</li>
<li><strong>缺点</strong>：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。（内核级线程缺点）</li>
</ul>
</li>
<li><p>多对一模型</p>
<p>多个用户级线程映射到一个内核级线程。且一个进程只被分配一个内核级线程。</p>
<ul>
<li><strong>优点</strong>：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高（用户级线程优点）</li>
<li><strong>缺点</strong>：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行（用户级线程缺点）</li>
</ul>
</li>
<li><p>多对多模型</p>
<p>n用户及线程映射到m个内核级线程（n&gt;&#x3D;m）。每个用户进程对应m个内核级线程。</p>
<p>克服了多对一模型并发度不高的缺点（一个阻塞全体阻塞），又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。还拥有上述两种模型各自的优点。</p>
</li>
</ul>
</li>
<li><p>线程的状态与转换</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230908114535993.png" alt="image-20230908114535993"></p>
</li>
<li><p>线程的组织与控制</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230908123934054.png" alt="image-20230908123934054"></p>
<ul>
<li><p>线程控制块</p>
<p>与进程类似，系统也为每个线程配置一个线程控制块TCB，用于记录控制和管理线程的信息。线程控制块通常包括</p>
<ul>
<li>①线程标识符</li>
<li>②一组寄存器，包括程序计数器、状态寄存器和通用寄存器</li>
<li>③线程运行状态，用于描述线程正处于何种状态</li>
<li>④优先级</li>
<li>⑤线程专有存储区，线程切换时用于保存现场等</li>
<li>⑥堆栈指针，用于过程调用时保存局部变量及返回地址等。</li>
</ul>
<p>同一进程中的所有线程都完全共享进程的地址空间和全局变量。</p>
<p>各个线程都可以访问进程地址空间的每个单元，所以一个线程可以读、写或甚至清除另一个线程的堆栈。</p>
</li>
<li><p>线程的创建</p>
<p>用户程序启动时，通常仅有一个称为“初始化线程”的线程正在执行，其主要功能是用于创建新线程。</p>
<p>在创建新线程时，需要利用一个线程创建函数，并提供相应的参数，如指向线程主程序的入口指针、堆栈的大小、线程优先级等。线程创建函数执行完后，将返回一个线程标识符。</p>
</li>
<li><p>线程的终止</p>
<p>当一个线程完成自己的任务后，或线程在运行中出现异常而要被强制终止时，由终止线程调用相应的函数执行终止操作。</p>
<p>但是有些线程（主要是系统线程）一旦被建立，便一直运行而不会被终止。通常，线程被终止后并不立即释放它所占有的资源，只有当进程中的其他线程执行了分离函数后，被终止线程才与资源分离，此时的资源才能被其他线程利用。</p>
<p>被终止但尚未释放资源的线程仍可被其他线程调用，以使被终止线程重新恢复运行。</p>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>例</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911100724303.png" alt="image-20230911100724303"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911100801565.png" alt="image-20230911100801565"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911103000066.png" alt="image-20230911103000066"></p>
<p>进程之间独立地址空间，独立资源；但也可以通过通信机制交换资源</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911105724596.png" alt="image-20230911105724596"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911105739059.png" alt="image-20230911105739059"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911110615213.png" alt="image-20230911110615213"></p>
<p>这些线程属于内核进程，它们在内核空间中运行，不受用户进程的影响。 因此，DLL库中的系统线程是唯一的，不会因为被不同的进程调用而产生多个副本。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911110637435.png" alt="image-20230911110637435"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911111039392.png" alt="image-20230911111039392"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911111052692.png" alt="image-20230911111052692"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911112244092.png" alt="image-20230911112244092"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911112258010.png" alt="image-20230911112258010"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911112506823.png" alt="image-20230911112506823"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911112519940.png" alt="image-20230911112519940"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911112712996.png" alt="image-20230911112712996"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911112724683.png" alt="image-20230911112724683"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911112828470.png" alt="image-20230911112828470"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911113034693.png" alt="image-20230911113034693"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911113159888.png" alt="image-20230911113159888"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911113244732.png" alt="image-20230911113244732"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911113721782.png" alt="image-20230911113721782"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911114135838.png" alt="image-20230911114135838"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911114235410.png" alt="image-20230911114235410"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911114246766.png" alt="image-20230911114246766"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911114447948.png" alt="image-20230911114447948"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911114528761.png" alt="image-20230911114528761"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911114649263.png" alt="image-20230911114649263"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911114713204.png" alt="image-20230911114713204"></p>
</blockquote>
<h3 id="2-2-处理机调度"><a href="#2-2-处理机调度" class="headerlink" title="2.2 处理机调度"></a>2.2 处理机调度</h3><h4 id="2-2-1-调度的概念"><a href="#2-2-1-调度的概念" class="headerlink" title="2.2.1 调度的概念"></a>2.2.1 调度的概念</h4><ol>
<li><p>调度的基本概念</p>
<p>处理机调度是对处理机进行分配，即从就绪队列中按照一定的算法（公平、高效的原则）去选择一个进程并将处理机分配给它运行，以实现进程<strong>并发</strong>地执行。</p>
</li>
<li><p>调度对层次</p>
<p>一个作业从提交开始直到完成，要经历以下三级调度，如下图所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911135226560.png" alt="image-20230911135226560"></p>
<ul>
<li><p>高级调度（作业调度）</p>
<p>内存空间有限时，无法将用户提交的作业全部放入内存，需要按一定的原则从外存的作业 后备队列 中挑选一个作业调入内存，并创建进程。</p>
<p>每个作业只调入一次，调出一次。作业调入时会建立PCB，调出时才撤销PCB。</p>
<blockquote>
<p>作业：一个具体的任务</p>
</blockquote>
<p>多道批处理系统中大多配有作业调度，而其他系统中通常不需要配置作业调度。</p>
<ul>
<li>发生频率最低 外存→内存（面向作业）</li>
</ul>
</li>
<li><p>中级调度（内存调度）</p>
<p>内存不够时，可将某些进程的数据调出外存。等内存空闲或者进程需要运行时，按照某种策略从 挂起队列 中选择合适的进程重新调入内存。</p>
<blockquote>
<p>暂时调到外存等待的进程状态为挂起状态。被挂起的进程PCB会被组织成挂起队列。</p>
</blockquote>
<ul>
<li>外存→内存（面向进程）</li>
</ul>
</li>
<li><p>低级调度（进程调度）</p>
<p>在内存中的按照某种策略从 就绪队列 中选取一个进程，将处理机分配给它。</p>
<ul>
<li>发生频率高 内存→CPU</li>
</ul>
</li>
</ul>
</li>
<li><p>三级调度的联系</p>
<ul>
<li><p>七状态模型</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911141922080.png" alt="image-20230911141922080"></p>
<p><strong>挂起和阻塞的区别：</strong> 两种状态都不获得 CPU 服务，但挂起状态将进程调到外存，而阻塞态还在内存中。</p>
</li>
<li><p>三层调度对比</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">要做什么</th>
<th align="center">在哪调度</th>
<th align="center">发生频率</th>
<th align="center">对进程状态影响</th>
</tr>
</thead>
<tbody><tr>
<td align="center">高级调度 （作业调度）</td>
<td align="center">从后备队列中选择合适的作业 将其调入内存，并为其创建进程</td>
<td align="center">外存→内存 (面向作业)</td>
<td align="center">最低</td>
<td align="center">无→创建态→就绪态</td>
</tr>
<tr>
<td align="center">中级调度 （内存调度）</td>
<td align="center">从挂起队列中选择合适的进程 将其数据调回内存</td>
<td align="center">外存→内存 （面向进程）</td>
<td align="center">中等</td>
<td align="center">挂起态→就绪态 阻塞挂起→阻塞态</td>
</tr>
<tr>
<td align="center">低级调度 （进程调度）</td>
<td align="center">从就绪队列中选择一个进程 为其分配处理机</td>
<td align="center">内存→CPU</td>
<td align="center">最高</td>
<td align="center">就绪态→运行态</td>
</tr>
</tbody></table>
</li>
<li><p>三层调度联系</p>
<ul>
<li>1）作业调度为进程活动做准备，进程调度使进程正常活动起来。</li>
<li>2）中级调度将暂时不能运行的进程挂起，中级调度处于作业调度和进程调度之间。</li>
<li>3）作业调度次数少，中级调度次数略多，进程调度频率最高。</li>
<li>4）进程调度是最基本的，不可或缺。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="2-2-2-调度的目标"><a href="#2-2-2-调度的目标" class="headerlink" title="2.2.2 调度的目标"></a>2.2.2 调度的目标</h4><p> 不同的调度算法具有不同的特性，在选择调度算法时，必须考虑算法的特性。评价标准如下。</p>
<ol>
<li><p><strong>CPU利用率</strong>：指CPU“忙碌”的时间占总时间的比例。<br>$$<br>利用率&#x3D;\frac{忙碌的时间}{总时间}<br>$$</p>
</li>
<li><p><strong>系统吞吐率</strong>：单位时间内完成作业的数量。<br>$$<br>系统吞吐率&#x3D;\frac{总共完成了多少道作业}{总共花了多少时间}<br>$$</p>
</li>
<li><p><strong>周转时间</strong>：指从作业被提交给系统开始，到作业完成为止的这段时间间隔。<br>$$<br>周转时间&#x3D;作业完成时间-作业提交时间<br>$$<br><strong>平均周转时间</strong>：指多个作业周转时间的平均值。<br>$$<br>平均周转时间&#x3D;\frac{各个作业周转时间之和}{作业数}<br>$$<br><strong>带权周转时间</strong>：作业周转时间与作业实际运行时间的比值。带权周转时间必然≥1<br>$$<br>带权周转时间&#x3D;\frac{作业周转时间}{作业实际运行时间}&#x3D;\frac{作业完成时间-作业提交时间}{作业实际运行时间}<br>$$<br><strong>平均带权周转时间</strong>：多个作业带权周转时间的平均值。<br>$$<br>平均带权周转时间&#x3D;\frac{各个作业带权周转时间之和}{作业数}<br>$$</p>
</li>
<li><p><strong>等待时间</strong></p>
<p>等待时间，指进程&#x2F;作业处于等待处理机状态时间之和，等待时间越长，用户满意度越低。<br>$$<br>等待时间&#x3D;周转时间-运行时间<br>$$</p>
<ul>
<li>对于进程来说，等待时间就是指进程建立后等待被服务的时间之和。</li>
<li>对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间。</li>
</ul>
<p><strong>平均等待时间</strong>：各个进程&#x2F;作业等待时间的平均值。<br>$$<br>平均等待时间&#x3D;\frac{各个进程&#x2F;作业等待时间之和}{进程&#x2F;作业数}<br>$$</p>
</li>
<li><p><strong>响应时间</strong>：从用户提交请求到首次产生响应所用的时间。</p>
</li>
</ol>
<h4 id="2-2-3-调度的实现"><a href="#2-2-3-调度的实现" class="headerlink" title="2.2.3 调度的实现"></a>2.2.3 调度的实现</h4><ol>
<li><p>调度程序（调度器）</p>
<p>用于调度和分派CPU 的组件称为调度程序，它通带由三部分组成，如图所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911150133174.png" alt="image-20230911150133174"></p>
<ul>
<li><p><strong>排队器</strong>：将系统中的所有就绪进程按照一定的策略排成一个或多个队列，以便于调度程序选择。每当有一个进程转变为就绪态时，排队器便将它插入到相应的就绪队列中。</p>
</li>
<li><p><strong>分派器</strong>：依据调度程序所选的进程，将其从就绪队列中取出，将CPU分配给新进程。</p>
</li>
<li><p>上下文切换器</p>
<p>：在对处理机进行切换时，会发生两对上下文的切换操作：</p>
<ul>
<li>第一对，将当前进程的上下文保存到其PCB中，再装入分派程序的上下文，以便分派程序运行；</li>
<li>第二对，移出分派程序的上下文，将新选进程的CPU现场信息装入处理机的各个相应寄存器。</li>
</ul>
</li>
</ul>
</li>
<li><p>调度的时机</p>
<ul>
<li>需要调度<ul>
<li>主动放弃：进程正常终止；运行过程中发生异常而终止；主动阻塞（比如等待IO）</li>
<li>被动放弃：时间片用完；有更紧急的事情处理（I&#x2F;O中断）；有更高优先级的进程进入就结队列</li>
</ul>
</li>
<li>不能调度<ul>
<li>处理中断的过程中</li>
<li>进程在操作系统内核程序临界区中</li>
<li>原子操作过程中</li>
</ul>
</li>
</ul>
<blockquote>
<p>临界资源：一个时间段内只允许一个进程使用的资源。各进程需要互斥地访问临界资源。</p>
<p>临界区：访问临界资源的那段代码。</p>
<p>内核程序临界区一般是用来访问某种内核数据结构的，比如进程的就绪队列（由各就绪进程的PCB组成）</p>
</blockquote>
</li>
<li><p>进程调度方式</p>
<ul>
<li><p><strong>非剥夺调度方式</strong></p>
<p>又称<strong>非抢占方式</strong>。即，只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。</p>
<p>实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统</p>
</li>
<li><p><strong>剥夺调度方式</strong></p>
<p>又称<strong>抢占方式</strong>。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停在执行的进程，将处理机分配给更重要紧迫的那个进程。</p>
<p>可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断）。适合于分时操作系统、实时操作系统</p>
</li>
</ul>
</li>
<li><p>进程切换</p>
<ul>
<li><p>上下文切换：切换CPU到另一个进程需要保存当前进程状态并恢复另一个进程的状态。</p>
<ul>
<li>对原来运行进程各种数据的保存</li>
<li>对新的进程各种数据的恢复（如：程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一保存在进程控制块）</li>
</ul>
<blockquote>
<p>上下文：某一时刻CPU寄存器和程序计数器的内容。</p>
</blockquote>
<p>切换流程：</p>
<ul>
<li>挂起一个进程，保存CPU上下文，包括程序计数器和其他寄存器。</li>
<li>更新PCB信息。</li>
<li>把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。</li>
<li>选择另一个进程执行，并更新其PCB。</li>
<li>跳转到新进程PCB中的程序计数器所指向的位置执行。</li>
<li>恢复处理机上下文。</li>
</ul>
</li>
<li><p>上下文切换的消耗</p>
<p>上下文切换需要消耗大量CPU时间，有些处理器有多个寄存器组，则切换只需改变指针。</p>
<blockquote>
<p>进程切换是有<strong>代价</strong>的，因此如果过于频繁的进行进程调度、切换，必然会使整个系统的效率降低，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。</p>
</blockquote>
</li>
<li><p>上下文切换与模式切换</p>
<ul>
<li>模式切换是用户态和内核态之间的切换，CPU逻辑上可能还在执行同一进程。用户进程最开始都运行在用户态，若进程因中断或异常进入核心态运行，执行完后又回到用户态刚被中断的进程运行。</li>
<li>上下文切换切换了进程，只能发生在内核态，它是多任务操作系统中的一个必需的特性。</li>
</ul>
</li>
</ul>
</li>
<li><p>闲逛进程</p>
<p>调度程序永远的备胎，没有其他就绪进程时，运行闲逛进程（idle）</p>
<p><strong>特性</strong>：</p>
<ul>
<li>优先级最低；</li>
<li>可以是0地址指令，占一个完整的指令周期（指令周期末尾例行检查中断）</li>
<li>能耗低</li>
</ul>
<blockquote>
<p>闲逛进程不需要CPU之外的资源，它不会被阻塞。</p>
</blockquote>
</li>
<li><p>两种线程的调度</p>
<ul>
<li><strong>用户级线程调度</strong>。由于内核并不知道线程的存在，所以内核还是和以前一样，选择一个进程，并给予时间控制。由进程中的调度程序决定哪个线程运行。</li>
<li><strong>内核级线程调度</strong>。内核选择一个特定线程运行，通常不用考虑该线程属于哪个进程。对被选择的线程赋予一个时间片，如果超过了时间片，就会强制挂起该线程。</li>
</ul>
<blockquote>
<p>用户级线程的线程切换在同一进程中进行，仅需少量的机器指令；</p>
<p>内核级线程的线程切换需要完整的上下文切换、修改内存映像、使高速缓存失效，这就导致了若干数量级的延迟。</p>
</blockquote>
</li>
</ol>
<h4 id="2-2-4-典型的调度算法"><a href="#2-2-4-典型的调度算法" class="headerlink" title="2.2.4 典型的调度算法"></a>2.2.4 典型的调度算法</h4><ol>
<li><p>先来先服务（FCFS）</p>
<ul>
<li>算法思想：主要从“公平”的角度考虑（类似于我们生活中排队买东西的例子）</li>
<li>算法规则：按照作业&#x2F;进程到达的先后顺序进行服务</li>
<li>用于作业&#x2F;进程调度：<ul>
<li>用于作业调度时，考虑是哪作业先达后备队列；</li>
<li>用于进程调度时，考虑的是哪个进程先到达就绪队列</li>
</ul>
</li>
<li>优缺点：<ul>
<li>优点：公平、算法实现简单</li>
<li>缺点：排在长作业（进程）后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好。即，FCFS算法对长作业有利，对作（Eg：排队。）</li>
</ul>
</li>
<li>非抢占式的算法；不会导致饥饿</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911164645302.png" alt="image-20230911164645302"></p>
</li>
<li><p>短作业优先（SJF）</p>
<ul>
<li><p>算法思想：追求最少的平均等待时间，最少的平均周转时间、最少的平均平均带权周转时间</p>
</li>
<li><p>算法规则：最短的作业&#x2F;进程优先得到服务（所谓“最短”，是指要求服务时间最短）</p>
</li>
<li><p>用于作业&#x2F;进程调度</p>
<ul>
<li>即可用于作业调度，也可用于进程调度。</li>
<li>用于进程调度时为”短进程优先”（SPF，Shortest Process First）</li>
</ul>
</li>
<li><p>优缺点</p>
<ul>
<li><p>优点：</p>
<p>“最短的”平均等待时间、平均周转时间</p>
<p>；</p>
<ul>
<li>在所有进程都几乎同时到达时，采用SJF调度算法的平均等待时间、平均周转时间最少；</li>
<li>“抢占式的短作业&#x2F;进程优先调度算法（最短剩余时间优先，SRNT算法）的平均等待时间、平均周转时间最少”</li>
</ul>
</li>
<li><p>缺点：不公平。对短作业有利，对长作业不利。可能产生饥饿现象。另外，作业进程的运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先。</p>
</li>
</ul>
</li>
<li><p>抢占式的算法；会导致饥饿</p>
<blockquote>
<p>SJF和SPF是非抢占式的算法。但是也有抢占式的版本：最剩间优先算法（SRTN，Shortest Remaining Time Next）</p>
<p>每当有进程加入就绪队列改变时就需要调度，如果新到达的进程剩余时间比当前运行的进程剩余时间更短，则由新进程抢占处理机，当前运行进程重新回到就绪队列。另外，当一个进程完成时也需要调度</p>
</blockquote>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911164811967.png" alt="image-20230911164811967"></p>
</li>
<li><p>高响应比优先（HRRN）</p>
<ul>
<li><p>算法思想：要综合考虑作业&#x2F;进程的等待时间和要求服务的时间</p>
</li>
<li><p>算法规则：在每次调度时先计算各个作业&#x2F;进程的响应比，选择响应比最高的作业&#x2F;进程为其服务<br>$$<br>响应比&#x3D;\frac{等待时间+要求服务时间}{要求服务时间}<br>$$<br><strong>高响应比优先算法</strong>：非抢占式的调度算法，只有当前运行的进程主动放CPU（常&#x2F;常成，主动阻塞），需行调度，调度时计算所有就绪进程的响应比，选响应比最高的进程上处理机。</p>
</li>
<li><p>用于作业&#x2F;进程调度：即可用于作业调度，也可用于进程调度</p>
</li>
<li><p>优缺点</p>
<ul>
<li>综合考虑了等待时间和运行时间（要求服务时间）等待时间相同时，要求服务时间短的优先（SJF的优点）；</li>
<li>要求服务时间相同时，等待时间长的优先（FCFS的优点）</li>
<li>对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿的问题</li>
</ul>
</li>
<li><p>非抢占式的算法；不会导致饥饿</p>
<blockquote>
<p>非抢占式的算法。因此只有当前运行的作业&#x2F;进程主动放弃处理机时，才需要调度，计算响应比</p>
</blockquote>
</li>
</ul>
</li>
<li><p>时间片轮转调度算法（RR）</p>
<ul>
<li><p>算法思想：公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应</p>
</li>
<li><p>算法规则：按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如100ms）。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。</p>
</li>
<li><p>用于作业&#x2F;进程调度：用于进程调度（只有作业放入内存建立了相应的进程后，才能被分配处理机时间片）</p>
</li>
<li><p>优缺点</p>
<ul>
<li>优点：公平；响应快，适用于分时操作系统；</li>
<li>缺点：由于高频率的进程切换，因此有一定开销；不区分任务的紧急程度。</li>
</ul>
</li>
<li><p>抢占式的算法；不会导致饥饿</p>
<blockquote>
<p>若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转调度算法属于抢占式的算法。由时钟装置发出时钟中断来通知CPU时间片已到</p>
</blockquote>
</li>
</ul>
</li>
<li><p>优先级调度算法</p>
<ul>
<li><p>算法思想：随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序</p>
</li>
<li><p>算法规则：每个作业&#x2F;进程有各自的优先级，调度时选择优先级最高的作业&#x2F;进程</p>
</li>
<li><p>用于作业&#x2F;进程调度：既可用于作业调度，也可用于进程调度。甚至，还会用于在之后会学习的I&#x2F;O调度中</p>
</li>
<li><p>优缺点</p>
<ul>
<li>优点：用优先级区分紧急程度、重要程度，适用于实时操作系统。可灵活地调整对各种作业&#x2F;进程的偏好程度</li>
<li>缺点：若源源不断地有高优先级进程到来，则可能导致饥饿</li>
</ul>
</li>
<li><p>抢占式&#x2F;非抢占式的算法；会导致饥饿</p>
<blockquote>
<p>抢占式、非抢占式都有。做题时的区别在于：非抢占式只需在进程主动放弃处理机时进行调度即可，而抢占式还需在就绪队列变化时，检查是否会发生抢占。</p>
</blockquote>
</li>
<li><p>优先级排序</p>
<p>系统进程优先级高于用户进程</p>
<p>前台进程优先级高于后台进程</p>
<p>操作系统更偏好I&#x2F;O型进程（或称I&#x2F;O繁忙型进程）</p>
<blockquote>
<p>注：与I&#x2F;O型进程相对的是计算型进程（或称CPU繁忙型程）</p>
</blockquote>
</li>
<li><p>优先级分类：根据优先级是否可以动态改变，可将优先级分为静态优先级和动态优先级两种。</p>
<ul>
<li>静态优先级：创建进程时确定，之后一直不变</li>
<li>动态优先级：创建进程时有一个初始值，之后会根据情况动态地调整优先级。</li>
</ul>
<blockquote>
<p>就绪队列未必只有一个，可以按照不同优先级来组织。另外，也可以把优先级高的进程排在更靠近队头的位置</p>
</blockquote>
</li>
</ul>
</li>
<li><p>多级队列调度算法</p>
<ul>
<li>系统中按进程类型设置多个队列，进程创建成功后插入某个队列</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911165310270.png" alt="image-20230911165310270"></p>
<ul>
<li><p>队列之间可采取固定优先级，或时间片划分</p>
<ul>
<li>固定优先级：高优先级空时低优先级进程才能被调度</li>
<li>时间片划分：如三个队列分配时间50%、40%、10%</li>
</ul>
</li>
<li><p>各队列可采用不同的调度策略，如</p>
<p>系统进程队列采用优先级调度、交互式队列采用RR、批处理队列采用FCFS</p>
</li>
</ul>
</li>
<li><p>多级反馈队列调度算法</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911165245192.png" alt="image-20230911165245192"></p>
<ul>
<li><p>算法思想：对其他调度算法的折中权衡</p>
</li>
<li><p>算法规则：</p>
<ul>
<li>1.设置多级就绪队列，各级队列优先级从高到低，时间片从小到大</li>
<li>2.新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级的队列，则重新放回该队列队尾</li>
<li>3.只有第k级队列为空时，才会为k+1级队头的进程分配时间片</li>
</ul>
</li>
<li><p>用于作业&#x2F;进程调度：用于进程调度</p>
</li>
<li><p>优缺点</p>
<ul>
<li>对各类型进程相对公平（FCFS的优点）；</li>
<li>每个新到达的进程都可以很快就得到响应（RR优点）；</li>
<li>短进程只用较少的时间就可完成（SPF优点）；</li>
<li>不必实现估程运时间（避用户作假）；</li>
<li>可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、IO密集型进程</li>
</ul>
<blockquote>
<p>拓展：可以将因I&#x2F;O而阻塞的进程重新放回原队列，这样I&#x2F;O型进程就可以保持较高优先级</p>
</blockquote>
</li>
<li><p>抢占式的算法；会导致饥饿</p>
<blockquote>
<p>在k级队列的进程运行过程中，若更上级的队列（1~k-1级）中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回k级队列队尾。</p>
</blockquote>
</li>
<li><p>例：</p>
</li>
<li><p>(2019年408第27题)系统采用二级反馈队列调度算法进行进程调度。就绪队列Q1采用时间片轮转调度算法，时间片为10ms；就绪队列Q2采用短进程优先调度算法，系统优先调度Q1队列中的进程，当Q1为空时系统才会调度Q2中的进程；新创建的进程首先进入Q1；Q1中的进程执行一个时间片后，若未结束，则转入Q2。若当前Q1、Q2为空，系统依次创建进程P1、P2后即开始进程调度，P1、P2需要的 CPU 时间分别为 30ms 和 20ms，则进程P1、P2在系统中的平均等待时间为( 15ms )。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/77af69c8c9764a18b2b830d201c93f26.png" alt="img"></p>
<ul>
<li>P1等待时间 &#x3D; P1周转时间 - P1运行时间 &#x3D; 50-30 &#x3D; 20ms</li>
<li>P2等待时间 &#x3D; P2周转时间 - P2运行时间 &#x3D; 30-20 &#x3D; 10ms</li>
<li>P1、P2在系统中的平均等待时间 &#x3D; (P1等待时间+P2等待时间)&#x2F;2 &#x3D; 15ms</li>
</ul>
</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">先来先服务</th>
<th align="center">短作业优先</th>
<th align="center">高响应比优先</th>
<th align="center">时间片轮转</th>
<th align="center">多级反馈队列</th>
</tr>
</thead>
<tbody><tr>
<td align="center">能否是可抢占</td>
<td align="center">否</td>
<td align="center">能</td>
<td align="center">能</td>
<td align="center">能</td>
<td align="center">队列内算法不一定</td>
</tr>
<tr>
<td align="center">能否是非抢占</td>
<td align="center">能</td>
<td align="center">能</td>
<td align="center">能</td>
<td align="center">否</td>
<td align="center">队列内算法不一定</td>
</tr>
<tr>
<td align="center">优点</td>
<td align="center">公平，实现简单</td>
<td align="center">平均等待时间最少，效率最高</td>
<td align="center">兼顾长短作业</td>
<td align="center">兼顾长短作业</td>
<td align="center">兼顾长短作业， 有较好的的响应时间， 可行性强</td>
</tr>
<tr>
<td align="center">缺点</td>
<td align="center">不利于短作业</td>
<td align="center">长作业会饥饿， 估计时间不易确定</td>
<td align="center">计算响应比的开销大</td>
<td align="center">平均等待时间较长， 上下文切换浪费时间</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">适用于</td>
<td align="center">无</td>
<td align="center">作业调度， 批处理系统</td>
<td align="center">无</td>
<td align="center">分时系统</td>
<td align="center">相当通用</td>
</tr>
<tr>
<td align="center">默认决策模式</td>
<td align="center">非抢占</td>
<td align="center">非抢占</td>
<td align="center">非抢占</td>
<td align="center">抢占</td>
<td align="center">抢占</td>
</tr>
</tbody></table>
<h3 id="2-3-同步与互斥"><a href="#2-3-同步与互斥" class="headerlink" title="2.3 同步与互斥"></a>2.3 同步与互斥</h3><h4 id="2-3-1-同步与互斥的基本概念"><a href="#2-3-1-同步与互斥的基本概念" class="headerlink" title="2.3.1 同步与互斥的基本概念"></a>2.3.1 同步与互斥的基本概念</h4><ol>
<li><p>临界资源：一次仅允许一个进程使用的资源</p>
<ul>
<li><p>类型：物理设备，如打印机等；可被进程共享的许多变量、数据等</p>
</li>
<li><p>临界区：访问临界资源的那段代码。</p>
<p>为了保证临界资源的正确使用，可把临界资源的访问过程分成4个部分：</p>
<ul>
<li>1）进入区。为了进入临界区使用临界资源，在进入区要检查可否进入临界区，若能进入临界区，则应设置正在访问临界区的标志，以阻止其他进程同时进入临界区。</li>
<li>2）临界区。进程中访问临界资源的那段代码，又称临界段。</li>
<li>3）退出区。将正在访问临界区的标志清除。</li>
<li>4）剩余区。代码中的其余部分。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    entry section;			<span class="comment">//进入区</span></span><br><span class="line">    critical section;		<span class="comment">//临界区</span></span><br><span class="line">    <span class="built_in">exit</span> section;			<span class="comment">//退出区</span></span><br><span class="line">    remainder section;		<span class="comment">//剩余区</span></span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>同步</p>
<ul>
<li>同步亦称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。</li>
<li>读进程和写进程并发地运行，由于并发必然导致异步性，因此“写数据”和“读数据”两个操作执行的先后顺序是不确定的。而实际应用中，又必须按照“写数据→读数据”的顺序来执行的。</li>
</ul>
<p>如何解决这种异步问题，就是“进程同步”所讨论的内容。</p>
</li>
<li><p>互斥</p>
<p> 互斥也称间接制约关系。当一个进程进入临界区使用临界资源，另一进程必须等待当占用临界资源的进程退出临界区后，另一进程才能访问此临界资源。</p>
<p>遵循原则：</p>
<ul>
<li><strong>空闲让进</strong>。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区；</li>
<li><strong>忙则等待</strong>。当已有进程进入临界区时，其他图进入临界区进必须等待</li>
<li><strong>有限等待</strong>。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）</li>
<li><strong>让权等待</strong>。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。</li>
</ul>
</li>
</ol>
<h4 id="2-3-2-实现临界区互斥的基本方法"><a href="#2-3-2-实现临界区互斥的基本方法" class="headerlink" title="2.3.2 实现临界区互斥的基本方法"></a>2.3.2 实现临界区互斥的基本方法</h4><p><strong>软件实现方法</strong></p>
<ol>
<li><p>单标志法（违背“空闲让进”原则）</p>
<p>两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程。也就是说每个进程进入临界区的权限只能被另一个进程赋予。</p>
<p>该算法设置一个公用整型变量turn，用于指示被允许进入临界区的进程编号。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911175422618.png" alt="image-20230911175422618"></p>
<p>若某个进程不再进入临界区，则另一个 进程也将无法进入临界区（违背”空闲让进”）。</p>
</li>
<li><p>双标志法先检查（违背“忙则等待”原则）</p>
<p>在每一个进程访问临界区资源之前，先查看一下临界区资源是否正被访问，若正被访问，该进程需等待：否则，进程才进入自己自己的临界区。</p>
<blockquote>
<p>设置一个布尔型数组flag[ ]，数组中各个元素用来标记各进程想进入临界区的意愿，比如“flag[0]&#x3D;ture”意味着0号进程P0现在想要进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志flag设为true，之后开始访问临界区。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911175704256.png" alt="image-20230911175704256"></p>
<ul>
<li>优点：不用交替进入，可连续使用</li>
<li>缺点：按序列①⑤②⑥执行时，会同时进入临界区（违背“忙则等待”），Pi进程和Pj进程可能同时进入临界区；检查和修改操作不能一次进行。</li>
</ul>
</li>
<li><p>双标志法后检查</p>
<p>双标志先检查法的改版。前一个算法的问题是先“检查”后“上锁”，但是这两个操作又无法一气呵成，因此导致了两个进程同时进入临界区的问题。因此，人们又想到先“上锁”后“检查”的方法，来避免上述问题。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230912090727614.png" alt="image-20230912090727614"></p>
<ul>
<li>缺点：当两个进程几乎同时都想进入临界区时，它们分别将自己的标志值设置为TRUE，并且同时检测对方的状态，发现对方也要进入临界区，于是双方互相谦让，结果谁也进不了临界区，从而导致“饥饿”现象。违背了“空闲让进”和“有限等待”产生饥饿</li>
</ul>
</li>
<li><p>Peterson算法</p>
<p>结合双标志法、单标志法的思想。如果双方都争着想进入临界区，那可以让进程尝试“孔融让梨”（谦让）。做一个有礼貌的进程。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230912091559736.png" alt="image-20230912091559736"></p>
<ul>
<li>为了防止两个进程为进入临界区而无限期等待，又设置了变量turn，每个进程在先设置自己的标志后再设置turn标志。这时，再同时检测另一个进程状态标志和允许进入标志，以便保证两个进程同时要求进入临界区时，只允许一个进程进入临界区。</li>
<li>进程在进入区要做的步骤： ① 主动争取 ② 主动谦让 ③ 检查对方是否也想使用，且最后一次是不是自己说了客气话</li>
<li><strong>存在问题</strong>：Peterson 算法用软件方法解决了进程互斥问题， 遵循 “空闲让进”、“忙则等待”、“有限等待” 三个原则，但是依然 未遵循 “让权等待” 的原则。</li>
</ul>
</li>
<li><p>软件方法总结</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">单标志法</th>
<th align="center">双标志先检查</th>
<th align="center">双标志后检查</th>
<th align="center">Peterson 算法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">算法</td>
<td align="center">在进入区只做“检查”，不”上锁“ 在退出区把临界区的使用权转交给另一个进程 (相当于在退出区既给另一进程”解锁”，又给自己”上锁”）</td>
<td align="center">在进入区先”检查”后”上锁”，退出区”解锁“</td>
<td align="center">在进入区先”加锁”后”检查”，退出区”解锁”</td>
<td align="center">在进入区”主动争取一主动谦让一检查对方是否想进、已方是否谦让“</td>
</tr>
<tr>
<td align="center">问题</td>
<td align="center">不遵循”空闲让进”</td>
<td align="center">不遵循”忙则等待”</td>
<td align="center">不遵循”空闲让进、有限等待”，可能导致”饥饿”</td>
<td align="center">不遵循”让权等待”，会发生”忙等”</td>
</tr>
</tbody></table>
</li>
</ol>
<p><strong>硬件实现方法</strong></p>
<ol>
<li><p>中断屏蔽方法</p>
<p>当一个进程正在使用处理机执行它的临界区代码时，要防止其他进程再进入其临界区访问的最简单的方法是：禁止一切中断发生，或称之为屏蔽中断、关中断。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">关中断;</span><br><span class="line">临界区;</span><br><span class="line">开中断;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>优点</strong>：简单、高效</li>
<li><strong>缺点</strong>：不适用于多处理机；只适用于操作系统内核进程，不适用于用户进程（因为开&#x2F;关中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险）</li>
</ul>
</li>
<li><p>硬件指令法</p>
<ul>
<li><p><strong>TestAndSet指令</strong></p>
<p>简称TS指令，也有地方称为TestAndSetLock指令，或TSL指令TSL指令是用硬件实现的。TS是原子操作，执行的过程不允许被中断，只能一气呵成。以下是用C语言描述的逻辑。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/60e50d9e651143749a7b7cb181c5be6e.png" alt="img"></p>
<p>相比软件实现方法，TSL 指令把 上锁和检查操作 用硬件的方式变成了一气呵成的 原子操作 。</p>
<ul>
<li><strong>优点：</strong> 实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞。适用于多处理机环境。</li>
<li><strong>缺点：</strong> 不满足 “让权等待” 原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致 忙等。</li>
</ul>
</li>
<li><p><strong>Swap指令</strong></p>
<p>有的地方也叫Exchange指令，或简称XCHG指令。Swp指令是用硬件实现的，是原子操作，执行的过程不允许被中断，只能一气呵成。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/cb2807d1e20b4e40811a04bd8b394e0c.png" alt="img"></p>
</li>
</ul>
<blockquote>
<p>逻辑上来看 Swap 和 TSL 并无太大区别，都是先记录下此时临界区是否已经被上锁（记录在 old 变量上），再将上锁标记 lock 设置为 true，最后检查 old，如果 old 为 false 则说明之前没有别的进程对临界区上锁，则可跳出循环，进入临界区。Swap 指令优点缺点和TSL指令相同。</p>
</blockquote>
<ul>
<li>硬件方法的优点<ul>
<li>适用于任意数目的进程，不管是单处理机还是多处理机；简单、容易验证其正确性。</li>
<li>可以支持进程内有多个临界区，只需为每个临界区设立一个布尔变量。</li>
</ul>
</li>
<li>硬件方法的缺点<ul>
<li>进程等待进入临界区时要耗费处理时间，不能实现让权等待。</li>
<li>从等待进程中随机选择一个进入临界区，有进程可能一直选不上，从而导致“饥饿”现象。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="2-3-3-互斥锁"><a href="#2-3-3-互斥锁" class="headerlink" title="2.3.3 互斥锁"></a>2.3.3 互斥锁</h4><p> 解决临界区最简单的工具就是互斥锁（mutex lock）。一个进程在进入临界区时获得锁；在退出临界区时释放锁。函数acquire()获得锁，而函数release()释放锁。acquire()和release()是原子操作，由硬件机制完成。</p>
<p> 每个互斥锁有一个布尔变量available，表示锁是否可用。如果锁是可用的，调用acquire()会成功，且锁不再可用。当一个进程试图获取不可用的锁时，会被阻塞，直到锁被释放。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">acquire()&#123;</span><br><span class="line">    <span class="keyword">while</span>(!available);		<span class="comment">//忙等待</span></span><br><span class="line">    avilable = <span class="literal">false</span>;		<span class="comment">//获得锁</span></span><br><span class="line">&#125;</span><br><span class="line">release()&#123;</span><br><span class="line">    available = <span class="literal">true</span>;		<span class="comment">//释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>优点：等待期间不用切换进程上下文，多处理器系统中，若上锁的时间短，则等待代价很低</li>
<li>缺点：需忙等，进程时间片用完才下处理机，违反“让权等待”；不太适用于单处理机系统，忙等的过程中不可能解锁</li>
</ul>
<h4 id="2-3-4-信号量"><a href="#2-3-4-信号量" class="headerlink" title="2.3.4 信号量"></a>2.3.4 信号量</h4><p> 信号量机制是一种功能较强的机制,可用来解决互斥与同步问题，它只能被两个标准的原语wait(S)和signal(S)访问，也可记为”P操作”和”V操作”。</p>
<p> 信号量其实就是一个变量（可以是一个整数，也可以是更复杂的记录型变量），可以用一个信号量来表示系统中某种资源的数量，比如：系统中只有一台打印机，就可以设置一个初值为1的信号量。</p>
<p> 原语是一种特殊的程序段，其执行只能一气呵成，不可被中断。原语是由关中断&#x2F;开中断指令实现的。软件解决方案的主要问题是由“进入区的各种操作无法一气呵成”，因此如果能把进入区、退出区的操作都用“原语”实现，使这些操作能“一气呵成”就能避免问题。</p>
<ol>
<li><p>整型信号量</p>
<p>用一个整数型的变量作为信号量，用来表示系统中某种资源的数量。wait(S)、signal(S)可描述为：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/05a7f28db02e4a36bb38a305d656333e.png" alt="img"></p>
<blockquote>
<p>与普通整数变量的区别：对信号量的操作只有三种，即初始化、P操作、V操作</p>
</blockquote>
<p>wait(S) 原语，“检查”和“上锁”一气呵成，避免了并发、异步导致的问题。以申请使用打印机举例：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/5f8b6961fc4046b08c5cc4f9cf72ac29.png" alt="img"></p>
<p><strong>存在的问题：</strong> 不满足 “让权等待” 原则，会发生 忙等。</p>
</li>
<li><p>记录型信号量</p>
<p>整型信号量存在“忙等”问题，因此人们又提出了“记录型信号量”，即用记录型数据结构表示的信号量。</p>
<p>除了需要用于代表资源数目的整型变量value外，再增加一个进程链表L，用于链接所有等待该资源的进程。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/9e380e703cce4e0e9b746339b92ef413.png" alt="img"></p>
<ul>
<li><p>wait：如果剩余资源数不够使用block原语使进程从运行态进入阻塞态，并把挂到信号量S的等待队列（即阻塞队列）中。</p>
</li>
<li><p>signal：释放资源后，若还有别的进程在等待这种资源，则使用wakeup原语唤醒等待队列中的一个进程，该进程从阻塞态变为就绪态。</p>
</li>
<li><p>S.value的初值表示系统中某种资源的数目。</p>
</li>
<li><p>P操作</p>
<p>：</p>
<ul>
<li>对信号量S的一次P操作意味着进程请求一个单位的该资源，因此需要执行S.value-，表示资源数减1</li>
<li>当S.value&lt;0时表示该类资源已分配完毕，因此进程应调用bock原语进行自我阻塞（当前运行的进程从运行态→阻塞态），主动放弃处理机，并插入该类资源的等待队列S.L中。</li>
<li>可见，该机制遵循了“让权等待”原则，不会出现“忙等”现象。</li>
</ul>
</li>
<li><p>V操作</p>
<p>：</p>
<ul>
<li>对信号量S的一次V操作意味进程释放一个单位的该资源，因此需要执行S.value.+，表示资源数加1，</li>
<li>若加1后仍是S.value&lt;&#x3D;0，表示依然有进程在等待该类资源，因此应调用wakeup原语唤醒等待队列中的第一个进程（被唤醒进程从阻塞态→就绪态）</li>
</ul>
</li>
</ul>
<blockquote>
<p>例：某计算机系统中有1台打印机，则可在初始化信号量 S 时将 S.value 的值设为 1，队列 S.L 设置为空。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/9ca601b23b2b4e8db55acc96c373d4a1.png" alt="img"></p>
<p>① CPU 为 P0 服务，S.value –，值为 0，P0开始使用打印机。<br>② CPU 为 P1 服务，S.value –，值为 -1，无资源执行 block 原语( wait原语 )。阻塞队列( P1 )，S.value &#x3D; -1 说明有1个进程在等待资源。<br>③ CPU 为 P2 服务，S.value –，值为 -2，无资源执行 block 原语。阻塞队列( P1→P2 )，S.value &#x3D; -2 说明有2个进程在等待资源。<br>④ CPU 为 P0 服务，S.value ++，S.value &#x3D; -1 ≤ 0，说明有进程在等待该资源。因此应调用 wakeup 原语(signal原语)唤醒等待队列中的第一个进程P1，将释放资源给 P1，P1从阻塞态变为就绪态，等待被 CPU 服务(CPU顺序执行)。阻塞队列( P2 )<br>⑤ CPU 为 P1 服务，P1 使用完打印机，S.value ++，S.value &#x3D; 0，调用 wakeup 原语唤醒 P2。阻塞队列()。<br>⑥ CPU 为 P2 服务， P2是用完打印机，S.value ++，S.value &#x3D; 1。</p>
</blockquote>
</li>
<li><p>信号量机制实现进程互斥</p>
<ul>
<li><p>伪代码如下所示：</p>
<p>设 S 为实现进程 P1、P2 互斥的信号量，由于只允许一个进程进入临界区，所以 S 的初值应设为 1。然后把临界区置于 P(S) 和 V(S) 之间，进入区之前申请资源（P操作），退出区之前释放资源（ V操作 ），即可实现两个进程对临界资源的互斥访问。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/7067be8a0612421391d204975ddda194.png" alt="img"></p>
</li>
<li><p>操作：</p>
<ul>
<li>1.分析并发进程的关键活动，划定临界区（如：对临界资源打印机的访问就应放在临界区）</li>
<li>2.设置互斥信号量mutex，初值为1</li>
<li>3.在进入区P（mutex）一一申请资源</li>
<li>4.在退出区V（mutex）一一释放资源</li>
</ul>
</li>
<li><p>注意</p>
<ul>
<li>对不同的临界资源需要设置不同的互斥信号量。</li>
<li>P、V操作必须成对出现。缺少P（mutex）就不能保证临界资源的互斥访问。缺少V（mutex）会导致资源永不被释放，等待进程永不被唤醒。</li>
</ul>
</li>
</ul>
</li>
<li><p>信号量机制实现进程同步</p>
<p>进程同步要让各并发进程按要求有序地推进。</p>
<ul>
<li><p>程序</p>
<p>保证了代码4一定是在代码2之后执行。</p>
</li>
<li><p>步骤：先V后P，后V前P</p>
<ul>
<li>1.分析什么地方需要实现“同步关系”，即必须保证“一前一后”执行的两个操作（或两句代码）</li>
<li>2.设置同步信号量S，初始为0</li>
<li>3.在“前操作”之后执行V（S）</li>
<li>4.在“后操作”之前执行P（S）</li>
</ul>
</li>
<li><p>注意</p>
<ul>
<li><strong>若先执行到V(S)操作</strong>，则S+后S&#x3D;1。之后当执行到P(S)操作时，由于S&#x3D;1，表示有可用资源，会执行S-，S的值变回0，P2进程不会执行block原语，而是继续往下执行代码4。</li>
<li><strong>若先执行到P(S)操作</strong>，由于S&#x3D;0，S-后S&#x3D;-1，表示此时没有可用资源，因此P操作中会执行bock原语，主动请求阻塞；当执行完代码2，继而执行V(S)操作，S+，使S变回0，由于此时有进程在该信号量对应的阻塞队列中，因此会在V操作中执行wakeup原语，唤醒P2进程。这样P2就可以继续执行代码4</li>
</ul>
</li>
</ul>
</li>
<li><p>信号量机制实现前驱关系</p>
<p>分析问题，画出前驱图，把每一对前驱关系都看成一个同步问题</p>
<ul>
<li><p>问题：下图是一个前驱图，其中 S1, S2, S3, … ,S6 是进程 P1, P2, P3,…, P6 中的程序段，这些程序段要求按如下前驱图所示的顺序来执行：</p>
</li>
<li><p>代码：</p>
</li>
<li><p>操作：</p>
<ul>
<li>1.要为每一对前驱关系各设置一个同步信号量</li>
<li>2.在“前操作”之后对相应的同步信号量执行V操作</li>
<li>3.在“后操作”之前对相应的同步信号量执行P操作</li>
</ul>
</li>
</ul>
</li>
<li><p>同步、互斥信号量总结</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/0cbb4aedf8ef4f60a9cb34d921efc7a0.png" alt="img"></p>
<p>注：互斥信号量初值一般为1，同步信号量的初始值要看对应资源的初始值是多少。</p>
</li>
</ol>
<h4 id="2-3-5-管程"><a href="#2-3-5-管程" class="headerlink" title="2.3.5 管程"></a>2.3.5 管程</h4><ol>
<li><p>引入管程原因</p>
<p>管程的引入让程序员写程序时不需要再关注复杂的PV操作，从而避免了传统信号量机制存在的很多问题。</p>
</li>
<li><p>定义：由一组数据及定义在这组数据之上的对这组数据的操作组成的软件模块，这组操作能初始化并改变管程中的数据和同步进程。</p>
</li>
<li><p>管程的组成</p>
<ul>
<li>局部于管程的共享数据结构说明</li>
<li>对该数据结构进行操作的一组过程（函数）</li>
<li>对局部于管程的共享数据设置初始值的语句</li>
<li>管程的名字</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">monitor Demo&#123;<span class="comment">//定义一个名称为&quot;Demo&quot;的管程</span></span><br><span class="line">    <span class="comment">//定义共享数据结构，对应系统中的某种共享资源</span></span><br><span class="line">    共享数据结构 S;</span><br><span class="line">    <span class="comment">//对共享数据结构初始化的语句</span></span><br><span class="line">    init_code()&#123;</span><br><span class="line">        S=<span class="number">5</span>;		<span class="comment">//初始资源数等于5</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//过程1：申请一个资源</span></span><br><span class="line">    take_away()&#123;</span><br><span class="line">        对共享数据结构x的一系列处理;</span><br><span class="line">        s--;		<span class="comment">//可用资源-1</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//过程2：归还一个资源</span></span><br><span class="line">    give_back()&#123;</span><br><span class="line">        对共享数据结构x的一系列处理;</span><br><span class="line">        s++;		<span class="comment">//可用资源+1</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>管程的基本特征</p>
<ul>
<li>局部于管程的数据只能被局部于管程的过程所访问</li>
<li>一个进程只有通过调用管程内的过程才能进入管程访问共享数据</li>
<li>每次仅允许一个进程在管程内执行某个内部过程</li>
</ul>
<blockquote>
<p>注：过程其实就是函数，如下面这个 People 类，People 是管程的名字，username 和 str 是局部于管程的共享数据结构，login 方法是该数据结构进行操作的过程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">People</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String username = <span class="string">&quot;admin&quot;</span>; <span class="comment">// 用户名</span></span><br><span class="line">	<span class="keyword">private</span> String str= <span class="string">&quot;123456&quot;</span>; <span class="comment">// 密码</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">login</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="string">&quot;admin&quot;</span>.<span class="built_in">equals</span>(username) &amp;&amp; <span class="string">&quot;123456&quot;</span>.<span class="built_in">equals</span>(str))&#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">&quot;登录成功！&quot;</span>);	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>条件变量</p>
<p>条件变量condition，是表示管程阻塞原因的变量。</p>
<p> 通常，一个进程被阻塞的原因可以有多个，因此在管程中设置了多个条件变量。每个条件变量保存了一个等待队列，用于记录因该条件变量而阻塞的所有进程，对条件变量只能进行两种操作，即wait和signal。</p>
<ul>
<li>x.wait：当x对应的条件不满足时，正在调用管程的进程调用x.wait将自己插入x条件的等待队列，并释放管程。此时其他进程可以使用该管程。</li>
<li>x.signal：x对应的条件发生了变化，则调用x.signal，唤醒一个因x条件而阻塞的进程。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">monitor Demo&#123;</span><br><span class="line">    共享数据结构 S;</span><br><span class="line">    condition x；					<span class="comment">//定义一个条件变量x</span></span><br><span class="line">    init_code()&#123;...&#125;</span><br><span class="line">    take_away()&#123;</span><br><span class="line">        <span class="keyword">if</span>(S&lt;<span class="number">0</span>) x.wait();			<span class="comment">//资源不够，在条件变量x上阻塞等待</span></span><br><span class="line">        资源足够，分配资源，做一系列处理；</span><br><span class="line">    &#125;</span><br><span class="line">    give_back()&#123;</span><br><span class="line">        归还资源，做一系列相应处理;</span><br><span class="line">		<span class="keyword">if</span>(有进程在等待）x.signal();	<span class="comment">//唤醒一个阻塞进程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>条件变量和信号量的比较：<ul>
<li><strong>相似点</strong>：条件变量的wait&#x2F;signal操作类似于信号量的P&#x2F;V操作，可以实现进程的阻塞&#x2F;唤醒。</li>
<li><strong>不同点</strong>：条件变量是“没有值”的，仅实现了“排队等待”功能；而信号量是“有值”的，信号量的值反映了剩余资源数，而在管程中，剩余资源数用共享数据结构记录。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="2-3-6-经典同步问题"><a href="#2-3-6-经典同步问题" class="headerlink" title="2.3.6 经典同步问题"></a>2.3.6 经典同步问题</h4><ol>
<li><p><strong>生产者-消费者问题</strong></p>
<ul>
<li><p>问题描述</p>
<p>系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用。（注：这里的“产品”理解为某种数据）</p>
<p>生产者、消费者共享一个初始为空、大小为n的缓冲区。</p>
<ul>
<li>只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待。</li>
<li>只有缓冲区不空时，消费者才能从中取出产品，否则必须等待。</li>
</ul>
<p>缓冲区是临界资源，各进程必须互斥地访问。</p>
</li>
<li><p>问题分析</p>
<ul>
<li><p>1.<strong>关系分析</strong>。找出题目中描述的各个进程，分析它们之间的同步、互斥关系。</p>
<p>同步关系：缓冲区没满，生产者生产；缓冲区没空，消费者消费。</p>
<p>互斥关系：各进程互斥访问缓冲区。</p>
</li>
<li><p>2.<strong>整理思路</strong>。根据各进程的操作流程确定P、V操作的大致顺序。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/51a89fdf9e594fb384ae212d810f97af.png" alt="img"></p>
</li>
<li><p>3.<strong>设置信号量</strong>。并根据题目条件确定信号量初值。（互斥信号量初值一般为1，同步信号量的初始值要看对应资源的初始值是多少）</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>; <span class="comment">//互斥信号量，实现对缓冲区的互斥访问</span></span><br><span class="line">semaphore empty = n; <span class="comment">//同步信号量，表示空闲缓冲区的数量</span></span><br><span class="line">semaphore full = <span class="number">0</span>;  <span class="comment">//同步信号量，表示产品的数量，也即非空缓冲区的数量</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>进程描述</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/fa5416e4f6dc4b718ab17bf8c38bd4b4.png" alt="img"></p>
</li>
<li><p>能否改变相邻P、V操作的顺序？</p>
<p>不能，会发生死锁</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/2c754dcb57824933b85650c2ff8b0bbf.png" alt="img"></p>
<p>若此时缓冲区内已经放满产品，则 empty&#x3D;0，full&#x3D;n。则生产者进程执行 ① 使mutex变为0，再执行②，由于已没有空闲缓冲区，因此生产者被阻塞。由于生产者阻塞，因此切换回消费者进程。消费者进程执行 ③，由于 mutex 为 0，即生产者还没释放对临界资源的 “锁”，因此消费者也被阻塞。生产者和消费者循环等待被对方唤醒，出现 死锁。</p>
<p> 因此 实现互斥的 P 操作一定要在实现同步的 P 操作之后。</p>
<p> V 操作不会导致进程阻塞，因此 两个 V 操作顺序可以交换。</p>
</li>
<li><p>能否只设置一个同步信号量</p>
<p>不能。原因在于：两个信号量 empty 和 full，其中 empty 用于制约生产者生产，full 用于制约消费者消费。如果只设置一个信号量，如 full，那么生产者会无限的生产，起不到制约作用。</p>
</li>
</ul>
</li>
<li><p><strong>多生产者多消费者问题</strong></p>
<ul>
<li><p>问题描述</p>
<p>桌子上有一只盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。只有盘子空时，爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。</p>
</li>
<li><p>问题分析</p>
<ul>
<li><p>1.<strong>关系分析</strong></p>
<p>同步关系：① 父亲将苹果放入盘子，女儿才能取苹果；<br>     ② 母亲将句子放入盘子，儿子才能取橘子；<br>     ③ 只有盘子为空，父亲或者母亲才能放水果。<br>互斥关系：对缓冲区(盘子)的访问要互斥的进行。</p>
</li>
<li><p>2.<strong>整理思路</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/715b4760323a46c1b97dcd79b01788e7.png" alt="img"></p>
<p>注：盘子为空这个事件可由儿子或者女儿触发，发生后父亲或母亲才可放水果。<br>分析同步要以 <strong>事件</strong> 的角度分析，不要以 <strong>进程</strong> 的角度分析。</p>
</li>
<li><p>3.<strong>信号量的设置</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;  <span class="comment">//实现互斥访问盘子（缓冲区）</span></span><br><span class="line">semaphore apple = <span class="number">0</span>;  <span class="comment">//盘子中有几个苹果</span></span><br><span class="line">semaphore orange = <span class="number">0</span>; <span class="comment">//盘子中有几个橘子</span></span><br><span class="line">semaphore plate = <span class="number">1</span>;  <span class="comment">//盘子中还可以放多少个水果</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>进程描述</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/03b5b144181941df8f7455a5350b5658.png" alt="img"></p>
</li>
<li><p>能否不用互斥信号量</p>
<p>如果缓冲区大小为1，在任何时刻，apple、orange、plate 三个信号量中最多只有一个是1。因此在任何时刻，最多只有一个进程的P操作不会被阻塞，并顺利地进入临界区。<br>  如果缓冲区大小大于1，数据可能存在相互覆盖的情况。如：父亲在向盘子放橘子的同时，母亲也可以往盘子里放橘子，有可能导致两个进程写入缓冲区的数据相互覆盖的情况。<br>  因此，当缓冲区大小等于1，有可能不设置互斥变量。当缓冲区大小大于1，必须设置互斥变量。是否不用设置互斥信号量主要观察，同一时刻信号量是否最多一个1，建议设置互斥信号量。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/3b52be6d997145738c875b31abacb69c.png" alt="img"></p>
<p>但需要注意的是，实现互斥的P操作一定要在实现同步的P操作之后，否则可能引起“死锁”。</p>
</li>
<li><p>分析</p>
<p>在分析同步问题（一前一后问题）的时候不能从单个进程行为的角度来分析，要把“一前一后”发生的事看做是两种“事件”的前后关系。</p>
<p>如果从 单个进程的角度 来考虑的话，会有以下结论：</p>
<ul>
<li>① 如果盘子里装有苹果，那么一定要女儿取走苹果后父亲或母亲才能再放入水果；</li>
<li>② 如果盘子里装有橘子，那么一定要儿子取走橘子后父亲或母亲才能再放入水果。</li>
</ul>
<p>这就意味着要 设置四个同步信号量 分别实现这 四个一前一后的关系，较为复杂。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/d17b09a31472491e98d081a335f1ef4a.png" alt="img"></p>
<p>若从 事件的角度 来考虑，我们可以把上述四对进程行为的前后关系抽象为 一对事件 的前后关系，即：盘子变空事件 → 放入水果事件。</p>
</li>
</ul>
</li>
<li><p><strong>读者-写者问题</strong></p>
<ul>
<li><p>问题描述</p>
<p>有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。因此要求：</p>
<ul>
<li>①允许多个读者可以同时对文件执行读操作</li>
<li>②只允许一个写者往文件中写信息</li>
<li>③任一写者在完成写操作之前不允许其他读者或写者工作</li>
<li>④写者执行写操作前，应让已有的读者和写者全部退出</li>
</ul>
</li>
<li><p>问题分析</p>
<ul>
<li>两类进程：写进程、读进程</li>
<li>互斥关系：写进程一写进程、写进程一读进程。读进程与读进程不存在互斥问题</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/ec6a024d98d74f21a86025ca9a930ba1.png" alt="img"></p>
</li>
<li><p>进程描述</p>
<ul>
<li><p>方案1</p>
<p>方案设置 rw 和 mutex 两个信号量。rw 信号量 用于实现 读进程与写进程、写进程与写进程 对共享文件的互斥访问。mutex 信号量 用于保证对 count 变量的互斥访问。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/a62d7354ba5944ffb4ca05e7662404f1.png" alt="img"></p>
<p>若没有设置 mutex 信号量，两个读进程并发执行到 if 条件且都满足，都会执行 P(rw)，会造成其中一个读进程阻塞的情况。设置 mutex 信号量，使得 count 信号量的检查和赋值操作一气呵成，保证了对 count 信号量访问的互斥性。</p>
<p> <strong>方案 1 存在的问题：</strong> 只要有读进程还在读，写进程就要一直阻塞等待，可能 “饿死”。因此，这种算法中，读进程是优先的。</p>
</li>
<li><p>方案2</p>
<p>方案 2 是对方案 1 问题的修正，添加了 w 信号量，保证了 读写公平 。如：假设对共享文件的访问顺序是：读者1→读者2→ 写者1 → 读者3 ，读者 2 执行完后，写者 1 将会进行写文件，读者 3 进程将会被阻塞。待写者1写完文件后，读者 3 进行读写者 1 访问后的文件。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/2b29530b97b94604b6d6bcafa84d217c.png" alt="img"></p>
<p>算法 核心思想 在于设置了一个 计数器 count 用来记录当前正在访问共享文件的读进程数。我们可以用 count 的值来判断当前进入的进程是否是第一个&#x2F;最后一个读进程，从而做出不同的处理。另外，还需考虑 count 变量的互斥性。</p>
</li>
</ul>
</li>
<li><p>结论</p>
<p> 在这种算法中，连续进入的多个读者可以同时读文件；写者和其他进程不能同时访问文件；写者不会饥饿，但也并不是真正的“写优先”，而是相对公平的先来先服务原则。</p>
<p> 有的书上把这种算法称为“读写公平法”</p>
</li>
</ul>
</li>
<li><p>哲学家进餐问题</p>
<ul>
<li><p>问题描述</p>
<p>一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭。哲学家们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时，才试图拿起左、右两根筷子（一根一根地拿起）。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。</p>
</li>
<li><p>问题分析</p>
<ul>
<li><p><strong>1.关系分析</strong></p>
<p>系统中有5个哲学家进程，5位哲学家与左右邻居对其中间筷子的访问是互斥关系。</p>
</li>
<li><p><strong>2.整理思路</strong></p>
<p>哲学家进餐问题中 只有互斥关系，但与之前遇到的问题不同点在于，每个哲学家进程需要同时持有两个临界资源才能开始吃饭。如何避免临界资源分配不当造成的死锁现象，是哲学家问题的关键。</p>
</li>
<li><p><strong>3.信号量的设置</strong></p>
<p>定义互斥信号量数组 chopstick[5]&#x3D;{1,1,1,1,1} 用于实现对 5 个筷子的互斥访问。并对哲学家按0~4编号，哲学家 i 左边的筷子编号为 i，右边的筷子编号为 (i+1)%5。此外，还需要设置 互斥信号量mutex，用以保证哲学家进程左右两支筷子都可用。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/6c94f1c773ad4e12934447c004e912c8.png" alt="img"></p>
</li>
</ul>
</li>
<li><p>进程描述</p>
<p>算法保证，一个哲学家再拿到筷子拿到一半时被阻塞，也不会有别的哲学家尝试拿筷子，即至少有一个哲学家进程不阻塞。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/0f12c4e77b7b47388efa55b690a67e02.png" alt="img"></p>
<blockquote>
<p>其他方案：<br>① 对哲学家进程施加一些限制条件，如最多允许四个哲学家同时进餐。这样可以保证至少有一个哲学家是可以拿到左右两只筷子的。<br>② 要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子，另一个会直接阻塞。这就避免了占有一支后再等待另一只的情况。</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>吸烟者问题</strong></p>
<ul>
<li><p>问题描述</p>
<p>假设一个系统有 三个抽烟者进程 和 一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一支烟，抽烟者需要有三种材料：烟草、纸和胶水。三个抽烟者中，第一个拥有烟草、第二个拥有纸、第三个拥有胶水。供应者进程无限地提供三种材料，供应者每次将两种材料放桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉完成了，供应者就会放另外两种材料在桌上，这个过程一直重复（让三个抽烟者轮流地抽烟）。</p>
</li>
<li><p>问题分析</p>
<ul>
<li><p><strong>1.关系分析</strong></p>
<p>同步关系：① 桌上有组合一，第一个抽烟者取走东西<br>     ② 桌上有组合二，第二个抽烟者取走东西<br>     ③ 桌上有组合三，第三个抽烟者取走东西<br>     ④ 抽烟者抽完发出完成信号，供应者将下一个组合放到桌上<br>互斥关系：对缓冲区的访问要互斥的进行。</p>
</li>
<li><p><strong>2.整理思路</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/a2e2be6b31ec48f6b9e4a63a7ce1cb20.png" alt="img"></p>
<blockquote>
<p>注：由于缓冲区大小为1，任意时刻同步信号量和互斥信号量最多只有一个1，因此互斥信号量可以不设置。</p>
</blockquote>
</li>
<li><p><strong>3.信号量的设置</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">semaphore offer1 = <span class="number">0</span>; <span class="comment">//桌上组合一的数量</span></span><br><span class="line">semaphore offer2 = <span class="number">0</span>; <span class="comment">//桌上组合二的数量</span></span><br><span class="line">semaphore offer3 = <span class="number">0</span>; <span class="comment">//桌上组合三的数量</span></span><br><span class="line">semaphore finish = <span class="number">0</span>; <span class="comment">//抽烟是否完成</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>; <span class="comment">//用于实现“三个抽烟者轮流抽烟”</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>进程描述</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/029d0f3880d441a5b46ae6b0db27b3ad.png" alt="img"></p>
</li>
<li><p>能否从进程角度思考？</p>
<p> 不可以。<br>    同多生产者多消费者问题，假设从进程角度思考，那么第一个抽烟者抽完后，供应者再将第一个组合放到桌上；第二个抽烟者抽完后，供应者再将第二个组合放到桌上；第三个抽烟者抽完后，供应者再将第三个组合放到桌上。这样相比于从事件考虑的一个一前一后的关系，多出了多个关系，并且较为复杂。因此要从事件的角度思考 PV 关系。</p>
</li>
</ul>
</li>
</ol>
<h3 id="2-4-死锁"><a href="#2-4-死锁" class="headerlink" title="2.4 死锁"></a>2.4 死锁</h3><h4 id="2-4-1-死锁的概念"><a href="#2-4-1-死锁的概念" class="headerlink" title="2.4.1 死锁的概念"></a>2.4.1 死锁的概念</h4><ol>
<li><p>死锁的定义</p>
<p> 在并发环境下，各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进的现象，就是“死锁”。发生死锁后若无外力干涉这些进程都将无法向前推进。</p>
</li>
<li><p>死锁、饥饿、死循环的区别</p>
<ul>
<li><p>共同点：都是进程无法顺利向前推进的现象（故意设计的死循环除外)</p>
</li>
<li><p>区别：</p>
<ul>
<li><p><strong>死锁</strong>：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。两个以上程序</p>
</li>
<li><p><strong>饥饿</strong>：由于长期得不到想要的资源，某进程无法向前推进的现象。单个程序</p>
<p>比如：在短进程优先（SPF）算法中，若有源源不断的短进程到来，则长进程将一直得不到处理机，从而发生长进程“饥饿”</p>
</li>
<li><p><strong>死循环</strong>：某进程执行过程中一直跳不出某个循环的现象。</p>
<p>有时是因为程序逻辑bug导致的，有时是程序员故意设计的。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>死锁产生原因</p>
<ul>
<li><p><strong>对系统资源的竞争</strong></p>
<p>各进程对不可剥夺的资源（如打印机）的竞争可能引起死锁，对可剥夺的资源（CPU）的竞争是不会引起死锁的。</p>
</li>
<li><p><strong>进程推进顺序非法</strong></p>
<p>请求和释放资源的顺序不当，也同样会导致死锁。例如，并发执行的进程P1、P2分别申请并占有了资源R1、R2，之后进程P1又紧接着申请资源R2，而进程P2又申请资源R1，两者会因为申请的资源被对方占有而阻塞，从而发生死锁。</p>
</li>
<li><p><strong>信号量的使用不当也会造成死锁</strong></p>
<p>如生产者-消费者问题中，如果实现互斥的P操柞在实现同步的P操作之前，就有可能导致死锁。（可以把互斥信号量、同步信号量也看做是一种抽象的系统资源）</p>
</li>
</ul>
</li>
<li><p>死锁产出的必要条件</p>
<p>产生死锁 必须同时满足以下四个条件，只要其中任一条件不成立，死锁就不会发生。</p>
<ul>
<li>① 互斥条件：只有对必须 互斥使用的资源的争抢 才会导致死锁（如哲学家的筷子、打印机设备）。像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的（因为进程不用阻塞等待这种资源）。</li>
<li>② 不剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。</li>
<li>③ 请求和保持条件：进程已经 保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。</li>
<li>④ 循环等待条件：存在一种进程资源的 循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。</li>
</ul>
<p>注：发生死锁时一定有循环等待，但是发生循环等待时未必死锁，即 循环等待是死锁的必要不充分条件。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/8d5f352afa3940b1a3e13deab4bd1e7f.png" alt="img"></p>
<p>如果同类资源数大于1，则即使有循环等待，也未必发生死锁（如上图 Pn 可以同时请求 P1 或者 Pk 的资源，得到 Pk 资源后，不会发生死锁）。 但如果系统中每类资源都只有一个，那循环等待就是死锁的充分必要条件了。</p>
</li>
<li><p>死锁处理策略</p>
<ul>
<li><strong>死锁预防</strong>。设置某些限制条件，破坏产生死锁的4个必要条件中的一个或几个。</li>
<li><strong>避免死锁</strong>。在资源的动态分配过程中，用某种方法防止系统进入不安全状态。</li>
<li><strong>死锁的检测及解除</strong>。无须采取任何限制性措施，允许进程在运行过程中发生死锁。通过系统的检测机构及时地检测出死锁的发生，然后采取某种措施解除死锁。</li>
</ul>
<p>死锁的几种处理策略的比较见下表。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">资源分配策略</th>
<th align="center">各种可能模式</th>
<th align="center">主要优点</th>
<th align="center">主要缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">死锁预防</td>
<td align="center">保守，宁可资源闲置</td>
<td align="center">一次请求所有资源，资源剥夺，资源按序分配</td>
<td align="center">适用于突发式处理的进程，不必进行剥夺</td>
<td align="center">效率低，进程初始化时间延长；剥夺次数过多；不便灵活申请新资源</td>
</tr>
<tr>
<td align="center">死锁避免</td>
<td align="center">是“预防”和“检测”的折中（在运行时判断是否可能死锁）</td>
<td align="center">寻找可能的安全允许顺序</td>
<td align="center">不必进行剥夺</td>
<td align="center">必须知道将来的资源需求；进程不能被长时间阻塞</td>
</tr>
<tr>
<td align="center">死锁检测</td>
<td align="center">宽松，只要允许就分配资源</td>
<td align="center">定期检查死锁是否已经发生</td>
<td align="center">不延长进程初始化时间，允许对死锁进行现场处理</td>
<td align="center">通过剥夺解除死锁，造成损失</td>
</tr>
</tbody></table>
</li>
</ol>
<h4 id="2-4-2-死锁预防"><a href="#2-4-2-死锁预防" class="headerlink" title="2.4.2 死锁预防"></a>2.4.2 死锁预防</h4><p>死锁的产生必须满足四个必要条件，只要其中一个或者几个条件不满足，死锁不会发生。</p>
<ol>
<li><p><strong>破坏互斥条件</strong></p>
<p>把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。如: SPOOLing技术。使用 SPOOLing 技术可以把 独占设备在逻辑上改造成共享设备。比如，用SPOOLing技术将打印机改造为共享设备…</p>
</li>
<li><p><strong>破坏不剥夺条件</strong></p>
<ul>
<li>提供两种方案：<ul>
<li>① 申请资源得不到时，主动释放所占有资源。</li>
<li>② 申请资源被其他进程占用时，由 OS 协助剥夺。</li>
</ul>
</li>
<li><strong>策略的缺点：</strong><ul>
<li>实现起来比较复杂；</li>
<li>释放已获得的资源可能造成前一阶段工作的失效，因此这种方法一般只适用于易保存和恢复状态的资源，如CPU；</li>
<li>反复地申请和释放资源会增加系统开销，降低系统吞吐量；</li>
<li>方案 ① 可能导致进程饥饿。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>破坏请求和保持条件</strong></p>
<p>采用 静态分配方法，即进程 在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行。一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源了。</p>
<p><strong>策略的缺点：</strong> 进程在整个运行期间都一直保持着所有资源，就会造成严重的资源浪费，资源利用率极低。另外，该策略也有 可能导致某些进程饥饿。</p>
</li>
<li><p><strong>破坏循环等待条件</strong></p>
<p>采用 顺序资源分配法。首先给系统中的资源编号，要求进程只能按编号递增顺序请求资源。</p>
<p><strong>原理分析</strong>： 一个进程只有已占有小编号的资源时，才有资格申请更大编号的资源。按此规则，已持有大编号资源的进程不可能逆向地回来申请小编号的资源，从而就不会产生循环等待的现象(类比拓扑排序)。</p>
<p><strong>策略的缺点</strong>： 不方便增加新的设备，因为可能需要重新分配所有的编号；进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源浪费；必须按规定次序申请资源，用户编程麻烦。</p>
</li>
</ol>
<h4 id="2-4-3-死锁避免"><a href="#2-4-3-死锁避免" class="headerlink" title="2.4.3 死锁避免"></a>2.4.3 死锁避免</h4><p> 死锁的避免是在资源动态分配过程中，防止系统进入不安全状态，以避免发生死锁。</p>
<ol>
<li><p>系统安全状态</p>
<ul>
<li>安全序列：是指如果系统按照这种序列分配资源，则每个进程都能顺利完成。</li>
<li>安全状态：系统如果存在安全序列，则处于<strong>安全状态</strong>，安全状态一定不发生死锁。安全序列可能有多个。</li>
<li>不安全状态：如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了<strong>不安全状态</strong>。可能发生死锁（处于不安全状态未必就是发生了死锁，但发生死锁时一定是在不安全状态）</li>
</ul>
<blockquote>
<p><strong>安全序列的计算方法：</strong></p>
<p>已知现有三个进程的资源分配表如下(可用代表系统还剩有 3 个资源)，现假设可用资源每次分配都是全部分配，并且分配给进程的资源总数应满足进程最多还需求的资源数目(如：可用资源有 3 个，由于 P2 进程还需要 2 个资源，因此只能满足 P2)，分配完后回收该进程所拥有的全部资源。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/a8fd403d874141cfbece5486934dc73a.png" alt="img"></p>
<p>计算步骤如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/9241e0fb8dfa413d807a6f11194279f0.png" alt="img"></p>
<p>因此得到安全序列是 {P2, P1, P3}。</p>
<hr>
<p>如果计算到 P3 时，可用资源无法满足 P3 的最大需求，即还需要的资源数目多于可用资源数目，那么就不存在安全序列。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/a1fbffe7bdad4cc99de2dd8f1d28e8f4.png" alt="img"></p>
<p>注：死锁状态一定是不安全状态，不安全状态不一定是死锁状态，即：死锁状态 ⇒ 不安全状态。</p>
<p>如：A 进程需 10 个资源，而可用资源有 5 个。若 A 还未提出申请，则不会进入死锁状态。</p>
<p>系统进入不安全状态后，便可能进入死锁状态；反之，只要系统处于安全状态，系统变可避免进入死锁。</p>
</blockquote>
</li>
<li><p>银行家算法</p>
<p><strong>核心思想：</strong> 在分配资源前，预先判断这次分配是否会导致系统进入不安全状态，以此来决定是否答应资源分配请求，从而使得系统避免死锁。</p>
<ul>
<li><p><strong>数据结构描述：</strong></p>
<ul>
<li>①可利用资源向量$Available$（一维数据）</li>
<li>②最大需求矩阵$Max$</li>
<li>③分配矩阵$Allocation$</li>
<li>④需求矩阵$Need$</li>
</ul>
<p>其中，$Need&#x3D;Max-Allocation$</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/c49ba6619b9b4d5aa0a933ee740b8493.png" alt="img"></p>
<p>注：$Available(A,B,C)&#x3D;(3,3,2)$代表可用的 A 类资源数目有 3 个，B 类资源数目有3个，C 类资源数目有 2 个。</p>
</li>
<li><p><strong>银行家算法描述</strong></p>
<p>设$Request_i$是进程Pi的请求向量，$Request_i[j]&#x3D;K$表示进程$Pi$需要$j$类资源$K$个。</p>
<ul>
<li><p>①若$Request_i[j]≤Need[i，j]$，检查此次申请是否超过最多还需求数。</p>
</li>
<li><p>②若$Request_i[j]≤Available[j]$，检查系统的可用资源是否还能满足此次需求。</p>
</li>
<li><p>③系统试探着把资源分配给$Pi$，并修改下面数据结构的数值：</p>
<p>$Available&#x3D;Available-Request_i$，修改i进程剩余可用资源数</p>
<p>$Allocation[i，j]&#x3D;Allocation[i，j]+Request_i[j]$，i进程已分配资源数加上本次请求资源数</p>
<p>$Need[i，j]&#x3D;Need[i，j]-Request_i[j]$，i进程还需的资源数减去本次请求的资源数</p>
</li>
<li><p>④执行安全性算法，检查系统是否处于安全状态，即检查当前系统是否存在安全序列。</p>
</li>
</ul>
<p>若系统安全，才正式将资源分配给$Pi$；否则此次试探分配作废，恢复原来分配状态。</p>
<p>注：安全性算法是银行家算法的核心。</p>
</li>
<li><p><strong>安全性算法描述</strong></p>
<p>设置工作向量$Work$，表示系统中剩余可用资源数目。算法执行开始时，$Work&#x3D;Available$</p>
<ul>
<li>①初始时安全序列为空。</li>
<li>②检查当前的剩余资源是否能满足某个进程的最大需求。如果可以就将它加入安全序列；若找不到执行步骤④</li>
<li>③把该进程持有资源全部回收，返回步骤②</li>
<li>④若此时安全序列中已有所有进程，则系统处于安全状态，否则处于不安全状态。</li>
</ul>
</li>
<li><p>例题</p>
<p>假设当前系统中资源分配和剩余情况如下表所示，现$P1$发出请求向量$Request_1(1，0，2)$，判断此次请求是否分配成功。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/c49ba6619b9b4d5aa0a933ee740b8493.png" alt="img"></p>
<ul>
<li><p>① 系统按银行家算法进行检查：</p>
<p>$Request_1(1,0,2)≤Need_1(1,2,2)$，$Request_1(1,0,2)≤Available(3,2,2)$</p>
<p>此次申请未超过$P1$进程最多还需求数,并且当前可用资源数可满足此次申请,则可试探的为$P1$分配资源,并修改:</p>
<p>$Available&#x3D;Available-Request_1&#x3D;(2,3,0)$<br>$Allocation_1&#x3D;Allocation_1+Request_1&#x3D;(3,0,2)$<br>$Need_1&#x3D;Need_1-Request_1&#x3D;(0,2,0)$</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/8fe6c5cad74c4e598da0d01b2a5f4054.png" alt="img"></p>
</li>
<li><p>② 系统执行安全性算法检查安全状态：</p>
<p>令$Work&#x3D;Available&#x3D;(2,3,0)$，执行安全性算法，如下表所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/9bab9019c27e4561adcb1d022b605be9.png" alt="img"></p>
<p>由安全性检查而知，可以找到一个安全序列 { P1, P3, P4, P0, P2 }，因此系统是安全的，可以将P1所申请的资源分配给他。</p>
</li>
</ul>
<p><strong>王道书解法</strong>：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230913154241862.png" alt="image-20230913154241862"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230913154306033.png" alt="image-20230913154306033"></p>
</li>
</ul>
</li>
</ol>
<h4 id="2-4-4-死锁检测和解除"><a href="#2-4-4-死锁检测和解除" class="headerlink" title="2.4.4 死锁检测和解除"></a>2.4.4 死锁检测和解除</h4><p> 如果系统既不采取预防死锁的措施，也不采取避免死锁的措施，系统就很可能发生死锁。在这种情况下，系统应当提供死锁检测和解除的手段。</p>
<ol>
<li><p>资源分配图</p>
<p>系统死锁可利用 资源分配图 来描述。圆代表一个进程，框代表一类资源，框中一个圆代表一类资源中的一个资源。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/ad8c5ea4cdbd48d99508aeb1f00065a8.png" alt="img"></p>
<ul>
<li>两种结点：<ul>
<li>进程结点：对应一个进程</li>
<li>资源结点：对应一类资源，一类资源可能有多个</li>
</ul>
</li>
<li>两种边：<ul>
<li>请求边：表示进程想申请几个资源（每条边代表一个）</li>
<li>分配边：表示已经为进程分配了几个资源（每条边代表一个）</li>
</ul>
</li>
</ul>
</li>
<li><p>死锁定理</p>
<p>简化资源分配图可检测系统状态是否为死锁状态。简化方法如下：</p>
<p>① 在资源分配图中，找出 既不阻塞又不是孤点的进程 Pi。</p>
<ul>
<li>不阻塞：表示进程申请的资源可以被满足，如 P1 进程。由于 R2 资源除分配给 P2 进程一个资源外，还剩有一个资源，因此 P1 进程申请的 R2 资源可以被满足。相反，P2 进程申请 R1 资源则不会被满足，由于 R1 资源全部被分配完。</li>
<li>不是孤点：表示与该进程节点至少一个边相连。</li>
</ul>
<p>② 消去进程所有的请求边和分配边，使之成为孤点。</p>
<p>重复以上步骤，若能消去图中所有的边，则称该图是可完全简化的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/cda1e353f29f4499baeed8c070096631.png" alt="img"></p>
<p>注：并不是系统中所有的进程都是死锁状态，用死锁检测算法 化简资源分配图后，还连着边的那些进程就是死锁进程。</p>
<p>死锁定理：如果某时刻系统的资源分配图是不可完全简化的，那么此时系统死锁</p>
</li>
<li><p>死锁解除</p>
<p>一旦检测出死锁的发生，就应该立即解除死锁。解除死锁的主要方法有：</p>
<ul>
<li><p>资源剥夺法</p>
<p>挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是 应防止被挂起的进程长时间得不到资源而饥饿。</p>
</li>
<li><p>撤销进程法（或称终止进程法）</p>
<p>强制撤销部分甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，已经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来。撤销的原则可以按进程优先级和撤销进程代价的高低进行。</p>
</li>
<li><p>进程回退法</p>
<p>让一个或多个死锁进程回退到足以避免死锁的地步。进程回退时，自愿释放资源而非剥夺。这就要求系统要记录进程的历史信息，设置还原点。</p>
</li>
</ul>
<blockquote>
<p>注：撤销进程法中参考的优先级，应考虑：进程优先级、已执行多长时间、还要多久能完成、进程已经使用了多少资源、进程是交互式的还是批处理式的等因素。</p>
</blockquote>
</li>
</ol>
<h2 id="3-内存管理"><a href="#3-内存管理" class="headerlink" title="3 内存管理"></a>3 内存管理</h2><h3 id="3-1-内存管理概念"><a href="#3-1-内存管理概念" class="headerlink" title="3.1 内存管理概念"></a>3.1 内存管理概念</h3><h4 id="3-1-1-内存管理的基本原理和要求"><a href="#3-1-1-内存管理的基本原理和要求" class="headerlink" title="3.1.1 内存管理的基本原理和要求"></a>3.1.1 内存管理的基本原理和要求</h4><ol>
<li><p>内存管理的概念</p>
<p> 虽然计算机技术飞速发展，内存容量也在不断扩大，但仍然不可能将所有用户进程和系统所需的全部程序与数据放入内存，因此操作系统对内存空间进行合理的划分和有效的动态分配。操作系统对内存的划分和动态分配，就是内存管理的概念。</p>
<p>内存空间的主要功能有：</p>
<ul>
<li>① <strong>内存空间的分配与回收</strong>：OS 要怎么记录哪些内存区域已经被分配出去了，哪些又还空闲；当进程运行结束之后，如何将进程占用的内存空间回收。</li>
<li>② <strong>内存空间的扩充</strong>：OS 利用虚拟内存技术或自动覆盖技术使得系统运行很大的程序，从逻辑上扩充内存。</li>
<li>③ <strong>地址转换</strong>：为了使编程更方便，程序员写程序时应该只需要关注指令、数据的逻辑地址。而 逻辑地址到物理地址的转换（这个过程称为地址重定位）应该由操作系统负责，其中地址重定位有三种方式。</li>
<li>④ <strong>内存保护</strong>：保证各进程在各自存储空间内运行，互不干扰。</li>
</ul>
</li>
<li><p>程序执行过程</p>
<p> 创建进程首先要将程序和数据装入内存。将用户源程序变为可在内存中执行的程序，通常需要以下几个步骤：</p>
<ul>
<li><strong>编译</strong>：由编译程序将用户源代码编译成若干目标模块，编译就是把高级语言翻译为机器语言。</li>
<li><strong>链接</strong>：由链接程序将编译后形成的一组目标模块及它们所需的库函数链接在一起，形成一个完整的装入模块。</li>
<li><strong>装入</strong>：由装入程序将装入模块装入内存运行。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/eee4ab27320e4dd5a28a1cd12d9e01a6.png" alt="img"></p>
<blockquote>
<p> 编译后，每个目标模块都是从 0 号单元开始编址，这称为该目标模块的 逻辑地址 (或相对地址)。当链接程序将各个模块连接成一个完整的可执行目标程序时，链接程序顺序依次按各个模块的相对地址构成统一的从 0 号单元开始编制的 逻辑地址空间。用户程序和程序员只需知道逻辑地址，而内存管理的具体机制则是完全透明的，只有系统编程人员才会涉及内存管理的具体机制。不同进程可以有相同的逻辑地址，因为这些相同的逻辑地址可以映射到内存的不同位置。<br>  物理地址空间 是指内存中物理单元的集合，它是地址转换的最终地址。进程在运行时执行指令和访问数据，最后都要通过物理地址从主存中存取。当装入程序将可执行代码装入内存时，必须通过地址转换将逻辑地址转换成物理地址(动态重定位是地址转换推迟到程序真正要执行时才进行)，这个过程称为 地址重定位。</p>
</blockquote>
</li>
<li><p>程序的链接</p>
<ul>
<li><p>静态链接</p>
<p>在程序运行之前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件(装入模块)，之后不再拆开。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/2b2053b9b6f44772a4b309c85d4998ff.png" alt="img"></p>
</li>
<li><p>装入时动态链接</p>
<p>将各 目标模块装入内存时，边装入边链接的链接方式。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/cd21652741714cca8732c044a2eaa684.png" alt="img"></p>
</li>
<li><p>运行时动态链接</p>
<p>在程序执行中需要该目标模块时，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/6c5ae35d6a89479cbcf34b99d4fd4435.png" alt="img"></p>
</li>
</ul>
</li>
<li><p>程序的装入</p>
<ul>
<li><p>绝对装入</p>
<p>在编译与链接后，得到的装入模块指定 直接使用了绝对地址。</p>
</li>
<li><p>可重定位装入</p>
<p>装入时对地址进行重定位，即将逻辑地址变换为物理地址，地址变换是在装入时一次完成的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/979dcf9791c34d428a2380f0c422f754.png" alt="img"></p>
<p><strong>静态重定位的特点：</strong> 在一个作业装入内存时，必须分配其要求的全部内存空间，如果没有足够的内存，就不能装入该作业。作业一旦进入内存后，在运行期间就不能再移动，也不能再申请内存空间。</p>
</li>
<li><p>动态运行时装入</p>
<p>装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址(装入时依然保持使用逻辑地址)，而是把地址转换推迟到程序真正要执行时才进行。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个重定位寄存器的支持。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/5768b6cbd3844ce2929672b40f3e7bf7.png" alt="img"></p>
<p><strong>动态重定位特点：</strong> 可以将程序分配到不连续的存储区中；在程序运行前只需装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存；便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间；采用动态重定位时允许程序在内存中发生移动。</p>
</li>
</ul>
<blockquote>
<p>注：链接的作用是形成了完整的装入模块与逻辑地址，但逻辑地址到物理地址的转换过程是重定位，而不是装入。</p>
</blockquote>
</li>
<li><p>内存映像</p>
<p> 不同于存放在硬盘上的可执行程序文件，当一个程序调入内存运行时，就构成了进程的内存映像。一个进程的内存映像一般有几个要素：</p>
<ul>
<li><strong>代码段</strong>：即程序的二进制代码，代码段是只读的，可以被多个进程共享。</li>
<li><strong>数据段</strong>：即程序运行时加工处理的对象，包括全局变量和静态变量。</li>
<li><strong>进程控制块（PCB）</strong>：存放在系统区。操作系统通过PCB来控制和管理进程。</li>
<li><strong>堆</strong>：用来存放动态分配的变量。通过调用malloc 函数动态地向高地址分配空间。</li>
<li><strong>栈</strong>：用来实现函数调用。从用户空间的最大地址往低地址方向增长。</li>
</ul>
<blockquote>
<p>代码段和数据段在程序调入内存时就指定了大小，而堆和栈不一样。</p>
<p>当调用像malloc和free这样的C标准库函数时，堆可以在运行时动态地扩展和收缩。</p>
<p>用户栈在程序运行期间也可以动态地扩展和收缩，每次调用一个函数，栈就会增长；从一个函数返回时，栈就会收缩。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230914155418540.png" alt="image-20230914155418540"></p>
<p> 上图是一个进程在内存中的映像。</p>
<ul>
<li>其中，共享库用来存放进程用到的共享函数库代码，如printf函数等。</li>
<li>在只读代码段中，.iit是程序初始化时调用的_init函数；.text是用户程序的机器代码；.rodata是只读数据。</li>
<li>在读&#x2F;写数据段中，.data是已初始化的全局变量和静态变量；.bss是未初始化及所有初始化为0的全局变量和静态变量。</li>
</ul>
</li>
<li><p>内存保护</p>
<p> 确保每个进程都有一个<strong>单独的内存空间</strong>。内存分配前，需要保护操作系统不受用户进程的影响，同时保护用户进程不受其他用户进程的影响。内存保护可采取两种方法：</p>
<ul>
<li><p>在CPU中设置一对上、下限寄存器，存放用户作业在主存中的下限和上限地址，每当CPU要访问一个地址时，分别和两个寄存器的值相比，判断有无越界。</p>
</li>
<li><p>采用重定位寄存器（又称基地址寄存器）和界地址寄存器（又称限长寄存器）来实现这种保护。</p>
<p><strong>重定位寄存器</strong>含最小的物理地址值，<strong>界地址寄存器</strong>含逻辑地址的最大值。内存管理机构动态地将逻辑地址与界地址寄存器进行比较，若未发生地址越界，则加上重定位寄存器的值后映射成物理地址，再送交内存单元，如下图所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230914160656627.png" alt="image-20230914160656627"></p>
<blockquote>
<p>重定位寄存器是用来“加”的，逻辑地址加上重定位寄存器中的值就能得到物理地址；</p>
<p>界地址寄存器是用来“比”的，通过比较界地址寄存器中的值与逻辑地址的值来判断是否越界。</p>
</blockquote>
<p> 加载重定位寄存器和界地址寄存器时必须使用特权指令，只有操作系统内核才可以加载这<br>两个存储器。这种方案允许操作系统内核修改这两个寄存器的值，而不允许用户程序修改。</p>
</li>
</ul>
</li>
<li><p>内存共享</p>
<p> 并不是所有的进程内存空间都适合共享，只有那些只读的区域才可以共享。</p>
<p> 可重入代码又称纯代码，是一种允许多个进程同时访问但不允许被任何进程修改的代码。</p>
<p> 在实际运行时，每个进程有自己的私有数据段，可以更改自己私有的数据区数据，不可改变共享的代码。</p>
<blockquote>
<p>例：考虑一个可以同时容纳40个用户的多用户系统，他们同时执行一个文本编辑程序，若该程序有160KB代码区和40KB数据区，则共需8000KB的内存空间来支持40个用户。如果160KB代码是可分享的纯代码，则不论是在分页系统中还是在分段系统中，整个系统只需保留一份副本即可，此时所需的内存空间仅为40KB×40+160KB&#x3D;1760KB。</p>
<p>对于分页系统，假设页面大小为4KB，则代码区占用40个页面、数据区占用10个页面。为实现代码共享，应在每个进程的页表中都建立40个页表项，它们都指向共享代码区的物理页号。此外，每个进程还要为自己的数据区建立10个页表项，指向私有数据区的物理页号。</p>
<p>对于分段系统，由于是以段为分配单位的，不管该段有多大，都只需为该段设置一个段表项（指向共享代码段始址，以及段长160KB）。由此可见，段的共享非常简单易行。</p>
</blockquote>
</li>
<li><p>内存分配与回收</p>
<p> 在操作系统由单道向多道发展时，存储管理方式便由单一连续分配发展为固定分区分配。为了能更好地适应不同大小的程序要求，又从固定分区分配发展到动态分区分配。</p>
<p> 为了更好地提高内存的利用率，进而从连续分配方式发展到离散分配方式一一页式存储管理。</p>
<p> 引入分段存储管理的目的，主要是为了满足用户在编程和使用方面的要求，其中某些要求是其他几种存储管理方式难以满足的。</p>
</li>
</ol>
<h4 id="3-1-2-覆盖与交换"><a href="#3-1-2-覆盖与交换" class="headerlink" title="3.1.2 覆盖与交换"></a>3.1.2 覆盖与交换</h4><p> 覆盖与交换技术是在多道程序环境下用来扩充内存的两种方法。</p>
<ol>
<li><p>覆盖</p>
<ul>
<li><p>基本思想：由于程序运行时并非任何时候都要访问程序及数据的各个部分（尤其是大程序），因此可把用户空间分成一个</p>
<p>固定区</p>
<p>和若干</p>
<p>覆盖区</p>
<p>。</p>
<ul>
<li>将经常活跃的部分放在固定区，其余部分按调用关系分段。</li>
<li>首先将那些即将要访问的段放入覆盖区，其他段放在外存中，在需要调用前，系统再将其调入覆盖区，替换覆盖区中原有的段。</li>
</ul>
</li>
<li><p>特点：</p>
<ul>
<li>打破了必须将一个进程的全部信息装入主存后才能运行的限制，但当同时运行程序的代码量大于主存时仍不能运行；</li>
<li>内存中能够更新的地方只有覆盖区的段，不在覆盖区中的段会常驻内存；</li>
<li>覆盖技术对用户和程序员不透明。</li>
</ul>
</li>
</ul>
</li>
<li><p>交换</p>
<ul>
<li>基本思想：把处于等待状态（或在CPU调度原则下被剥夺运行权利）的程序从内存移到辅存，把内存空间腾出来，这一过程又称换出；把准备好竞争CPU运行的程序从辅存移到内存，这一过程又称换入。</li>
<li>交换过程：例如，有一个CPU采用时间片轮转调度算法的多道程序环境。时间片到，内存管理器将刚刚执行过的进程换出，将另一进程换入刚刚释放的内存空间。同时，CPU调度器可以将时间片分配给其他已在内存中的进程。每个进程用完时间片都与另一进程交换。在理想情况下，内存管理器的交换过程速度足够快，总有进程在内存中可以执行。</li>
<li>问题：<ul>
<li>交换需要备份存储，通常是磁盘。它必须足够大，并提供对这些内存映像的直接访问。</li>
<li>为了有效使用CPU，需要使每个进程的执行时间比交换时间长。</li>
<li>若换出进程，则必须确保该进程完全处于空闲状态。</li>
<li>交换空间通常作为磁盘的一整块，且独立于文件系统，因此使用起来可能很快。</li>
<li>交换通常在有许多进程运行且内存空间吃紧时开始启动，而在系统负荷降低时就暂停。</li>
<li>普通的交换使用不多，但交换策略的某些变体在许多系统（如UNX）中仍发挥作用。</li>
</ul>
</li>
</ul>
</li>
<li><p>区别</p>
<p> 交换技术主要在<strong>不同进程（或作业）之间</strong>进行，而覆盖则用于<strong>同一个程序或进程</strong>中。对于主存无法存放用户程序的矛盾，现代操作系统是通过<strong>虚拟内存技术</strong>来解决的，覆盖技术则已成为历史；而交换技术在现代操作系统中仍具有较强的生命力。</p>
</li>
</ol>
<h4 id="3-1-3-连续分配管理方式"><a href="#3-1-3-连续分配管理方式" class="headerlink" title="3.1.3 连续分配管理方式"></a>3.1.3 连续分配管理方式</h4><p> 连续分配方式是指为一个用户程序分配一个连续的内存空间，包括单一连续分配、固定分区分配和动态分区分配。</p>
<ol>
<li><p>单一连续分配</p>
<p> 在单一连续分配方式中，内存被分为 系统区和用户区。系统区通常位于内存的低地址部分，用于存放操作系统相关数据；用户区用于存放用户进程相关数据。内存中只能有一道用户程序，用户程序独占整个用户区空间。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/49406fbc9608493b9b36588ed2a17485.png" alt="img"></p>
<p><strong>优点：</strong> 实现简单；无外部碎片；可以采用覆盖技术扩充内存；无需采取内存保护，因为内存中永远只有一道程序。</p>
<p><strong>缺点：</strong>只能用于单用户、单任务的操作系统中；有内部碎片；存储器利用率极低。</p>
<blockquote>
<p>内部碎片：分配给某进程的内存区域中，如果有些部分没有用上。</p>
<p>外部碎片：是指内存中的某些空闲分区由于太小而难以利用。</p>
</blockquote>
</li>
<li><p>固定分区分配</p>
<p>固定分区分配是最简单的一种多道程序存储管理方式，它将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业。当有空闲分区时，便可从外存的后备作业队列中选择适当大小的作业装入该分区，如此循环。划分分区有两种方法：</p>
<ul>
<li>分区大小相等。程序太小会造成浪费，程序太大又无法装入，缺乏灵活性。</li>
<li>分区大小不等。划分为多个较小的分区、适量的中等分区和少量大分区，增加了灵活性。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/8a164fe40fa0477eaeaa4ef304967362.png" alt="img"></p>
<p> 为了便于分配，建立一张分区使用表，通常按分区大小排队，各表项包括每个分区的起始地址、大小及状态（是否已分配），如下图所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230915143014357.png" alt="image-20230915143014357"></p>
<blockquote>
<p>分配内存时，便检索该表，以找到一个能满足要求且尚未分配的分区分配给装入程序，并将对应表项的状态置为“已分配”；若找不到这样的分区，则拒绝分配。</p>
<p>回收内存时，只需将对应表项的状态置为“未分配”即可。</p>
</blockquote>
<p><strong>优点：</strong> 实现简单，无外部碎片。</p>
<p><strong>缺点：</strong> 当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采用覆盖技术来解决，但这又会降低性能；会产生内部碎片，内存利用率低。</p>
</li>
<li><p>动态分区分配</p>
<p>动态分区分配 又称为 可变分区分配。这种分配方式不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此，系统分区的大小和数目是可变的。</p>
<blockquote>
<p>例：如图所示，系统有64MB内存空间，其中低8MB固定分配给操作系统，其余为用户可用内存。</p>
<p>开始时装入前三个进程，它们分别分配到所需的空间后，内存仅剩4MB，进程4无法装入。</p>
<p>在某个时刻，内存中没有一个就绪进程，CPU出现空闲，操作系统就换出进程2，换入进程4。由于进程4比进程2小，这样在主存中就产生了一个6MB的内存块。</p>
<p>之后CPU又出现空闲，需要换入进程2，而主存无法容纳进程2，操作系统就换出进程1，换入进程2。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230915143834058.png" alt="image-20230915143834058"></p>
</blockquote>
<p>紧凑技术：动态分区在开始时是很好的，但随着时间的推移，内存中会产生越来越多的外部碎片。需要通过紧凑技术来解决，即操作系统不时地对进程进行移动和整理。但这需要动态重定位寄存器的支持，且相对费时。</p>
<p> 在进程装入或换入主存时，若内存中有多个足够大的空闲块，则操作系统必须确定分配哪个内存块给进程使用，这就是动态分区的分配策略。考虑以下几种算法：</p>
<ul>
<li><p>首次适应（FirstFit）算法</p>
<ul>
<li><strong>算法思想</strong>：每次都从低地址开始查找，找到第一个能满足大小的空闲分区。</li>
<li><strong>如何实现</strong>：空闲分区以地址递增的次序链接。分配内存时，从链首开始顺序查找，找到大小能满足要求的第一个空闲分区分配给作业。</li>
<li>算法简单，最好最快，回收分区后一般不需要对空闲分区队列重新排序</li>
</ul>
</li>
<li><p>最佳适应（BestFit）算法</p>
<ul>
<li><strong>算法思想：</strong>优先使用更小的分区，以保留更多大分区。</li>
<li><strong>如何实现：</strong>空闲分区按容量递增的次序形成空闲分区链，找到第一个能满足要求且最小的空闲分区分配给作业，避免“大材小用”。</li>
<li><strong>缺点：</strong>产生大量小的、难以利用的外部碎片</li>
</ul>
</li>
<li><p>最坏适应（WorstFit）算法</p>
<p>（最大适应算法）</p>
<ul>
<li><strong>算法思想：</strong>优先使用更大的分区，以防止产生太小的不可用的碎片。</li>
<li><strong>如何实现：</strong>空闲分区以容量递减的次序链接，找到第一个能满足要求的，即最大的分区，从中分割一部分存储空间给作业。</li>
<li><strong>缺点：</strong>如果之后有“大进程”到达，无足够大连续内存空间分配。</li>
</ul>
</li>
<li><p>邻近适应（NextFit）算法</p>
<p>（循环首次适应算法）</p>
<ul>
<li><strong>算法思想：</strong>由首次适应演变而来，每次从上次查找结束位置开始查找。</li>
<li><strong>如何实现：</strong>空闲分区以地址递增的顺序排列（可排成一个循环链表）。每次分配内存时从上次查找结束的位置开始查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</li>
<li><strong>缺点：</strong>导致无论低地址、高地址部分的空闲分区都有相同的概率被使用，也就导致了高地址部分的大分区更可能被使用，划分为小分区，最后导致无大分区可用。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">算法</th>
<th align="center">算法思想</th>
<th align="center">分区排列顺序</th>
<th align="center">优点</th>
<th align="center">缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">首次适应</td>
<td align="center">从头到尾找适合的分区</td>
<td align="center">空闲分区以地址递增次序排列</td>
<td align="center">性能最好 算法开销小</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">最佳适应</td>
<td align="center">优先使用更小的分区</td>
<td align="center">空闲分区以容量递增次序排列</td>
<td align="center">保留更大分区</td>
<td align="center">产生大量碎小的外部碎片；算法开销大</td>
</tr>
<tr>
<td align="center">最坏适应</td>
<td align="center">优先使用更大的分区</td>
<td align="center">空闲分区以容量递减次序排列</td>
<td align="center">减少难以利用的碎片</td>
<td align="center">大分区容易被用完；算法开销大</td>
</tr>
<tr>
<td align="center">邻近适应</td>
<td align="center">每次从上次查找结束位置开始查找</td>
<td align="center">空闲分区以地址递增次序排列（可排列成循环链表)</td>
<td align="center">空闲分区有相同概率被使用，算法开销小</td>
<td align="center">使高地址大分区也被用完</td>
</tr>
</tbody></table>
<blockquote>
<p>注：动态分区分配没有内部碎片，但是有外部碎片。</p>
</blockquote>
</li>
<li><p>分区的分配与回收</p>
<p>回收内存分区时，有可能遇到四种情况：</p>
<ul>
<li>① 回收区的后面有一个相邻的空闲分区。</li>
<li>② 回收区的前面有一个相邻的空闲分区。</li>
<li>③ 回收区的前、后各有一个相邻的空闲分区。</li>
<li>④ 回收区的前、后都没有相邻的空闲分区。</li>
</ul>
<p>无论那种情况，都要遵循相邻的空闲分区要合并的原则。</p>
</li>
</ol>
<h4 id="3-1-4-基本分页存储管理"><a href="#3-1-4-基本分页存储管理" class="headerlink" title="3.1.4 基本分页存储管理"></a>3.1.4 基本分页存储管理</h4><p> 固定分区会产生内部碎片，动态分区会产生外部碎片，这两种技术对内存的利用率都比较低。为了避免碎片的产出，引出了分页的思想。<br>​ <strong>分页的思想</strong>：把主存空间划分为大小相等且固定的块，块相对较小，作为主存的基本单位。每个进程也以块为单位进行划分，进程在执行时，以块为单位逐个申请主存中的块空间。</p>
<p> 分页管理与固定分区类似，不会产生外部碎片；进程运行按块申请主存空间，只会在最后一块有内部碎片，每个进程平均只有半个块的内部碎片（页内碎片）。</p>
<ol>
<li><p>基本概念</p>
<ul>
<li><p>页面和页面大小</p>
<ul>
<li>进程中的块称为页或页面（Page)，</li>
<li>内存中的块称为页框或页帧（Page Frame)</li>
<li>外存也以同样的单位进行划分，直接称为块或盘块（Block)。</li>
</ul>
<p>进程在执行时需要为每个页面分配主存中的可用页框，这就产生了页和页框的一一对应。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/e149642fce4145539ec3871fc85f2e86.png" alt="img"></p>
<blockquote>
<ul>
<li>将内存空间分为一个个大小相等的分区，每个分区就是一个页框 。每个页框有一个编号，即 页框号，页框号 从 0 开始。</li>
<li>将进程的逻辑地址空间也分为与页框大小相等的一个个部分，每个部分称为一个 页或页面。每个页面也有一个编号，即 页号，页号也是 从 0 开始。</li>
</ul>
<p>页框&#x3D;页帧&#x3D;内存块&#x3D;物理块&#x3D;物理页面</p>
</blockquote>
<p>为方便地址转换，页面大小应是2的整数幂。同时页面大小应该适中，</p>
<ul>
<li>页面太小会使进程的页面数过多，这样页表就会过长，占用大量内存，而且也会增加硬件地址转换的开销，降低页面换入&#x2F;换出的效率；</li>
<li>页面过大又会使页内碎片增多，降低内存的利用率。</li>
</ul>
</li>
<li><p>地址结构</p>
<p> 地址结构决定了虚拟内存的寻址空间有多大。</p>
<p>分页存储管理的 逻辑地址结构 如下所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/000c51965bd3456dbf10934cd923bd7c.png" alt="img"></p>
<p> 地址结构包含两个部分：前一部分为页号，后一部分为页内偏移量 W。</p>
<p> 在上图所示的例子中，地址长度为 32 位，其中 0 ~ 11位 为页内偏移量(或称页内地址)，即每页大小为 4KB；12~31 位为页号，进程地址空间最多允许 220 页。</p>
</li>
<li><p>页表</p>
<p>为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一张 页表。页表通常存在 PCB (进程控制块，在操作系统的内核地址空间)中。页表记录进程 页面 和实际存放的 内存块 之间的 映射关系。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/187e4f5ea97449f9a859d715237d41d8.png" alt="img"></p>
<ul>
<li>①一个进程对应一张页表。</li>
<li>②进程的每个页面对应一个页表项。</li>
<li>③每个页表项由页号和块号组成。</li>
<li>④每个页表项的长度是相同的。</li>
</ul>
<blockquote>
<p>例：假设某系统物理内存大小为 4 GB，页面大小为 4 KB，则每个页表项至少应该为多少字节？</p>
<ul>
<li>内存块大小&#x3D;页面大小&#x3D;4KB&#x3D;212B</li>
<li>4GB的内存总共会被分为232／212&#x3D;220个内存块</li>
<li>内存块号的范围应该是0～220-1</li>
<li>内存块号至少要用20 bit来表示</li>
<li>至少要用3B来表示块号（3＊8&#x3D;24 bit＞20bit）</li>
</ul>
<p>页表项在内存中是连续存放，因此页号是可以隐藏的，不占内存空间，页表项占 3 个字节。</p>
</blockquote>
<p>注：如果未特别强调，默认计算机按字节编址。</p>
</li>
<li><p>地址转换</p>
<p><strong>分页存储特点：</strong> 虽然进程的各个页面是离散存放的，但是页面内部是连续存放的。</p>
<p>页号 &#x3D; 逻辑地址 &#x2F; 页面长度<br>页内偏移量 &#x3D; 逻辑地址 % 页面长度</p>
<p>如果要访问逻辑地址 A 的物理块，则</p>
<ul>
<li>① 确定逻辑地址 A 对应的页号 P</li>
<li>② 找到 P 号页面在内存中的起始地址（需要查页表）</li>
<li>③ 确定逻辑地址 A 的页内偏移量 W</li>
</ul>
</li>
</ul>
</li>
<li><p>基本地址变换机构</p>
<p>基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址。变换机构如下图所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230915162458487.png" alt="image-20230915162458487"></p>
<p>通常会在系统中设置一个 页表寄存器(PTR)，存放 页表在内存中的起始地址 F 和页表长度 M。<br>进程未执行时，页表的始址 和 页表长度 放在进程控制块(PCB)中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。</p>
<ul>
<li><p>设页面大小为 L ，逻辑地址 A 到物理地址 E 的变换过程如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/d3e7e501b58f4f1da9a028a072074163.png" alt="img"></p>
<ul>
<li><p>①<strong>计算页号P和页内偏移量W</strong></p>
<p>如果用十进制数手算，则$P&#x3D;A&#x2F;L，W&#x3D;A%L$；但是在计算机实际运行时，逻辑地址结构是固定不变的，因此计算机硬件可以更快地得到二进制表示的页号、页内偏移量</p>
</li>
<li><p>②<strong>判断页号是否越界</strong></p>
<p>比较页号P和页表长度M，若P≥M，则产生越界中断，否则继续执行。</p>
<p>注意：页号是从0开始的，而页表长度至少是1，因此P&#x3D;M时也会越界</p>
</li>
<li><p>③<strong>查页表，找页号对应的页表项，确定内存块号</strong><br>$$<br>页表中页号P对应的页表项地址&#x3D;页表起始地址F+页号P*页表项长度<br>$$<br>取出该页表项内容b，即为内存块号。</p>
<blockquote>
<p><strong>注意区分页表项长度、页表长度、页面大小的区别。</strong></p>
<p>页表长度指的是这个页表中总共有几个页表项，即总共有几个页；</p>
<p>页表项长度指的是每个页表项占多大的存储空间；</p>
<p>页面大小指的是一个页面占多大的存储空间</p>
</blockquote>
</li>
<li><p>④<strong>用内存块号和偏移量得到物理地址</strong></p>
<p>计算$E&#x3D;b*L+W$，用得到的物理地址E去访存。</p>
<p>如果内存块号、页面偏移量是用二进制表示的，那么把二者拼接起来就是最终的物理地址了</p>
</li>
<li><p>⑤<strong>访问目标内存单元</strong></p>
</li>
</ul>
</li>
</ul>
<p> 在分页存储管理（页式管理）的系统中，页是信息的物理单位，分页完全是系统行为，因此 页的大小由系统决定，逻辑地址在计算机的视角很好确定。所以，页式管理中地址是一维的。即，只要给出一个逻辑地址，系统就可以自动地算出页号、页内偏移量 两个部分，并不需要显式地告诉系统这个逻辑地址中，页内偏移量占多少位。</p>
</li>
<li><p>具有快表的地址变换机构</p>
<p>快表，又称联想寄存器(TLB)，是一种 访问速度比内存快很多的高速缓存器，用来存放最近访问的页表项的副本，可以加速地址变换的速度。与此对应，内存中的页表常称为慢表。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230915170102254.png" alt="image-20230915170102254"></p>
<blockquote>
<p>注：TLB 不是内存；快表与 Cache(高速缓冲器) 的区别在于，块表中只有页表项的副本，而普通 Cache 中可能有其他各种数据的副本，可以把快表理解为一种特殊的 Cache。</p>
</blockquote>
<ul>
<li><p>设某进程执行过程中要访问 (0,4) 这个逻辑地址，访问过程如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/09cdc9c2ed774334998cb93421ffc158.png" alt="img"></p>
<ul>
<li>① CPU 给出逻辑地址，由硬件进行地址转换，将页号与快表中的所有页号进行比较。</li>
<li>② 如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后再访存。因此，若快表命中，存取数据仅一次访存。</li>
<li>③ 如果没有找到匹配的页号，则需要访问内存中的页表。找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后再访存。因此，若快表未命中，存取数据需两次访存。</li>
</ul>
</li>
</ul>
<p>注：在找到页表项后，应同时将其存入快表，以便后面可能的再次访问。但若快表已满，则必须按照一定算法对旧的页表项进行替换（局部性原理）。</p>
</li>
<li><p>两级页表</p>
<p>两级页表的分配管理方式属于基本分页存储管理范畴，其用于解决页表项占据连续页框的问题。</p>
<ul>
<li><p>单级页表存在的问题</p>
<p><strong>问题一</strong>：页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框。</p>
<p><strong>解决</strong>：可建立两级页表，一级页表为页目录表，二级页表离散存储。</p>
<p><strong>问题二</strong>：没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面。</p>
<p><strong>解决</strong>：可以在需要访问页面时才把页面调入内存（虚拟存储技术）。可以在页表项中增加一个标志位，用于表示该页面是否已经调入内存</p>
</li>
<li><p>两级页表的原理、地址结构</p>
<p>二级页表实际上是在原有页表结构上再加上一层页表，如下图所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230915175632539.png" alt="image-20230915175632539"></p>
<p> 建立多级页表的目的在于建立索引，以便不用浪费主存空间去存储无用的页表项，也不用盲目地顺序式查找页表项。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/9784e5f0c318438a9412c145206cff78.png" alt="img"></p>
<blockquote>
<p>例：某系统按字节寻址，支持 30 位的逻辑地址，采用分页存储管理，页面大小为 4KB，页表项长度为 4B，试问逻辑地址的结构。</p>
<p>页面大小为4KB&#x3D;212B，则页内偏移量要用12位表示。</p>
<p>30-12&#x3D;18，则顷号用18位表示，即进程最多有218个页面，一共需要218个页表项来记录这些页面与物理块的映射关系，且页号范围是：0~218-1。</p>
<p>页表项长度是4B，一个内存块（页框）最多存储4K&#x2F;4&#x3D;212&#x2F;4&#x3D;210个页表项。</p>
<p>218个页表项则需要218&#x2F;210&#x3D;28个内存块才能存储。</p>
<p>即需要专门给进程分配28&#x3D;256个连续的物理块（页框）来存放它的页表。</p>
<p>为避免连续占用内存块问题，可以设置28&#x3D;256个二级页表，并用一级页表来记录这些二级页表，因此一级页号占8位。</p>
</blockquote>
</li>
<li><p>地址变换</p>
<p><strong>例：</strong> 将逻辑地址 (00000000,0000000001,111111111111) 转换为物理地址（用十进制表示）。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/82c7749b04fb4c8a9c8fdf8efd4206ad.png" alt="img"></p>
<p>首先，按照地址结构将逻辑地址拆分成三部分</p>
<ul>
<li>① 从 PCB 中读出页目录表始址，再根据一级页号查页目录表，找到下一级页表在内存中的存放位置。</li>
<li>② 根据二级页号查二级页表，找到最终想访问的内存块号。</li>
<li>③ 结合页内偏移量得到物理地址。</li>
</ul>
<p>最终要访问的内存块号为 4，该内存块的起始地址为 4*4096 &#x3D; 16384 页内偏移量为 4095。</p>
<p>最终的物理地址为：16384 + 4095&#x3D; 20479。</p>
<blockquote>
<p><strong>两次页表，若采用“快表”，需要3次访存。</strong></p>
<ul>
<li>第一次：访问页目录表。</li>
<li>第二次：访问内存中的二级页表。</li>
<li>第三次：访问目标内存单元。</li>
</ul>
</blockquote>
</li>
<li><p>多级页表</p>
<p>若分为两级页表后，页表依然很长，则可以采用更多级页表。并且，若采用多级页表机制，则各级页表的大小不能超过一个页面。</p>
<blockquote>
<p>例：某系统按字节编址，采用 40 位逻辑地址，页面大小为 4KB，页表项大小为 4B，假设采用纯页式存储，则要采用 (   ) 级页表，页内偏移量为 (   ) 位？</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/1becafe302474e46b71ec544f94aca3e.png" alt="img"></p>
<p>页面大小&#x3D;4KB&#x3D;212B，按字节编址，因此页内偏移量为12位。</p>
<p>页号&#x3D;40-12&#x3D;28位</p>
<p>页面大小&#x3D;212B，页表项大小&#x3D;4B，则每个页面可存放212&#x2F;4&#x3D;210个页表项。</p>
<p>因此，各级页表最多包含210个页表项，需要10位二进制位才能映射到210个页表项。</p>
<p>因此每一级的页表对应页号应为10位。总共28位的页号至少要分为3级。</p>
</blockquote>
<p>此外，若未用“快表”，N 级页表机制，需要 N+1 次访问内存。</p>
</li>
</ul>
</li>
</ol>
<h4 id="3-1-5-基本分段式存储管理"><a href="#3-1-5-基本分段式存储管理" class="headerlink" title="3.1.5 基本分段式存储管理"></a>3.1.5 基本分段式存储管理</h4><p> 分页管理方式是从计算机的角度考虑设计的，目的是提高内存的利用率，提升计算机的性能。分页通过硬件机制实现，对用户完全透明。</p>
<p> 分段管理方式的提出则考虑了用户和程序员，以满足方便编程、信息保护和共享、动态增长及动态链接等多方面的需要。</p>
<ol>
<li><p>分段</p>
<p>段式管理方式按照用户进程中的自然段划分逻辑空间。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/e7ee7ecc5347417c91887ff7bb1416b5.png" alt="img"></p>
<blockquote>
<p>例如，用户进程由主程序段、两个子程序段、栈段和数据段组成，于是可以把这个用户进程划分为5段，每段从0开始编址，并分配一段连续的地址空间。</p>
</blockquote>
<p>段内要求连续，段间不要求连续，因此整个作业的地址空间是二维的。</p>
<p>其逻辑地址由段号S与段内偏移量W两部分组成，如下图所示分段系统中的逻辑地址结构。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230918092323039.png#pic_center" alt="image-20230918092323039"></p>
<p>其中，段号为16位，段内偏移量为16位，因此一个作业最多有216&#x3D;65536段，最大段长为64KB。</p>
<blockquote>
<p>在页式系统中，逻辑地址的页号和页内偏移量对用户是透明的，但在段式系统中，段号和段内偏移量必须由用户显式提供，在高级程序设计语言中，这个工作由编译程序完成。</p>
</blockquote>
</li>
<li><p>段表</p>
<p>程序分多个段，各段离散地装入内存，为了保证程序能正常运行，就必须能从物理内存中找到各个逻辑段的存放位置。为此，需为每个进程建立一张段映射表，简称段表。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/26729d8d16904859a5c212627606ade2.png" alt="img"></p>
<p>段表用于实现从逻辑段到物理内存区的映射。</p>
<p>特点：</p>
<ul>
<li>① 每个段对应一个段表项，其中 记录了该段在内存中的起始位置（又称“基址”）和段的长度。</li>
<li>② 各个段表项的长度是相同的。</li>
<li>③ 由于段表项长度相同，在内存中是连续存放，因此段号可以是隐含的，不占存储空间。</li>
<li>④ 段内要求连续，段间不要求连续，因此整个作业的地址空间是二维的。</li>
</ul>
</li>
<li><p>地址变换机构</p>
<p> 分段系统的地址变换过程如图所示。为了实现进程从逻辑地址到物理地址的变换功能，在系统中设置了段表寄存器，用于存放段表始址F和段表长度M。从逻辑地址A到物理地址E之间的地址变换过程如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/1d8a08763d62462fb2c79df0f70e258a.png" alt="img"></p>
<ul>
<li><p>① <strong>根据逻辑地址得到段号，段内地址</strong></p>
<p>从逻辑地址A中取出前几位为段号S，后几位为段内偏移量W。</p>
</li>
<li><p>② <strong>判断段号是否越界</strong></p>
<p>比较段号S和段表长度M，若 $段号S≥段表长度M$ ，则产生越界中断，否则继续执行。</p>
</li>
<li><p>③ <strong>查询段表，找到对应段表项</strong></p>
<p>段表中段号S对应的 $段表项地址&#x3D;段表始址F+段号S×段表项长度$ 。</p>
</li>
<li><p>④ <strong>检查段内地址是否超过段长</strong></p>
<p>取出该段表项的前几位得到段长C。若$段内偏移量W≥段长C$，则产生越界中断，否则继续执行。</p>
</li>
<li><p>⑤ <strong>计算得到物理地址</strong></p>
<p>取出段表项中该段的始址b，计算 $物理地址E&#x3D;段基址b+偏移量W$ ，得到物理地址E。</p>
</li>
<li><p>⑥ <strong>访问目标内存单元</strong></p>
<p>用得到的物理地址E去访问内存。</p>
</li>
</ul>
</li>
<li><p>段的共享与保护</p>
<ul>
<li><p>共享</p>
<p>在分段系统中，段的共享是通过两个作业的段表中相应表项指向被共享的段的同一个物理副本来实现的。</p>
<p>不能修改的代码称为纯代码或可重入代码（它不属于临界资源），这样的代码和不能修改的数据可以共享，而可修改的代码和数据不能共享。</p>
</li>
<li><p>保护</p>
<p>分段管理的保护方法主要有两种：一种是存取控制保护，另一种是地址越界保护。</p>
<ul>
<li><strong>存取控制保护</strong>：指在段表的每个表项中，设置“存取控制”字段，规定对该段的访问方式。</li>
<li><strong>地址越界保护</strong>：指在进行存储访问时，要检查逻辑地址是否超出了进程的地址空间。</li>
</ul>
</li>
</ul>
</li>
<li><p>分段、分页管理的对比</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">存储信息</th>
<th align="center">地址空间</th>
<th align="center">信息保护</th>
<th align="center">访存次数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">分页管理</td>
<td align="center">页是信息的物理单位 对用户透明 系统行为</td>
<td align="center">一维 记忆符(<A>)</td>
<td align="center">不易</td>
<td align="center">分页(单级页表)需两次访问 页表+目标内存单元</td>
</tr>
<tr>
<td align="center">分段管理</td>
<td align="center">段是信息的逻辑单位 对用户可见 用户需求</td>
<td align="center">二维 段名+段内地址([D]|<A>)</td>
<td align="center">容易 纯代码</td>
<td align="center">分段需两次访问 段表+目标内存单元</td>
</tr>
</tbody></table>
</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/d61d4a9c2bdc45768ec8e3b1b1af43fa.png" alt="img"></p>
<h4 id="3-1-6-段页式管理"><a href="#3-1-6-段页式管理" class="headerlink" title="3.1.6 段页式管理"></a>3.1.6 段页式管理</h4><ol>
<li><p>段页式管理结构</p>
<p> 分页存储管理能有效地提高内存利用率，而分段存储管理能反映程序的逻辑结构并有利于段的共享和保护。将这两种存储管理方法结合起来，便形成了段页式存储管理方式。</p>
<p> 段页式存储管理方式，将作业的地址空间首先被分成若干逻辑段，每段都有自己的段号，然后将每个段分成若干大小固定的页，内存空间分为大小一个个大小相等的分区。如下图所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230918135016046.png" alt="image-20230918135016046"></p>
<p> 在段页式系统中，作业的逻辑地址分为三部分：段号、页号和页内偏移量。如下图所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230918135200702.png" alt="image-20230918135200702"></p>
<p> 段号的位数决定了每个进程最多可以分几个段，页号位数决定了每个段最大有多少页，页内偏移量决定了页面大小、内存块大小是多少。</p>
<p> 在一个进程中，段表只有一个，而页表可能有多个。</p>
<blockquote>
<p>例：如下图所示的段页式格式，</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/3528a43d260646b9ba48507c2d18725f.png" alt="img"></p>
<ul>
<li>段号16位，因此进程中最多有216&#x3D;64K个段。</li>
<li>页号4位，因此每个段最多有24&#x3D;16页。</li>
<li>页内偏移量有12位，因此每个内存块大小为212&#x3D;2KB</li>
</ul>
</blockquote>
<p>分段对用户是可见的，程序员编程时需要显式地给出段号、段内地址。而将各段分页对用户是不可见的。系统会根据段内地址自动划分页号和页内偏移量。因此，段页式管理的地址结构是二维的。</p>
</li>
<li><p>地址转换</p>
<p> 在进行地址变换时，首先通过段表查到页表始址，然后通过页表找到页号，最后形成物理地址。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230918140200214.png" alt="image-20230918140200214"></p>
<p> 如下图所示，进行一次访问实际需要三次访问主存，这里同样可以使用快表来加快查找速度，其关键字由段号、页号组成，值是对应的页帧号和保护码。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/6bc46dbddfdb4cab8e5f184094540a0b.png" alt="img"></p>
<ul>
<li>① 根据逻辑地址得到段号、页号、页内偏移量</li>
<li>② 判断段号是否越界若S≥M，则产生越界中断，否则继续执行</li>
<li>③ 查询段表找到对应的段表项，段表项的存放地址为$F+S×段表顶长度$</li>
<li>④ 检查页号是香越界，若页号≥页表长度，则发生越界中断，否则继续执行</li>
<li>⑤ 根据页表存放块号、页号查询页表找到对应页表项</li>
<li>⑥ 根据内存块号页内偏移量得到最终的物理地址</li>
<li>⑦ 访问目标内存单元</li>
</ul>
</li>
</ol>
<h3 id="3-2-虚拟内存管理"><a href="#3-2-虚拟内存管理" class="headerlink" title="3.2 虚拟内存管理"></a>3.2 虚拟内存管理</h3><h4 id="3-2-1-虚拟内存的基本概念"><a href="#3-2-1-虚拟内存的基本概念" class="headerlink" title="3.2.1 虚拟内存的基本概念"></a>3.2.1 虚拟内存的基本概念</h4><ol>
<li><p>传统存储管理方式的特征</p>
<ul>
<li>传统存储管理方式<ul>
<li>连续分配<ul>
<li>单一连续分配</li>
<li>固定分区分配</li>
<li>动态分区分配</li>
</ul>
</li>
<li>非连续分配<ul>
<li>基本分页存储管理</li>
<li>基本分段存储管理</li>
<li>基本段页式存储管理</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>特征</strong>：</p>
<ul>
<li><p>一次性</p>
<p>：</p>
<p>作业必须一次性全部装入内存后，才能开始运行</p>
<p>。这会导致两种情况：</p>
<ul>
<li>①当作业很大而不能全部被装入内存时，将使该作业无法运行；</li>
<li>②当大量作业要求运行时，由于内存不足以容纳所有作业，只能使少数作业先运行，导致多道程序度的下降。</li>
</ul>
</li>
<li><p><strong>驻留性</strong>：作业被装入内存后，就一直驻留在内存中，其任何部分都不会被换出，直至作业运行结束。运行中的进程会因等待IO而被阻塞，可能处于长期等待状态。</p>
</li>
</ul>
<p> 由以上分析可知，许多在程序运行中不用或暂时不用的程序（数据）占据了大量的内存空间，而一些需要运行的作业又无法装入运行，显然浪费了宝贵的内存资源。</p>
</li>
<li><p>局部性原理</p>
<p>快表、页高速缓存及虚拟内存技术都属于高速缓存技术，这个技术所依赖的原理就是局部性原理。</p>
<ul>
<li><p><strong>时间局部性</strong>。</p>
<p>程序中的某条指令一且执行，不久后该指令可能再次执行；某数据被访问过，不久后该数据可能再次被访问。产生的原因是程序中存在着大量的循环操作。</p>
</li>
<li><p><strong>空间局部性</strong>。</p>
<p>一旦程序访问了某个存储单元，在不久后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式聚存储的。</p>
</li>
</ul>
</li>
<li><p>虚拟存储器的定义和特征</p>
<p>程序不需全部装入即可运行，运行时根据需要动态调入数据，若内存不够，还需换出一些数据。系统好像为用户提供了一个比实际内存容量大得多的存储器，称为虚拟存储器。</p>
<ul>
<li><strong>多次性</strong>：无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存。</li>
<li><strong>对换性</strong>：无需在作业运行时一直常驻内存，而是允许在作业运行过程中，将作业换入、换出。</li>
<li><strong>虚拟性</strong>：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量。</li>
</ul>
</li>
<li><p>虚拟内存技术的实现</p>
<p>虚拟内存的实现需要建立在离散分配的内存管理方式的基础上。</p>
<p>访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存（请求调页功能）</p>
<p>内存空间不够时，将内存中暂时用不到的信息换出到外存（页面置换功能）</p>
<ul>
<li><p>虚拟内存的实现方式</p>
<ul>
<li>请求分页存储管理</li>
<li>请求分段存储管理</li>
<li>请求段页式存储管理</li>
</ul>
</li>
<li><p>所需要的</p>
<p>硬件支持</p>
<ul>
<li>一定容量的内存和外存。</li>
<li>页表机制（或段表机制），作为主要的数据结构。</li>
<li>中断机构，当用户程序要访问的部分尚未调入内存时，则产生中断。</li>
<li>地址变换机构，逻辑地址到物理地址的变换。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="3-2-2-请求分页管理方式"><a href="#3-2-2-请求分页管理方式" class="headerlink" title="3.2.2 请求分页管理方式"></a>3.2.2 请求分页管理方式</h4><p> 请求分页系统建立在基本分页系统基础之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。</p>
<ol>
<li><p>页表机制</p>
<p> 请求分页系统在一个作业运行之前不要求全部一次性调入内存，因此在作业的运行过程中，必然会出现要访问的页面不在内存中的情况。因此在请求页表项中增加了 4个字段，如下图所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230918151653087.png" alt="image-20230918151653087"></p>
<ul>
<li><strong>状态位P</strong>：用于指示该页是否已调入内存，供程序访问时参考。</li>
<li><strong>访问字段A</strong>：用于记录本页在一段时间内被访问的次数，或记录本页最近已有多长时间未被访问，供置换算法换出页面时参考。</li>
<li><strong>修改位M</strong>：标识该页在调入内存后是否被修改过，以确定页面置换时是否写回外存。</li>
<li><strong>外存地址</strong>：用于指出该页在外存上的地址，通常是物理块号，供调入该页时参考。</li>
</ul>
</li>
<li><p>缺页中断机构</p>
<p> 在请求分页系统中，每当所要访问的页面不在内存中时，便产生一个缺页中断，请求操作系统将所缺的页调入内存。</p>
<ul>
<li><strong>缺页中断执行过程</strong><ul>
<li>先将缺页的进程阻塞（调页完成唤醒)，</li>
<li>若内存中有空闲块，则分配一个块，将要调入的页装入该块，并修改页表中的相应页表项，</li>
<li>若此时内存中没有空闲块，则要淘汰某页（若被淘汰页在内存期间被修改过，则要将其写回外存）。</li>
</ul>
</li>
<li><strong>缺页中断和一般中断的区别</strong>：<ul>
<li>在指令执行期间而非一条指令执行完后产生和处理中断信号，属于内部异常。</li>
<li>一条指令在执行期间，可能产生多次缺页中断。</li>
</ul>
</li>
</ul>
</li>
<li><p>地址变换机构</p>
<p> 请求分页系统中的地址变换机构，是在分页系统地址变换机构的基础上，为实现虚拟内存，又增加了某些功能而形成的，如产生和处理缺页中断，及从内存中换出一页的功能等等。</p>
<ul>
<li>新增步骤1：请求调页（查到页表项时进行判断）</li>
<li>新增步骤2：页面置换（需要调入页面，但没有空闲内存块时进行)</li>
<li>新增步骤3：需要修改请求页表中新增的表项</li>
</ul>
<p>请求分页管理的地址变换过程，如下图所示，红框部分为新增步骤：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230918154105795.png" alt="image-20230918154105795"></p>
<p>①只有“写指令”才需要修改“修改位”。并且，一般来说只需修改快表中的数据，只有要将快表项删除时才需要写回内存中的慢表。这样可以减少访存次数。</p>
<p>②和普通的中断处理一样，缺页中断处理依然需要保留CPU现场。</p>
<p>③需要用某种“页面置换算法”来决定一个换出页面（下节内容）</p>
<p>④换入&#x2F;换出页面都需要启动慢速的I&#x2F;O操作，可见，如果换入换出太频繁，会有很大的开销。</p>
<p>⑤页面调入内存后，需要修改慢表，同时也需要将表项复制到快表中。</p>
</li>
</ol>
<h4 id="3-2-3-页框分配"><a href="#3-2-3-页框分配" class="headerlink" title="3.2.3 页框分配"></a>3.2.3 页框分配</h4><ol>
<li><p>驻留集大小</p>
<p>给一个进程分配的物理页框的集合就是这个进程的驻留集。</p>
<ul>
<li>分配给一个进程的页框越少，驻留在主存中的进程就越多，从而可提高CPU的利用率。</li>
<li>若一个进程在主存中的页面过少，则尽管有局部性原理，缺页率仍相对较高。</li>
<li>若分配的页框过多，则由于局部性原理，对该进程的缺页率没有太明显的影响。</li>
</ul>
</li>
<li><p>内存分配策略</p>
<p> 在请求分页系统中，可采取两种内存分配策略，即固定和可变分配策略。在进行置换时，也可采取两种策略，即全局置换和局部置换。</p>
<ul>
<li><strong>固定分配</strong>：操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不再改变。即，驻留集大小不变</li>
<li><strong>可变分配</strong>：先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少。即驻留集大小可变</li>
<li><strong>局部置换</strong>：发生缺页时只能选进程自己的物理块进行置换。</li>
<li><strong>全局置换</strong>：可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程。</li>
</ul>
<blockquote>
<p>固定分配VS可变分配：区别在于进程运行期间驻留集大小是否可变</p>
<p>局部置换VS全局置换：区别在于发生缺页时是否只能从进程自己的页面中选择一个换出</p>
</blockquote>
<p>三种组合方案：</p>
<ul>
<li><p><strong>固定分配局部置换</strong></p>
<p>它为每个进程分配一定数目的物理块，在整个运行期间都不改变。</p>
<p>若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面。</p>
</li>
<li><p><strong>可变分配全局置换</strong></p>
<p>为系统中的每个进程分配一定数目的物理块，操作系统自身也保持一个空闲物理块队列。</p>
<p>当某进程发生缺页时，系统从空闲物理块队列中取出物理块分配给该进程，井将欲调入的页装入其中。</p>
</li>
<li><p><strong>可变分配局部置换</strong></p>
<p>它为每个进程分配一定数目的物理块，当某进程发生缺页时，只允许从该进程在内存的页面中选出一页换出动态变换，频繁缺页，分配物理块，缺页率低，减少物理块</p>
</li>
</ul>
</li>
<li><p>物理块调入算法</p>
<p>采用固定分配策略时，将系统中的空闲物理块分配给各个进程，可采用下述几种算法。</p>
<ul>
<li><strong>平均分配算法</strong>，将系统中所有可供分配的物理块平均分配给各个进程。</li>
<li><strong>按比例分配算法</strong>，根据进程的大小按比例分配物理块。</li>
<li><strong>优先权分配算法</strong>，为重要和紧迫的进程分配较多的物理块。通常采取的方法是把所有可分配的物理块分成两部分：一部分按比例分配给各个进程；一部分则根据优先权分配。</li>
</ul>
</li>
<li><p>调入页面的时机</p>
<p>为确定系统将进程运行时所缺的页面调入内存的时机，可采取以下两种调页策略：</p>
<ul>
<li><strong>预调页策略：</strong>将预计在不久后便会被访问的页面预先调入内存；主要用于进程的首次调入，由程序员指出应先调入哪些页。</li>
<li><strong>请求调页策略：</strong>进程在运行中需要访问的页面不再内存而提出请求，由系统将所需页面调入内存。每次仅调入一页，增加了磁盘I&#x2F;O开销。</li>
</ul>
</li>
<li><p>从何处调入页面</p>
<p> 请求分页系统中的外存分为两部分：用于存放文件的文件区和用于存放对换页面的对换区。</p>
<p> 对换区采用连续分配方式，而文件区采用离散分配方式，因此对换区的磁盘IO速度比文件区的更快。这样，当发生缺页请求时，系统从何处将缺页调入内存就分为三种情况：</p>
<ul>
<li><p><strong>系统拥有足够的对换区空间</strong></p>
<p>可以全部从对换区调入所需页面，以提高调页速度。为此，在进程运行前，需将与该进程有关的文件从文件区复制到对换区。</p>
</li>
<li><p><strong>系统缺少足够的对换区空间</strong></p>
<p>凡是不会被修改的文件都直接从文件区调入；而当换出这些页面时，由于它们未被修改而不必再将它们换出。但对于那些可能被修改的部分，在将它们换出时须调到对换区，以后需要时再从对换区调入（因为读比写的速度快）。</p>
</li>
<li><p><strong>UNIX方式</strong></p>
<p>运行之前进程有关的数据全部放在文件区，故未使用过的页面，都可从文件区调入。若被使用过的页面需要换出，则写回对换区，下次需要时从对换区调入。进程请求的共享页面若被其他进程调入内存，则无须再从对换区调入。</p>
</li>
</ul>
</li>
<li><p>如何调入页面</p>
<ul>
<li><p>当进程所访问的页面不在内存中时（存在位为0)，便向CPU发出缺页中断，中断响应后便转入缺页中断处理程序。</p>
</li>
<li><p>该程序通过查找页表得到该页的物理块，此时如果内存未满，则启动磁盘I&#x2F;O，将所缺页调入内存，并修改页表。</p>
</li>
<li><p>如果内存已满，则先按某种置换算法从内存中选出一页准备换出；</p>
<ul>
<li>如果该页未被修改过（修改位为0)，则无须将该页写回磁盘；</li>
<li>如果该页已被修改（修改位为1)，则必须将该页写回磁盘，</li>
</ul>
<p>然后将所缺页调入内存，并修改页表中的相应表项，置其存在位为1。</p>
</li>
<li><p>调入完成后，进程就可利用修改后的页表形成所要访问数据的内存地址。</p>
</li>
</ul>
</li>
</ol>
<h4 id="3-2-4-页面置换算法"><a href="#3-2-4-页面置换算法" class="headerlink" title="3.2.4 页面置换算法"></a>3.2.4 页面置换算法</h4><p> 进程运行时，若其访问的页面不在内存中而需将其调入，但内存已无空闲空间时，就需要从内存中调出一页程序或数据，送入磁盘的对换区，选择调出页面的算法就称为页面置换算法。</p>
<ol>
<li><p>最佳置换算法（OPT）</p>
<p> 选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/71a285fc3367ccf50d377f44e700f4fb.png" alt="img"></p>
<p>但由于人们目前无法预知进程在内存下的页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。</p>
</li>
<li><p>先进先出置换算法（FIFO）</p>
<p>优先淘汰最早进入内存的页面，即在内存中驻留时间最久的页面。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/047d308ca4a04dde65345bc9d2326f20.png" alt="img"></p>
<p>该算法实现简单，只需把调入内存的页面根据先后次序链接成队列，设置一个指针总指向最早的页面。</p>
<ul>
<li><p>Belady异常一一当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。</p>
<p>只有FIFO算法回产生Belady异常，算法性能差。</p>
<p>该算法与进程实际运行时的规律不适应，因为在进程中，有的页面经常被访问。</p>
</li>
</ul>
</li>
<li><p>最近最久未使用置换算法（LRU）</p>
<p> 选择最近最长时间未访问过的页面予以淘汰，它认为过去一段时间内未访问过的页面，在最近的将来可能也不会被访问。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/00d4372fa2790806a982d58b47a32b42.png" alt="img"></p>
<p> 该算法为每个页面设置一个访问字段，来记录页面自上次被访问以来所经历的时间，淘汰页面时选择现有页面中值最大的予以淘汰。</p>
<p> 该算法的实现需要专门的硬件支持，虽然算法性能好，但是实现困难，开销大。</p>
</li>
<li><p>时钟置换算法（CLOCK）&#x2F;最近未用算法（NRU）</p>
<p>简单的CLOCK算法实现方法：</p>
<ul>
<li>为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个循环队列。</li>
<li>当某页被访问时，其访问位置为1。</li>
<li>当需要淘汰一个页面时，只需检查页的访问位。如果是0，就选择该页换出；如果是1，则将它置为0，暂不换出，继续检查下一个页面，</li>
<li>若第一轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描（第二轮扫描中一定会有访问位为0的页面，因此简单的CLOCK算法选择一个淘汰页面最多会经过两轮扫描）</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/aabbed4621bdebbcc188e9f10763e92c.png" alt="img"></p>
</li>
<li><p>改进型的时钟置换算法</p>
<ul>
<li><p>简单时钟问题：简单的时钟置换算法仅考虑到一个页面最近是否被访问过。事实上，如果被淘汰的页面没有被修改过，就不需要执行I&#x2F;O操作写回外存。只有被淘汰的页面被修改过时，才需要写回外存。</p>
<p>因此，除了考虑一个页面最近有没有被访问过之外，操作系统还应考虑页面有没有被修改过。在其他条件都相同时，应优先淘汰没有修改过的页面，避免I&#x2F;O操作。这就是改进型的时钟置换算法的思想。</p>
<p>修改位&#x3D;0，表示页面没有被修改过：修改位&#x3D;1，表示页面被修改过。</p>
</li>
<li><p>算法规则：将所有可能被置换的页面排成一个循环队列，用（访问位A，修改位M）表示各页面状态。</p>
<blockquote>
<p>替换帧优先级：</p>
<ul>
<li>1类A&#x3D;0，M&#x3D;0：最近未被访问且未被修改，是最佳淘汰页。</li>
<li>2类A&#x3D;0，M&#x3D;1：最近未被访问，但已被修改，不是很好的淘汰页。</li>
<li>3类A&#x3D;1，M&#x3D;0：最近已被访问，但未被修改，可能再被访问。</li>
<li>4类A&#x3D;1，M&#x3D;1：最近已被访问且已被修改，可能再被访问。</li>
</ul>
</blockquote>
<ul>
<li><p><strong>第一轮</strong>：第一优先级——最近设访问，且没修改的页面</p>
<p>从当前位置开始扫描到第一个(0，0)的帧用于替换。本轮扫描不修改任何标志位</p>
</li>
<li><p><strong>第二轮</strong>：第二优先级——最近没访问，但修改过的页面</p>
<p>若第一轮扫描失败，则重新扫描，查找第一个（0，1）的帧用于替换。本轮将所有扫描过的帧访问位设为0</p>
</li>
<li><p><strong>第三轮</strong>：第三优先级——最近访问过，但没修改的页面</p>
<p>若第二轮扫描失败，则重新扫描，查找第一个（0，0）的帧用于替换。本轮扫描不修改任何标志位</p>
</li>
<li><p><strong>第四轮</strong>：第四优先级——最近访问过，且修改过的页面</p>
<p>若第三轮扫描失败，则重新扫描，查找第一个（0，1）的帧用于替换。</p>
</li>
</ul>
<p>由于第二轮己将所有帧的访问位设为0，因此经过第三轮、第四轮扫描定会有一个帧被选中，因此改进型CLOCK置换算法选择一个淘汰页面最多会进行四轮扫描。</p>
</li>
<li><p>性能：算法开销较小，性能也不错</p>
</li>
</ul>
</li>
</ol>
<h4 id="3-2-5-抖动和工作集"><a href="#3-2-5-抖动和工作集" class="headerlink" title="3.2.5 抖动和工作集"></a>3.2.5 抖动和工作集</h4><ol>
<li><p>抖动</p>
<ul>
<li>定义：抖动，又称颠簸，指在页面置换过程中，刚刚换出的页面马上又要换入主存，刚刚换入的页面马上又要换出主存。</li>
<li>抖动发生的原因：系统中同时运行的进程太多，由此分配给每个进程的物理块太少，不能满足进程正常运行的基本要求，致使每个进程在运行时频繁地出现缺页，必须请求系统将所缺页面调入内存。</li>
<li>抖动的危害：<ul>
<li>使得在系统中排队等待页面调入&#x2F;调出的进程数目增加。</li>
<li>对磁盘的有效访问时间也随之急剧增加，造成每个进程的大部分时间都用于页面的换入&#x2F;换出，而几乎不能再去做任何有效的工作，</li>
<li>进而导致发生处理机的利用率急剧下降并趋于零的情况。</li>
</ul>
</li>
</ul>
</li>
<li><p>工作集</p>
<p>由于抖动的发生与系统为进程分配物理块的多少有关，于是又提出了关于进程工作集的概念。</p>
<p>工作集是指在某段时间间隔内，进程要访问的页面集合。</p>
<p> 基于局部性原理，可以用最近访问过的页面来确定工作集。一般来说，工作集$W$可由时间$t$和工作集窗口大小$Δ$来确定。例如，某进程对页面的访问次序如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230918174429395.png" alt="image-20230918174429395"></p>
<p> 假设系统为该进程设定的工作集窗口大小$Δ$为5，则在$t_1$时刻，进程的工作集为{2,3,5}，在$t_2$时刻，进程的工作集为{1,2,3,4}。</p>
<p> 工作集大小一般会比窗口小很多，工作集反映了进程在接下来的一段时间内很有可能会频繁访问的页面集合，因此，若分配给进程的物理块小于工作集大小，则该进程就很有可能频繁缺页。</p>
<p> 一般来说分配给进程的物理块数（即驻留集大小）要大于工作集大小。</p>
</li>
</ol>
<h4 id="3-2-6-内存映射文件"><a href="#3-2-6-内存映射文件" class="headerlink" title="3.2.6 内存映射文件"></a>3.2.6 内存映射文件</h4><p> 内存映射文件（Memory-MappedFiles）与虚拟内存有些相似，将磁盘文件的全部或部分内容与进程虚拟地址空间的某个区域建立映射关系，便可以直接访问被映射的文件，而不必执行文件 I&#x2F;O 操作，也无须对文件内容进行缓存处理。这种特性非常适合用来管理大尺寸文件。</p>
<ol>
<li><p>特性</p>
<ul>
<li>进程可使用系统调用，请求操作系统将文件映射到进程的虚拟地址空间</li>
<li>以访问内存的方式读写文件</li>
<li>进程关闭文件时，操作系统负责将文件数据写回磁盘，并解除内存映射</li>
<li>多个进程可以映射同一个文件，方便共享</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230918175326496.png" alt="image-20230918175326496"></p>
</li>
<li><p>优点</p>
<ul>
<li>程序员编程更简单，已建立映射的文件，只需按访问内存的方式读写即可</li>
<li>文件数据的读入&#x2F;写出完全由操作系统负责，I\O效率可以由操作系统负责优化</li>
</ul>
</li>
</ol>
<h4 id="3-2-7-虚拟存储器性能影响因素"><a href="#3-2-7-虚拟存储器性能影响因素" class="headerlink" title="3.2.7 虚拟存储器性能影响因素"></a>3.2.7 虚拟存储器性能影响因素</h4><ol>
<li><p>页面大小</p>
<p>根据局部性原理，页面较大则缺页率较低，页面较小则缺页率较高。</p>
<ul>
<li>页面较小时，一方面减少了内存碎片，有利于提高内存利用率；另一方面，也会使每个进程要求较多的页面，导致页表过长，占用大量内存。</li>
<li>页面较大时，虽然可以减少页表长度，但会使页内碎片增大。</li>
</ul>
</li>
<li><p>分配给进程的物理块</p>
<p>分配给进程的物理块数越多，缺页率就越低，但是当物理块超过某个数目时，再为进程增加一个物理块对缺页率的改善是不明显的。</p>
</li>
<li><p>页面置换算法</p>
<p>好的页面置换算法可使进程在运行过程中具有较低的缺页率。</p>
<p>选择LRU、CLOCK等置换算法，将未来有可能访问的页面尽量保留在内存中，从而提高页面的访问速度。</p>
</li>
<li><p>写回磁盘的频率</p>
<p>换出已修改过的页面时，应当写回磁盘，如果每当一个页面被换出时就将它写回磁盘，那么每换出一个页面就需要启动一次磁盘，效率极低。</p>
<p>建立一个已修改换出页面的链表，对每个要被换出的页面（已修改），可以暂不将它们写回磁盘，而将它们挂在该链表上，仅当被换出页面数达到给定值时，才将其写回磁盘。</p>
</li>
<li><p>局部化程度</p>
<p>编写程序的局部化程度越高，执行时的缺页率就越低。如果存储采用的是按行存储，访问时就要尽量采用相同的访问方式，避免按列访问造成缺页率过高的现象。</p>
</li>
</ol>
<h4 id="3-2-8-地址翻译"><a href="#3-2-8-地址翻译" class="headerlink" title="3.2.8 地址翻译"></a>3.2.8 地址翻译</h4><p>设某系统满足以下条件：</p>
<ul>
<li>有一个TLB与一个data Cache</li>
<li>存储器以字节为编址单位</li>
<li>虚拟地址14位</li>
<li>物理地址12位</li>
<li>页面大小为64B</li>
<li>TLB为四路组相联，共有16个条目</li>
<li>data Cache是物理寻址、直接映射的，行大小为4B，共有16组</li>
</ul>
<p>写出访问地址为0x03d4, 0x00f1和0x0229的过程。</p>
<ol>
<li><p><strong>写出其地址结构</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230919094611325.png" alt="image-20230919094611325"></p>
<ul>
<li><p><strong>根据页面大小求页内偏移量与页号长度</strong></p>
<p>本系统以字节编址，页面大小为64B，则页内偏移量为$log_2(64B&#x2F;1B)&#x3D;6位$，所以虚拟页号为$14-6&#x3D;8位$，物理页号为$12-6&#x3D;6位$。</p>
</li>
<li><p><strong>根据TLB结构求虚拟页号地址结构</strong></p>
<p>因为TLB为四路组相联，共有16个条目，则TLB有16&#x2F;4&#x3D;4组，因此虚拟页号低$log_24&#x3D;2位$就为组索引，高6位为TLB标记。</p>
</li>
<li><p><strong>根据Cache机构求物理页号地址结构</strong></p>
<p>因为Cache行大小为4B，因此物理地址中低$log_24&#x3D;2位$为块索引，Cache共有16组，可知接下来$log_216&#x3D;4位$为组索引，剩下高6位作为标记。</p>
</li>
</ul>
</li>
<li><p><strong>根据TLB、页表寻找物理页号</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230919094851074.png" alt="image-20230919094851074"></p>
<p>先把十六进制的虚拟地址0x03d4, 0x00f1和0x0229转化为二进制形式，如下表所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230919095151415.png" alt="image-20230919095151415"></p>
<p>得到每个地址的组索引和TLB标记，接下来就要找出每个地址的页面在不在主存中，若在主存中，则还要找出物理地址。</p>
<ul>
<li>查TLB得到物理块号<ul>
<li>对于0x03d4，组索引为3，TLB标记为0x03。</li>
<li>查TLB表，第3组中有标记为03的项，且有效位为1，找到物理块0D。</li>
<li>拼接页内地址（010100），得到物理地址为0x354。</li>
</ul>
</li>
<li>查TLB未得到物理块号，查页表得到物理块号<ul>
<li>对于0x00f1，组索引为3，TLB标记为0x00。</li>
<li>查TLB表，第3组未找到有标记为00的项。</li>
<li>访存查页表，根据虚拟页号0x03，找到物理块号02，且有有效位为1。</li>
<li>拼接页内地址（110001），得到物理地址为0x0b1。</li>
</ul>
</li>
<li>查TLB未得到物理块号，查页表也未得到物理块号<ul>
<li>对于0x0229，组索引为0，TLB标记为0x02。</li>
<li>查TLB表，第0组未找到有标记为02的项。</li>
<li>访存查页表，根据虚拟页号0x08，页表08项有效位为0，页面不在主存中，产生缺页中断。</li>
</ul>
</li>
</ul>
</li>
<li><p>根据Cache寻找内存地址</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230919094903450.png" alt="image-20230919094903450"></p>
<p> 找出在主存中的页面的物理地址后，就要通过物理地址访问数据，接下来要找该物理地址的 内容在不在Cache中，物理地址结构如下表所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230919101554108.png" alt="image-20230919101554108"></p>
<ul>
<li>Cache块命中<ul>
<li>对于0x354，Cache索引为5，Cache标记为0x0d。</li>
<li>查询Cache索引为5的行，标记为0d，有效位为1，则该块在Cache中。</li>
<li>偏移为0，即块0，可得虚拟地址0x03d4的内容为36H。</li>
</ul>
</li>
<li>Cache块未命中<ul>
<li>对于0x0b1，Cache索引为C，Cache标记为0x02。</li>
<li>查询Cache索引为C的行，标记为02，有效位为0，则该块不在Cache中。</li>
<li>需去访问主存查找，物理页号为2、偏移为0x31的内容。</li>
</ul>
</li>
</ul>
</li>
<li><p>虚拟地址寻址总流程</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/b0b9bc36ae3ba18efd06a04216caa7f.jpg" alt="b0b9bc36ae3ba18efd06a04216caa7f"></p>
</li>
</ol>
<h2 id="4-文件管理"><a href="#4-文件管理" class="headerlink" title="4 文件管理"></a>4 文件管理</h2><h3 id="4-1-文件系统基础"><a href="#4-1-文件系统基础" class="headerlink" title="4.1 文件系统基础"></a>4.1 文件系统基础</h3><h4 id="4-1-1-文件的基本概念"><a href="#4-1-1-文件的基本概念" class="headerlink" title="4.1.1 文件的基本概念"></a>4.1.1 文件的基本概念</h4><ol>
<li><p>定义</p>
<p>文件是以计算机硬盘为载体的存储在计算机上的信息集合，在用户进行的输入、输出中，以文件位基本单位。</p>
<p>文件管理系统是实现的文件的访问、修改和保存，对文件维护管理的系统。</p>
</li>
<li><p>文件的组成</p>
<ul>
<li>存储空间：用于存储数据</li>
<li>标签：便于对数据的分类和索引</li>
<li>访问权限：不同用户对数据有不同的访问权限</li>
</ul>
</li>
<li><p>文件的结构</p>
<ul>
<li><p>数据项</p>
<p>：是文件系统中最低级的数据组织形式，可分为以下两种类型：</p>
<ul>
<li>基本数据项：用于描述一个对象的某种属性的一个值，是数据中的最小逻辑单位。</li>
<li>组合数据项：由多个基本数据项组成。</li>
</ul>
</li>
<li><p><strong>记录</strong>：是一组相关的数据项的集合，用于描述一个对象在某方面的属性。</p>
</li>
<li><p>文件</p>
<p>：是指由创建者所定义的、具有文件名的一组相关元素的集合，分为有结构文件和无结构文件两种。</p>
<ul>
<li>在有结构的文件中，文件由若干个相似的记录组成，如一个班的学生记录；</li>
<li>无结构文件则被视为一个字符流，比如一个二进制文件或字符文件。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="4-1-2-文件控制块和索引结点"><a href="#4-1-2-文件控制块和索引结点" class="headerlink" title="4.1.2 文件控制块和索引结点"></a>4.1.2 文件控制块和索引结点</h4><ol>
<li><p>文件的属性</p>
<ul>
<li>文件名：由创建文件的用户决定文件名，主要是为了方便用户找到文件，同一目录下不允许有重名文件</li>
<li>标识符：一个系统内的各文件标识符唯一，对用户来说毫无可读性，因此标识符只是操作系统用于区分各个文件的一种内部名称。</li>
<li>类型：指明文件的类型</li>
<li>位置：文件存放的路径（让用户使用）、在外存中的地址（操作系统使用，对用户不可见）</li>
<li>大小：指明文件大小</li>
<li>保护信息：对文件进行保护的访问控制信息</li>
<li>创建时间、最后一次修改时间和最后一次存取时间：文件创建、上次修改和上次访问的相关信息，用于保护和跟踪文件的使用。</li>
</ul>
</li>
<li><p>文件控制块FCB</p>
<p>文件控制块（FCB）是用来存放控制文件需要的各种信息的数据结构，以实现“按名存取”。</p>
<p>操作系统通过文件控制块（FCB）来维护文件元数据。FCB的有序集合称为文件目录，一个FCB就是一个文件目录项。下图为一个典型的FCB。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230919110034223.png" alt="image-20230919110034223"></p>
<p>FCB包含以下信息：</p>
<ul>
<li><strong>基本信息</strong>：如文件名、文件的物理位置、文件的逻辑结构、文件的物理结构等。</li>
<li><strong>存取控制信息</strong>：包括文件主的存取权限、核准用户的存取权限以及一般用户的存取权限。</li>
<li><strong>使用信息</strong>：如文件建立时间、上次修改时间等。</li>
</ul>
<blockquote>
<p>一个文件目录也被视为一个文件，称为目录文件。</p>
</blockquote>
</li>
<li><p>索引结点</p>
<p> 在检索目录时，只用到了文件名，因此有的系统采用文件名与文件描述分开的方法，使文件描述信息单独形成一个称为索引结点的数据结构，简称 i 结点（inode)。</p>
<p> 在文件目录中的每个目录项仅由文件名和指向该文件所对应的i结点的指针构成。</p>
<blockquote>
<p>假设一个FCB为64B，盘块大小是1KB，则每个盘块中可以存放16个FCB（FCB必须连续存放），若一个文件目录共有640个FCB，则查找文件平均需要启动磁盘20次。</p>
<p>而在UNIX系统中，一个目录项仅占16B，其中14B是文件名，2B是 i 结点指针。在1KB的盘块中可存放64个目录项。这样，可使查找文件的平均启动磁盘次数减少到原来的1&#x2F;4，大大节省了系统开销。</p>
</blockquote>
<ul>
<li><p>磁盘索引结点</p>
<p>它是指存放在磁盘上的索引结点。每个文件有一个唯一的磁盘索引结点，主要包括以下内容：</p>
<ul>
<li><strong>文件主标识符</strong>，拥有该文件的个人或小组的标识符。</li>
<li><strong>文件类型</strong>，包括普通文件、目录文件或特别文件。</li>
<li><strong>文件存取权限</strong>，各类用户对该文件的存取权限。</li>
<li><strong>文件物理地址</strong>，每个索引结点中含有13个地址项，即iaddr(0)～iaddr(12)，它们以直接或间接方式给出数据文件所在盘块的编号。</li>
<li><strong>文件长度</strong>，指以字节为单位的文件长度。</li>
<li><strong>文件链接计教</strong>，在本文件系统中所有指向该文件的文件名的指针计数。</li>
<li><strong>文件存取时间</strong>，本文件最近被进程存取的时间、最近被修改的时间及索引结点最近被修改的时间。</li>
</ul>
</li>
<li><p>内存索引结点</p>
<p>它是指存放在内存中的索引结点。当文件被打开时，要将磁盘索引结点复制到内存的索引结点中，便于以后使用。在内存索引结点中增加了以下内容：</p>
<ul>
<li><strong>索引结点编号</strong>，用于标识内存索引结点。</li>
<li><strong>状态</strong>，指示 i 结点是否上锁或被修改。</li>
<li><strong>访问计数</strong>，每当有一进程要访问此 i 结点时，计数加1；访问结束减1。</li>
<li><strong>逻辑设备号</strong>，文件所属文件系统的逻辑设备号。</li>
<li><strong>链接指针</strong>，设置分别指向空闲链表和散列队列的指针。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="4-1-3-文件的操作"><a href="#4-1-3-文件的操作" class="headerlink" title="4.1.3 文件的操作"></a>4.1.3 文件的操作</h4><ol>
<li><p>文件的基本操作</p>
<p> 文件属于抽象数据类型。为了正确地定义文件，需要考虑可以对文件执行的操作。操作系统提供系统调用，它对文件进行创建、写、读、重定位、删除和截断等操作。</p>
<ul>
<li><p><strong>创建文件（create系统调用）</strong></p>
<ul>
<li>为新文件分配必要的外存空间；</li>
<li>在目录 中为之创建一个目录项，目录项记录了新文件名、在外存中的地址及其他可能的信息。</li>
</ul>
</li>
<li><p><strong>删除文件（delete系统调用）</strong></p>
<ul>
<li>先从目录中检索指定文件名的目录项</li>
<li>然后释放该文件所占的存储空间，以便可被其他文件重复使用，并删除目录条目。</li>
</ul>
</li>
<li><p><strong>读文件（read系统调用）</strong></p>
<ul>
<li>对于给定文件名，搜索目录以查找文件位置。</li>
<li>系统维护一个读位置的指针。</li>
<li>每当发生读操作时，更新读指针。</li>
</ul>
</li>
<li><p><strong>写文件（write系统调用）</strong></p>
<ul>
<li>对于给定文件名，搜索目录以查找文件位置。</li>
<li>系统必须为该文件维护一个写位置的指针。</li>
<li>每当发生写操作时，便更新写指针。</li>
</ul>
<blockquote>
<p>一个进程通常只对一个文件读或写，因此当前操作位置可作为每个进程当前文件位置的指针。</p>
<p>由于读和写操作都使用同一指针，因此节省了空间，也降低了系统复杂度。</p>
</blockquote>
</li>
<li><p><strong>重新定位文件</strong></p>
<p>也称文件定位。搜索目录以找到适当的条目，并将当前文件位置指针重新定位到给定值。</p>
<p>重新定位文件不涉及读、写文件。</p>
</li>
<li><p><strong>截断文件</strong></p>
<p>允许文件所有属性不变，并删除文件内容，将其长度置为0并释放其空间。</p>
</li>
</ul>
<p>这6个基本操作可以组合起来执行其他文件操作。例如，一个文件的复制，可以创建新文件、从旧文件读出并写入新文件。</p>
</li>
<li><p>文件的打开与关闭</p>
<ul>
<li><p><strong>打开文件（open系统调用）</strong></p>
<ul>
<li>过程：调用open根据文件名搜索目录，将指明文件的属性（包括该文件在外存上的物理位置)，从外存复制到内存打开文件表的一个表目中，并将该表目的编号（也称索引）返回给用户。</li>
</ul>
<blockquote>
<p>打开文件时并不会把文件数据直接读入内存。“索引号”也称“文件描述符”。</p>
</blockquote>
<p>打开文件之后，对文件的操作不再需要每次都查询目录，可以根据内存中的打开文件表进行操作。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230919114840253.png" alt="image-20230919114840253"></p>
<p>如上图所示，在多个不同进程同时打开文件的操作系统中，通常采用两级表：整个系统表和每个进程表。</p>
<ul>
<li>整个系统的打开文件表包含FCB的副本及其他信息。</li>
<li>每个进程的打开文件表根据它打开的所有文件，包含指向系统表中适当条目的指针。</li>
</ul>
<p>一旦有进程打开了一个文件，系统表就包含该文件的条目。当另一个进程执行调用open时，只不过是在其文件打开表中增加一个条目，并指向系统表的相应条目。</p>
</li>
<li><p><strong>关闭文件（close系统调用）</strong></p>
<ul>
<li>1.将进程的打开文件表相应表项删除</li>
<li>2.回收分配给该文件的内存空间等资源</li>
<li>3.系统打开文件表的打开计数器count减1，若count&#x3D;0，则删除对应表项。</li>
</ul>
</li>
</ul>
<p>系统打开文件表为每个文件关联一个打开计数器（OpenCount)，以记录多少进程打开了该文件。</p>
<blockquote>
<p>文件名不必是打开文件表的一部分，因为一且完成对FCB在磁盘上的定位，系统就不再使用文件名。对于访问打开文件表的索引，UNIX称之为文件描述符，而Windows称之为文件句柄。<br>因此，只要文件未被关闭，所有文件操作就通过打开文件表来进行。</p>
</blockquote>
<ul>
<li>打开文件信息<ul>
<li><strong>文件指针</strong>。系统跟踪上次的读写位置作为当前文件位置的指针，这种指针对打开文件的某个进程来说是唯一的，因此必须与磁盘文件属性分开保存。</li>
<li><strong>文件打开计数</strong>。计数器跟踪当前文件打开和关闭的数量。因为多个进程可能打开同一个文件，所以系统在删除打开文件条目之前，必须等待最后一个进程关闭文件。</li>
<li><strong>文件磁盘位置</strong>。大多数文件操作要求系统修改文件数据。查找磁盘上的文件所需的信息保存在内存中，以便系统不必为每个操作都从磁盘上读取该信息。</li>
<li><strong>访问权限</strong>。每个进程打开文件都需要有一个访问模式（创建、只读、读写、添加等）。该信息保存在进程的打开文件表中，以便操作系统能够允许或拒绝后续的I&#x2F;O请求。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="4-1-4-文件保护"><a href="#4-1-4-文件保护" class="headerlink" title="4.1.4 文件保护"></a>4.1.4 文件保护</h4><p> 文件保护通过口令保护、加密保护和访问控制等方式实现。其中，口令和加密是为了防止用户文件被他人存取或窃取，而访问控制则用于控制用户对文件的访问方式。</p>
<ol>
<li><p>口令保护</p>
<p>为文件设置一个“口令”，用户想要访问文件时需要提供口令，由系统验证口令是否正确。</p>
<p>实现开销小，但“口令”一般存放在FCB或索引结点中（也就是存放在系统中）因此不太安全</p>
</li>
<li><p>加密保护</p>
<p>用一个“密码“对文件加密，用户想要访问文件时，需要提供相同的“密码“才能正确的解密</p>
<p>安全性高，但加密解密需要耗费一定的时间（Eg：异或加密）</p>
</li>
<li><p>访问控制</p>
<ul>
<li><p>访问类型</p>
<p>对文件的保护可从限制对文件的访问类型中出发。可加以控制的访问类型主要有以下几种。</p>
<ul>
<li>读。从文件中读。</li>
<li>写。向文件中写。</li>
<li>执行。将文件装入内存并执行。</li>
<li>添加。将新信息添加到文件结尾部分。</li>
<li>删除。删除文件，释放空间。</li>
<li>列表清单。列出文件名和文件属性。</li>
</ul>
<p>此外还可以对文件的重命名、复制、编辑等加以控制。这些高层的功能可以通过系统程序调用低层系统调用来实现。保护可以只在低层提供。</p>
</li>
<li><p>访问控制</p>
<p> 解决访问控制最常用的方法是根据用户身份进行控制。而实现基于身份访问的最为普通的方法是，为每个文件和目录增加一个访问控制列表（Access-Control List，ACL），以规定每个用户名及其所允许的访问类型。</p>
<ul>
<li>优点：可以使用复杂的访问方法，</li>
<li>缺点：长度无法预计并且可能导致复杂的空间管理，</li>
</ul>
<p>使用精简的访问列表可以解决这个问题，精简的访问列表采用拥有者、组和其他三种用户类型。</p>
<ul>
<li>拥有者。创建文件的用户。</li>
<li>组。一组需要共享文件且具有类似访问的用户。</li>
<li>其他。系统内的所有其他用户。</li>
</ul>
<p>文件主在创建文件时，说明创建者用户名及所在的组名，系统在创建文件时也将文件主的名字、所属组名列在该文件的FCB中。用户访问该文件时，</p>
<ul>
<li>若用户是文件主，按照文件主所拥有的权限访问文件；</li>
<li>若用户和文件主在同一个用户组，则按照同组权限访问，</li>
<li>否则只能按其他用户权限访问。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="4-1-5-文件的逻辑结构"><a href="#4-1-5-文件的逻辑结构" class="headerlink" title="4.1.5 文件的逻辑结构"></a>4.1.5 文件的逻辑结构</h4><p> 文件的逻辑结构是从用户观点出发看到的文件的组织形式。文件的物理结构（存储结构）是从实现观点出发看到的文件在外存上的存储组织形式。</p>
<p> 文件的逻辑结构与存储介质特性无关，它实际上是指在文件的内部，数据逻辑上是如何组织起来的。</p>
<ol>
<li><p>无结构文件（流式文件）</p>
<p>无结构文件将数据按顺序组织成记录并积累、保存，它是有序相关信息项的集合，以字节（Byte）为单位。</p>
<ul>
<li>只能通过穷举搜索的方式访问记录。</li>
<li>其管理简单，用户操作方便。</li>
<li>对基本信息单位操作不多的文件适于采用字符流的无结构文件。例如源程序文件、目标代码文件等。</li>
</ul>
</li>
<li><p>有结构文件（记录式文件）</p>
<ul>
<li><p>顺序文件</p>
<p>文件中的记录一个接一个地顺序排列（逻辑上），记录可以是定长的或可变长的。</p>
<p>各个记录在物理上可以顺序存储或链式存储。</p>
<ul>
<li><p>链式存储：无论是定长何变长记录，都无法实现随机存取，每次只能从第一个记录开始依次往后查找</p>
</li>
<li><p>顺序存储：</p>
<p>可实现随机存取，记录长度为L，则第ⅰ个记录存放的相对位置是i*L</p>
<p>若采用串结构，记录之间的顺序与关键字无关，无法快速找到某关键字对应的记录</p>
<p>若采用顺序结构，可以快速找到某关键字对应的记录（如折半查找）</p>
</li>
</ul>
<blockquote>
<p>定长记录的顺序文件，若物理上采用顺序存储，则可实现随机存取：若能再保证记录的顺序结构，则可实现快速检索（即根据关键字快速找到对应记录）</p>
</blockquote>
<p>优点：读写一大批文件时，效率最高。适用于顺序存储设备（磁带）</p>
<p>缺点：不方便增加、删除记录</p>
</li>
<li><p>索引文件</p>
<ul>
<li><p>索引表：高效查询变长记录文件。索引表本身是定长记录的顺序文件，因此可以快速找到第ⅰ个记录对应的索引项。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230920095845915.png" alt="image-20230920095845915"></p>
</li>
<li><p>方式：可将关键字作为索引号内容，若按关键字顺序排列，则还可以支持按照关键字折半查找</p>
<p>每当要增加&#x2F;删除一个记录时，需要对索引表进行修改。由于索引文件有很快的检索速度，因此主要用于对信息处理的及时性要求比较高的场合。</p>
</li>
</ul>
</li>
<li><p>索引顺序文件</p>
<p>索引顺序文件是索引文件和顺序文件思想的结合。索引顺序文件中，同样会为文件建立一张索引表，但不同的是：并不是每个记录对应一个索引表项，而是一组记录对应一个索引表项。</p>
<ul>
<li>将记录分组，每组对应一个素引表项</li>
<li>检素记录时先顺序查索引表，找到分组，再顺序查找分组</li>
<li>当记录过多时，可建立多级素引表</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230920100345089.png" alt="image-20230920100345089"></p>
<p>如上图所示，主文件名包含姓名和其他数据项。</p>
<ul>
<li>姓名为关键字，索引表中为每组的第一条记录（不是每条记录）的关键字值，用指针指向主文件中该记录的起始位置。</li>
<li>索引表只包含关键字和指针两个数据项，所有姓名关键字递增排列。</li>
<li>主文件中记录分组排列，同一个组中的关键字可以无序，但组与组之间的关键字必须有序。</li>
<li>查找一条记录时，首先通过索引表找到其所在的组，然后在该组中使用顺序查找，就能很快地找到记录。</li>
</ul>
</li>
<li><p>直接文件或散列文件（Hash File）</p>
<p> 给定记录的键值或通过散列函数转换的键值直接决定记录的物理地址。这种映射结构不同于顺序文件或索引文件，没有顺序的特性。</p>
<p> 散列文件有很高的存取速度，但是会引起冲突，即不同关键字的散列函数值相同。</p>
</li>
</ul>
</li>
</ol>
<h4 id="4-1-6-文件的物理结构"><a href="#4-1-6-文件的物理结构" class="headerlink" title="4.1.6 文件的物理结构"></a>4.1.6 文件的物理结构</h4><p> 文件的物理结构就是研究文件的实现，即文件数据在物理存储设备上是如何分布和组织的。</p>
<p> 文件分配对应于文件的物理结构，是指如何为文件分配磁盘块。常用的磁盘空间分配方法有三种：连续分配、链接分配和索引分配。</p>
<ol>
<li><p>连续分配</p>
<p>连续分配方法要求每个文件在磁盘上占有一组连续的块。磁盘地址定义了磁盘上的一个线性排序，这种排序使作业访问磁盘时需要的寻道数和寻道时间最小。</p>
<ul>
<li>物理块号&#x3D;起始块号+逻辑块号</li>
<li>优点：支持顺序访问和直接访问（即随机访问）；连续分配的文件在顺序访问时速度最快。</li>
<li>缺点：不方便文件拓展、存储空间利用率低、会产生磁盘碎片（外部碎片）。<ul>
<li>①文件长度不宜动态增加，因为一个文件末尾后的盘块可能已分配给其他文件，一旦需要增加，就需要大量移动盘块。</li>
<li>②为保持文件的有序性，删除和插入记录时，需要对相邻的记录做物理上的移动，还会动态改变文件的长度。</li>
<li>③反复增删文件后会产生外部碎片（与内存管理分配方式中的碎片相似）。</li>
<li>④很难确定一个文件需要的空间大小，因而只适用于长度固定的文件。</li>
</ul>
</li>
<li>访存次数：访问第n条记录需访问磁盘1次</li>
</ul>
</li>
<li><p>链接分配</p>
<p>链接分配采取离散分配的方式，可以为文件分配离散的磁盘块。分为隐式链接和显式链接两种。</p>
<p>访问第n条记录需访问磁盘n次</p>
<ul>
<li><p>隐式链接</p>
<p>除文件的最后一个盘块之外，每个盘块中都存有指向下一个盘块的指针。文件目录包括文件第一块的指针和最后一块的指针。</p>
<ul>
<li>优点：很方便文件拓展，不会有碎片问题，外存利用率高。</li>
<li>缺点：只支持顺序访问，不支持随机访问，查找效率低，指向下一个盘块的指针也需要耗费少量的存储空间。</li>
<li>结论：采用隐式链接的链接分配方式，很方便文件拓展。另外，所有的空闲磁盘块都可以被利用，不会有碎片问题，外存利用率高</li>
</ul>
</li>
<li><p>显式链接</p>
<p>把用于链接文件各物理块的指针显式地存放在文件分配表（FAT）中。一个磁盘只会建立一张文件分配表。开机时文件分配表放入内存，并常驻内存。</p>
<ul>
<li>优点：很方便文件拓展，不会有碎片问题，外存利用率高，并且支持随机访问。相比于隐式链接来说，地址转换时不需要访问磁盘，因此文件的访问效率更高。</li>
<li>缺点：文件分配表的需要占用一定的存储空间。</li>
<li>结论：采用链式分配（显式链接）方式的文件，支持顺序访问，也支持随机访问（想访问ⅰ号逻辑块时，并不需要依次访问之前的0~ｉ-1号逻辑块），由于块号转换的过程不需要访问磁盘，因此相比于隐式链接来说，访问速度快很多。</li>
</ul>
</li>
<li><p><strong>文件分配表</strong>：FAT不仅记录了文件分配信息（显示链接），还“兼职”做了空闲块管理</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230920103528057.png" alt="image-20230920103528057"></p>
</li>
</ul>
</li>
<li><p>索引分配</p>
<p> 索引分配允许文件离散地分配在各个磁盘块中，系统会为每个文件建立一张索引表，索引表中记录了文件的各个逻辑块对应的物理块。索引表存放的磁盘块称为索引块。文件数据存放的磁盘块称为数据块。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/0a98951136ab4d348376f0bfdb20fd61.png" alt="img"></p>
<blockquote>
<p>索引表的 逻辑块号 可以是隐含的，进一步节约空间；</p>
</blockquote>
<ul>
<li><p>链接方案</p>
<p>如果索引表太大，一个索引块装不下，那么可以将多个索引块链接起来存放。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/976b1da9f7334755956429610f98eb56.png" alt="img"></p>
<p>缺点：需要顺序访问，当文件很大时，查我效率低下</p>
</li>
<li><p>多层索引</p>
<p>建立多层索引（原理类似于多级页表）。使第一层索引块指向第二层的索引块。还可根据文件大小的要求再建立第三层、第四层索引块。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/f241b98d0efd44f781d5b6bab1274f48.png" alt="img"></p>
<p>采用K层索引结构，且顶级索引表未调入内存，则访问一个数据块只需要K+1次读磁盘操作</p>
<p>缺点：即使是小文件，访问数据块也需受K+1次读磁盘</p>
</li>
<li><p>混合索引</p>
<p>多种索引分配方式的结合。例如，一个文件的顶级索引表中，既包含直接地址索引（直接指向数据块），又包含一级间接索引（指向单层索引表）、还包含两级间接索引（指向两层索引表）。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/3c0e2e9e2293438a8f04ccf0557fa50e.png" alt="img"></p>
<p>所允许的文件最大长度：设有N0个直接地址项；N1个一次间接地址项；N2个二次间接地址项；每个盘块大小M字节；盘块号占m个字节，公式如下：<br>$$<br>文件最大长度&#x3D;(N_0 + N_1·\frac{M}{m}+N_2·(\frac{M}{m})^2)·M<br>$$<br>优点：对于小文件，只需较少的读磁盘次数就可以访问目标数据块。（一般计算机中小文件更多）</p>
</li>
<li><p>总结</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/e4cbd52e0f934cf296bd2ace1d87ac5b.png" alt="img"></p>
</li>
</ul>
</li>
</ol>
<h3 id="4-2-目录"><a href="#4-2-目录" class="headerlink" title="4.2 目录"></a>4.2 目录</h3><h4 id="4-2-1-目录的基本概念"><a href="#4-2-1-目录的基本概念" class="headerlink" title="4.2.1 目录的基本概念"></a>4.2.1 目录的基本概念</h4><p> 文件目录指FCB的有序集合，一个FCB就是一个文件的目录项。与文件管理系统和文件集合相关联的是文件目录，它包含有关文件的属性、位置和所有权等。</p>
<ul>
<li>目录管理的基本要求：<ul>
<li>从用户的角度看，目录在用户（应用程序）所需要的文件名和文件之间提供一种映射，所以目录管理要实现“按名存取”；</li>
<li>目录存取的效率直接影响到系统的性能，所以要提高对目录的检索速度；</li>
<li>在多用户系统中，应允许多个用户共享一个文件，因此目录还需要提供用于控制访问文件的信息。</li>
<li>此外，应允许不同用户对不同文件采用相同的名字，以便于用户按自己的习惯给文件命名，目录管理通过树形结构来解决和实现。</li>
</ul>
</li>
</ul>
<h4 id="4-2-2-目录结构"><a href="#4-2-2-目录结构" class="headerlink" title="4.2.2 目录结构"></a>4.2.2 目录结构</h4><ol>
<li><p>单级目录结构</p>
<p>在整个文件系统中只建立一张目录表，每个文件占一个目录项，不允许文件重名，如下图所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230920114101960.png" alt="image-20230920114101960"></p>
<p>当访问一个文件时，先按文件名在该目录中查找到相应的FCB，经合法性检查后执行相应的操作。</p>
<p>当建立一个新文件时，必须先检索所有目录项，以确保没有“重名”的情况，然后在该目录中增设一项，把新文件的属性信息填入到该项中。</p>
</li>
<li><p>两级目录结构</p>
<p> 将文件目录分成主文件目录（MFD）和用户文件目录（UFD）两级，不同用户的文件可以重名，但不能对文件分类。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230920114603663.png" alt="image-20230920114603663"></p>
<p>主文件目录项记录用户名及相应用户文件目录所在的存储位置。</p>
<p>用户文件目录项记录该用户文件的FCB信息。</p>
</li>
<li><p>树形目录结构</p>
<p>不同目录下的文件可以重名，可以对文件进行分类，不方便共享。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230920114906657.png" alt="image-20230920114906657"></p>
<p>根据“文件路径”找到目标文件。用户（或用户进程）要访问某个文件时要用文件路径名标识文件，文件路径名是个字符串。各级日录之间用“&#x2F;”隔开。从根目录出发的路径称为绝对路径。</p>
<blockquote>
<p>例如：自拍.jpg的绝对路径是“&#x2F;照片&#x2F;2015-08&#x2F;自拍jpg”</p>
<p>系统根据绝对路径一层一层地找到下一级目录。刚开始从外存读入根目录的目录表；找到“照片”目录的存放位置后，从外存读入对应的目录表；再找到“2015-08”目录的存放位置，再从外存读入对应目录表；最后才找到文件“自拍Jpg”的存放位置。整个过程需要3次读磁盘I&#x2F;O操作。</p>
</blockquote>
<p>引入“当前目录”和“相对路径”后，磁盘I&#x2F;O的次数减少了。这就提升了访问文件的效率。</p>
<p>从根目录出发是绝对路径；从当前目录出发是相对路径。</p>
</li>
<li><p>无环图目录结构</p>
<p>在树形目录的基础上，增加一些指向同一结点的有向边，使整个目录成为一个有向无环图，实现文件的共享。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230920134102332.png" alt="image-20230920134102332"></p>
<p>为共享结点设置一个共享计数器，计数器为0时才真正删除该结点。</p>
<p>对于共享文件，只存在一个真正的文件，任何改变都会为其他用户所见。</p>
</li>
</ol>
<h4 id="4-2-3-目录的操作"><a href="#4-2-3-目录的操作" class="headerlink" title="4.2.3 目录的操作"></a>4.2.3 目录的操作</h4><ul>
<li><strong>搜索</strong>。当用户使用一个文件时，需要搜索目录，以找到该文件的对应目录项。</li>
<li><strong>创建文件</strong>。当创建一个新文件时，需要在目录中增加一个目录项。</li>
<li><strong>删除文件</strong>。当删除一个文件时，需要在目录中删除相应的目录项。</li>
<li><strong>创建目录</strong>。在树形目录结构中，用户可创建自己的用户文件目录，并可再创建子目录。</li>
<li><strong>删除目录</strong>。有两种方式：①不删除非空目录，删除时要先删除目录中的所有文件，并递归地删除子目录。②可删除非空目录，目录中的文件和子目录同时被删除。</li>
<li><strong>移动目录</strong>。将文件或子目录在不同的父目录之间移动，文件的路径名也会随之改变。</li>
<li><strong>显示目录</strong>。用户可以请求显示目录的内容，如显示该用户目录中的所有文件及属性。</li>
<li><strong>修改目录</strong>。某些文件属性保存在目录中，因而这些属性的变化需要改变相应的目录项。</li>
</ul>
<h4 id="4-2-4-目录实现"><a href="#4-2-4-目录实现" class="headerlink" title="4.2.4 目录实现"></a>4.2.4 目录实现</h4><p> 目录实现有线性列表和哈希表两种方式，线性列表实现对应线性查找，哈希表的实现对应散列查找。</p>
<ol>
<li><p>线性列表</p>
<p>最简单的目录实现方法是，采用文件名和数据块指针的线性列表。</p>
<ul>
<li><p>当创建新文件时，必须首先搜索目录以确定没有同名的文件存在，然后在目录中增加一个新的目录项。</p>
</li>
<li><p>当删除文件时，则根据给定的文件名搜索目录，然后释放分配给它的空间。</p>
</li>
<li><p>当要</p>
<p>重用目录项</p>
<p>时有许多种方法：</p>
<ul>
<li>可以将目录项标记为不再使用，或将它加到空闲目录项的列表上，</li>
<li>还可以将目录的最后一个目录项复制到空闲位置，并减少目录的长度。</li>
</ul>
</li>
</ul>
<p>采用链表结构可以减少删除文件的时间。</p>
<p>线性列表的优点在于实现简单，不过由于线性表的特殊性，查我比较费时。</p>
</li>
<li><p>哈希表</p>
<p>哈希表根据文件名得到一个值，并返回一个指向线性列表中元素的指针。</p>
<ul>
<li>优点：查找非常迅速，插入和删除也较简单，</li>
<li>问题：需要一些措施来避免冲突（两个文件名称哈希到同一位置）。</li>
</ul>
</li>
</ol>
<p> 为了减少I&#x2F;O操作，把当前使用的文件目录复制到内存，以后要使用该文件时只需在内存中操作，因此降低了磁盘操作次数，提高了系统速度。</p>
<h4 id="4-2-5-文件共享"><a href="#4-2-5-文件共享" class="headerlink" title="4.2.5 文件共享"></a>4.2.5 文件共享</h4><p> 文件共享使多个用户共享同一个文件，系统中只需保留该文件的一个副本。</p>
<ol>
<li><p>基于索引结点的共享方式（硬链接）</p>
<p>各个用户的目录项指向同一个索引结点，索引结点中需要链接计数count，用于表示链接到本索引结点上的用户目录项数。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230920140425794.png" alt="image-20230920140425794"></p>
<p>某用户删除文件只是删除该用户的目录项，count–</p>
<p>只有count&#x3D;&#x3D;0才能真正删除文件数据和索引结点。</p>
</li>
<li><p>利用符号链实现文件共享（软链接）</p>
<p>为使用户B能共享用户A的一个文件F,可以由系统创建一个LINK类型的新文件，也取名为F，并将该文件写入用户B的目录中，以实现用户B的目录与文件F的链接。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230920140838755.png" alt="image-20230920140838755"></p>
<p>在一个Link型的文件中记录共享文件的存放路径（Windows快捷方式），操作系统根据路径一层层查找目录，最终找到共享文件。</p>
<blockquote>
<p>当User3访问“ccc”时，操作系统判断文件“ccc”属于Link类型文件，于是会根据其中记录的路径层层查找目录，最终找到User1的目录表中的“aaa”表项，于是就找到了文件1的索引结点。</p>
</blockquote>
<p>即使软链接指向的共享文件已被删除，Link型文件依然存在，只是通过Link型文件中的路径去查找共享文件会失败（找不到对应目录项）。</p>
<p>由于用软链接的方式访问共享文件时要查询多级目录，会有多次磁盘I&#x2F;O，因此用软链接访问的速度要比硬链接更慢。</p>
</li>
</ol>
<p> 硬链接和软链接都是文件系统中的静态共享方法，在文件系统中还存在着另外的共享需求，即两个进程同时对同一个文件进行操作，这样的共享称为动态共享。</p>
<h3 id="4-3-文件系统"><a href="#4-3-文件系统" class="headerlink" title="4.3 文件系统"></a>4.3 文件系统</h3><h4 id="4-3-1-文件系统结构"><a href="#4-3-1-文件系统结构" class="headerlink" title="4.3.1 文件系统结构"></a>4.3.1 文件系统结构</h4><p> 文件系统(File system)提供高效和便捷的磁盘访问，以便允许存储、定位、提取数据。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/81e5fc0bafd94c1780f0e4302f4bfc50.png" alt="img"></p>
<p>用一个例子来辅助记忆文件系统的层次结构：<br>假设某用户请求删除文件”D:&#x2F;工作目录&#x2F;学生信息.xIsx”的最后100条记录。</p>
<ol>
<li>用户需要通过操作系统提供的接口发出上述请求一一用户接口</li>
<li>由于用户提供的是文件的存放路径，因此需要操作系统一层一层地查找目录，找到对应的目录项一一文件目录系统</li>
<li>不同的用户对文件有不同的操作权限，因此为了保证安全，需要检查用户是否有访问权限一一存取控制模块（存取控制验证层）</li>
<li>验证了用户的访问权限之后，需要把用户提供的“记录号”转变为对应的逻辑地址一一逻辑文件系统与文件信息缓冲区</li>
<li>知道了标记录对应的逻辑地址后，还需要转换成实际的物理地址一一物理文件系统</li>
<li>要删除这条记录，必定要对磁盘设备发出请求一一设备管理程序模块</li>
<li>删除这些记录后，会有一些盘块空闲，因此要将这些空闲盘块回收一一辅助分配模块</li>
</ol>
<h4 id="4-3-2-文件系统布局"><a href="#4-3-2-文件系统布局" class="headerlink" title="4.3.2 文件系统布局"></a>4.3.2 文件系统布局</h4><ol>
<li><p>文件系统在磁盘中的结构</p>
<p> 文件系统存放在磁盘上，多数磁盘划分为一个或多个分区，每个分区中有一个独立的文件系统。文件系统可能包括如下信息：启动存储在那里的操作系统的方式、总的块数、空闲块的数量和位置、目录结构以及各个具体文件等。如下图所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230920143351257.png" alt="image-20230920143351257"></p>
<ul>
<li><p>**主引导记录（MasterBootRecord，MBR)**，位于磁盘的0号扇区，用来引导计算机，MBR后面是分区表，该表给出每个分区的起始和结束地址。表中的一个分区被标记为活动分区，当计算机启动时，BIOS读入并执行MBR。MBR做的第一件事是确定活动分区，读入它的第一块，即引导块。</p>
</li>
<li><p>**引导块（bootblock)**，MBR执行引导块中的程序后，该程序负责启动该分区中的操作系统。为统一起见，每个分区都从一个引导块开始，即使它不含有一个可启动的操作系统，也不排除以后会在该分区安装一个操作系统。Windows系统称之为分区引导扇区。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/c237ab8ed54f45d396996f02e460113b.png" alt="img"></p>
<p>除了从引导块开始，磁盘分区的布局是随着文件系统的不同而变化的。文件系统经常包含有如上图所列的一些项目。</p>
</li>
<li><p>**超级块（superblock)**，包含文件系统的所有关键信息，在计算机启动时，或者在该文件系统首次使用时，超级块会被读入内存。超级块中的典型信息包括分区的块的数量、块的大小、空闲块的数量和指针、空闲的FCB数量和FCB指针等。</p>
</li>
<li><p><strong>文件系统中空闲块的信息</strong>，可以使用位示图或指针链接的形式给出。</p>
</li>
<li><p><strong>i 结点</strong>。索引结点，连续存放，每个文件对应一个结点，可以把 i 结点区看成一个大数组；</p>
</li>
<li><p><strong>根目录</strong>，它存放文件系统目录树的根部。</p>
</li>
<li><p><strong>其他部分</strong>，存放了其他所有的目录和文件。</p>
</li>
</ul>
</li>
<li><p>文件系统在内存中的结构</p>
<p> 内存中的信息用于管理文件系统并通过缓存来提高性能。这些数据在安装文件系统时被加载，在文件系统操作期间被更新，在卸载时被丢弃。这些结构的类型可能包括：</p>
<ul>
<li>**内存中的安装表(mount table)**，包含每个己安装文件系统分区的有关信息。</li>
<li><strong>内存中的目录结构的缓存</strong>，包含最近访问目录的信息。对安装分区的目录，它可以包括一个指向分区表的指针。</li>
<li><strong>整个系统的打开文件表</strong>，包含每个打开文件的FCB副本及其他信息。</li>
<li><strong>每个进程的打开文件表</strong>，包含一个指向整个系统的打开文件表中的适当条目的指针，以及其他信息。</li>
</ul>
<p><strong>进程创建：</strong></p>
<p> 为了创建新的文件，应用程序调用逻辑文件系统。逻辑文件系统知道目录结构的格式，它将为文件分配一个新的FCB。然后，系统将相应的目录读入内存，使用新的文件名和FCB进行更新，并将它写回磁盘。</p>
<p>一旦文件被创建，它就能用于I&#x2F;O，不过，首先要打开文件。系统调用open()将文件名传递给逻辑文件系统。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/dde627283c6e4edd9bbba2670d4c5ad7.png" alt="img"></p>
<ul>
<li><p>调用open()首先</p>
<p>搜索整个系统的打开文件表</p>
<p>，以确定这个文件是否已被其他进程使用。</p>
<ul>
<li>如果<strong>已被使用</strong>，则在单个进程的打开文件表中创建一个条目，让其指向现有整个系统的打开文件表的相应条目。该算法在文件已打开时，能节省大量开销。</li>
<li>如果这个文件<strong>尚未打开</strong>，则根据给定文件名来搜索目录结构。部分目录结构通常缓存在内存中，以加快目录操作。</li>
</ul>
</li>
<li><p>找到文件后，它的FCB会复制到整个系统的打开文件表中；该表不但存储FCB，而且跟踪打开该文件的进程的数量。</p>
</li>
<li><p>然后，在单个进程的打开文件表中创建一个条目，并且通过指针将整个系统打开文件表的条目与其他域（如文件当前位置的指针和文件访问模式等）相连。</p>
</li>
<li><p>调用open()返回的是一个指向单个进程的打开文件表中的适当条自的指针。以后，所有文件操作都通过该指针执行。</p>
</li>
<li><p>一旦文件被打开，内核就不再使用文件名来访问文件，而使用文件描述符（Windows称之为文件句柄）</p>
</li>
</ul>
<p><strong>进程关闭：</strong></p>
<p> 当进程关闭一个文件时，就会删除单个进程打开文件表中的相应条目，整个系统的打开文件表的文件打开数量也会递减。当所有打开某个文件的用户都关闭该文件后，任何更新的元数据将复制到磁盘的目录结构中，并且整个系统的打开文件表的对应条目也会被删除。</p>
</li>
</ol>
<h4 id="4-3-3-外存空闲空间管理"><a href="#4-3-3-外存空闲空间管理" class="headerlink" title="4.3.3 外存空闲空间管理"></a>4.3.3 外存空闲空间管理</h4><p> 一个存储设备可以按整体用于文件系统，也可以细分。例如，一个磁盘可以划分为4个分区，每个分区都可以有单独的文件系统。包含文件系统的分区通常称为卷（volumme)。卷可以是磁盘的一部分，也可以是整个磁盘，还可以是多个磁盘组成RAID集，如图所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230920152153475.png" alt="image-20230920152153475"></p>
<p> 在一个卷中，存放文件数据的空间（文件区）和FCB的空间（目录区）是分离的。</p>
<p> 文件存储设备分成许多大小相同的物理块，并以块为单位交换信息，因此，文件存储设备的管理实质上是对空闲块的组织和管理，它包括空闲块的组织、分配与回收等问题。</p>
<ol>
<li><p>空闲表法</p>
<p>空闲表法属于连续分配方式，它与内存的动态分配方式类似，为每个文件分配一块连续的存储空间。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/93dd888cea6b48c99149a8f3a8383581.png" alt="img"></p>
<ul>
<li><p>盘块的分配</p>
<p>与内存管理中的动态分区分配很类似，为一个文件分配连续的存储空间。</p>
<p>同样可采用首次适应、最佳适应、最坏适应等算法来决定要为文件分配哪个区间。</p>
</li>
<li><p>盘块的回收</p>
<p>与内存管理中的动态分区分配很类似，当回收某个存储区时需要有四种情况：</p>
<ul>
<li>①回收区的前后都没有相邻空闲区</li>
<li>②回收区的前后都是空闲区</li>
<li>③回收区前面是空闲区</li>
<li>④回收区后面是空闲区</li>
</ul>
<p>总之，回收时需要注意表项的合并问题</p>
</li>
</ul>
</li>
<li><p>空闲链表法</p>
<p>将所有空闲盘区拉成一条空闲链。根据构成链所用基本元素的不同，分为两种形式：</p>
<ul>
<li><p>空闲盘块链：将磁盘上的所有空闲空间以盘块为单位拉成一条链。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/a5cfd4f93acb44e6a4ee4090ad9c3463.png" alt="img"></p>
<p>操作系统保存着链头、链尾指针。</p>
<ul>
<li>如何分配：若某文件申请K个盘块，则从链头开始依次摘下K个盘块分配，并修改空闲链的链头指针。</li>
<li>如何回收：回收的盘块依次挂到链尾，并修改空闲链的链尾指针。</li>
</ul>
<p>适用于离散分配的物理结构。为文件分配多个盘块时可能要重复多次操作</p>
</li>
<li><p>空闲盘区链：将磁盘上的所有空闲盘区（每个盘区可包含若干个盘块）拉成一条链。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/5b4399a136fb42f789c07166813e9282.png" alt="img"></p>
<p>操作系统保存着链头、链尾指针。</p>
<ul>
<li><p>如何分配：</p>
<p>若某文件申请K个盘块，则可以采用首次适应、最佳适应等算法，从链头开始检索，按照算法规则找到一个大小符合要求的空闲盘区，分配给文件。</p>
<p>若没有合适的连续空闲块，也可以将不同盘区的盘块同时分配给一个文件，注意分配后可能要修改相应的链指针、盘区大小等数据。</p>
</li>
<li><p>如何回收：若回收区和某个空闲盘区相邻，则需要将回收区合并到空闲盘区中。若回收区没有和任何空闲区相邻，将回收区作为单独的一个空闲盘区挂到链尾。</p>
</li>
</ul>
<p>离散分配、连续分配都适用。为一个文件分配多个盘块时效率更高。</p>
</li>
</ul>
</li>
<li><p>位示图法</p>
<p> 位示图是利用二进制的一位来表示磁盘中一个盘块的使用情况，磁盘上所有的盘块都有一个二进制位与之对应。当其值为“0”时，表示对应的盘块空闲；为“1”时，表示已分配。</p>
<p> 这样，一个m×n位组成的位示图就可用来表示m×n个盘块的使用情况，如图所示。行为位号，列为字号</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230920153912806.png" alt="image-20230920153912806"></p>
<blockquote>
<p>注意：盘块号、字号、位号到底是从0开始，还是从1开始。两者计算盘块号方式不同。</p>
</blockquote>
<ul>
<li>盘块的分配<ul>
<li>顺序扫描位示图，从中找出一个或一组其值为“0”的二进制位。</li>
<li>将找到的一个或一组二进制位，转换成与之对应的盘块号。若找到的其值为“0”的二进制位位于位示图的第i行、第j列，则其相应的盘块号应按下式计算（n为每行位数）：<br>$$<br>\begin{cases}b&#x3D;n(i-1)+j, &amp; \text{字、位、盘块号从1开始}<br>b&#x3D;ni+j&amp; \text{字、位、盘块号从0开始}\end{cases}<br>$$</li>
<li>修改位示图，令$map[i,j]&#x3D;1$</li>
</ul>
</li>
<li>盘块的回收<ul>
<li>将回收盘块的盘块号转换成位示图中的行号和列号。转换公式为<br>$$<br>\begin{cases}i&#x3D;(b-1)&#x2F;n+1;j&#x3D;(b-1)% n+1, &amp; \text{字、位、盘块号从1开始}<br>i&#x3D;b&#x2F;n;j&#x3D;b% n, &amp; \text{字、位、盘块号从0开始}\end{cases}<br>$$</li>
<li>修改位示图，令$map[i,j]&#x3D;0$。</li>
</ul>
</li>
</ul>
<p>空闲表法和空闲链表法都不适用于大型文件系统，因为这会使空闲表或空闲链表太大。</p>
</li>
<li><p>成组链接法</p>
<p> 在UNIX系统中采用的是成组链接法，这种方法结合了空闲表和空闲链表两种方法，它具有上述两种方法的优点，克服了两种方法均有的表太长的缺点。</p>
<p> 文件卷的目录区中专门用一个磁盘块作为“超级块”，当系统启动时需要将超级块读入内存。并且要保<br>证内存与外存中的“超级块”数据一致。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/f5ec3f528eff44cc93ab2a804ffd73ab.png" alt="img"></p>
<p>用来存放一组空闲盘块号（空闲盘块的块号）的盘块称为成组链块。</p>
<ul>
<li><p><strong>成组链接思想</strong>：把顺序的n个空闲盘块号保存在第一个成组链块中，其最后一个空闲盘块（作为成组链块）则用于保存另一组空闲盘块号，如此继续，直至所有空闲盘块均予以链接。</p>
</li>
<li><p>盘块的分配</p>
<p><strong>分配1个空闲块</strong>：</p>
<ul>
<li>①检查第一个分组的块数是否足够。1＜100，是足够的。</li>
<li>②分配第一个分组中的1个空闲块，并修改相应数据</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/c25a6835e1f145e9a9f45c8590e26aff.png" alt="img"></p>
<p><strong>分配100个空闲块</strong>：</p>
<ul>
<li>①检查第一个分组的块数是否足够。100&#x3D;100，是足够的。</li>
<li>②分配第一个分组中的100个空闲块。但是由于300号块内存放了再下一组的信息，因此300号块的数据需要复制到超级块中</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/5042968c565b49ee955245784c5f5581.png" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/23e43a6a09a1454c81b5859c93b40cfa.png" alt="img"></p>
</li>
<li><p>盘块的回收</p>
<p>需要将超级块中的数据复制到新回收的块中，并修改超级块的内容，让新回收的块成为第一个分组。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/5daaee59628e44c7a7e8fddd7898c903.png" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/05001072ac594a3e87f570af49c7a259.png" alt="img"></p>
</li>
</ul>
</li>
</ol>
<h4 id="4-3-4-虚拟文件系统"><a href="#4-3-4-虚拟文件系统" class="headerlink" title="4.3.4 虚拟文件系统"></a>4.3.4 虚拟文件系统</h4><p> 虚拟文件系统（VFS）为用户程序提供了文件系统操作的统一接口，屏蔽了不同文件系统的差异和操作细节。</p>
<ol>
<li><p>普通文件系统</p>
<p> 下图普通的文件系统，不同的外部存储设备，它的文件系统可能是不相同的，对于同一个操作的函数方法定义也许也各不相同；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/101097bd7cd54bb7a124846abb561dfa.png" alt="img"></p>
</li>
<li><p>虚拟文件系统</p>
<p> 下图为虚拟文件系统，用户程序可以通过VFS提供的统一调用函数（如open()等）来操作不同文件系统的文件，而无须考虑具体的文件系统和实际的存储介质。</p>
<p> 虚拟文件系统采用了面向对象的思想，它抽象出一个通用的文件系统模型，定义了通用文件系统都支持的接口。新的文件系统只要支持并实现这些接口，即可安装和使用。</p>
<p> 为了实现VFS，Linux主要抽象了四种对象类型。每个VFS对象都存放在一个适当的数据结构中，其中包括对象的属性和指向对象方法（函数）表的指针。</p>
<ul>
<li>超级块对象：表示一个已安装（或称挂载）的特定文件系统。</li>
<li>索引结点对象：表示一个特定的文件。</li>
<li>目录项对象：表示一个特定的目录项。</li>
<li>文件对象：表示一个与进程相关的已打开文件。</li>
</ul>
<p>进程与VFS对象之间的交互如下图所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230920163914222.png" alt="image-20230920163914222"></p>
<blockquote>
<p>三个不同的进程已打开了同一个文件，其中两个进程使用同一个硬链接。</p>
<p>在这种情况下，每个进程都使用自己的文件对象，但只需要两个目录项对象，每个硬链接对应一个目录项对象。这两个目录项对象指向同一个索引结点对象, 这个索引结点对象标识的是超级块对象及随后的普通磁盘文件。</p>
</blockquote>
<p> 对于不同文件系统的数据结构，VFS 在每打开一个文件，就在主存建立一个vnode，用统一的数据结构表示文件；</p>
<p>打开文件后，创建vnode，并将文件信息复制到vnode中，vnode的功能指针指向具体文件系统的函数功能</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/146a6f2e812b416b9131a7042e879a4b.png" alt="img"></p>
<blockquote>
<p>vnode只存在于主存中，而inode既会被调入主存，也会在外存中存储</p>
</blockquote>
<p><strong>特点：</strong></p>
<ul>
<li>①向上层用户进程提供统一标准的系统调用接口，屏蔽底层具体文件系统的实现差异</li>
<li>②VFS要求下层的文件系统必须实现某些规定的函数功能，如：open&#x2F;read&#x2F;write。一个新的文件系统想要在某操作系统上被使用，就必须满足该操作系统VFS的要求</li>
<li>③每打开一个文件，VFS就在主存中新建一个vnode，用统一的数据结构表示文件，无论该文件存储在哪个文件系统</li>
</ul>
</li>
</ol>
<h4 id="4-3-5-分区和安装"><a href="#4-3-5-分区和安装" class="headerlink" title="4.3.5 分区和安装"></a>4.3.5 分区和安装</h4><ol>
<li><p>分区</p>
<ul>
<li><p>物理格式化（低级格式化）：划分扇区、检测坏扇区、用备用扇区替换坏扇区；当要访问某一块坏扇区时，会使用备用扇区，默默完成替换工作；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/bb2de2422d474017b034aab701652aab.png" alt="img"></p>
</li>
<li><p>逻辑格式化（高级格式化）：磁盘分区；每个区的大小、地址范围等信息，会使用 分区表 来记录；</p>
<p>在每个区里可以建立各自独立的文件系统 ，例如在C盘里建立UNIZX文件系统；</p>
<p>分区的第一部分是引导块，里面存储着引导信息，它有自身的格式，因为在引导时系统并未 加载文件系统代码，因此不能解释文件系统的格式。下图为一个典型的Linux分区。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230920164945003.png" alt="image-20230920164945003"></p>
</li>
</ul>
</li>
<li><p>安装</p>
<p>文件系统在进程使用前必须先安装，也称挂载，任务是将一个文件系统挂载到操作系统中。</p>
<p><strong>功能：</strong></p>
<ul>
<li>①在VFS中注册新挂载的文件系统。内存中的挂载表（mount table）包含每个文件系统的相关信息，包括文件系统类型、容量大小等。</li>
<li>②新挂载的文件系统，要向VFS提供一个函数地址列表</li>
<li>③将新文件系统加到挂载点（mountpoint），也就是将新文件系统挂载在某个父目录下</li>
</ul>
<blockquote>
<p>UNIX本身是一个固定的目录树，只要安装就有，但是如果不给它分配存储空间，就不能对它进行操作，所以首先要给根目录分配空间，这样才能操作这个目录树。</p>
</blockquote>
</li>
</ol>
<h2 id="5-输入-输出（I-O）管理"><a href="#5-输入-输出（I-O）管理" class="headerlink" title="5 输入&#x2F;输出（I&#x2F;O）管理"></a>5 输入&#x2F;输出（I&#x2F;O）管理</h2><h3 id="5-1-I-O管理概述"><a href="#5-1-I-O管理概述" class="headerlink" title="5.1 I&#x2F;O管理概述"></a>5.1 I&#x2F;O管理概述</h3><h4 id="5-1-1-I-O设备"><a href="#5-1-1-I-O设备" class="headerlink" title="5.1.1 I&#x2F;O设备"></a>5.1.1 I&#x2F;O设备</h4><p> I&#x2F;O设备是将数据输入到计算机中，或者可以接收计算机输出数据的外部设备，属于计算机中的硬件部件；</p>
<ol>
<li><p>设备的分类</p>
<ul>
<li>按使用特性分类：<ul>
<li>人机交互类外部设备：鼠标、键盘、打印机等，用于人机交互。数据传输速度慢。</li>
<li>存储设备：移动硬盘、光盘等，用于数据存储。数据传输速度快。</li>
<li>网络通信设备：调制解调器等，用于网络通信。数据传输速度介于上述二者之间。</li>
</ul>
</li>
<li>按信息交换的单位分类：<ul>
<li>块设备。信息交换以数据块为单位。它属于有结构设备，如磁盘等。磁盘设备的基本特征是传输速率较高、可寻址，即对它可随机地读&#x2F;写任意一块。</li>
<li>字符设备。信息交换以字符为单位。它属于无结构类型，如交互式终端机、打印机等。</li>
</ul>
</li>
<li>按传输速率分类：<ul>
<li>低速设备。传输速率仅为每秒几字节到数百字节的一类设备，如键盘、鼠标等。</li>
<li>中速设备。传输速率为每秒数千字节至数万字节的一类设备，如激光打印机等。</li>
<li>高速设备。传输速率在数百千字节至千兆字节的一类设备，如磁盘机、光盘机等。</li>
</ul>
</li>
</ul>
</li>
<li><p>I&#x2F;O接口</p>
<p> I&#x2F;O接口（设备控制器）位于CPU与设备之间，它既要与CPU通信，又要与设备通信，还要具有按CPU发来的命令去控制设备工作的功能，主要由三部分组成，如下图所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230921092426001.png" alt="image-20230921092426001"></p>
<ul>
<li><p>组成部分：</p>
<ul>
<li><p><strong>设备控制器与CPU的接口</strong>：实现控制器与CPU之间的通信</p>
<p>该接口有三类信号线：数据线、地址线和控制线。</p>
<p>数据线与两类寄存器相连：数据寄存器（存放从设备送来的输入数据或从CPU送来的输出数据）和控制&#x2F;状态寄存器（存放从CPU送来的控制信息或设备的状态信息）。</p>
</li>
<li><p><strong>设备控制器与设备的接口</strong>：实现控制器与设备之间的通信</p>
<p>一个设备控制器可以连接一个或多个设备，因此控制器中有一个或多个设备接口。</p>
<p>每个接口中都存在数据、控制和状态三种类型的信号。</p>
</li>
<li><p><strong>I&#x2F;O逻辑</strong>：负责识别CPU发出的命令，并向设备发出命令</p>
<p>用于实现对设备的控制。它通过一组控制线与CPU交互，对从CPU收到的I&#x2F;O命令进行译码。</p>
<p>CPU启动设备时，将启动命令发送给控制器，同时通过地址线把地址发送给控制器，由控制器的I&#x2F;O逻辑对地址进行译码，并相应地对所选设备进行控制。</p>
</li>
</ul>
</li>
<li><p>主要功能：</p>
<ul>
<li>接受和识别CPU发出的指令（控制寄存器）</li>
<li>向CPU报告设备的状态（状态寄存器）</li>
<li>数据交换（数据寄存器暂存数据）</li>
<li>地址识别（由I&#x2F;O逻辑实现）</li>
<li>数据缓冲</li>
<li>差错控制</li>
</ul>
</li>
</ul>
</li>
<li><p>I&#x2F;O端口</p>
<p>I&#x2F;O端口是指设备控制器中可被CPU直接访问的寄存器，主要有以下三类寄存器。</p>
<ul>
<li><p>寄存器类型：</p>
<ul>
<li><strong>数据寄存器</strong>：实现CPU和外设之间的数据缓冲。</li>
<li><strong>状态寄存器</strong>：获取执行结果和设备的状态信息，以让CPU知道是否准备好。</li>
<li><strong>控制寄存器</strong>：由CPU写入，以便启动命令或更改设备模式。</li>
</ul>
</li>
<li><p>实现I&#x2F;O端口通信，有两种编址方法：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230921095553061.png" alt="image-20230921095553061"></p>
<ul>
<li><strong>独立编址</strong>。为每个端口分配一个I&#x2F;O端口号，所有I&#x2F;O端口形成I&#x2F;O端口空间，普通用户程序不能对其进行访问，只有操作系统使用特殊的I&#x2F;O指令才能访问端口。</li>
<li><strong>统一编址</strong>。又称内存映射I&#x2F;O，每个端口被分配唯一的内存地址，且不会有内存被分配这地址，通常分配给端口的地址靠近地址空间的顶端。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="5-1-2-I-O控制方式"><a href="#5-1-2-I-O控制方式" class="headerlink" title="5.1.2 I&#x2F;O控制方式"></a>5.1.2 I&#x2F;O控制方式</h4><p> 设备管理的主要任务之一是控制设备和内存或CPU之间的数据传送。外围设备与内存之间的输入&#x2F;输出控制方式有以下4种。</p>
<ol>
<li><p>程序直接控制方式</p>
<p> 如下图所示，计算机从外部设备读取的每个字，CPU需要对外设状态进行循环检查，直到确定该字已经在I&#x2F;O控制器的数据寄存器中。</p>
<ul>
<li><p>工作流程：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/b0bd7062507d4d8aa46dc9baae5af73d.png" alt="img"></p>
</li>
<li><p>CPU干预的频率：很频繁，I&#x2F;O操作开始之前、完成之后需要CPU介入，并且在等待I&#x2F;O完成的过程中CPU需要不断地轮询检查。</p>
</li>
<li><p>数据传送的单位：每次读&#x2F;写一个字</p>
</li>
<li><p>数据的流向：</p>
<ul>
<li>读操作（数据输入）：I&#x2F;O设备→CPU→内存</li>
<li>写操作（数据输出）：内存→CPU→I&#x2F;O设备</li>
<li>每个字的读&#x2F;写都需要CPU的帮助</li>
</ul>
</li>
<li><p>优点：实现简单。在读&#x2F;写指令之后，加上实现循环检查的一系列指令即可</p>
</li>
<li><p>缺点：CPU和I&#x2F;O设备只能串行工作，CPU需要一直轮询检查，长期处于“忙等”状态，CPU利用率低。</p>
</li>
</ul>
</li>
<li><p>中断驱动方式</p>
<p> 中断驱动方式的思想是，允许I&#x2F;O设备主动打断CPU的运行并请求服务，从而”解放” CPU，使得其向I&#x2F;O控制器发送读命令后可以继续做其他有用的工作。</p>
<ul>
<li>工作流程：<ul>
<li>引入中断机制。由于I&#x2F;O设备速度很慢，因此在CPU发出读&#x2F;写命令后，可将等待I&#x2F;O的进程阻塞，先切换到别的进程执行。</li>
<li>当I&#x2F;O完成后，控制器会向CPU发出一个中断信号，CPU检测到中断信号后，会保存当前进程的运行环境信息，转去执行中断处理程序处理该中断。</li>
<li>处理中断的过程中，CPU从I&#x2F;O控制器读一个字的数据传送到CPU寄存器，再写入主存。接着，CPU恢复等待I&#x2F;O的进程（或其他进程）的运行环境，然后继续执行。</li>
</ul>
</li>
</ul>
<blockquote>
<p>①CPU会在每个指令周期的末尾检查中断：<br>②中断处理过程中需要保存、恢复进程的运行环境，这个过程是需要一定时间开销的。可见，如果中断发生的须率太高，也会降低系统性能。</p>
</blockquote>
<ul>
<li>CPU干预的频率：每次I&#x2F;O操作开始之前、完成之后需要CPU介入。等待I&#x2F;O完成的过程中CPU可以切换到别的进程执行。</li>
<li>数据传送单位：每次读&#x2F;写一个字</li>
<li>数据流向：<ul>
<li>读操作（数据输入）：I&#x2F;O设备→CPU→内存</li>
<li>写操作（数据输出）：内存→CPU→I&#x2F;O设备</li>
</ul>
</li>
<li>优点：与“程序直接控制方式”相比，在“中断驱动方式”中，I&#x2F;O控制器会通过中断信号主动报告I&#x2F;O已完成，CPU不再需要不停地轮询。CPU和I&#x2F;O设备可并行工作，CPU利用率得到明显提升。</li>
<li>缺点：每个字在I&#x2F;O设备与内存之间的传输，都需要经过CPU。而频繁的中断处理会消耗较多的CPU时间。</li>
</ul>
</li>
<li><p>DMA方式</p>
<p> DMA（直接存储器存取）方式的基本思想是在I&#x2F;O设备和内存之间开辟直接的数据交换通路，彻底“解放”CPU。下图为DMA工作流程。</p>
<ul>
<li><p>与“中断驱动方式”相比，DMA方式有这样几个改进：</p>
<ul>
<li>①数据的传送单位是“块”。不再是一个字、一个字的传送：</li>
<li>②数据的流向是从设备直接放入内存，或者从内存直接到设备。不再需要CPU作为“快递小哥”。</li>
<li>③仅在传送一个或多个数据块的开始和结束时，才需要CPU干预，数据传送通过DMA控制器完成。</li>
</ul>
</li>
<li><p>DMA控制器组成：</p>
<p>下图为DMA控制器的组成。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230921102823702.png" alt="image-20230921102823702"></p>
<p>DMA控制器中设置如下4类寄存器：</p>
<ul>
<li><strong>数据寄存器（DR）</strong>。暂存从设备到内存或从内存到设备的数据。</li>
<li><strong>内存地址寄存器（MAR）</strong>。在输入时，它存放把数据从设备传送到内存的起始目标地址；在输出时，它存放由内存到设备的内存源地址。</li>
<li><strong>数据计数器（DC）</strong>。存放本次要传送的字（节）数，剩余要读&#x2F;写的字节数。</li>
<li><strong>命令&#x2F;状态寄存器（CR）</strong>。接收从CPU发来的I&#x2F;O命令、有关控制信息，或设备的状态。</li>
</ul>
</li>
<li><p>CPU干预的频率：仅在传送一个或多个数据块的开始和结束时，才需要CPU干预。</p>
</li>
<li><p>数据传送单位：每次读&#x2F;写一个或多个块（注意：每次读写的只能是连续的多个块，且这些块读入内存后在内存中也必须是连续的）</p>
</li>
<li><p>数据流向：</p>
<ul>
<li>读操作（数据输入）：I&#x2F;O设备→内存</li>
<li>写操作（数据输出）：内存→I&#x2F;O设备</li>
</ul>
</li>
<li><p>优点：数据传输以“块”为单位，CPU介入频率进一步降低。数据的传输不再需要先经过CPU再写入内存，数据传输效率进一步增加。CPU和I&#x2F;O设备的并行性得到提升。</p>
</li>
<li><p>缺点：CPU每发出一条I&#x2F;O指令，只能读&#x2F;写一个或多个连续的数据块。如果要读&#x2F;写多个离散存储的数据块，或者要将数据分别写到不同的内存区域时，CPU要发出多条I&#x2F;O指令，进行多次中断处理才能完成。</p>
</li>
</ul>
</li>
<li><p>通道控制方式</p>
<p>通道：I&#x2F;O通道是指专门负责输入输出的处理机。是一种硬件，可以理解为是“弱鸡版的CPU”。通道可以识别并执行一系列通道指令。</p>
<blockquote>
<p>与CPU相比，通道可以执行的指令很单一，并且通道程序是放在主机内存中的，也就是说通道与CPU共享内存</p>
</blockquote>
<ul>
<li><p>完成一次读写流程：</p>
</li>
<li><p>CPU干预的频率：极低，通道会根据CPU的指示执行相应的通道程序，只有完成一组数据块的读&#x2F;写后才需要发出中断信号，请求CPU干预。</p>
</li>
<li><p>数据传送的单位：每次读&#x2F;写一组数据块</p>
</li>
<li><p>数据的流向（在通道的控制下进行）</p>
<ul>
<li>读操作（数据输入）：I&#x2F;O设备→内存</li>
<li>写操作（数据输出）：内存→I&#x2F;O设备</li>
</ul>
</li>
<li><p>缺点：实现复杂，需要专门的通道硬件支持</p>
</li>
<li><p>优点：CPU、通道、I&#x2F;O设备可并行工作，资源利用率很高。</p>
</li>
</ul>
</li>
</ol>
<h4 id="5-1-4-I-O软件层次结构"><a href="#5-1-4-I-O软件层次结构" class="headerlink" title="5.1.4 I&#x2F;O软件层次结构"></a>5.1.4 I&#x2F;O软件层次结构</h4><p> 为了更好地设计 I&#x2F;O 软件，采用 层次式结构 的 I&#x2F;O 软件；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230921104928744.png" alt="image-20230921104928744"></p>
<p> 一个比较合理的层次划分如上图所示。整个I&#x2F;O软件可以视为具有4个层次的系统结构，各层次功能如下：</p>
<ol>
<li><p>用户层软件</p>
<p> 实现了与用户交互的接口，用户可直接使用该层提供的、与I&#x2F;O操作相关的库函数对设备进行操作。</p>
<p> 用户层软件将用户请求翻译成格式化的I&#x2F;O请求，并通过“系统调用”请求操作系统内核的服务</p>
</li>
<li><p>设备独立性软件</p>
<p> 设备独立性软件，又称设备无关性软件。与设备的硬件特性无关的功能几乎都在这一层实现。</p>
<ul>
<li><p>功能：</p>
<ul>
<li>① 向上层提供统一的调用接口（如read&#x2F;write系统调用）</li>
<li>② 设备的保护</li>
<li>③ 差错处理</li>
<li>④ 设备的分配与可收</li>
<li>⑤ 数据缓冲区管理</li>
<li>⑥ 建立逻辑设备名到物理设备名的映射关系；根据设备类型选择调用相应的驱动程序</li>
</ul>
</li>
<li><p>逻辑设备</p>
<p> 为实现设备独立性而引入了逻辑设备和物理设备这两个概念。在应用程序中，使用逻辑设备名来请求使用某类设备；而在系统实际执行时，必须将逻辑设备名映射成物理设备名使用。</p>
<p><strong>使用逻辑设备名好处</strong>：</p>
<ul>
<li>①增加设备分配的灵活性</li>
<li>②易于实现I&#x2F;O重定向，指用于I&#x2F;O操作的设备可以更换(即重定向)，而不必改变应用程序。</li>
</ul>
<p> 设备独立性软件需要通过“逻辑设备表（LUT，Logical Unit Table）”来确定逻辑设备对应的物理设备，并找到该设备对应的设备驱动程序。</p>
<blockquote>
<p>I&#x2F;O设备被当做一种特殊的文件；不同类型的I&#x2F;O设备需要有不同的驱动程序处理</p>
</blockquote>
<p>操作系统系统可以采用两种方式<strong>管理逻辑设备表（LUT）</strong>：</p>
<ul>
<li>第一种方式，整个系统只设置一张LUT，这就意味着所有用户不能使用相同的逻辑设备名，因此这种方式只适用于单用户操作系统。</li>
<li>第二种方式，为每个用户设置一张LUT，各个用户使用的逻辑设备名可以重复，适用于多用户操作系统。系统会在用户登录时为其建立一个用户管理进程，而LUT就存放在用户管理进程的PCB中。</li>
</ul>
</li>
</ul>
</li>
<li><p>设备驱动程序</p>
<p> 与硬件直接相关，负责具体实现系统对设备发出的操作指令，驱动I&#x2F;O设备工作的驱动程序。 将上层发出的一系列命令（如read&#x2F;write）转化成特定设备“能听得懂”的一系列操作。</p>
<p> 不同设备的内部硬件特性也不同，这些特性只有厂家才知道，因此厂家须提供与设备相对应的驱动程序，CPU执行驱动程序的指令序列，来完成设置设备寄存器，检查设备状态等工作。</p>
<p> 为I&#x2F;O内核子系统隐藏设备控制器之间的差异。</p>
</li>
<li><p>中断处理程序</p>
<p> 当I&#x2F;O任务完成时，I&#x2F;O控制器会发送一个中断信号，系统会根据中断信号类型找到相应的中断处理程序并执行。</p>
<ul>
<li><p>中断处理程序的处理流程如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230901173205434.png#pic_center" alt="image-20230901173205434"></p>
</li>
<li><p>中断处理层的任务：</p>
<ul>
<li>进行进程上下文的切换，</li>
<li>对处理中断信号源进行测试，</li>
<li>读取设备状态和修改进程状态等。</li>
</ul>
</li>
</ul>
<blockquote>
<p>由于中断处理与硬件紧密相关，对用户而言，应尽量加以屏蔽，因此应放在操作系统的底层，系统的其余部分尽可能少地与之发生联系。</p>
</blockquote>
</li>
<li><p>总结</p>
<p>说明用户对设备的一次命令过程如下所示：</p>
<ul>
<li>①当用户要读取某设备的内容时，通过操作系统提供的read命令接口，这就经过了用户层。</li>
<li>②操作系统提供给用户使用的接口，一般是统一的通用接口，也就是几乎每个设备都可以响应的统一命令，如read命令，用户发出的read命令，首先经过设备独立层进行解析，然后交往下层。</li>
<li>③接下来，不同类型的设备对read命令的行为会有所不同，如磁盘接收read命令后的行为与打印机接收read命令后的行为是不同的。因此，需要针对不同的设备，把read命令解析成不同的指令，这就经过了设备驱动层。</li>
<li>④命令解析完毕后，需要中断正在运行的进程，转而执行read命令，这就需要中断处理程序。</li>
<li>⑤最后，命令真正抵达硬件设备，硬件设备的控制器按照上层传达的命令操控硬件设备，完成相应的功能。</li>
</ul>
<p>直接涉及到硬件其体细节、且与中断无关的操作肯定是在设备驱动程序层完成的；</p>
<p>没有涉及硬件的、对各种设备都需要进行的管理工作都是在设备独立性软件层完成的。</p>
</li>
</ol>
<h4 id="5-1-4-应用程序I-O接口"><a href="#5-1-4-应用程序I-O接口" class="headerlink" title="5.1.4 应用程序I&#x2F;O接口"></a>5.1.4 应用程序I&#x2F;O接口</h4><p> 在I&#x2F;O系统与高层之间的接口中，根据设备类型的不同，又进一步分为若干接口。</p>
<ol>
<li><p>字符设备接口</p>
<p> 字符设备是指数据的存取和传输是以字符为单位的设备，如键盘、打印机等。基本特征是传输速率较低、不可寻址，并且在输入输出时通常采用中断驱动方式。</p>
<ul>
<li><p>字符设备的操作</p>
<ul>
<li><strong>get和put操作</strong>。由于字符设备不可寻址，只能采取顺序存取方式，通常为字符设备建立一个字符缓冲区，用户程序通过get操作从缓冲区获取字符，通过put操作将字符输出到缓冲区。</li>
<li><strong>in-control指令</strong>。字符设备类型繁多，差异甚大，因此在接口中提供一种通用的in-control指令来处理它们（包含了许多参数，每个参数表示一个与具体设备相关的特定功能）。</li>
</ul>
<p>字符设备都属于独占设备，为此接口中还需要提供打开和关闭操作，以实现互斥共享。</p>
</li>
</ul>
</li>
<li><p>块设备接口</p>
<p> 块设备是指数据的存取和传输是以数据块为单位的设备，典型的块设备是磁盘。基本特征是传输速率较高、可寻址。磁盘设备的I&#x2F;O常采用DMA方式。</p>
<ul>
<li><strong>隐藏了磁盘的二维结构</strong>：在二维结构中，每个扇区的地址需要用磁道号和扇区号来表示。块设备接口将磁盘的所有扇区从0到n-1依次编号，这样，就将二维结构变为一种线性序列。</li>
<li><strong>将抽象命令映射为低层操作</strong>：块设备接口支持上层发来的对文件或设备的打开、读、写和关闭等抽象命令，该接口将上述命令映射为设备能识别的较低层的具体操作。</li>
<li><strong>内存映射接口</strong>：内存映射接口通过内存的字节数组来访问磁盘，而不提供读&#x2F;写磁盘操作。映射文件到内存的系统调用返回包含文件副本的一个虚拟内存地址。只在需要访问内存映像时，才由虚拟存储器实际调页。内存映射文件的访问如同内存读写一样简单，极大地方便了程序员。</li>
</ul>
</li>
<li><p>网络设备接口</p>
<p> 许多操作系统提供的网络I&#x2F;O接口为网络套接字接口，套接字接口的系统调用使应用程序创建的本地套接字连接到远程应用程序创建的套接字，通过此连接发送和接收数据。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/7dc576d4af9a4e769647e6d1773db343.png" alt="img"></p>
</li>
<li><p>阻塞&#x2F;非阻塞I&#x2F;O</p>
<ul>
<li><p><strong>阻塞I&#x2F;O：</strong>当用户进程调用I&#x2F;O操作时，进程就被阻塞，需要等待I&#x2F;O操作完成，进程才被唤醒继续执行。</p>
<p>eg：字符设备接口一一从键盘读一个字符get</p>
</li>
<li><p><strong>非阻塞I&#x2F;O</strong>：用户进程调用I&#x2F;O操作时，不阻塞该进程，该I&#x2F;O调用返回一个错误返回值，通常，进程需要通过轮询的方式来查询I&#x2F;O操作是否完成。</p>
<p>eg：块设备接口一一往磁盘写数据write</p>
</li>
</ul>
</li>
</ol>
<h3 id="5-2-设备独立性软件"><a href="#5-2-设备独立性软件" class="headerlink" title="5.2 设备独立性软件"></a>5.2 设备独立性软件</h3><h4 id="5-2-1-与设备无关的软件"><a href="#5-2-1-与设备无关的软件" class="headerlink" title="5.2.1 与设备无关的软件"></a>5.2.1 与设备无关的软件</h4><p> 与设备无关的软件是I&#x2F;O系统的最高层软件，它的下层是设备驱动程序。</p>
<ul>
<li>设备保护：<ul>
<li>操作系统需要实现文件保护功能，不同的用户对各个文件有不同的访问权限（如：只读、读和写等）</li>
<li>在UNIX系统中，设备被看做是一种特殊的文件，每个设备也会有对应的FCB。当用户请求访问某个设备时，系统根据FCB中记录的信息来判断该用户是否有相应的访问权限，以此实现“设备保护”的功能。</li>
</ul>
</li>
</ul>
<h4 id="5-2-2-高速缓存与缓冲区"><a href="#5-2-2-高速缓存与缓冲区" class="headerlink" title="5.2.2 高速缓存与缓冲区"></a>5.2.2 高速缓存与缓冲区</h4><ol>
<li><p>磁盘高速缓存（Disk Cache）</p>
<p>操作系统中使用磁盘高速缓存技术来提高磁盘的I&#x2F;O速度，对访问高速缓存要比访问原始磁盘数据更为高效。</p>
<p> 磁盘高速缓存技术不同于通常意义下的介于CPU与内存之间的小容量高速存储器，而是指利用内存中的存储空间来暂存从磁盘中读出的一系列盘块中的信息。因此，磁盘高速缓存逻辑上属于磁盘，物理上则是驻留在内存中的盘块。</p>
<ul>
<li>高速缓存在内存中分为两种形式：<ul>
<li>一种是在内存中开辟一个单独的空间作为磁盘高速缓存，大小固定</li>
<li>另一种是把未利用的内存空间作为一个缓冲池，供请求分页系统和磁盘I&#x2F;O时共享。</li>
</ul>
</li>
</ul>
</li>
<li><p>缓冲区（Buffer）</p>
<ul>
<li><p>概念：缓冲区是一个存储区域，可以由专门的硬件寄存器组成，也可利用内存作为缓冲区。</p>
<ul>
<li>硬件做缓冲区：使用硬件作为缓冲区的成本较高，容量也较小，一般仅用在对速度要求非常高的场合（如存储器管理中所用的联想寄存器，由于对页表的访问频率极高，因此使用速度很快的联想寄存器来存放页表项的副本）</li>
<li>内存做缓冲区：一般情况下，更多的是利用内存作为缓冲区，“设备独立性软件”的缓冲区管理就是要组织管理好这些缓冲区</li>
</ul>
</li>
<li><p>作用</p>
<ul>
<li>缓和CPU与I&#x2F;O设备之间速度不匹配的矛盾</li>
<li>减少对CPU的中断频率，放宽对CPU中断相应时间的限制</li>
<li>解决数据粒度不匹配的问题</li>
<li>提高CPU与I&#x2F;O设备之间的并行性</li>
</ul>
</li>
<li><p><strong>单缓冲</strong></p>
<p>若采用单缓冲的策略，操作系统会在主存中为其分配一个缓冲区（若题目中没有特别说明，一个缓冲区的大小就是一个块）。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230921143949738.png" alt="image-20230921143949738"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230921141924797.png" alt="image-20230921141924797"></p>
<blockquote>
<p>注意：当缓冲区数据非空时，不能往缓冲区冲入数据，只能从缓冲区把数据传出；当缓冲区为空时，可以往缓冲区冲入数据，但必须把缓冲区充满以后，才能从缓冲区把数据传出。</p>
</blockquote>
<p>设块设备输入缓冲区时间为T，缓冲区传送至工作区时间为M，CPU处理工作区时间为C：</p>
<ul>
<li>若T&gt;C，从初始状态到下一个开始状态，整个过程用时为M+T</li>
<li>若T&lt;C，从初始状态到下一个开始状态，整个过程用时为M+C</li>
</ul>
<p>结论：故单缓冲区处理每块数据的用时为$max(C,T)+M$。</p>
<p>若两个相互通信的机器只设置单缓冲区，在任一时刻只能实现数据的单向传输。</p>
</li>
<li><p><strong>双缓冲</strong></p>
<p>若采用双缓冲的策略，操作系统会在主存中为其分配两个缓冲区。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230921143131283.png" alt="image-20230921143131283"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230921144213776.png" alt="image-20230921144213776"></p>
<p>双缓冲题目中，假设初始状态为；工作区空，其中一个缓冲区满，另一个缓冲区空</p>
<ul>
<li>若T&gt;C+M，则处理一块数据的平均用时为T</li>
<li>若T&lt;C+M，意味着输入数据块速度要比处理机处理数据块速度更快，处理一个数据块的平均耗时为C+M</li>
</ul>
<p>结论：采用双缓冲策略，处理一个数据块的平均耗时为$Max(T,C+M)$</p>
<blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230921144605057.png" alt="image-20230921144605057"></p>
<p>若两个相互通信的机器只设置单缓冲区，在任一时刻只能实现数据的单向传输。</p>
<p>若两个相互通信的机器设置双缓冲区，则同一时刻可以实现双向的数据传输。</p>
</blockquote>
</li>
<li><p><strong>循环缓冲</strong></p>
<p>将多个大小相等的缓冲区链接成一个循环队列。</p>
<p>注：上图中，橙色表示已充满数据的缓冲区，绿色表示空缓冲区。</p>
</li>
<li><p><strong>缓冲池</strong></p>
<p> 缓冲池由系统中共用的缓冲区组成。</p>
<p>这些缓冲区按使用状况可以分为：</p>
<ul>
<li>空缓冲队列</li>
<li>装满输入数据的缓冲队列（输入队列）</li>
<li>装满输出数据的缓冲队列（输出队列）</li>
</ul>
<p>根据一个缓冲区在实际运算中扮演的功能不同，又设置了<strong>四种工作缓冲区</strong>：</p>
<ul>
<li>用于收容输入数据的工作缓冲区（hin）</li>
<li>用于提取输入数据的工作缓冲区（sin）</li>
<li>用于收容输出教据的工作绥冲区（hout）</li>
<li>用于提取输出数据的工作缓冲区（sout）</li>
</ul>
<p><strong>工作过程：</strong></p>
<ul>
<li><p><strong>① 输入进程请求输入数据</strong></p>
<p>从空缓冲队列中取出一块作为收容输入数据的工作缓冲区（hin）。冲满数据后将缓冲区挂到输入队列队尾</p>
</li>
<li><p><strong>② 计算进程想要取得一块输入数据</strong></p>
<p>从输入队列中取得一块冲满输入数据的缓冲区作为“提取输入数据的工作缓冲区（sin）”。缓冲区读空后挂到空缓冲区队列</p>
</li>
<li><p><strong>③ 计算进程想要将准备好的数据冲入缓冲区</strong></p>
<p>从空缓冲队列中取出一块作为“收容输出数据的工作缓冲区（hout）”，数据冲满后将缓冲区挂到输出队列队尾</p>
</li>
<li><p><strong>④ 输出进程请求输出数据</strong></p>
<p>从输出队列中取得一块冲满输出数据的缓冲区作为“提取输出数据的工作缓冲区（sout）”。缓冲区读空后挂到空缓冲区队列</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="5-2-3-设备的分配与回收"><a href="#5-2-3-设备的分配与回收" class="headerlink" title="5.2.3 设备的分配与回收"></a>5.2.3 设备的分配与回收</h4><ol>
<li><p>设备分配概述</p>
<p> 设备分配是指根据用户的I&#x2F;O请求分配所需的设备。分配的总原则是充分发挥设备的使用效率，尽可能地让设备忙碌，又要避免由于不合理的分配方法造成进程死锁。</p>
<p> 从设备特性来看，分为以下三种设备：</p>
<ul>
<li><strong>独占式使用设备</strong>。进程分配到独占设备后，便由其独占，直至该进程释放该设备。</li>
<li><strong>分时式共享使用设备</strong>。对于共享设备，可同时分配给多个进程，通过分时共享使用。</li>
<li><strong>以SPOOLing方式使用外部设备</strong>。SPOOLing技术实现了虚拟设备功能，可以将设备同时分配给多个进程。这种技术实质上就是实现了对设备的I&#x2F;O操作的批处理。</li>
</ul>
</li>
<li><p>设备分配的数据结构</p>
<p> 设备分配依据的主要数据结构有**设备控制表(DCT)<strong>、</strong>控制器控制表(COCT)<strong>、</strong>通道控制表 (CHCT)<strong>和</strong>系统设备表(SDT)**，各数据结构功能如下。</p>
<ul>
<li><p>设备控制表（DCT）：系统为每个设备配置一张DCT，用于记录设备情况</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230921152138973.png" alt="image-20230921152138973"></p>
</li>
<li><p>控制器控制表（COCT）：每个设备控制器都会对应一张COCT。操作系统根据COCT的信息对控制器进行操作和管理。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230921152213087.png" alt="image-20230921152213087"></p>
</li>
<li><p>通道控制表（CHCT）：每个通道都会对应一张CHCT。操作系统根据CHCT的信息对通道进行操作和管理。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230921152241283.png" alt="image-20230921152241283"></p>
</li>
<li><p>系统设备表（SDT）：记录了系统中全部设备的情况，每个设备对应一个表目。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230921152258475.png" alt="image-20230921152258475"></p>
</li>
</ul>
</li>
<li><p>设备分配的策略</p>
<ul>
<li><p><strong>设备分配原则</strong>。设备分配应根据设备特性、用户要求和系统配置情况。既要充分发挥设备的使用效率，又要避免造成进程死锁，还要将用户程序和具体设备隔离开。</p>
</li>
<li><p><strong>设备分配方式</strong>。设备分配方式有静态分配和动态分配两种。</p>
<ul>
<li><p>①静态分配：进程运行前为其分配全部所需资源，运行结束后归还资源。主要用于对独占设备的分配，它在用户作业开始执行前，由系统一次性分配该作业所要求的全部设备、控制器。</p>
<p>静态分配方式不会出现死锁，但设备的使用效率低。</p>
</li>
<li><p>②动态分配：进程运行过程中动态申请设备资源。在进程执行过程中根据执行需要进行。</p>
<p>这种方式有利于提高设备利用率，但若分配算法使用不当，则有可能造成进程死锁。</p>
</li>
</ul>
</li>
<li><p><strong>设备分配算法</strong>。常用的动态设备分配算法有先请求先分配、优先级高者优先等。</p>
</li>
</ul>
</li>
<li><p>设备分配的安全性</p>
<p>设备分配的安全性是指设备分配中应防止发生进程死锁。</p>
<ul>
<li><p><strong>安全分配方式</strong>。</p>
<ul>
<li>为进程分配一个设备后就将进程阻塞，本次I&#x2F;O完成后才将进程唤醒。一个时段内每个进程只能使用一个设备。</li>
<li>优点：破坏了“请求和保持”条件，不会死锁</li>
<li>缺点：对于一个进程来说，CPU和I&#x2F;O设备只能串行工作</li>
</ul>
</li>
<li><p><strong>不安全分配方式</strong>。</p>
<p>进程发出I&#x2F;O请求后，系统为其分配I&#x2F;O设备，进程可继续执行，之后还可以发出新的I&#x2F;O请求。只有某个I&#x2F;O请求得不到满足时才将进程阻塞。一个进程可以同时使用多个设备。</p>
<ul>
<li>优点：进程的计算任务和I&#x2F;O任务可以并行处理，使进程迅速推进</li>
<li>缺点：有可能发生死锁（死锁避免、死锁的检测和解除）</li>
</ul>
</li>
</ul>
</li>
<li><p>设备分配的步骤</p>
<ul>
<li><p>步骤</p>
<ul>
<li>① 根据进程请求的物理设备名查找SDT（注：物理设备名是进程请求分配设备时提供的参数）</li>
<li>② 根据SDT找到DCT，若设备忙碌则将进程PCB挂到设备等待队列中，不忙碌则将设备分配给进程。</li>
<li>③ 根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程。</li>
<li>④ 根据COCT找到CHCT，若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进程。</li>
</ul>
<blockquote>
<p>注：只有设备、控制器、通道三者都分配成功时，这次设备分配才算成功，之后便可启动I&#x2F;O设备进行数据传送</p>
</blockquote>
</li>
<li><p>缺点</p>
<ul>
<li>①用户编程时必须使用“物理设备名”，底层细节对用户不透明，不方便编程</li>
<li>②若换了一个物理设备，则程序无法运行</li>
<li>③若进程请求的物理设备正在忙碌，则即使系统中还有同类型的设备，进程也必须阻塞等待</li>
</ul>
</li>
</ul>
</li>
<li><p>设备分配步骤的改进</p>
<p>改进方法：建立逻辑设备名与物理设备名的映射机制，用户编程时只需提供逻辑设备名。</p>
<ul>
<li><p><strong>逻辑设备表（LUT）</strong></p>
<p>逻辑设备表（LUT）建立了逻辑设备名与物理设备名之间的映射关系。</p>
<p>某用户进程第一次使用设备时使用逻辑设备名向操作系统发出请求，操作系统根据用户进程指定的设备类型（逻辑设备名）查找系统设备表，找到一个空闲设备分配给进程，并在LUT中增加相应表项。</p>
<p>如果之后用户进程再次通过相同的逻辑设备名请求使用设备，则操作系统通过LUT表即可知道用户进程实际要使用的是哪个物理设备了，并且也能知道该设备的驱动程序入口地址。</p>
<ul>
<li><strong>整个系统只有一张LUT</strong>：各用户所用的逻辑设备名不允许重复，适用于单用户操作系统</li>
<li><strong>每个用户一张LUT</strong>：不同用户的逻辑设备名可重复，适用于多用户操作系统</li>
</ul>
</li>
<li><p>步骤</p>
<ul>
<li>① 根据进程请求的逻辑设备名查找SDT（注：用户编程时提供的逻辑设备名其实就是“设备类型”）</li>
<li>② 查找SDT，找到用户进程指定类型的、并且空闲的设备，将其分配给该进程。操作系统在逻辑设备表（LUT）中新增一个表项。</li>
<li>③ 根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程。</li>
<li>④ 根据COCT找到CHCT，若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进程</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="5-2-4-SPOOLing技术（假脱机技术）"><a href="#5-2-4-SPOOLing技术（假脱机技术）" class="headerlink" title="5.2.4 SPOOLing技术（假脱机技术）"></a>5.2.4 SPOOLing技术（假脱机技术）</h4><ol>
<li><p>概念</p>
<ul>
<li><p><strong>脱机技术</strong>：脱离主机的控制进行的输入&#x2F;输出操作。</p>
<p>批处理阶段引入了脱机输入&#x2F;输出技术（用磁带完成），在外围控制机的控制下，慢速输入设备的数据先被输入到更快速的磁带上。之后主机可以从快速的磁带上读入数据，从而缓解了速度矛盾。</p>
</li>
<li><p><strong>SPOOLing技术</strong>：“假脱机技术”，又称“SPOOLing技术”，用软件的方式模拟脱机技术。</p>
<p>要实现SPOOLing技术，必须要有多道程序技术的支持。系统会建立“输入进程”和“输出进程”</p>
</li>
</ul>
</li>
<li><p>原理</p>
<ul>
<li>输入井和输出井<ul>
<li>在磁盘上开辟出两个存储区域一一“输入井”和“输出井”</li>
<li>”输入井”模拟脱机输入时的磁带，用于收容I&#x2F;O设备输入的数据</li>
<li>“输出井”模拟脱机输出时的磁带，用于收容用户进程输出的数据</li>
</ul>
</li>
<li>输入进程和输出进程<ul>
<li>“输入进程”模拟脱机输入时的外围控制机</li>
<li>“输出进程”模拟脱机输出时的外围控制机</li>
</ul>
</li>
<li>输入缓冲区和输出缓冲区<ul>
<li>在输入进程的控制下，“输入缓冲区”用于暂存从输入设备输入的数据，之后再转存到输入井中</li>
<li>在输出进程的控制下，“输出缓冲区”用于暂存从输出井送来的数据，之后再传送到输出设备上</li>
<li>注意，输入缓冲区和输出缓冲区是在内存中的缓冲区</li>
</ul>
</li>
</ul>
</li>
<li><p>预读和滞后写</p>
<ul>
<li><p>预读（提前读）：</p>
<p>如果采用的顺序访问方式对文件进行访问，便可预知下一次要读的盘块。此时可采用预读策略，即在读当前块的同时，也将下一个盘块提前读入内存缓冲区，这样在访问下一个盘块时就不需要再启动磁盘，从而提升磁盘I&#x2F;O速度。</p>
</li>
<li><p>滞后写（延迟写）</p>
<p>滞后写是指缓冲区A中的数据本应立即写回磁盘，但考虑到其中的数据在不久之后有可能再次被访问，因此并不会立即把A中的数据写回磁盘，而是将缓冲区A挂到空闲缓冲区队列。如果有别的进程申请使用该缓冲区时，才把A中的数据写回磁盘。这样做的好处是，只要缓冲区A仍在队列中，任何访问该数据的进程，都可以直接读出其中的数据而不必访问磁盘。因而这种方式也可以减少磁盘I&#x2F;O次数，改善性能。</p>
</li>
</ul>
</li>
<li><p>共享打印机的原理分析</p>
<p>SPOOLing技术可以把一台物理设备虚拟成逻辑上的多台设备，可将独占式设备改造成共享设备。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230921163421824.png" alt="image-20230921163421824"></p>
<ul>
<li>当多个用户进程提出输出打印的请求时，系统会答应它们的请求，但是并不是真正把打印机分配给他们，而是由假脱机管理进程为每个进程做两件事：<ul>
<li>1）在磁盘输出井中为进程申请一个空闲缓冲区（也就是说，这个缓冲区是在磁盘上的），并将要打印的数据送入其中</li>
<li>2）为用户进程申请一张空白的打印请求表，并将用户的打印请求填入表中（其实就是用来说明用户的打印数据存放位置等信息的），再将该表挂到假脱机文件队列上。</li>
</ul>
</li>
</ul>
<p>当打印机空闲时，输出进程会从文件队列的队头取出一张打印请求表，并根据表中的要求将要打印的数据从输出井传送到输出缓冲区，再输出到打印机进行打印。用这种方式可依次处理完全部的打印任务。</p>
<blockquote>
<p>虽然系统中只有一个台打印机，但每个进程提出打印请求时，系统都会为在输出井中为其分配一个存储区（相当于分配了一个逻辑设备），使每个用户进程都觉得自己在独占一台打印机，从而实现对打印机的共享。</p>
</blockquote>
</li>
</ol>
<h4 id="5-2-5-设备驱动程序接口"><a href="#5-2-5-设备驱动程序接口" class="headerlink" title="5.2.5 设备驱动程序接口"></a>5.2.5 设备驱动程序接口</h4><p> 要求每个设备驱动程序与操作系统之间都有着相同或相近的接口。这样会使得添加一个新设备驱动程序变得很容易，同时也便于开发人员编制设备驱动程序。</p>
<p> 对于每种设备类型，例如磁盘，操作系统都要定义一组驱动程序必须支持的函数。</p>
<p> 与设备无关的软件还要负责将符号化的设备名映射到适当的驱动程序上。</p>
<p> 在UNIX和Windows中，设备是作为命名对象出现在文件系统中的，因此针对文件的常规保护规则也适用于I&#x2F;O设备。系统管理员可以为每个设备设置适当的访问权限。</p>
<h3 id="5-3-磁盘和固态硬盘"><a href="#5-3-磁盘和固态硬盘" class="headerlink" title="5.3 磁盘和固态硬盘"></a>5.3 磁盘和固态硬盘</h3><h4 id="5-3-1-磁盘"><a href="#5-3-1-磁盘" class="headerlink" title="5.3.1 磁盘"></a>5.3.1 磁盘</h4><ol>
<li><p>磁盘结构</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230921170548395.png" alt="image-20230921170548395"></p>
<ul>
<li><p>磁盘：磁盘的表面由一些磁性物质组成，可以用这些磁性物质来记录二进制数据</p>
</li>
<li><p>磁道：磁盘的盘面被划分成一个个磁道。这样的一个“圈”就是一个磁道</p>
</li>
<li><p>扇区：一个磁道又被划分成一个个扇区，每个扇区就是一个“磁盘块”各个扇区存放的数据量相同</p>
<p>最内侧磁道上的扇区面积最小，因此数据密度最大</p>
</li>
<li><p>盘面：磁盘有多个盘片”摞”起来，每个盘片有两个盘面。</p>
</li>
<li><p>柱面：所有盘面中相对位置相同的磁道组成柱面。</p>
</li>
</ul>
</li>
<li><p>如何在磁盘中读&#x2F;写数据</p>
<p>需要把“磁头”移动到想要读&#x2F;写的扇区所在的磁道。磁盘会转起来，让目标扇区从磁头下面划过，才能完成对扇区的读&#x2F;写操作。</p>
</li>
<li><p>磁盘的物理地址：磁盘地址用“柱面号•盘面号•扇区号”表示，可根据该地址读取一个“块”</p>
<ul>
<li>①根据“柱面号”移动磁臂，让磁头指向指定柱面；</li>
<li>②激活指定盘面对应的磁头；</li>
<li>③磁盘旋转的过程中，指定的扇区会从磁头下面划过，这样就完成了对指定扇区的读&#x2F;写。</li>
</ul>
</li>
<li><p>磁盘读写时间</p>
<ul>
<li><p>寻找时间Ts</p>
<p>：在读&#x2F;写数据前，将磁头移动到指定磁道所花的时间。</p>
<ul>
<li>①启动磁头臂是需要时间的。假设耗时为s；</li>
<li>②移动磁头也是需要时间的。假设磁头匀速移动，每跨越一个磁道耗时为m，总共需要跨越n条磁道。则：寻道时间$Ts&#x3D;s+ m*n$</li>
</ul>
</li>
<li><p>延迟时间TR</p>
<p>：通过旋转磁盘，使磁头定位到目标扇区所需要的时间。</p>
<ul>
<li>设磁盘转速为r（单位：转&#x2F;秒，或转&#x2F;分），则平均所需的延迟时间$TR&#x3D;(1&#x2F;2)*(1&#x2F;r)&#x3D; 1&#x2F;2r$</li>
<li>硬盘的典型转速为5400 转&#x2F;分，或7200转&#x2F;分</li>
</ul>
</li>
<li><p>传输时间Tt</p>
<p>：从磁盘读出或向磁盘写入数据所经历的时间</p>
<ul>
<li>假设磁盘转速为r，此次读&#x2F;写的字节数为b，每个磁道上的字节数为N。</li>
<li>则：传输时间$Tt&#x3D;(1&#x2F;r)*(b&#x2F;N)&#x3D; b&#x2F;(rN)$</li>
</ul>
</li>
<li><p>平均存取时间</p>
<ul>
<li>总的平均存取时间$T&#x3D;Ts + 1&#x2F;2r + b&#x2F;(rN)$</li>
<li>延迟时间和传输时间都与磁盘转速相关，且为线性相关而转速是硬件的固有属性，因此操作系统也无法优化延迟时间和传输时间</li>
</ul>
</li>
</ul>
</li>
<li><p>磁盘的分类</p>
<ul>
<li>磁头是否移动<ul>
<li>磁头可以移动的称为活动头磁盘。磁臂可以来回伸缩来带动磁头定位磁道</li>
<li>磁头不可移动的称为固定头磁盘。这种磁盘中每个磁道有一个磁头</li>
</ul>
</li>
<li>根据盘片是否可更换<ul>
<li>固定盘磁盘</li>
<li>可换盘磁盘</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="5-3-2-磁盘管理"><a href="#5-3-2-磁盘管理" class="headerlink" title="5.3.2 磁盘管理"></a>5.3.2 磁盘管理</h4><ol>
<li><p>磁盘初始化</p>
<p> 一个新的磁盘只是一个磁性记录材料的空白盘。在磁盘可以存储数据之前，必须将它分成扇区，以便磁盘控制器能够进行读写操作，这个过程称为低级格式化（或称物理格式化）。</p>
<p> 低级格式化为每个扇区使用特殊的数据结构，填充磁盘。每个扇区的数据结构通常由头部、数据区域（通常为512B大小）和尾部组成。头部和尾部包含了一些磁盘控制器的使用信息。</p>
</li>
<li><p>分区</p>
<p>在可以使用磁盘存储文件之前，操作系统还要将自己的数据结构记录到磁盘上，分为两步：</p>
<ul>
<li>第一步是，将磁盘分为由一个或多个柱面组成的分区（即我们熟悉的C盘、D盘等形式的分区），每个分区的起始扇区和大小都记录在磁盘主引导记录的分区表中</li>
<li>第二步是，对物理分区进行逻辑格式化（创建文件系统），操作系统将初始的文件系统数据结构存储到磁盘上，这些数据结构包括空闲空间和已分配的空间以及一个初始为空的目录。</li>
</ul>
<p>因扇区的单位太小，为了提高效率，操作系统将多个相邻的扇区组合在一起，形成一簇（在Linux中称为块）。为了更高效地管理磁盘，一簇只能存放一个文件的内容，文件所占用的空间只能是簇的整数倍；如果文件大小小于一簇（甚至是0字节），也要占用一簇的空间。</p>
</li>
<li><p>引导块</p>
<p> 计算机启动时需要运行一个初始化程序（自举程序），它初始化CPU、寄存器、设备控制器和内存等，接着启动操作系统。为此，自举程序找到磁盘上的操作系统内核，将它加载到内存， 并转到起始地址，从而开始操作系统的运行。</p>
<p> 自举程序通常存放在ROM中，为了避免改变自举代码而需要改变ROM硬件的问题，通常只在ROM中保留很小的自举装入程序，而将完整功能的引导程序保存在磁盘的启动块上，启动块位于磁盘的固定位置。具有启动分区的磁盘称为启动磁盘或系统磁盘。</p>
<ul>
<li><p>Windows允许将磁盘分为多个分区，有一个分区为引导分区，它包含操作系统和设备驱动程序。</p>
</li>
<li><p>Windows系统将引导代码存储在磁盘的第0号扇区，它称为主引导记录（MBR）。</p>
</li>
<li><p>引导首先运行ROM中的代码，这个代码指示系统从MBR中读取引导代码。</p>
<p>除了包含引导代码，MBR还包含：一个磁盘分区表和一个标志（以指示从哪个分区引导系统）</p>
</li>
<li><p>当系统找到引导分区时，读取分区的第一个扇区，称为引导扇区，并继续余下的引导过程，包括加载各种系统服务。</p>
</li>
</ul>
</li>
<li><p>坏块</p>
<p>由于磁盘有移动部件且容错能力弱，因此容易导致一个或多个扇区损坏。</p>
<ul>
<li>对于简单磁盘，如采用IDE控制器的磁盘，坏块可手动处理，如MS-DOS的Format命令执行逻辑格式化时会扫描磁盘以检查坏块。坏块在FAT表上会标明，因此程序不会使用它们。</li>
<li>对于复杂的磁盘，控制器维护磁盘内的坏块列表。这个列表在出厂低级格式化时就已初始化，并在磁盘的使用过程中不断更新。低级格式化将一些块保留作为备用，操作系统看不到这些块。<br>控制器可以采用备用块来逻辑地替代坏块，这种方案称为扇区备用。</li>
</ul>
<p>对坏块的处理实质上就是用某种机制使系统不去使用坏块。</p>
</li>
<li><p>减少磁盘延迟时间的方法</p>
<ul>
<li>磁盘地址结构的设计：<ul>
<li>为什么磁盘的物理地址是（柱面号，盘面号，扇区号）而不是（盘面号，柱面号，扇区号）？</li>
<li>答：读取地址连续的磁盘块时，采用这样的的地址结构可以减少磁头移动消耗的时间</li>
</ul>
</li>
<li>方法<ul>
<li>交替编号<ul>
<li>具体做法：让编号相邻的扇区在物理上不相邻</li>
<li>原理：磁头读入一个扇区数据后需要一小段时间处理，如果逻辑上相邻的扇区在物理上也相邻，则读入几个连续的逻辑扇区，可能需要很长的“延迟时间”</li>
</ul>
</li>
<li>错位命名<ul>
<li>具体做法：让相邻盘面的扇区编号”错位”</li>
<li>原理：与”交替编号”的原理相同。“错位命名法”可降低延迟时间</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="5-3-3-磁盘调度算法"><a href="#5-3-3-磁盘调度算法" class="headerlink" title="5.3.3 磁盘调度算法"></a>5.3.3 磁盘调度算法</h4><ol>
<li><p><strong>先来先服务（FCFS）</strong></p>
<p>根据进程请求访问磁盘的先后顺序进行调度。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230922090407192.png" alt="image-20230922090407192"></p>
<ul>
<li>优点：公平；如果请求访问的磁道比较集中的话，算法性能还算过的去</li>
<li>缺点：如果有大量进程竞争使用磁盘，请求访问的磁道很分散，则FCFS在性能上很差，寻道时间长。</li>
</ul>
</li>
<li><p><strong>最短寻找时间优先（SSTF）</strong></p>
<p>SSTF算法会优先处理的磁道是与当前磁头最近的磁道。可以保证每次的寻道时间最短，但是并不能保证总的寻道时间最短。（其实就是贪心算法的思想，只是选择眼前最优，但是总体未必最优）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230922090856029.png" alt="image-20230922090856029"></p>
<ul>
<li><p>优点：性能较好，平均寻道时间短</p>
</li>
<li><p>缺点：可能产生“饥饿”现象，磁头有可能在一个小区域内来回来去地移动。</p>
<blockquote>
<p>Eg：本例中，如果在处理18号磁道的访问请求时又来了一个38号磁道的访问请求，处理38号磁道的访问请求时又来了一个18号磁道的访问请求。如果有源源不断的18号、38号磁道的访问请求到来的话，150、160、184号磁道的访问请求就永远得不到满足，从而产生“饥饿”现象。</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>扫描算法（SCAN）</strong></p>
<p>又称电梯算法，只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移动。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230922091629172.png" alt="image-20230922091629172"></p>
<ul>
<li>优点：性能较好，平均寻道时间较短，不会产生饥饿现象</li>
<li>缺点：<ul>
<li>①只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了184号磁道的访问请求之后就不需要再往右移动磁头了。</li>
<li>②SCAN算法对于各个位置磁道的响应频率不平均（如：假设此时磁头正在往右移动，且刚处理过90号磁道，那么下次处理90号磁道的请求就需要等磁头移动很长一段距离；而响应了184号磁道的请求之后，很快又可以再次响应184号磁道的请求了）</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>LOOK调度算法</strong></p>
<p>如果在磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向。（边移动边观察，因此叫 LOOK）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230922092519102.png" alt="image-20230922092519102"></p>
<ul>
<li>优点：比起SCAN算法来，不需要每次都移动到最外侧或最内侧才改变磁头方向，使寻道时间进一步缩短</li>
</ul>
</li>
<li><p><strong>循环扫描算法（C-SCAN）</strong></p>
<p>只有磁头朝某个特定方向移动时才处理磁道访问请求，而返回时直接快速移动至起始端而不处理任何请求。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230922092744277.png" alt="image-20230922092744277"></p>
<ul>
<li>优点：比起SCAN来，对于各个位置磁道的响应频率很平均。</li>
<li>缺点：只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了184号磁道的访问请求之后就不需要再往右移动磁头了；并且，磁头返回时其实只需要返回到18号磁道即可，不需要返回到最边缘的磁道。另外，比起SCAN算法来，平均寻道时间更长。</li>
</ul>
</li>
<li><p><strong>C-LOOK 调度算法</strong></p>
<p>如果磁头移动的方向上已经没有磁道访问请求了，就可以立即让磁头返回，并且磁头只需要返回到有磁道访问请求的位置即可。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230922092846866.png" alt="image-20230922092846866"></p>
<ul>
<li>优点：比起C-SCAN算法，不需要每次都移动到最外侧或最内侧才改变磁头方向，使寻道时间进一步缩短</li>
</ul>
</li>
</ol>
<h4 id="5-3-4-固态硬盘"><a href="#5-3-4-固态硬盘" class="headerlink" title="5.3.4 固态硬盘"></a>5.3.4 固态硬盘</h4><ol>
<li><p>固态硬盘的特性</p>
<ul>
<li><p>原理：固态硬盘(SSD)是基于闪存技术Flash Memory，属于电可擦除ROM，即EEPROM</p>
</li>
<li><p>组成：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230922093902941.png" alt="image"></p>
<ul>
<li>闪存翻译层：负责翻译逻辑块号，找到对应页（Page）</li>
<li>存储介质：多个闪存芯片（Flash Chip）；每个芯片包含多个块（block）；每个块包含多个页（page）。</li>
</ul>
</li>
<li><p>读写性能特性：</p>
<ul>
<li>数据是以页为单位读写的。相当于磁盘的“扇区”</li>
<li>以块（bock）为单位“擦除“，擦干净的块，其中的每页都可以写一次，读无限次。</li>
<li>支持随机访问，系统给定一个逻辑地址，闪存翻译层可通过电路迅速定位到对应的物理地址</li>
<li>读快、写慢。要写的页如果有数据，则不能写入，需要将块内其他页全部复制到一个新的（擦除过的）块中，再写入新的页</li>
</ul>
</li>
<li><p>与机械硬盘对比</p>
<ul>
<li>SSD读写速度快，随机访问性能高，用电路控制访问位置；机诚硬盘通过移动磁臂旋转磁盘控制访问位置，有寻道时间和旋转延迟</li>
<li>SSD安静无噪音、耐摔抗震、能耗低、造价更贵</li>
<li>SSD的一个”块”被擦除次数过多（重复写同一个块）可能会坏掉，而机械硬盘的扇区不会因为写的次数太多而坏掉</li>
</ul>
</li>
</ul>
</li>
<li><p>磨碎均衡</p>
<p>思想：将“擦除”平均分布在各个块上，以提升使用寿命</p>
<ul>
<li>动态磨损均衡：写入数据时，优先选择累计擦除次数少的新闪存块。</li>
<li>静态磨损均衡：SSD监测并自动进行数据分配、迁移，让老旧的闪存块承担以读为主的储存任务，让较新的闪存块承担更多的写任务</li>
</ul>
<blockquote>
<p>例：某固态硬盘采用磨损均衡技术，大小为240B&#x3D;1TB，闪存块的擦写寿命只有210&#x3D;1K次。某男子平均每天会对该固态硬盘写237B&#x3D;128GB数据。在最理想的情况下，这个固态硬盘可以用多久？</p>
<p>SSD采用磨损均衡技术，最理想情况下，SSD中每个块被擦除的次数都是完全均衡的。<br>$$<br>1T&#x2F;128G&#x3D;8<br>$$<br>因此，平均8天，每个闪存块需要擦除一次。</p>
<p>每个闪存块可以被擦除1K次，因此经过8K天，约23年，固态使用到寿命。</p>
</blockquote>
</li>
</ol>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/freecompress-girl.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/freecompress-girl.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">Artemis</div><div class="post-copyright__author_desc">不要用逻辑生活   生活没有逻辑 🏠</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://sukhoigit.github.io/posts/b64a7908.html">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://sukhoigit.github.io/posts/b64a7908.html')">Operating System</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://bu.dusays.com/2024/11/16/6738094119d8b.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/11/16/6738094119d8b.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://bu.dusays.com/2024/11/16/67380940f10d9.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/11/16/67380940f10d9.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://sukhoigit.github.io/posts/b64a7908.html"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=Operating System&amp;url=http://sukhoigit.github.io/posts/b64a7908.html&amp;pic=https://bu.dusays.com/2024/12/09/67566a877214f.png" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://sukhoigit.github.io" target="_blank">Artemis`s Blog</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>操作系统<span class="tagsPageCount">1</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://bu.dusays.com/2024/12/17/6760fdc6cd350.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/a1116f6.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/11/22/6740421aca3c3.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">谈谈教师</div></div></a></div><div class="next-post pull-right"><a href="/posts/c272b9d9.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/12/17/6760fdc6cd350.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">谈谈做父母的期望值</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.</span> <span class="toc-text">操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">1 计算机系统概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1 操作系统的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2 操作系统发展历程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.3 操作系统运行环境</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1-%E5%A4%84%E7%90%86%E5%99%A8%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">1.3.1 处理器运行模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">1.3.2 中断和异常的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-3-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">1.3.3 系统调用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.4.</span> <span class="toc-text">1.4 操作系统结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC"><span class="toc-number">1.1.5.</span> <span class="toc-text">1.5 操作系统引导</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-number">1.1.6.</span> <span class="toc-text">1.6 虚拟机</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">2 进程与线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1 进程与线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E7%89%B9%E5%BE%81"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">2.1.1 进程的概念和特征</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">2.1.2 进程的状态与转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-3-%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">2.1.3 进程的组织方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-4-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">2.1.4 进程控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-5-%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-number">1.2.1.5.</span> <span class="toc-text">2.1.5 进程的通信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-6-%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.1.6.</span> <span class="toc-text">2.1.6 线程和多线程模型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2 处理机调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-%E8%B0%83%E5%BA%A6%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">2.2.1 调度的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-%E8%B0%83%E5%BA%A6%E7%9A%84%E7%9B%AE%E6%A0%87"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">2.2.2 调度的目标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-%E8%B0%83%E5%BA%A6%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">2.2.3 调度的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-4-%E5%85%B8%E5%9E%8B%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">2.2.4 典型的调度算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.3 同步与互斥</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">2.3.1 同步与互斥的基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-%E5%AE%9E%E7%8E%B0%E4%B8%B4%E7%95%8C%E5%8C%BA%E4%BA%92%E6%96%A5%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">2.3.2 实现临界区互斥的基本方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-3-%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">2.3.3 互斥锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-4-%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">2.3.4 信号量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-5-%E7%AE%A1%E7%A8%8B"><span class="toc-number">1.2.3.5.</span> <span class="toc-text">2.3.5 管程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-6-%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.3.6.</span> <span class="toc-text">2.3.6 经典同步问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E6%AD%BB%E9%94%81"><span class="toc-number">1.2.4.</span> <span class="toc-text">2.4 死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-%E6%AD%BB%E9%94%81%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">2.4.1 死锁的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">2.4.2 死锁预防</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-3-%E6%AD%BB%E9%94%81%E9%81%BF%E5%85%8D"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">2.4.3 死锁避免</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-4-%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B%E5%92%8C%E8%A7%A3%E9%99%A4"><span class="toc-number">1.2.4.4.</span> <span class="toc-text">2.4.4 死锁检测和解除</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">1.3.</span> <span class="toc-text">3 内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1 内存管理概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%92%8C%E8%A6%81%E6%B1%82"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">3.1.1 内存管理的基本原理和要求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-2-%E8%A6%86%E7%9B%96%E4%B8%8E%E4%BA%A4%E6%8D%A2"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">3.1.2 覆盖与交换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-3-%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">3.1.3 连续分配管理方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-4-%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">3.1.4 基本分页存储管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-5-%E5%9F%BA%E6%9C%AC%E5%88%86%E6%AE%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">1.3.1.5.</span> <span class="toc-text">3.1.5 基本分段式存储管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-6-%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86"><span class="toc-number">1.3.1.6.</span> <span class="toc-text">3.1.6 段页式管理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.2 虚拟内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">3.2.1 虚拟内存的基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">3.2.2 请求分页管理方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-%E9%A1%B5%E6%A1%86%E5%88%86%E9%85%8D"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">3.2.3 页框分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-4-%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">3.2.4 页面置换算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-5-%E6%8A%96%E5%8A%A8%E5%92%8C%E5%B7%A5%E4%BD%9C%E9%9B%86"><span class="toc-number">1.3.2.5.</span> <span class="toc-text">3.2.5 抖动和工作集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-6-%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6"><span class="toc-number">1.3.2.6.</span> <span class="toc-text">3.2.6 内存映射文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-7-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E6%80%A7%E8%83%BD%E5%BD%B1%E5%93%8D%E5%9B%A0%E7%B4%A0"><span class="toc-number">1.3.2.7.</span> <span class="toc-text">3.2.7 虚拟存储器性能影响因素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-8-%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%91"><span class="toc-number">1.3.2.8.</span> <span class="toc-text">3.2.8 地址翻译</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="toc-number">1.4.</span> <span class="toc-text">4 文件管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80"><span class="toc-number">1.4.1.</span> <span class="toc-text">4.1 文件系统基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1-%E6%96%87%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">4.1.1 文件的基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-2-%E6%96%87%E4%BB%B6%E6%8E%A7%E5%88%B6%E5%9D%97%E5%92%8C%E7%B4%A2%E5%BC%95%E7%BB%93%E7%82%B9"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">4.1.2 文件控制块和索引结点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-3-%E6%96%87%E4%BB%B6%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">4.1.3 文件的操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-4-%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4"><span class="toc-number">1.4.1.4.</span> <span class="toc-text">4.1.4 文件保护</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-5-%E6%96%87%E4%BB%B6%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.1.5.</span> <span class="toc-text">4.1.5 文件的逻辑结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-6-%E6%96%87%E4%BB%B6%E7%9A%84%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.1.6.</span> <span class="toc-text">4.1.6 文件的物理结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E7%9B%AE%E5%BD%95"><span class="toc-number">1.4.2.</span> <span class="toc-text">4.2 目录</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-%E7%9B%AE%E5%BD%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">4.2.1 目录的基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">4.2.2 目录结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-3-%E7%9B%AE%E5%BD%95%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">4.2.3 目录的操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-4-%E7%9B%AE%E5%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.2.4.</span> <span class="toc-text">4.2.4 目录实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-5-%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB"><span class="toc-number">1.4.2.5.</span> <span class="toc-text">4.2.5 文件共享</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.4.3.</span> <span class="toc-text">4.3 文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-1-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">4.3.1 文件系统结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-2-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B8%83%E5%B1%80"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">4.3.2 文件系统布局</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-3-%E5%A4%96%E5%AD%98%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">4.3.3 外存空闲空间管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-4-%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.4.3.4.</span> <span class="toc-text">4.3.4 虚拟文件系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-5-%E5%88%86%E5%8C%BA%E5%92%8C%E5%AE%89%E8%A3%85"><span class="toc-number">1.4.3.5.</span> <span class="toc-text">4.3.5 分区和安装</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%EF%BC%88I-O%EF%BC%89%E7%AE%A1%E7%90%86"><span class="toc-number">1.5.</span> <span class="toc-text">5 输入&#x2F;输出（I&#x2F;O）管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-I-O%E7%AE%A1%E7%90%86%E6%A6%82%E8%BF%B0"><span class="toc-number">1.5.1.</span> <span class="toc-text">5.1 I&#x2F;O管理概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-1-I-O%E8%AE%BE%E5%A4%87"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">5.1.1 I&#x2F;O设备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-2-I-O%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">5.1.2 I&#x2F;O控制方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-4-I-O%E8%BD%AF%E4%BB%B6%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.1.3.</span> <span class="toc-text">5.1.4 I&#x2F;O软件层次结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-4-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8FI-O%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.5.1.4.</span> <span class="toc-text">5.1.4 应用程序I&#x2F;O接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E6%80%A7%E8%BD%AF%E4%BB%B6"><span class="toc-number">1.5.2.</span> <span class="toc-text">5.2 设备独立性软件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-1-%E4%B8%8E%E8%AE%BE%E5%A4%87%E6%97%A0%E5%85%B3%E7%9A%84%E8%BD%AF%E4%BB%B6"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">5.2.1 与设备无关的软件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-2-%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">5.2.2 高速缓存与缓冲区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-3-%E8%AE%BE%E5%A4%87%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">5.2.3 设备的分配与回收</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-4-SPOOLing%E6%8A%80%E6%9C%AF%EF%BC%88%E5%81%87%E8%84%B1%E6%9C%BA%E6%8A%80%E6%9C%AF%EF%BC%89"><span class="toc-number">1.5.2.4.</span> <span class="toc-text">5.2.4 SPOOLing技术（假脱机技术）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-5-%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.5.2.5.</span> <span class="toc-text">5.2.5 设备驱动程序接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E7%A3%81%E7%9B%98%E5%92%8C%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98"><span class="toc-number">1.5.3.</span> <span class="toc-text">5.3 磁盘和固态硬盘</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-1-%E7%A3%81%E7%9B%98"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">5.3.1 磁盘</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-2-%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">5.3.2 磁盘管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-3-%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.3.3.</span> <span class="toc-text">5.3.3 磁盘调度算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-4-%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98"><span class="toc-number">1.5.3.4.</span> <span class="toc-text">5.3.4 固态硬盘</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="footer_deal"><a class="deal_link" target="_blank" rel="noopener" href="https://x.com/OriginBlue50362?t=Yu96I7tDxgX9IGv2CzNnbQ&amp;s=09" title="twitter"><i class="fa-brands fa-twitter"></i></a><a class="deal_link" href="/img/QQ.jpg" title="QQ"><i class="anzhiyufont anzhiyu-icon-qq"></i></a><img class="footer_mini_logo" title="返回顶部" alt="返回顶部" onclick="anzhiyu.scrollToDest(0, 500)" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/freecompress-girl.jpg" size="50px"/><a class="deal_link" href="/img/wechat.jpg" title="微信"><i class="fa-brands fa-weixin"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://github.com/SukhoiGit" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a></div><div id="workboard"><div id="runtimeTextTip"></div></div><div id="anzhiyu-footer"><div class="footer-group"><div class="footer-title">服务</div><div class="footer-links"><a class="footer-item" title="51la统计" target="_blank" rel="noopener" href="https://v6.51.la/">51la统计</a><a class="footer-item" title="十年之约" target="_blank" rel="noopener" href="https://www.foreverblog.cn/">十年之约</a><a class="footer-item" title="开往" target="_blank" rel="noopener" href="https://github.com/travellings-link/travellings">开往</a></div></div><div class="footer-group"><div class="footer-title">导航</div><div class="footer-links"><a class="footer-item" title="即刻短文" href="/essay/">即刻短文</a><a class="footer-item" title="友链文章" href="/fcircle/">友链文章</a><a class="footer-item" title="留言板" href="/comments/">留言板</a></div></div><div class="footer-group"><div class="footer-title">协议</div><div class="footer-links"><a class="footer-item" title="隐私协议" href="/privacy/">隐私协议</a><a class="footer-item" title="Cookies" href="/cookies/">Cookies</a><a class="footer-item" title="版权协议" href="/copyright/">版权协议</a></div></div><div class="footer-group"><div class="footer-title-group"><div class="footer-title">友链</div><a class="random-friends-btn" id="footer-random-friends-btn" href="javascript:addFriendLinksInFooter();" title="换一批友情链接"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right"></i></a></div><div class="footer-links" id="friend-links-in-footer"></div></div></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://github.com/SukhoiGit" style="margin-inline:5px" data-title="本站项目由Github托管" title="本站项目由Github托管"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Source-Github.svg" alt="本站项目由Github托管"/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.2.0/img/badge/Copyright-BY-NC-SA.svg" alt="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"/></a></p></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2023 - 2024 By <a class="footer-bar-link" href="/" title="Artemis" target="_blank">Artemis</a></div></div><div id="footer-type-tips"></div><div class="js-pjax"><script>function subtitleType () {
  if (true) { 
    window.typed = new Typed("#footer-type-tips", {
      strings: ["你千万不要忘记，你永远要为你驯化的东西负责，你要为你的玫瑰🌹负责 ———— 《小王子》","答案在路上,自由在风里","如果你不想成为一个average的人，就去做不average的事","永远保持热情和好奇心","过度地追求局部最优会影响全局最优","莫道桑榆晚，为霞尚满天","心明，万里皆是春","留在码头的船才最安全，但亲爱的，那不是造船的目的","Things will be better while nobody kowns what you are donging"],
      startDelay: 300,
      typeSpeed: 125,
      loop: true,
      backSpeed: 40
    })
  } else {
    document.getElementById("footer-type-tips").innerHTML = '你千万不要忘记，你永远要为你驯化的东西负责，你要为你的玫瑰🌹负责 ———— 《小王子》'
  }
}

if (true) {
  if (typeof Typed === 'function') {
    subtitleType()
  } else {
    getScript('https://cdn.cbd.int/typed.js@2.1.0/dist/typed.umd.js').then(subtitleType)
  }
} else {
  subtitleType()
}</script></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/SukhoiGit" title="项目">项目</a><a class="footer-bar-link" target="_blank" rel="noopener" href="https://7bu.top/login" title="图床">图床</a><a class="footer-bar-link" target="_blank" rel="noopener" href="https://beian.miit.gov.cn/" title="赣ICP备-xxxxxxx号">赣ICP备-xxxxxxx号</a><a class="footer-bar-link cc" href="/copyright" title="cc协议"><i class="anzhiyufont anzhiyu-icon-copyright-line"></i><i class="anzhiyufont anzhiyu-icon-creative-commons-by-line"></i><i class="anzhiyufont anzhiyu-icon-creative-commons-nc-line"></i><i class="anzhiyufont anzhiyu-icon-creative-commons-nd-line"></i></a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">24</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">23</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">5</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://7bu.top/user/dashboard" title="图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="图床"/><span class="back-menu-item-text">图床</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://origin.eqing.tech/" title="AI"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="AI"/><span class="back-menu-item-text">AI</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 链接</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 网页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=9852413331&amp;server=netease"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/API/" style="font-size: 0.88rem;">API<sup>1</sup></a><a href="/tags/Class/" style="font-size: 0.88rem;">Class<sup>1</sup></a><a href="/tags/Collection%E9%9B%86%E5%90%88/" style="font-size: 0.88rem;">Collection集合<sup>1</sup></a><a href="/tags/IO/" style="font-size: 0.88rem;">IO<sup>1</sup></a><a href="/tags/Interface/" style="font-size: 0.88rem;">Interface<sup>1</sup></a><a href="/tags/JS/" style="font-size: 0.88rem;">JS<sup>1</sup></a><a href="/tags/List/" style="font-size: 0.88rem;">List<sup>1</sup></a><a href="/tags/Mybatis/" style="font-size: 0.88rem;">Mybatis<sup>2</sup></a><a href="/tags/Object-Oriented/" style="font-size: 0.88rem;">Object Oriented<sup>1</sup></a><a href="/tags/SpringBoot/" style="font-size: 0.88rem;">SpringBoot<sup>1</sup></a><a href="/tags/String/" style="font-size: 0.88rem;">String<sup>1</sup></a><a href="/tags/Vue/" style="font-size: 0.88rem;">Vue<sup>1</sup></a><a href="/tags/java%E5%9F%BA%E7%A1%80/" style="font-size: 0.88rem;">java基础<sup>1</sup></a><a href="/tags/maven/" style="font-size: 0.88rem;">maven<sup>1</sup></a><a href="/tags/springboot/" style="font-size: 0.88rem;">springboot<sup>1</sup></a><a href="/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/" style="font-size: 0.88rem;">动态代理<sup>1</sup></a><a href="/tags/%E5%8F%8D%E5%B0%84/" style="font-size: 0.88rem;">反射<sup>1</sup></a><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 0.88rem;">多线程<sup>3</sup></a><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 0.88rem;">操作系统<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 0.88rem;">数据结构<sup>2</sup></a><a href="/tags/%E6%B3%A8%E8%A7%A3/" style="font-size: 0.88rem;">注解<sup>1</sup></a><a href="/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/" style="font-size: 0.88rem;">红黑树<sup>1</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" style="font-size: 0.88rem;">网络编程<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="switch-commentBarrage" href="javascript:anzhiyu.switchCommentBarrage();" title="开关弹幕"><i class="anzhiyufont anzhiyu-icon-danmu"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="9852413331" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://music.163.com/#/playlist?id=9852413331&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script async src="/anzhiyu/random.js"></script><script async="async">(function () {
  var grt = new Date("12/25/2023 00:00:00"); //设置网站上线时间
  var now = new Date();
  var dnum;
  var hnum;
  var mnum;
  var snum;
  var nowHour;

  // 计算并更新天数、小时数、分钟数和秒数
  function updateTime() {
    now = new Date(); // 更新 now 的值
    nowHour = now.getHours(); // 更新 nowHour 的值
    var days = (now - grt) / 1000 / 60 / 60 / 24;
    dnum = Math.floor(days);
    var hours = (now - grt) / 1000 / 60 / 60 - 24 * dnum;
    hnum = Math.floor(hours);
    if (String(hnum).length == 1) {
      hnum = "0" + hnum;
    }
    var minutes = (now - grt) / 1000 / 60 - 24 * 60 * dnum - 60 * hnum;
    mnum = Math.floor(minutes);
    if (String(mnum).length == 1) {
      mnum = "0" + mnum;
    }
    var seconds = (now - grt) / 1000 - 24 * 60 * 60 * dnum - 60 * 60 * hnum - 60 * mnum;
    snum = Math.round(seconds);
    if (String(snum).length == 1) {
      snum = "0" + snum;
    }
  }

  // 更新网页中显示的网站运行时间
  function updateHtml() {
    const footer = document.getElementById("footer");
    if (!footer) return
    let currentTimeHtml = "";
    if (nowHour < 18 && nowHour >= 9) {
      // 如果是上班时间，默认就是"安知鱼-上班摸鱼中.svg"图片，不需要更改
      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    } else {
      // 如果是下班时间，插入"安知鱼-下班啦.svg"图片
      let img = document.querySelector("#workboard .workSituationImg");
      if (img != null) {
        img.src = "";
        img.title = "下班了就该开开心心的玩耍，嘿嘿~";
        img.alt = "下班了就该开开心心的玩耍，嘿嘿~";
      }

      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    }

    if (document.getElementById("runtimeTextTip")) {
      document.getElementById("runtimeTextTip").innerHTML = currentTimeHtml;
    }
  }

  setInterval(() => {
    updateTime();
    updateHtml();
  }, 1000);
})();</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><script id="click-heart" src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>