<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>谈谈做父母的期望值</title>
      <link href="/posts/c272b9d9.html"/>
      <url>/posts/c272b9d9.html</url>
      
        <content type="html"><![CDATA[<p>如果父母是985，他们可能会告诉你985虽然在大多数人那有点难，但是你努力肯定是没问题的，因为爸爸妈妈都是这样过来的，甚至像你爸爸还在剑桥上过学，因此咱们只要努力尽力就好，爸妈给你最大的支持和动力，只要你遇到问题，我们都站在你身边。</p><p>如果父母是211，他们会说考不上985没事，考上个不错的211也行。但咱们还是最好冲985呀！爸妈没那个本事考上，但也不至于混得太差！将来给你安排事业单位，到时候工作很稳定，不能富裕但最起码能保证你的安稳，爸妈也给你攒了钱留着买房子，所以，尽力985，不行211。</p><p>如果父母是双非，他们会说别太累着自己，尽力就好。套路如上。</p><p>如果父母*啥不是，他们就望子成龙，望女成凤：他妈**，你个天杀的，天天不好好学习，我费那么大力气供你读书，你学的什么？有没有辜负父母对你的一番折腾？让你好好读书，是让你以后赚大钱的，现在看看你自己，什么都没有，人家（上面父母的小孩儿）怎么就能考上这考上那的？给我出去干活去，学别上了，过一段时间给你找个对象结婚了吧！</p><p>过于真实？</p><p>怎么办？</p><p>请远离上述任何情况的父母，你没有听错。去远征，去探索。</p><p>我：宝贝，做你自己。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Operating System</title>
      <link href="/posts/b64a7908.html"/>
      <url>/posts/b64a7908.html</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="1-计算机系统概述"><a href="#1-计算机系统概述" class="headerlink" title="1 计算机系统概述"></a>1 计算机系统概述</h2><h3 id="1-1-操作系统的基本概念"><a href="#1-1-操作系统的基本概念" class="headerlink" title="1.1 操作系统的基本概念"></a>1.1 操作系统的基本概念</h3><ol><li><p>定义</p><p> 操作系统（Operating System，OS）是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配；以提供给用户和其他软件方便的接口和环境；它是计算机系统中最基本的系统软件。</p></li><li><p>特征</p><ul><li><p>并发</p><p>并发指两个或多个事件在同一时间间隔内发生。这些事件<strong>宏观上是同时发生的，但微观上是交替发生</strong>的。</p><p>OS的并发性是通过分时实现的。</p><ul><li>单核CPU同一时刻只能执行一个程序，各个程序只能并发地执行</li><li>多核CPU同一时刻可以同时执行多个程序，多个程序可以并行地执行</li></ul><blockquote><p><strong>并发性</strong>：两个或多个事件在同一时间间隔内发生。</p><p><strong>并行性</strong>：两个或多个事件在同一时刻发生，需要硬件支持，如多流水线或多处理机硬件环境。</p></blockquote><p>多道程序环境下，一段时间，宏观上，多道程序同时执行某一时刻，单处理机环境下实际仅有一道程序执行，微观上程序分时交替执行</p></li><li><p>共享</p><p>共享即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。</p><ul><li><p><strong>互斥共享方式</strong>：系统中的某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源。</p><p>应用：使用QQ和微信视频。同一时间段内摄像头只能分配给其中一个进程。</p></li><li><p><strong>同时共享方式</strong>：系统中的某些资源，允许一个时间段内由多个进程“同时”对它们进行访问。</p><p>应用：使用QQ发送文件A，同时使用微信发送文件B。宏观上看，两边都在同时读取并发送文件说明两个进程都在访问硬盘资源，从中读取数据。微观上看，两个进程是交替着访问硬盘的。</p></li></ul><blockquote><p>所谓的“同时”往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问的（即分时共享）</p></blockquote><p>并发和共享是操作系统两个最基本的特征，两者之间互为存在的条件：</p><ul><li>①资源共享是以程序的并发为条件的，若系统不允许程序并发执行，则自然不存在资源共享问题；</li><li>②若系统不能对资源共享实施有效的管理，则必将影响到程序的并发执行，甚至根本无法并发执行。</li></ul></li><li><p>虚拟</p><p>虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的。</p><ul><li><p><strong>虚拟处理器</strong>：通过<strong>时分复用</strong>技术，让多道程序并发执行的方法，来分时使用一个处理器的。</p><p>虽然只有一个处理器，但它能同时为多个用户服务，使每个终端用户都感觉有一个中央处理器（CPU）在专门为它服务。</p></li><li><p><strong>虚拟存储器</strong>：通过<strong>空分复用</strong>技术，将一台机器的物理存储器变为虚拟存储器，以便从逻辑上扩充存储器的容量。当然，这时用户所感觉到的内存容量是虚的。</p></li><li><p>虚拟I&#x2F;O设备：采用虚拟设备技术将一台物理I&#x2F;O设备虚拟为多台逻辑上的I&#x2F;O设备，并允许每个用户占用一台逻辑上的I&#x2F;O设备，使原来仅允许在一段时间内由一个用户访问的设备（即临界资源）变为在一段时间内允许多个用户同时访问的<strong>共享设备</strong>。</p></li></ul></li><li><p>异步</p><p>在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是<strong>进程的异步性</strong>。</p></li></ul></li><li><p>功能</p><p> 为了给多道程序提供良好的运行环境，操作系统应具有以下几方面的功能：处理机管理、存储器管理、设备管理和文件管理。为了方便用户使用操作系统，还必须向用户提供接口。同时，操作系统可用来扩充机器，以提供更方便的服务、更高的资源利用率。</p><ul><li><p>操作系统是系统资源的管理者</p><ul><li><p><strong>处理机管理</strong></p><p>即<strong>对进程的管理</strong>，包括进程控制、进程同步、进程通信、死锁处理、处理机调度等。</p></li><li><p><strong>存储器管理</strong></p><p>方便程序运行、用户使用及提高内存的利用率，包括内存分配与回收、地址映射、内存保护与共享和内存扩充等功能。</p></li><li><p><strong>文件管理</strong></p><p>计算机中的信息都是以文件的形式存在的，操作系统中负责文件管理的部分称为<strong>文件系统</strong>。</p><p>文件管理包括文件存储空间的管理、目录管理及文件读写管理和保护等。</p></li><li><p><strong>设备管理</strong></p><p>设备管理的主要任务是完成用户的I&#x2F;O请求，方便用户使用各种设备，并提高设备的利用率，主要包括缓冲管理、设备分配、设备处理和虚拟设备等功能。</p></li></ul></li><li><p>向上层提供方便易用的服务</p><ul><li><p><strong>命令接口</strong></p><p><strong>用户</strong>利用这些操作命令来组织和控制作业的执行。</p><ul><li><p><strong>联机命令接口</strong>：即交互式命令接口，适用于分时或实时系统。</p><p>“雇主”说一句话，“工人”做一件事，并做出反馈，这就强调了交互性。</p></li><li><p><strong>脱机命令接口</strong>：即批处理命令接口，适用于批处理系统</p><p>“雇主”把要“工人”做的事写在清单上，“工人”按照清单命令逐条完成这些事，这就是批处理。</p></li></ul></li><li><p><strong>程序接口</strong></p><p>程序接口由一组<strong>系统调用</strong>（也称广义指令）组成。是为编程人员提供的接口。普通用户不能直接使用程序接口，只能通过程序代码间接使用。</p><p>用户通过在程序中使用<strong>系统调用命令</strong>请求OS为其提供服务。系统调用命令又称广义指令。</p></li><li><p><strong>GUl：图形化用户接口</strong>（Graphical User Interface）</p><p>用户可以使用形象的图形界面进行操作，而不再需要记忆复杂的命令、参数。</p></li></ul></li><li><p>是最接近硬件的一层软件</p><p><strong>裸机</strong>：没有任何软件支持的计算机称为裸机，它仅构成计算机系统的物质基础。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230906161936845.png" alt="image-20230906161936845"></p><p>在裸机上安装的操作系统，可以提供资源管理功能和方便用户的服务功能，将裸机改造成功能更强、使用更方便的机器。</p><p>通常把覆盖了软件的机器成为<strong>扩充机器</strong>，又称之为<strong>虚拟机</strong>。</p></li></ul></li></ol><blockquote><p>例：</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230906162625137.png" alt="image-20230906162625137"></p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230906162652164.png" alt="image-20230906162652164"></p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230906162907975.png" alt="image-20230906162907975"></p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230906162925001.png" alt="image-20230906162925001"></p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230906163023486.png" alt="image-20230906163023486"></p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230906163041909.png" alt="image-20230906163041909"></p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230906163257516.png" alt="image-20230906163257516"></p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230906163342210.png" alt="image-20230906163342210"></p></blockquote><h3 id="1-2-操作系统发展历程"><a href="#1-2-操作系统发展历程" class="headerlink" title="1.2 操作系统发展历程"></a>1.2 操作系统发展历程</h3><ol><li><p>手工操作阶段（此阶段无操作系统）</p><p>用户在计算机上算题的所有工作都要人工干预，如程序的装入、运行、结果的输出等。</p><ul><li>缺点：<ul><li>用户独占全机</li><li>CPU等待手工操作，CPU利用不充分</li></ul></li><li>人机矛盾：CPU和I&#x2F;O速度不匹配的矛盾。</li></ul></li><li><p>批处理阶段（操作系统开始出现）</p><ul><li><p><strong>单道批处理系统</strong>：引入脱机输入输出技术</p><ul><li><strong>特征</strong>：<ul><li><strong>自动性</strong>。在顺利的情况下，磁带上的一批作业能自动地逐个运行，而无须人工干预。</li><li><strong>顺序性</strong>。磁带上的各道作业顺序地进入内存，各道作业的完成顺序与它们进入内存的顺序在正常情况下应完全相同，亦即先调入内存的作业先完成。</li><li><strong>单道性</strong>。内存中仅有一道程序运行，即监督程序每次从磁带上只调入一道程序进入内存运行，当该程序完成或发生异常情况时，才换入其后继程序进入内存运行。</li></ul></li><li><strong>优点</strong>：缓解人机速度矛盾。</li><li><strong>缺点</strong>：资源利用率仍低，高速CPU等待低速I&#x2F;O。</li></ul></li><li><p><strong>多道批处理系统</strong>：多道程序设计技术操作系统开始出现</p><p><strong>多道程序设计</strong>：允许<strong>多个程序同时进入内存</strong>并允许它们<strong>在CPU中交替地运行</strong>，这些程序共享系统中的各种硬&#x2F;软件资源。当一道程序因I&#x2F;O请求而暂停运行时，CPU便立即转去运行另一道程序。</p><ul><li><strong>特点</strong>：<ul><li><strong>多道</strong>。计算机内存中同时存放多道相互独立的程序。</li><li><strong>宏观上并行</strong>。同时进入系统的多道程序都处于运行过程中，即它们先后开始各自的运行，但都未运行完毕。</li><li><strong>微观上串行</strong>。内存中的多道程序轮流占有CPU，交替执行。</li><li><strong>间断性</strong>：由于多道程序之间需要共享和竞争系统资源，因此每个程序的执行过程不是连续的，而是有间断的。</li><li><strong>共享性</strong>：多道程序之间需要共享系统的各种资源，如CPU、内存、外设等。</li><li><strong>制约性</strong>：多道程序之间存在相互制约的关系，如同步、互斥、优先级等。</li></ul></li><li>技术实现：<ul><li>如何分配处理器。</li><li>多道程序的内存分配问题。</li><li>I&#x2F;O设备如何分配。</li><li>如何组织和存放大量的程序和数据，以方便用户使用并保证其安全性与一致性。</li></ul></li><li><strong>优点</strong>：<ul><li>资源利用率高，多道程序并发执行，共享计算机资源</li><li>系统吞叶量大，CPU和其他资源保持”忙碌”</li></ul></li><li><strong>缺点</strong>：用户响应时间长、无人机交互能力</li></ul></li></ul></li><li><p>分时操作系统</p><p><strong>分时技术</strong>：计算机以<strong>时间片为单位</strong>轮流为各个用户&#x2F;作业服务，各个用户可通过终端与计算机进行交互。</p><p>多个用户通过终端同时共享一台主机，用户可以同时与主机进行交互操作而互不干扰。</p><ul><li><strong>特点</strong><ul><li><strong>同时性</strong>。同时性也称多路性，指允许多个终端用户同时使用一台计算机，即一台计算机与若干台终端相连接，终端上的这些用户可以同时或基本同时使用计算机。</li><li><strong>交互性</strong>。用户能够方便地与系统进行人机对话，即用户通过终端采用人机对话的方式直接控制程序运行，与同程序进行交互。</li><li><strong>独立性</strong>。系统中多个用户可以彼此独立地进行操作，互不干扰，单个用户感觉不到别人也在使用这台计算机，好像只有自己单独使用这台计算机一样。</li><li><strong>及时性</strong>。用户请求能在很短时间内获得响应。分时系统采用时间片轮转方式使一台计算机同时为多个终端服务，使用户能够对系统的及时响应感到满意。</li></ul></li><li>优点<ul><li>用户请求可以被即时响应，解决了人机交互问题。</li><li>允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。</li></ul></li><li>缺点：无法优先处理紧急任务</li></ul></li><li><p>实时操作系统</p><p>能在某个时间限制内完成某些紧急任务而不需要时间片排队。</p><ul><li><p>分类：</p><ul><li><p>软实时系统：能够接受偶尔违反时间规定且不会引起永久性的损害。</p><p>如飞机订票系统、银行管理系统。</p></li><li><p>硬实时系统：某个动作必须绝对地在规定的时刻（或规定的时间范围）发生。</p><p>如飞行器的飞行自动控制系统。</p></li></ul></li><li><p>特点</p><ul><li>及时性</li><li>可靠性</li></ul></li><li><p>优点：能够优先处理紧急任务</p></li></ul></li><li><p>网络操作系统和分布式计算机系统</p><ul><li>网络操作系统：把计算机网络中的各台计算机有机地结合起来，提供一种统一、经济而有效的使用各台计算机的方法，实现各台计算机之间数据的互相传送。<ul><li>特点<ul><li>网络中各种资源的共享</li><li>各台计算机之间的通信</li></ul></li></ul></li><li>分布式计算机系统：由多台计算机组成并满足下列条件的系统，主要特点是分布性和并行性。<ul><li>系统中任意两台计算机通过通信方式交换信息</li><li>系统中的每台计算机都具有同等的地位，即没有主机也没有从机</li><li>每台计算机上的资源为所有用户共享</li><li>系统中的任意台计算机都可以构成一个子系统，并且还能重构</li><li>任何工作都可以分布在几台计算机上，由它们并行工作、协同完成</li></ul></li><li>分布式操作系统与网络操作系统的本质不同：分布式操作系统中的若干计算机<strong>相互协同完成同一任务</strong>。</li></ul></li><li><p>个人计算机操作系统</p><p>个人计算机操作系统是目前使用最广泛的操作系统，它广泛应用于文字处理、电子表格、游戏中。</p><p>常见的有Windows、Linux和MacOS等。</p></li></ol><p> 操作系统发展历程如下图所示。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230906170455342.png" alt="image-20230906170455342"></p><p> 此外，还有嵌入式操作系统、服务器操作系统、智能手机操作系统等。</p><blockquote><p>例</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230906172127304.png" alt="image-20230906172127304"></p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230906172205744.png" alt="image-20230906172205744"></p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230906172222270.png" alt="image-20230906172222270"></p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230906172239874.png" alt="image-20230906172239874"></p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230906172347580.png" alt="image-20230906172347580"></p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230906172651255.png" alt="image-20230906172651255"></p></blockquote><h3 id="1-3-操作系统运行环境"><a href="#1-3-操作系统运行环境" class="headerlink" title="1.3 操作系统运行环境"></a>1.3 操作系统运行环境</h3><h4 id="1-3-1-处理器运行模型"><a href="#1-3-1-处理器运行模型" class="headerlink" title="1.3.1 处理器运行模型"></a>1.3.1 处理器运行模型</h4><ol><li><p>在计算机系统中，通常CPU执行两种不同性质的程序：</p><ul><li>操作系统<strong>内核程序</strong>：是用户自编程序的管理者，“管理程序”（即内核程序）要执行一些特权指令。</li><li>用户自编程序：即系统外层的应用程序，或简称“应用程序”，“被管理程序”（即用户自编程序）出于安全考虑不能执行这特权指令。</li></ul></li><li><p>特权指令和非特权指令</p><ul><li><strong>特权指令</strong>：是指不允许用户直接使用的指令，如&#x2F;O指令、置中断指令，存取用于内存保护的寄存器、送程序状态字到程序状态字寄存器等的指令。</li><li><strong>非特权指令</strong>：是指允许用户直接使用的指令，它不能直接访问系统中的软硬件资源，仅限于访问用户的地址空间，这也是为了防止用户程序对系统造成破坏。</li></ul></li><li><p>CPU的运行模式</p><ul><li><strong>用户态（目态）</strong>：CPU处于用户态，此时CPU只能执行非特权指令。</li><li><strong>核心态（又称管态、内核态）</strong>：CPU处于核心态，此时CPU可以执行特权指令，切换到用户态的指令也是特权指令。</li></ul><p>应用程序运行在用户态，操作系统内核程序运行在核心态。</p><blockquote><p>内核态一&gt;用户态：一条修改PSW的特权指令</p><p>用户态一&gt;内核态：应用程序向操作系统请求服务时通过使用访管指令，从而产生一个中断事件将操作系统转换为核心态。</p></blockquote></li><li><p>分层管理</p><ul><li>一些与硬件关联较紧密的模块，如时钟管理、中断处理、设备驱动等处于最低层。</li><li>其次是运行频率较高的程序，如进程管理、存储器管理和设备管理等。</li></ul><p>这两部分内容构成了操作系统的内核。这部分内容的指令操作工作在核心态。</p></li><li><p>操作系统内核功能</p><p><strong>内核</strong>（Kernel）是计算机上配置的底层软件，它管理着系统的各种资源，可以看作是连接应用程序和硬件的一座桥梁。由很多内核程序组成操作系统内核。</p><ul><li><p><strong>时钟管理</strong></p><ul><li><p>计时：是时钟的第一功能，操作系统需要通过时钟管理，向用户提供标准的系统时间。</p></li><li><p>进程切换：通过时钟中断的管理实现。</p><p>例如，在分时操作系统中采用时间片轮转调度，在实时系统中按截止时间控制运行，在批处理系统中通过时钟管理来衡量一个作业的运行程度等。</p></li></ul></li><li><p><strong>中断机制</strong></p><p><strong>中断作用</strong>：</p><ul><li>让操作系统内核强行夺回CPU的控制权</li><li>使CPU从用户态变为内核态</li></ul><p>引入原因：提高多道程序运行环境中CPU的利用率。</p><p>现代操作系统是靠中断驱动的软件</p></li><li><p><strong>原语</strong></p><p>由若干条指令组成的，用于完成一定功能的一个过程。</p><p><strong>特点</strong>：</p><ul><li>1）处于操作系统的最底层，是最接近硬件的部分。</li><li>2）这些程序的运行具有原子性，其操作只能一气呵成（出于系统安全性和便于管理考虑）。</li><li>3）这些程序的运行时间都较短，而且调用频繁。</li></ul><p>定义原语的直接方法是关闭中断，让其所有动作不可分割地完成后再打开中断。</p><p>系统中的设备驱动、CPU切换、进程通信等功能中的部分操作都可定义为原语，使它们成为内核的组成部分。</p></li><li><p><strong>系统控制的数据结构及处理</strong></p><p>系统中用来登记状态信息的<strong>数据结构</strong>很多，如作业控制块、进程控制块（PCB）、设备控制块、各类链表、消息队列、缓冲区、空闲区登记表、内存分配表等。</p><p>为了实现有效的管理，系统需要一些基本的操作，常见的操作有以下3种：</p><ul><li>1）进程管理。进程状态管理、进程调度和分派、创建与撤销进程控制块等。</li><li>2）存储器管理。存储器的空间分配和回收、内存信息保护程序、代码对换程序等。</li><li>3）设备管理。缓冲区管理、设备分配和回收等。</li></ul></li></ul><p><strong>核心态指令</strong>实际上包括<strong>系统调用类指令</strong>和一些针对<strong>时钟、中断</strong>和<strong>原语</strong>的操作指令。</p></li></ol><h4 id="1-3-2-中断和异常的概念"><a href="#1-3-2-中断和异常的概念" class="headerlink" title="1.3.2 中断和异常的概念"></a>1.3.2 中断和异常的概念</h4><ol><li><p>中断作用</p><p>让操作系统内核强行夺回CPU的控制权；使CPU从用户态变为内核态。</p></li><li><p>中断和异常的分类</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230907103043486.png" alt="image-20230907103043486"></p><ul><li><strong>异常</strong>：又称内中断，指来自CPU执行指令内部的事件，如程序的非法操作码、地址越界、运算溢出、虚存系统的缺页及专门的陷入指令等引起的事件。<ul><li>故障（Fault）通常是由指令执行引起的异常，如非法操作码、缺页故障、除数为0、运算溢出等。</li><li>自陷（Trap）是一种事先安排的“异常”事件，用于在用户态下调用操作系统内核程序，如条件陷阱指令。</li><li>终止（Abort）是指出现了使得CPU无法继续执行的硬件故障，如控制器出错、存储器校验错等。</li></ul></li><li><strong>中断</strong>：又称外中断，指来自CPU执行指令外部的事件，通常用于信息输入&#x2F;输出，如I&#x2F;O中断，时钟中断。<ul><li><strong>可屏蔽中断</strong>：指通过INTR线发出的中断请求，通过改变屏蔽字可以实现多重中断，从而使得中断处理更加灵活。</li><li><strong>不可屏蔽中断</strong>：指通过NMI线发出的中断请求，通常是紧急的硬件故障，如电源掉电等。此外，异常也是不能被屏蔽的。</li></ul></li></ul><p>故障异常和自陷异常属于<strong>软件中断（程序性异常）</strong>，终止异常和外部中断属于<strong>硬件中断</strong>。</p><p>异常不能被屏蔽，一旦出现，就应立即处理。</p></li><li><p>中断和异常的处理过程</p><ul><li><p>当CPU在执行用户程序的第i条指令时检测到一个异常事件，或在执行第i条指令后发现一个中断请求信号，</p></li><li><p>则CPU打断当前的用户程序，然后转到相应的中断或异常处理程序去执行。</p></li><li><p>若中断或异常处理程序能够解决相应的问题，则在中断或异常处理程序的最后，CPU通过执行中断或异常返回指令，回到被打断的用户程序的第i条指令或第i+1条指令继续执行</p><blockquote><p>返回第i+1条指令：由自陷（Trap）引起的内中断；如系统调用。由外部设备引起的外中断，如键盘</p><p>返回第i条指令：由故障（Fault）引起的内中断；如缺页等。</p></blockquote></li><li><p>若中断或异常处理程序发现是不可恢复的致命错误，则终止用户程序。</p></li></ul><p>通常情况下，对中断和异常的具体处理过程由操作系统（和驱动程序）完成。</p></li></ol><h4 id="1-3-3-系统调用"><a href="#1-3-3-系统调用" class="headerlink" title="1.3.3 系统调用"></a>1.3.3 系统调用</h4><ol><li><p>定义</p><p>操作系统作为用户和计算机硬件之间的接口，需要向上提供一些简单易用的服务，系统调用可视为特殊的公共子程序。又称<strong>广义指令</strong>。<strong>程序接口</strong>由一组系统调用组成。目的为解决资源分配问题</p></li><li><p>分类</p><ul><li><strong>设备管理</strong>：完成设备的请求或释放，以及设备启动等功能。</li><li><strong>文件管理</strong>：完成文件的读、写、创建及删除等功能。</li><li><strong>进程控制</strong>：完成进程的创建、撤销、阻塞及唤醒等功能。</li><li><strong>进程通信</strong>：完成进程之间的消息传递或信号传递等功能。</li><li><strong>内存管理</strong>：完成内存的分配、回收以及获取作业占用内存区大小及始址等功能。</li></ul></li><li><p>系统调用过程</p><p>系统调用的处理需要由操作系统内核程序负责完成，要运行在<strong>核心态</strong>。</p><p>用户程序可以执行陷入指令（又称访管指令或trap指令）来发起系统调用，请求操作系统提供服务。</p><blockquote><p>访管指令不是特权指令，访管指令是在用户态使用的，所以它不可能是特权指令。</p></blockquote><ul><li><p><strong>系统调用执行过程：</strong></p><p>传递系统调用参数→执行陷入（trap）指令→执行相应的服务程序→返回用户态</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230907104615415.png" alt="image-20230907104615415"></p><ul><li>当需要管理程序服务时，系统则通过硬件中断机制进入核心态，运行管理程序；</li><li>也可能是程序运行出现异常情况，被动地需要管理程序的服务，这时就通过异常处理来进入核心态。</li><li>管理程序运行结束时，用户程序需要继续运行，此时通过相应的保存的程序现场退出中断处理程序或异常处理程序，返回断点处继续执行</li></ul></li><li><p><strong>用户态转向核心态的例子：</strong></p><ul><li>用户程序要求操作系统的服务，即系统调用。</li><li>发生一次中断。</li><li>用户程序中产生了一个错误状态。</li><li>用户程序中企图执行一条特权指令。</li><li>从核心态转向用户态由一条指令实现，这条指令也是特权命令，一般是中断返回指令。</li></ul></li><li><p><strong>只能在核心态下执行的指令（特权指令）：</strong></p><ul><li>开关中断指令，用于允许或禁止中断，控制中断屏蔽位</li><li>设置时钟日期指令，用于修改系统时钟</li><li>改变存储映像图指令，用于修改主存保护机制</li><li>启动I&#x2F;O指令，用于控制I&#x2F;O设备的工作状态和动作</li><li>加载PSW指令，用于修改程序状态字（PSW），包括中断标志位、运算结果标志位等</li><li>置特殊寄存器指令，用于存取中断寄存器、时钟寄存器等特殊寄存器</li><li>停机指令，用于停止一个中央处理器的工作</li></ul></li></ul><blockquote><p>注意：由用户态进入核心态，不仅状态需要切换，而且所用的堆栈也可能需要由用户堆栈切换为系统堆栈，但这个系统堆栈也是属于该进程的。</p></blockquote></li><li><p>与库函数的区别</p><ul><li>有的库函数是对系统调用的进一步封装：如“创建一个新文件”的函数</li><li>有的库函数没有使用系统调用：如的“取绝对值”的函数</li></ul></li></ol><blockquote><p>例：</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230907110731631.png" alt="image-20230907110731631"></p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230907110712402.png" alt="image-20230907110712402"></p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230907111326699.png" alt="image-20230907111326699"></p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230907111012720.png" alt="image-20230907111012720"></p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230907112051407.png" alt="image-20230907112051407"></p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230907112105166.png" alt="image-20230907112105166"></p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230907112801641.png" alt="image-20230907112801641"></p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230907112817415.png" alt="image-20230907112817415"></p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230907113824708.png" alt="image-20230907113824708"></p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230907113836680.png" alt="image-20230907113836680"></p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230907114514637.png" alt="image-20230907114514637"></p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230907114540607.png" alt="image-20230907114540607"></p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230907124502957.png" alt="image-20230907124502957"></p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230907124527899.png" alt="image-20230907124527899"></p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230907134939200.png" alt="image-20230907134939200"></p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230907135000007.png" alt="image-20230907135000007"></p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230907135104614.png" alt="image-20230907135104614"></p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230907135130034.png" alt="image-20230907135130034"></p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230907141021682.png" alt="image-20230907141021682"></p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230907141044338.png" alt="image-20230907141044338"></p></blockquote><h3 id="1-4-操作系统结构"><a href="#1-4-操作系统结构" class="headerlink" title="1.4 操作系统结构"></a>1.4 操作系统结构</h3><ol><li><p>分层法</p><p> 分层法是将操作系统分为若干层，最底层（层0）为<strong>硬件</strong>，最高层（层N）为<strong>用户接口</strong>，每层只能调用紧邻它的低层的功能和服务（<strong>单向依赖</strong>）。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230907141834858.png" alt="image-20230907141834858"></p><ul><li>优点：<ul><li>①便于系统的调试和验证，简化了系统的设计和实现。只需调试每层功能，无需考虑其他层。</li><li>②易扩充和易维护。在系统中修改添加某层，不改变接口就不影响其他层。</li></ul></li><li>缺点：<ul><li>①合理定义各层比较困难。因为依赖关系固定后，往往就显得不够灵活。</li><li>②效率较差。执行一个功能要穿梭多层，每层通信增大开销。</li></ul></li></ul></li><li><p>模块化</p><p>模块化是将操作系统按功能划分为若干具有一定独立性的模块。每个模块具有某方面的管理功能，并规定好各模块间的接口，使各模块之间能够通过接口进行通信。各模块还可划分成子模块，子模块之间也规定好接口。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230907142713472.png" alt="image-20230907142713472"></p><ul><li>模块划分应考虑其划分大小，及独立性，衡量独立性有两个标准：<ul><li>内聚性，模块内部各部分间联系的紧密程度。内聚性越高，模块独立性越好。</li><li>耦合度，模块间相互联系和相互影响的程度。耦合度越低，模块独立性越好。</li></ul></li><li>优点：<ul><li>①提高了操作系统设计的正确性、可理解性和可维护性；</li><li>②增强了操作系统的可适应性；</li><li>③加速了操作系统的开发过程。</li></ul></li><li>缺点：<ul><li>①模块间的接口规定很难满足对接口的实际需求。</li><li>②各模块设计者齐头并进，每个决定无法建立在上一个已验证的正确决定的基础上，因此无法找到一个可靠的决定顺序。</li></ul></li></ul></li><li><p>宏内核</p><p>又称<strong>大内核</strong>或<strong>单内核</strong>，是指将系统的<strong>主要功能模块</strong>都作为一个紧密联系的整体运行在核心态，从而为用户程序提供高性能的系统服务。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230907143626843.png" alt="image-20230907143626843"></p><ul><li>优点：高性能</li><li>缺点：内核代码庞大，结构混乱，难以维护</li><li>应用：Windows、Linux、Android、IOS、macOS等架构；但其都广泛吸取微内核的优点进行改进。</li></ul></li><li><p>微内核</p><p>微内核构架，是指将内核中<strong>最基本的功能</strong>保留在内核，而将那些不需要在核心态执行的功能移到用户态执行，从而降低内核的设计复杂性。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230907143857739.png" alt="image-20230907143857739"></p><p>那些移出内核的操作系统代码根据分层的原则被划分成若干服务程序，它们的执行相互独立，交互则都借助于微内核进行通信。</p><p>微内核架构&#x3D;微内核+多个服务器</p><ul><li><p>微内核内容</p><ul><li>①与硬件处理紧密相关的部分</li><li>②一些较基本的功能</li><li>③客户和服务器之间的通信。</li></ul></li><li><p>服务器（进程）</p><ul><li>用于提供对进程（线程）进行管理的进程（线程）服务器、</li><li>提供虚拟存储器管理功能的虚拟存储器服务器等，</li></ul><p>它们都是作为进程来实现的，运行在用户态，客户与服务器之间是借助微内核提供的消息传递机制来实现交互的。下图为单机环境下的客户&#x2F;服务器模式。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230907144344712.png" alt="image-20230907144344712"></p></li><li><p>微内核基本功能</p><ul><li><p>①进程（线程）管理。</p><p>如进程（线程）之间通信、切换、调度以及多处理机之间的同步。</p></li><li><p>②低级存储器管理。</p><p>如用于实现将逻辑地址变换为物理地址等的页表机制和地址变换机制，这一部分是依赖于硬件的，因此放入微内核。</p></li><li><p>③中断和陷入处理。</p><p>捕获所发生的中断和陷入事件，并进行中断响应处理，在识别中断或陷入的事件后，再发送给相关的服务器来处理</p></li></ul></li><li><p>微内核特点</p><ul><li>①扩展性和灵活性。增添新的功能无需改变内核代码，只需在相应服务器中修改添加新功能。</li><li>②可靠性和安全性。某个模块崩溃时，只会使该进程崩溃，不会使整个系统崩溃。</li><li>③可移植性。与CPU和I&#x2F;O硬件有关的代码均放在内核中，移植代码无需考虑硬件差异。</li><li>④分布式计算。采用消息传递机制，使微内核系统能很好地支持分布式系统和网络系统。</li></ul></li><li><p>微内核缺点：需要频繁地在核心态和用户态之间切换，性能低</p></li><li><p>应用：鸿蒙OS、实时、工业、航空及军事应用。</p></li></ul></li><li><p>外核（exokernel）</p><p> 内核负责进程调度、进程通信等功能；外核在内核态运行，负责为用户进程分配未经抽象的硬件资源，且由外核负责保证资源使用安全。</p><ul><li>任务：为虚拟机分配资源，并检查使用这些资源的企图，以确保没有机器会使用他人的资源。每个用户层的虚拟机可以运行自己的操作系统，但限制只能使用已经申请并且获得分配的那部分资源。</li><li>优点<ul><li>外核可直接给用户进程分配“不虚拟、不抽象的硬件资源，使用户进程可以更灵活的使用硬件资源</li><li>减少了虚拟硬件资源的“映射层”，提升效率</li></ul></li><li>缺点<ul><li>降低了系统的一致性</li><li>使系统变得更复杂</li></ul></li></ul></li></ol><h3 id="1-5-操作系统引导"><a href="#1-5-操作系统引导" class="headerlink" title="1.5 操作系统引导"></a>1.5 操作系统引导</h3><ol><li><p>概念</p><ul><li><p>BIOS 程序（Basic Input&#x2F;Output System）</p><p>BIOS 是固化在主板上的<strong>基本输入输出系统</strong>，是计算机启动第一个运行的软件，存放在ROM中。它会进行硬件初始化和自检，然后查找引导程序并执行。</p></li><li><p>引导程序（Boot）</p><p>引导程序是存储在主存ROM中的一段小程序，它的作用是将操作系统的内核文件从硬盘中读取到内存中，并跳转到内核入口点开始执行。</p></li><li><p>主引导记录(MBR)</p><p>MBR是硬盘的主引导记录，位于硬盘的第一个扇区。它包含了磁盘引导程序和分区表。该引导程序会找到<strong>活动分区</strong>并读取其分区引导记录，完成硬盘的引导。</p></li><li><p>分区引导记录(PBR)</p><p>PBR是分区引导记录，位于每个分区的第一个扇区。PBR中包含了一个引导程序，可以寻找并激活分区根目录下的启动管理器，完成分区的引导过程。</p></li></ul></li><li><p>引导过程</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230907152457354.png" alt="image-20230907152457354"></p><p>引导过程：</p><ul><li><p>①CPU从一个特定主存地址开始，取指令，执行ROM中的引导程序（先进行硬件自检，再开机）</p><ul><li>BIOS初始化并执行引导程序进行自检,确保硬件工作正常。</li><li>BIOS查找可引导设备(通常是安装有操作系统的硬盘),读取主引导记录(MBR)。</li></ul></li><li><p>②将磁盘的第一块一一</p><p>主引导记录</p><p>读入内存，执行磁盘引导程序，扫描分区表</p><ul><li>MBR执行,识别活动分区,查找并执行该分区的分区引导记录(PBR)。</li></ul></li><li><p>③从</p><p>活动分区</p><p>（又称主分区，即安装了操作系统的分区）读入分区引导记录，执行其中的程序</p><ul><li>PBR找到分区中操作系统的启动管理器程序并加载执行。</li></ul></li><li><p>④从根目录下找到完整的操作系统初始化程序（即启动管理器）并执行，完成“开机”的一系列动作</p><ul><li>启动管理器进一步加载操作系统内核和关键组件到内存。</li><li>操作系统内核接管硬件控制权,初始化系统,启动操作系统。</li></ul></li></ul><blockquote><p>注：操作系统最终被加载到 RAM 中。</p></blockquote></li></ol><h3 id="1-6-虚拟机"><a href="#1-6-虚拟机" class="headerlink" title="1.6 虚拟机"></a>1.6 虚拟机</h3><ol><li><p>定义</p><p>使用虚拟化技术，将一台物理机器虚拟化为多台虚拟机器（Virtual Machine，VM），每个虚拟机器都可以独立运行一个操作系统。</p></li><li><p>分类</p><ul><li><p>第一类虚拟机程序</p><p>第一类虚拟机管理程序就像一个<strong>操作系统</strong>，因为它是唯一一个运行在最高特权级的程序。</p><p>它在裸机上运行并且具备多道程序功能。虚拟机管理程序向上层提供若干台虚拟机，这些虚拟机是裸机硬件的精确复制品。由于每台虚拟机都与裸机相同，所以在不同的虚拟机上可以<strong>运行任何不同的操作系统</strong>。</p><p>虚拟内核态：虚拟机作为用户态的一个进程运行，不允许执行敏感指令。然而，虚拟机上的操作系统认为自己运行在内核态（实际上不是），称为虚拟内核态。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/babb5d7bec774542a42669e1fd185de3.png" alt="babb5d7bec774542a42669e1fd185de3"></p></li><li><p>第二类虚拟机程序</p><p>它是一个依赖于Windows、Linux等操作系统分配和调度资源的程序，很像一个<strong>普通的进程</strong>。</p><p>如VMware Workstation。</p><p>对于第二类虚拟机管理程序，运行在底层硬件上的操作系统称为<strong>宿主操作系统</strong>；运行在虚拟机管理程序上的操作系统称为<strong>客户操作系统</strong>。</p><p>首次启动时，第二类虚拟机管理程序像一台刚启动的计算机那样运转，期望找到的驱动器可以是虚拟设备。然后将操作系统安装到虚拟磁盘上（其实只是宿主操作系统中的一个文件）。客户操作系统安装完成后，就能启动并运行。</p></li></ul></li><li><p>对比</p><table><thead><tr><th align="center"></th><th align="center">第一类VMM</th><th align="center">第二类VMM</th></tr></thead><tbody><tr><td align="center">对物理资源的控制权</td><td align="center">直接运行在硬件之上，能直接控制和分配物理资源</td><td align="center">运行在Host OS之上，依赖于Host OS为其分配物理资源</td></tr><tr><td align="center">资源分配方式</td><td align="center">在安装Guest OS时，VMM要在原本的硬盘上自行分配存储空间，类似于”外核“的分配方式，分配未经抽象的物理硬件</td><td align="center">GuestOs拥有自己的虚拟磁盘，该盘实际上是HostOs文件系统中的一个大文件。GuestOs分配到的内存是虚拟内存</td></tr><tr><td align="center">性能</td><td align="center">性能更好</td><td align="center">性能更差，需要Host Os作为”中介”</td></tr><tr><td align="center">可支持的虚拟机数量</td><td align="center">更多，不需要和Host OS竞争资源，相同的硬件资源可以支持更多的虚拟机</td><td align="center">更少，Host Os本身需要使用物理资源，Host OS上运行的其他进程也需要物理资源</td></tr><tr><td align="center">虚拟机的可迁移性</td><td align="center">更差</td><td align="center">更好，只需导出虚拟机镜像文件即可迁移到另一台Host Os上，商业化应用更广泛</td></tr><tr><td align="center">运行模式</td><td align="center">第一类VMM运行在最高特权级（Ring 0），可以执行最高特权的指令。</td><td align="center">第二类VMM部分运行在用户态、部分运行在内核态。GuestOs发出的系统调用会被VMM截获，并转化为VMM对Hostos的系统调用</td></tr></tbody></table></li></ol><blockquote><p>例<br><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230907162533481.png" alt="image-20230907162533481"></p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230907162545296.png" alt="image-20230907162545296"></p></blockquote><h2 id="2-进程与线程"><a href="#2-进程与线程" class="headerlink" title="2 进程与线程"></a>2 进程与线程</h2><h3 id="2-1-进程与线程"><a href="#2-1-进程与线程" class="headerlink" title="2.1 进程与线程"></a>2.1 进程与线程</h3><h4 id="2-1-1-进程的概念和特征"><a href="#2-1-1-进程的概念和特征" class="headerlink" title="2.1.1 进程的概念和特征"></a>2.1.1 进程的概念和特征</h4><ol><li><p>进程的概念</p><p>进程是进程实体的<strong>运行过程</strong>，是系统进行<strong>资源分配和调度</strong>的一个独立单位。</p><blockquote><p>进程实现操作系统的并发性和共享性。</p></blockquote><p>程序：是<strong>静态</strong>的，就是个存放在磁盘里的<strong>可执行文件</strong>，如：QQ.exe。</p><p>进程：是<strong>动态</strong>的，是程序的一次<strong>执行过程</strong>，或者是一个<strong>正在运行的程序</strong>，如：可同时启动多次QQ程序。</p><p>进程实体：即<strong>进程映像</strong>，是<strong>静态</strong>的，可理解为进程的一次时刻的状态。</p><p>作业：用户向计算机提交的一项<strong>任务</strong>，是<strong>静态</strong>的，它通常是一个批处理程序或一个后台程序。</p></li><li><p>进程实体的组成</p><ul><li><p><strong>程序控制块PCB</strong></p><p>PCB是进程存在的唯一标志，当进程被创建时，操作系统为其创建PCB，当进程结束时，会回收其PCB。</p><ul><li>进程描述信息<ul><li>进程标识符PID：当进程被创建时，操作系统会为该进程分配一个唯一的、不重复的“身份证号”–PID（Process ID，进程ID）</li><li>用户标识符UID</li></ul></li><li>进程控制和管理信息<ul><li>CPU、磁盘、网络流量使用情况统计…</li><li>进程当前状态：就绪态&#x2F;阻塞态&#x2F;运行态.…</li></ul></li><li>资源分配清单<ul><li>正在使用哪些文件</li><li>正在使用哪些内存区域</li><li>正在使用哪些I&#x2F;O设备</li></ul></li><li><strong>处理机相关信息（CPU现场信息）</strong>：如PSW、PC等等各种寄存器的值（用于实现进程切换）</li></ul></li></ul><blockquote><p>① PCB，即<strong>进程控制块</strong>，操作系统需要对各个并发运行的进程进行管理， 但凡管理时所需要的信息，都会被放在 PCB 中。<br>② PCB 是进程存在的唯一标志。<br>③ PCB 存于内存的内核区，注意内存的内核区和 OS 的内核态的区别，内核程序运行在内核态。</p></blockquote><ul><li>程序段：程序的代码（指令序列）</li><li>数据段：运行过程中产生的各种数据（如：程序中定义的变量）</li></ul><blockquote><p>①PCB 是给操作系统用的，程序段和数据段是给进程自己用的。</p><p>②引入进程实体的概念后，可把进程定义为是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</p></blockquote></li><li><p>进程的特征</p><ul><li>动态性：进程是程序的一次执行过程，是动态地产生、变化和消亡的；动态性是进程最基本的特征。</li><li>并发性：内存中有多个进程实体，各进程可<strong>并发执行</strong></li><li>独立性：进程是能独立运行、独立获得资源、独立接受调度的基本单位</li><li>异步性：各进程按<strong>各自独立的</strong>、不可预知的速度向前推进，异步性会导致并发程序执行结果的不确定性。</li><li>结构性：每个进程都会配置一个PCB。结构上看，进程由程序段、数据段、PCB组成</li></ul></li></ol><h4 id="2-1-2-进程的状态与转换"><a href="#2-1-2-进程的状态与转换" class="headerlink" title="2.1.2 进程的状态与转换"></a>2.1.2 进程的状态与转换</h4><ol><li><p>基本状态</p><ul><li><p><strong>运行态</strong>。占有CPU，并在CPU上运行；√CPU√其他所需资源</p></li><li><p><strong>就绪态</strong>。已具有运行条件，但无空闲CPU，暂时不能运行；×CPU√其他所需资源</p><blockquote><p>系统中处于就绪状态的进程可能有多个，通常将它们排成一个队列，称为就绪队列。</p></blockquote></li><li><p><strong>阻塞态</strong>，又称等待态。因等待某一事件暂时不能运行；×CPU×其他所需资源</p><blockquote><p>系统通常将处于阻塞态的进程也排成一个队列，甚至根据阻塞原因的不同，设置多个阻塞队列。</p></blockquote></li><li><p><strong>创建态</strong>。进程正在被创建，尚未转到就绪态。OS为进程分配系统资源、初始化PCB</p><ul><li>首先申请一个空白PCB，并向PCB中填写用于控制和管理进程的信息</li><li>然后为该进程分配运行时所必须的资源</li><li>最后把该进程转入就绪态并插入就绪队列</li></ul><p>但是，如果进程所需的资源尚不能得到满足，如内存不足，则创建工作尚未完成，进程此时所处的状态称为创建态。</p></li><li><p><strong>终止态</strong>。进程正从系统中消失，进程正常结束或其他原因退出运行。OS回收进程拥有的资源，撤销PCB</p></li></ul></li><li><p>进程状态的转换</p><p><img src="https://img-blog.csdnimg.cn/ee76634e0d554449b9c693e9c069a655.png" alt="img"></p><ul><li>就绪态一&gt;运行态：进程被调度</li><li>运行态一&gt;就绪态：时间片到 or CPU被其他进程抢占</li><li>运行态一&gt;阻塞态：等待系统资源分配or等待某事件发生（主动行为）</li><li>阻塞态一&gt;就绪态：资源分配到位，等待的事件发生（被动行为）</li><li>创建态一&gt;就绪态：系统完成创建进程相关的工作</li><li>运行态一&gt;终止态：进程运行结束 or 运行过程中遇到不可修复的错误</li></ul></li></ol><h4 id="2-1-3-进程的组织方式"><a href="#2-1-3-进程的组织方式" class="headerlink" title="2.1.3 进程的组织方式"></a>2.1.3 进程的组织方式</h4><ol><li><p>链接方式</p><p>链接方式是将同一状态的进程的PCB组成一个双向链表，称为进程队列。</p><ul><li>结构：每个队列的队首和队尾都有一个指针，指向第一个和最后一个PCB。每个PCB中也有两个指针，分别指向前一个和后一个PCB。这样，就可以方便地在队列中插入或删除PCB。</li><li>优点：简单、灵活</li><li>缺点：查找效率低，需要遍历链表</li></ul></li><li><p>索引方式</p><p>索引方式是将所有的PCB存放在一张索引表中，每个表项包含一个PCB的地址和状态信息。</p><ul><li>结构：索引表可以是顺序表或散列表，可以按照进程号或其他关键字进行排序或散列。</li><li>优点：查找效率高，可以快速定位到某个PCB</li><li>缺点：需要额外的空间存储索引表，且索引表的大小受限于内存容量</li></ul></li></ol><h4 id="2-1-4-进程控制"><a href="#2-1-4-进程控制" class="headerlink" title="2.1.4 进程控制"></a>2.1.4 进程控制</h4><p> 进程控制就是要实现进程状态的转换，通过原语实现。</p><ol><li><p>进程的创建</p><ul><li><p>创建原语：操作系统创建一个进程时使用的原语，其操作如下；创建态→就绪态</p><ul><li>申请空白PCB</li><li>为新进程分配所需资源</li><li>初始化PCB</li><li>将PCB插入就绪队列</li></ul></li><li><p>引起进程创建的事件</p><ul><li>用户登录：分时系统中，用户登录成功，系统会建立为其建立一个新的进程</li><li>作业调度：多道批处理系统中，有新的作业放入内存时，会为其建立一个新的进程</li><li>提供服务：用户向操作系统提出某些请求时，会新建一个进程处理该请求</li><li>应用请求：由用户进程主动请求创建一个子进程</li></ul></li><li><p>父子进程</p><p>允许一个进程创建另一个进程，此时创建者称为<strong>父进程</strong>，被创建的进程称为<strong>子进程</strong>。</p><ul><li>进程可以继承父进程所拥有的资源。</li><li>当子进程被撤销时，应将其从父进程那里获得的资源归还给父进程。</li><li>在撤销父进程时，通常也会同时撤销其所有的子进程。</li></ul></li></ul></li><li><p>进程的终止</p><ul><li><p>撤销原语：其操作如下；</p><p>就绪态&#x2F;阻塞态&#x2F;运行态→终止态→无</p><ul><li>从PCB集合中找到终止进程的PCB</li><li>若进程正在运行，立即剥夺CPU，将CPU分配给其他进程</li><li>终止其所有子进程</li><li>将该进程拥有的所有资源归还给父进程或操作系统</li><li>删除PCB</li></ul></li><li><p>引起进程终止的事件</p><ul><li>正常结束：进程自已请求终止（exit系统调用）</li><li>异常结束：整数除以0、非法使用特权指令，然后被操作系统强行杀掉</li><li>外界干预：Ctrl+Alt+delete，用户选择杀掉进程</li></ul></li></ul></li><li><p>进程的阻塞</p><ul><li><p>阻塞原语：其操作如下；</p><p>运行态→阻塞态</p><ul><li>找到要阻塞的进程对应的PCB</li><li>保护进程运行现场，将PCB状态信息设置为“阻塞态，暂时停止进程运行</li><li>将PCB插入相应事件的等待队列</li></ul></li><li><p>引起进程阻塞的事件</p><ul><li>需要等待系统分配某种资源</li><li>需要等待相互合作的其他进程完成工作</li></ul></li></ul></li><li><p>进程的唤醒</p><ul><li><p>唤醒原语：其操作如下；</p><p>阻塞态→就绪态</p><ul><li>在事件等待队列中找到PCB</li><li>将PCB从等待队列移除，设置进程为就绪态</li><li>将PCB插入就绪队列，等待被调度</li></ul></li><li><p>引起进程唤醒的事件</p><ul><li>等待的事件发生：因何事阻塞，就应由何事唤醒</li></ul></li></ul><p>阻塞原语唤醒原语必须成对使用</p></li><li><p>进程的切换</p><ul><li><p>切换原语：其操作如下；</p><p>运行态→就绪态，就绪态→运行态</p><ul><li>将运行环境信息存入PCB</li><li>PCB移入相应队列选择</li><li>另一个进程执行，并更新其PCB</li><li>根据PCB恢复新进程所需的运行环境</li></ul></li><li><p>引起进程切换的事件</p><ul><li>当前进程时间片到</li><li>有更高优先级的进程到达</li><li>当前进程主动阻塞</li><li>当前进程终止</li></ul></li></ul></li></ol><h4 id="2-1-5-进程的通信"><a href="#2-1-5-进程的通信" class="headerlink" title="2.1.5 进程的通信"></a>2.1.5 进程的通信</h4><p> <strong>低级通信方式</strong>：PV操作。<strong>高级通信方式</strong>：共享存储、消息传递、管道通信。</p><ol><li><p>共享存储</p><p>设置一个共享空间，通过对其进行读&#x2F;写操作实现信息交换</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230908090734034.png" alt="image-20230908090734034"></p><p>在对共享空间进行写&#x2F;读操作时，需要使用同步互斥工具（如PV操作）。</p><p>共享存储分为两种：</p><ul><li><p>低级方式：基于数据结构的共享</p><p>比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种低级通信方式</p></li><li><p>高级方式：基于存储区的共享</p><p>操作系统在内存中划出一块共享存储区，数据的形式、存放位置都由通信进程控制，而不是操作系统。这种共享方式速度很快，是一种高级通信方式。</p></li></ul><blockquote><p>进程之间共享空间需要通过特殊的系统调用实现；进程内线程共享进程空间。</p></blockquote></li><li><p>消息传递</p><p>在消息传递系统中，进程间的数据交换以格式化的消息（Message）为单位。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230908091456671.png" alt="image-20230908091456671"></p><p>进程通过操作系统提供的“发送消息&#x2F;接收消息”两个原语进行数据交换。</p><blockquote><p>在<strong>微内核操作系统</strong>中，微内核与服务器之间的通信就采用了消息传递机制。</p></blockquote><p><strong>消息格式</strong>：</p><ul><li>消息头：发送进程ID、接受进程ID、消息长度等格式化的信息</li><li>消息体</li></ul><p><strong>通信方式</strong>：</p><ul><li><p><strong>直接通信方式</strong>：发送进程直接把消息发送给接收进程，并将它挂在接收进程的消息缓冲队列上，接收进程从消息缓冲队列中取得消息。</p></li><li><p><strong>间接通信方式</strong>：送进程通过信箱间接地通信，将消息发送到某个中间实体，接收进程从中间实体取得消息。该通信方式广泛应用于计算机网络中。</p><blockquote><p>注：可以多个进程往同一个信箱 send 消息，也可以多个进程从同一个信箱中 receive 消息。</p><p>用发送原语和接收原语实现基于信箱的进程间通信</p></blockquote></li></ul></li><li><p>管道通信</p><p>管道是一个特殊的共享文件，又名pipe文件。其实就是在内存中开辟一个大小固定的内存缓冲区。</p><p>管道通信允许两个进程按生产者-消费者方式进行通信。各进程要互斥访问管道。</p><ul><li>写满时，不能再写，读空时，不能再读</li><li>没写满时，不能读，没读空时，不能写</li></ul><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230908101047933.png" alt="image-20230908101047933"></p><blockquote><p>一个管道只能实现半双工通信；实现<strong>双向同时通信</strong>要建立两个管道</p></blockquote><ul><li>管道本质上是一种特殊的文件。相比于普通的文件通信，其区别如下：<ul><li><strong>限制管道的大小</strong>。管道文件是一个固定大小的缓冲区，使得它的大小不像普通文件那样不加检验地增长。</li><li><strong>读进程也可能工作得比写进程快</strong>。读空时再读管道会被阻塞，而不是调用返回文件结束。</li></ul></li><li><strong>管道中的数据一旦被读出，就彻底消失</strong>。因此，当多个进程读同一个管道时，可能会错乱。对此，通常有两种解决方案：<ul><li>①一个管道允许多个写进程，一个读进程（2014年408真题高教社官方答案）；</li><li>②允许有多个写进程，多个读进程，但系统会让各个读进程轮流从管道中读数据（Liux的方案）。</li></ul></li></ul><p>管道只能由<strong>创建进程</strong>所访问，当父进程创建一个管道后，由于管道是一种特殊文件，子进程会继承父进程的打开文件，因此子进程也继承父进程的管道，并使用它来与父进程进进行通信。</p></li></ol><h4 id="2-1-6-线程和多线程模型"><a href="#2-1-6-线程和多线程模型" class="headerlink" title="2.1.6 线程和多线程模型"></a>2.1.6 线程和多线程模型</h4><ol><li><p>线程的基本概念</p><p>线程可理解为轻量级进程，它是一个基本的CPU执行单元，也是程序执行流的最小单位。</p><p>线程由线程ID、程序计数器、寄存器集合和堆栈组成。</p><blockquote><p>引入进程的目的是更好地使多道程序并发执行，提高资源利用率和系统吞吐量；</p><p>而引入线程的目的则是减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能。</p></blockquote><p>引入线程后，<strong>进程</strong>只作为除CPU外的系统资源的分配单位，线程则作为处理机的分配单元</p></li><li><p>线程与进程的比较</p><table><thead><tr><th align="center"></th><th align="center">传统进程机制</th><th align="center">引入线程后</th></tr></thead><tbody><tr><td align="center">资源分配、调度</td><td align="center">进程是资源分配、调度基本单位</td><td align="center">进程是资源分配基本单位 线程是资源调度基本单位</td></tr><tr><td align="center">并发性</td><td align="center">进程间并发</td><td align="center">线程间也能并发</td></tr><tr><td align="center">拥有资源</td><td align="center">拥有资源的基本单位</td><td align="center">不拥有系统资源</td></tr><tr><td align="center">独立性</td><td align="center">进程间独立地址空间和资源</td><td align="center">同进程下的线程共享地址空间和资源</td></tr><tr><td align="center">系统开销</td><td align="center">需要切换进程运行环境，开销大</td><td align="center">同一进程内线程，不需切换进程环境，开销小</td></tr><tr><td align="center">支持多处理机系统</td><td align="center">进程只能运行在一个处理机上</td><td align="center">进程中多个线程可以分配到多个处理机执行</td></tr></tbody></table></li><li><p>线程的属性</p><p>多线程操作系统中的进程已不再是一个基本的执行实体，但它仍具有与执行相关的状态。所谓进程处于“执行”状态，实际上是指该进程中的某线程正在执行。</p><ul><li>线程是处理机调度的单位</li><li>多CPU计算机中，各个线程可占用不同的CPU</li><li>每个线程都有一个线程ID、线程控制块（TCB）</li><li>线程也有就绪、阻塞、运行三种基本状态</li><li>线程几乎不拥有系统资源</li><li>同一进程的不同线程间共享进程的资源</li><li>由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预</li><li>同一进程中的线程切换，不会引起进程切换</li><li>不同进程中的线程切换，会引起进程切换</li><li>切换同进程内的线程，系统开销很小</li><li>切换进程，系统开销较大</li></ul><blockquote><p>注：线程是处理机调度的单位，这里的线程指的是 操作系统看得见的内核级线程，<strong>内核级线程是处理机分配的单位</strong> 。</p><p>同进程的线程之间可以共享进程的代码段、全局变量、打开的文件，不共享线程各自的栈指针等TCB内容</p></blockquote></li><li><p>线程的实现方式</p><p>线程的实现可以分为两类：用户级线程 和 内核级线程。内核级线程又称内核支持的线程。</p><ul><li><p><strong>用户级线程</strong></p><p>在用户级线程中，有关线程管理(创建、撤销和切换等)的所有工作都由应用程序在<strong>用户空间</strong>中完成，内核意识不到线程的存在，因此说用户级线程对操作系统透明。</p><ul><li>用户级线程由应用程序通过线程库实现，所有的线程管理工作都由应用程序负责（包括线程切换）</li><li>用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预。</li><li>在<strong>用户</strong>看来，是有多个线程。但是在<strong>操作系统内核</strong>看来，并意识不到线程的存在。“用户级线程”就是“从用户视角看能看到的线程</li></ul><blockquote><p>若系统中只有用户级线程，则处理机的调度对象是进程</p></blockquote><p><strong>优点</strong>：</p><ul><li>用户级线程的切换在用户空间即可完成，不需要切换到核心态，</li><li>线程管理的系统开销小，效率高</li></ul><p><strong>缺点</strong>：</p><ul><li>当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。</li><li>多个线程不可在多核处理机上并行运行</li></ul></li><li><p><strong>内核级线程</strong></p><p>内核级线程是在内核的支持下运行的，线程管理的所有工作也是在内核空间内实现的。</p><ul><li>内核级线程的管理工作由操作系统内核完成。</li><li>线程调度、切换等工作都由内核负责，因此<strong>内核级线程的切换</strong>必然需要在<strong>核心态</strong>下才能完成。</li><li>操作系统会为每个内核级线程建立相应的TCB（Thread Control Block，线程控制块）通过TCB对线程进行管理。“内核级线程”就是“从操作系统内核视角看能看到的线程”</li></ul><p><strong>优点</strong>：</p><ul><li>当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。</li><li>多线程可在多核处理机上并行执行。</li></ul><p><strong>缺点</strong>：</p><ul><li>一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。</li></ul><table><thead><tr><th align="center"></th><th align="center">用户级线程</th><th align="center">内核级线程</th></tr></thead><tbody><tr><td align="center">线程的管理工作由谁来完成</td><td align="center">由 应用程序 通过线程库实现所有的线程管理工作 ，包括线程切换</td><td align="center">线程管理工作由 操作系统内核完成</td></tr><tr><td align="center">线程切换是否需要 CPU 变态</td><td align="center">用户级线程切换 可以在用户态下即可完成 ，无需操作系统干预</td><td align="center">线程调度、切换等工作都由内核负责，因此 内核级线程的切换 必然需要在 核心态 下才能完成。</td></tr><tr><td align="center">OS 是否能意识到用户级线程的存在</td><td align="center">OS 内核意识不到用户级线程的存在 用户级线程就是从用户视角看能看到的线程</td><td align="center">OS 会为每个内核级线程建立相应的 TCB（线程控制块） 通过TCB对线程进行管理 内核级线程就是从操作系统内核视角看能看到的线程</td></tr><tr><td align="center">优点</td><td align="center">用户级线程的切换在用户空间即可完成， 不需要切换到核心态，线程管理的系统开销小，效率高</td><td align="center">当一个线程被阻塞后，其他线程还可以继续执行，并发能力强 多线程可在多核处理机上并行执行</td></tr><tr><td align="center">缺点</td><td align="center">当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高 因为进程是处理机调度的基本单位，同一进程的多个线程不可在多核处理机上并行运行</td><td align="center">一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成 需要切换到核心态，因此线程管理的开销大，效率低，成本高</td></tr></tbody></table></li><li><p>组合方式</p><p>有些系统使用组合方式的多线程实现。在组合实现方式中，内核支持多个内核级线程的建立、调度和管理，同时允许用户程序建立、调度和管理用户级线程。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230908113303239.png" alt="image-20230908113303239"></p><ul><li>一些内核级线程对应多个用户级线程，这是用户级线程通过时分多路复用内核级线程实现的。</li><li>同一进程中的多个线程可以同时在多处理机上并行执行，</li><li>且在阻塞一个线程时不需要将整个进程阻塞，</li></ul></li><li><p>线程库</p><p>线程库是为程序员提供创建和管理线程的API。实现方式有以下两种。</p><ul><li>①在用户空间中提供一个没有内核支持的库。这种库的所有代码和数据结构都位于用户空间中。这意味着，调用库内的一个函数只导致用户空间中的一个本地函数的调用。</li><li>②实现由操作系统直接支持的内核级的一个库。对于这种情况，库内的代码和数据结构位于内核空间。调用库中的一个API函数通常会导致对内核的系统调用。</li></ul></li></ul></li><li><p>多线程模型</p><ul><li><p>一对一模型</p><p>一个用户级线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。</p><ul><li><strong>优点</strong>：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。（内核级线程优点）</li><li><strong>缺点</strong>：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。（内核级线程缺点）</li></ul></li><li><p>多对一模型</p><p>多个用户级线程映射到一个内核级线程。且一个进程只被分配一个内核级线程。</p><ul><li><strong>优点</strong>：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高（用户级线程优点）</li><li><strong>缺点</strong>：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行（用户级线程缺点）</li></ul></li><li><p>多对多模型</p><p>n用户及线程映射到m个内核级线程（n&gt;&#x3D;m）。每个用户进程对应m个内核级线程。</p><p>克服了多对一模型并发度不高的缺点（一个阻塞全体阻塞），又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。还拥有上述两种模型各自的优点。</p></li></ul></li><li><p>线程的状态与转换</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230908114535993.png" alt="image-20230908114535993"></p></li><li><p>线程的组织与控制</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230908123934054.png" alt="image-20230908123934054"></p><ul><li><p>线程控制块</p><p>与进程类似，系统也为每个线程配置一个线程控制块TCB，用于记录控制和管理线程的信息。线程控制块通常包括</p><ul><li>①线程标识符</li><li>②一组寄存器，包括程序计数器、状态寄存器和通用寄存器</li><li>③线程运行状态，用于描述线程正处于何种状态</li><li>④优先级</li><li>⑤线程专有存储区，线程切换时用于保存现场等</li><li>⑥堆栈指针，用于过程调用时保存局部变量及返回地址等。</li></ul><p>同一进程中的所有线程都完全共享进程的地址空间和全局变量。</p><p>各个线程都可以访问进程地址空间的每个单元，所以一个线程可以读、写或甚至清除另一个线程的堆栈。</p></li><li><p>线程的创建</p><p>用户程序启动时，通常仅有一个称为“初始化线程”的线程正在执行，其主要功能是用于创建新线程。</p><p>在创建新线程时，需要利用一个线程创建函数，并提供相应的参数，如指向线程主程序的入口指针、堆栈的大小、线程优先级等。线程创建函数执行完后，将返回一个线程标识符。</p></li><li><p>线程的终止</p><p>当一个线程完成自己的任务后，或线程在运行中出现异常而要被强制终止时，由终止线程调用相应的函数执行终止操作。</p><p>但是有些线程（主要是系统线程）一旦被建立，便一直运行而不会被终止。通常，线程被终止后并不立即释放它所占有的资源，只有当进程中的其他线程执行了分离函数后，被终止线程才与资源分离，此时的资源才能被其他线程利用。</p><p>被终止但尚未释放资源的线程仍可被其他线程调用，以使被终止线程重新恢复运行。</p></li></ul></li></ol><blockquote><p>例</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911100724303.png" alt="image-20230911100724303"></p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911100801565.png" alt="image-20230911100801565"></p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911103000066.png" alt="image-20230911103000066"></p><p>进程之间独立地址空间，独立资源；但也可以通过通信机制交换资源</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911105724596.png" alt="image-20230911105724596"></p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911105739059.png" alt="image-20230911105739059"></p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911110615213.png" alt="image-20230911110615213"></p><p>这些线程属于内核进程，它们在内核空间中运行，不受用户进程的影响。 因此，DLL库中的系统线程是唯一的，不会因为被不同的进程调用而产生多个副本。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911110637435.png" alt="image-20230911110637435"></p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911111039392.png" alt="image-20230911111039392"></p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911111052692.png" alt="image-20230911111052692"></p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911112244092.png" alt="image-20230911112244092"></p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911112258010.png" alt="image-20230911112258010"></p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911112506823.png" alt="image-20230911112506823"></p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911112519940.png" alt="image-20230911112519940"></p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911112712996.png" alt="image-20230911112712996"></p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911112724683.png" alt="image-20230911112724683"></p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911112828470.png" alt="image-20230911112828470"></p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911113034693.png" alt="image-20230911113034693"></p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911113159888.png" alt="image-20230911113159888"></p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911113244732.png" alt="image-20230911113244732"></p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911113721782.png" alt="image-20230911113721782"></p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911114135838.png" alt="image-20230911114135838"></p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911114235410.png" alt="image-20230911114235410"></p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911114246766.png" alt="image-20230911114246766"></p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911114447948.png" alt="image-20230911114447948"></p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911114528761.png" alt="image-20230911114528761"></p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911114649263.png" alt="image-20230911114649263"></p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911114713204.png" alt="image-20230911114713204"></p></blockquote><h3 id="2-2-处理机调度"><a href="#2-2-处理机调度" class="headerlink" title="2.2 处理机调度"></a>2.2 处理机调度</h3><h4 id="2-2-1-调度的概念"><a href="#2-2-1-调度的概念" class="headerlink" title="2.2.1 调度的概念"></a>2.2.1 调度的概念</h4><ol><li><p>调度的基本概念</p><p>处理机调度是对处理机进行分配，即从就绪队列中按照一定的算法（公平、高效的原则）去选择一个进程并将处理机分配给它运行，以实现进程<strong>并发</strong>地执行。</p></li><li><p>调度对层次</p><p>一个作业从提交开始直到完成，要经历以下三级调度，如下图所示。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911135226560.png" alt="image-20230911135226560"></p><ul><li><p>高级调度（作业调度）</p><p>内存空间有限时，无法将用户提交的作业全部放入内存，需要按一定的原则从外存的作业 后备队列 中挑选一个作业调入内存，并创建进程。</p><p>每个作业只调入一次，调出一次。作业调入时会建立PCB，调出时才撤销PCB。</p><blockquote><p>作业：一个具体的任务</p></blockquote><p>多道批处理系统中大多配有作业调度，而其他系统中通常不需要配置作业调度。</p><ul><li>发生频率最低 外存→内存（面向作业）</li></ul></li><li><p>中级调度（内存调度）</p><p>内存不够时，可将某些进程的数据调出外存。等内存空闲或者进程需要运行时，按照某种策略从 挂起队列 中选择合适的进程重新调入内存。</p><blockquote><p>暂时调到外存等待的进程状态为挂起状态。被挂起的进程PCB会被组织成挂起队列。</p></blockquote><ul><li>外存→内存（面向进程）</li></ul></li><li><p>低级调度（进程调度）</p><p>在内存中的按照某种策略从 就绪队列 中选取一个进程，将处理机分配给它。</p><ul><li>发生频率高 内存→CPU</li></ul></li></ul></li><li><p>三级调度的联系</p><ul><li><p>七状态模型</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911141922080.png" alt="image-20230911141922080"></p><p><strong>挂起和阻塞的区别：</strong> 两种状态都不获得 CPU 服务，但挂起状态将进程调到外存，而阻塞态还在内存中。</p></li><li><p>三层调度对比</p><table><thead><tr><th align="center"></th><th align="center">要做什么</th><th align="center">在哪调度</th><th align="center">发生频率</th><th align="center">对进程状态影响</th></tr></thead><tbody><tr><td align="center">高级调度 （作业调度）</td><td align="center">从后备队列中选择合适的作业 将其调入内存，并为其创建进程</td><td align="center">外存→内存 (面向作业)</td><td align="center">最低</td><td align="center">无→创建态→就绪态</td></tr><tr><td align="center">中级调度 （内存调度）</td><td align="center">从挂起队列中选择合适的进程 将其数据调回内存</td><td align="center">外存→内存 （面向进程）</td><td align="center">中等</td><td align="center">挂起态→就绪态 阻塞挂起→阻塞态</td></tr><tr><td align="center">低级调度 （进程调度）</td><td align="center">从就绪队列中选择一个进程 为其分配处理机</td><td align="center">内存→CPU</td><td align="center">最高</td><td align="center">就绪态→运行态</td></tr></tbody></table></li><li><p>三层调度联系</p><ul><li>1）作业调度为进程活动做准备，进程调度使进程正常活动起来。</li><li>2）中级调度将暂时不能运行的进程挂起，中级调度处于作业调度和进程调度之间。</li><li>3）作业调度次数少，中级调度次数略多，进程调度频率最高。</li><li>4）进程调度是最基本的，不可或缺。</li></ul></li></ul></li></ol><h4 id="2-2-2-调度的目标"><a href="#2-2-2-调度的目标" class="headerlink" title="2.2.2 调度的目标"></a>2.2.2 调度的目标</h4><p> 不同的调度算法具有不同的特性，在选择调度算法时，必须考虑算法的特性。评价标准如下。</p><ol><li><p><strong>CPU利用率</strong>：指CPU“忙碌”的时间占总时间的比例。<br>$$<br>利用率&#x3D;\frac{忙碌的时间}{总时间}<br>$$</p></li><li><p><strong>系统吞吐率</strong>：单位时间内完成作业的数量。<br>$$<br>系统吞吐率&#x3D;\frac{总共完成了多少道作业}{总共花了多少时间}<br>$$</p></li><li><p><strong>周转时间</strong>：指从作业被提交给系统开始，到作业完成为止的这段时间间隔。<br>$$<br>周转时间&#x3D;作业完成时间-作业提交时间<br>$$<br><strong>平均周转时间</strong>：指多个作业周转时间的平均值。<br>$$<br>平均周转时间&#x3D;\frac{各个作业周转时间之和}{作业数}<br>$$<br><strong>带权周转时间</strong>：作业周转时间与作业实际运行时间的比值。带权周转时间必然≥1<br>$$<br>带权周转时间&#x3D;\frac{作业周转时间}{作业实际运行时间}&#x3D;\frac{作业完成时间-作业提交时间}{作业实际运行时间}<br>$$<br><strong>平均带权周转时间</strong>：多个作业带权周转时间的平均值。<br>$$<br>平均带权周转时间&#x3D;\frac{各个作业带权周转时间之和}{作业数}<br>$$</p></li><li><p><strong>等待时间</strong></p><p>等待时间，指进程&#x2F;作业处于等待处理机状态时间之和，等待时间越长，用户满意度越低。<br>$$<br>等待时间&#x3D;周转时间-运行时间<br>$$</p><ul><li>对于进程来说，等待时间就是指进程建立后等待被服务的时间之和。</li><li>对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间。</li></ul><p><strong>平均等待时间</strong>：各个进程&#x2F;作业等待时间的平均值。<br>$$<br>平均等待时间&#x3D;\frac{各个进程&#x2F;作业等待时间之和}{进程&#x2F;作业数}<br>$$</p></li><li><p><strong>响应时间</strong>：从用户提交请求到首次产生响应所用的时间。</p></li></ol><h4 id="2-2-3-调度的实现"><a href="#2-2-3-调度的实现" class="headerlink" title="2.2.3 调度的实现"></a>2.2.3 调度的实现</h4><ol><li><p>调度程序（调度器）</p><p>用于调度和分派CPU 的组件称为调度程序，它通带由三部分组成，如图所示。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911150133174.png" alt="image-20230911150133174"></p><ul><li><p><strong>排队器</strong>：将系统中的所有就绪进程按照一定的策略排成一个或多个队列，以便于调度程序选择。每当有一个进程转变为就绪态时，排队器便将它插入到相应的就绪队列中。</p></li><li><p><strong>分派器</strong>：依据调度程序所选的进程，将其从就绪队列中取出，将CPU分配给新进程。</p></li><li><p>上下文切换器</p><p>：在对处理机进行切换时，会发生两对上下文的切换操作：</p><ul><li>第一对，将当前进程的上下文保存到其PCB中，再装入分派程序的上下文，以便分派程序运行；</li><li>第二对，移出分派程序的上下文，将新选进程的CPU现场信息装入处理机的各个相应寄存器。</li></ul></li></ul></li><li><p>调度的时机</p><ul><li>需要调度<ul><li>主动放弃：进程正常终止；运行过程中发生异常而终止；主动阻塞（比如等待IO）</li><li>被动放弃：时间片用完；有更紧急的事情处理（I&#x2F;O中断）；有更高优先级的进程进入就结队列</li></ul></li><li>不能调度<ul><li>处理中断的过程中</li><li>进程在操作系统内核程序临界区中</li><li>原子操作过程中</li></ul></li></ul><blockquote><p>临界资源：一个时间段内只允许一个进程使用的资源。各进程需要互斥地访问临界资源。</p><p>临界区：访问临界资源的那段代码。</p><p>内核程序临界区一般是用来访问某种内核数据结构的，比如进程的就绪队列（由各就绪进程的PCB组成）</p></blockquote></li><li><p>进程调度方式</p><ul><li><p><strong>非剥夺调度方式</strong></p><p>又称<strong>非抢占方式</strong>。即，只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。</p><p>实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统</p></li><li><p><strong>剥夺调度方式</strong></p><p>又称<strong>抢占方式</strong>。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停在执行的进程，将处理机分配给更重要紧迫的那个进程。</p><p>可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断）。适合于分时操作系统、实时操作系统</p></li></ul></li><li><p>进程切换</p><ul><li><p>上下文切换：切换CPU到另一个进程需要保存当前进程状态并恢复另一个进程的状态。</p><ul><li>对原来运行进程各种数据的保存</li><li>对新的进程各种数据的恢复（如：程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一保存在进程控制块）</li></ul><blockquote><p>上下文：某一时刻CPU寄存器和程序计数器的内容。</p></blockquote><p>切换流程：</p><ul><li>挂起一个进程，保存CPU上下文，包括程序计数器和其他寄存器。</li><li>更新PCB信息。</li><li>把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。</li><li>选择另一个进程执行，并更新其PCB。</li><li>跳转到新进程PCB中的程序计数器所指向的位置执行。</li><li>恢复处理机上下文。</li></ul></li><li><p>上下文切换的消耗</p><p>上下文切换需要消耗大量CPU时间，有些处理器有多个寄存器组，则切换只需改变指针。</p><blockquote><p>进程切换是有<strong>代价</strong>的，因此如果过于频繁的进行进程调度、切换，必然会使整个系统的效率降低，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。</p></blockquote></li><li><p>上下文切换与模式切换</p><ul><li>模式切换是用户态和内核态之间的切换，CPU逻辑上可能还在执行同一进程。用户进程最开始都运行在用户态，若进程因中断或异常进入核心态运行，执行完后又回到用户态刚被中断的进程运行。</li><li>上下文切换切换了进程，只能发生在内核态，它是多任务操作系统中的一个必需的特性。</li></ul></li></ul></li><li><p>闲逛进程</p><p>调度程序永远的备胎，没有其他就绪进程时，运行闲逛进程（idle）</p><p><strong>特性</strong>：</p><ul><li>优先级最低；</li><li>可以是0地址指令，占一个完整的指令周期（指令周期末尾例行检查中断）</li><li>能耗低</li></ul><blockquote><p>闲逛进程不需要CPU之外的资源，它不会被阻塞。</p></blockquote></li><li><p>两种线程的调度</p><ul><li><strong>用户级线程调度</strong>。由于内核并不知道线程的存在，所以内核还是和以前一样，选择一个进程，并给予时间控制。由进程中的调度程序决定哪个线程运行。</li><li><strong>内核级线程调度</strong>。内核选择一个特定线程运行，通常不用考虑该线程属于哪个进程。对被选择的线程赋予一个时间片，如果超过了时间片，就会强制挂起该线程。</li></ul><blockquote><p>用户级线程的线程切换在同一进程中进行，仅需少量的机器指令；</p><p>内核级线程的线程切换需要完整的上下文切换、修改内存映像、使高速缓存失效，这就导致了若干数量级的延迟。</p></blockquote></li></ol><h4 id="2-2-4-典型的调度算法"><a href="#2-2-4-典型的调度算法" class="headerlink" title="2.2.4 典型的调度算法"></a>2.2.4 典型的调度算法</h4><ol><li><p>先来先服务（FCFS）</p><ul><li>算法思想：主要从“公平”的角度考虑（类似于我们生活中排队买东西的例子）</li><li>算法规则：按照作业&#x2F;进程到达的先后顺序进行服务</li><li>用于作业&#x2F;进程调度：<ul><li>用于作业调度时，考虑是哪作业先达后备队列；</li><li>用于进程调度时，考虑的是哪个进程先到达就绪队列</li></ul></li><li>优缺点：<ul><li>优点：公平、算法实现简单</li><li>缺点：排在长作业（进程）后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好。即，FCFS算法对长作业有利，对作（Eg：排队。）</li></ul></li><li>非抢占式的算法；不会导致饥饿</li></ul><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911164645302.png" alt="image-20230911164645302"></p></li><li><p>短作业优先（SJF）</p><ul><li><p>算法思想：追求最少的平均等待时间，最少的平均周转时间、最少的平均平均带权周转时间</p></li><li><p>算法规则：最短的作业&#x2F;进程优先得到服务（所谓“最短”，是指要求服务时间最短）</p></li><li><p>用于作业&#x2F;进程调度</p><ul><li>即可用于作业调度，也可用于进程调度。</li><li>用于进程调度时为”短进程优先”（SPF，Shortest Process First）</li></ul></li><li><p>优缺点</p><ul><li><p>优点：</p><p>“最短的”平均等待时间、平均周转时间</p><p>；</p><ul><li>在所有进程都几乎同时到达时，采用SJF调度算法的平均等待时间、平均周转时间最少；</li><li>“抢占式的短作业&#x2F;进程优先调度算法（最短剩余时间优先，SRNT算法）的平均等待时间、平均周转时间最少”</li></ul></li><li><p>缺点：不公平。对短作业有利，对长作业不利。可能产生饥饿现象。另外，作业进程的运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先。</p></li></ul></li><li><p>抢占式的算法；会导致饥饿</p><blockquote><p>SJF和SPF是非抢占式的算法。但是也有抢占式的版本：最剩间优先算法（SRTN，Shortest Remaining Time Next）</p><p>每当有进程加入就绪队列改变时就需要调度，如果新到达的进程剩余时间比当前运行的进程剩余时间更短，则由新进程抢占处理机，当前运行进程重新回到就绪队列。另外，当一个进程完成时也需要调度</p></blockquote></li></ul><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911164811967.png" alt="image-20230911164811967"></p></li><li><p>高响应比优先（HRRN）</p><ul><li><p>算法思想：要综合考虑作业&#x2F;进程的等待时间和要求服务的时间</p></li><li><p>算法规则：在每次调度时先计算各个作业&#x2F;进程的响应比，选择响应比最高的作业&#x2F;进程为其服务<br>$$<br>响应比&#x3D;\frac{等待时间+要求服务时间}{要求服务时间}<br>$$<br><strong>高响应比优先算法</strong>：非抢占式的调度算法，只有当前运行的进程主动放CPU（常&#x2F;常成，主动阻塞），需行调度，调度时计算所有就绪进程的响应比，选响应比最高的进程上处理机。</p></li><li><p>用于作业&#x2F;进程调度：即可用于作业调度，也可用于进程调度</p></li><li><p>优缺点</p><ul><li>综合考虑了等待时间和运行时间（要求服务时间）等待时间相同时，要求服务时间短的优先（SJF的优点）；</li><li>要求服务时间相同时，等待时间长的优先（FCFS的优点）</li><li>对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿的问题</li></ul></li><li><p>非抢占式的算法；不会导致饥饿</p><blockquote><p>非抢占式的算法。因此只有当前运行的作业&#x2F;进程主动放弃处理机时，才需要调度，计算响应比</p></blockquote></li></ul></li><li><p>时间片轮转调度算法（RR）</p><ul><li><p>算法思想：公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应</p></li><li><p>算法规则：按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如100ms）。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。</p></li><li><p>用于作业&#x2F;进程调度：用于进程调度（只有作业放入内存建立了相应的进程后，才能被分配处理机时间片）</p></li><li><p>优缺点</p><ul><li>优点：公平；响应快，适用于分时操作系统；</li><li>缺点：由于高频率的进程切换，因此有一定开销；不区分任务的紧急程度。</li></ul></li><li><p>抢占式的算法；不会导致饥饿</p><blockquote><p>若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转调度算法属于抢占式的算法。由时钟装置发出时钟中断来通知CPU时间片已到</p></blockquote></li></ul></li><li><p>优先级调度算法</p><ul><li><p>算法思想：随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序</p></li><li><p>算法规则：每个作业&#x2F;进程有各自的优先级，调度时选择优先级最高的作业&#x2F;进程</p></li><li><p>用于作业&#x2F;进程调度：既可用于作业调度，也可用于进程调度。甚至，还会用于在之后会学习的I&#x2F;O调度中</p></li><li><p>优缺点</p><ul><li>优点：用优先级区分紧急程度、重要程度，适用于实时操作系统。可灵活地调整对各种作业&#x2F;进程的偏好程度</li><li>缺点：若源源不断地有高优先级进程到来，则可能导致饥饿</li></ul></li><li><p>抢占式&#x2F;非抢占式的算法；会导致饥饿</p><blockquote><p>抢占式、非抢占式都有。做题时的区别在于：非抢占式只需在进程主动放弃处理机时进行调度即可，而抢占式还需在就绪队列变化时，检查是否会发生抢占。</p></blockquote></li><li><p>优先级排序</p><p>系统进程优先级高于用户进程</p><p>前台进程优先级高于后台进程</p><p>操作系统更偏好I&#x2F;O型进程（或称I&#x2F;O繁忙型进程）</p><blockquote><p>注：与I&#x2F;O型进程相对的是计算型进程（或称CPU繁忙型程）</p></blockquote></li><li><p>优先级分类：根据优先级是否可以动态改变，可将优先级分为静态优先级和动态优先级两种。</p><ul><li>静态优先级：创建进程时确定，之后一直不变</li><li>动态优先级：创建进程时有一个初始值，之后会根据情况动态地调整优先级。</li></ul><blockquote><p>就绪队列未必只有一个，可以按照不同优先级来组织。另外，也可以把优先级高的进程排在更靠近队头的位置</p></blockquote></li></ul></li><li><p>多级队列调度算法</p><ul><li>系统中按进程类型设置多个队列，进程创建成功后插入某个队列</li></ul><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911165310270.png" alt="image-20230911165310270"></p><ul><li><p>队列之间可采取固定优先级，或时间片划分</p><ul><li>固定优先级：高优先级空时低优先级进程才能被调度</li><li>时间片划分：如三个队列分配时间50%、40%、10%</li></ul></li><li><p>各队列可采用不同的调度策略，如</p><p>系统进程队列采用优先级调度、交互式队列采用RR、批处理队列采用FCFS</p></li></ul></li><li><p>多级反馈队列调度算法</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911165245192.png" alt="image-20230911165245192"></p><ul><li><p>算法思想：对其他调度算法的折中权衡</p></li><li><p>算法规则：</p><ul><li>1.设置多级就绪队列，各级队列优先级从高到低，时间片从小到大</li><li>2.新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级的队列，则重新放回该队列队尾</li><li>3.只有第k级队列为空时，才会为k+1级队头的进程分配时间片</li></ul></li><li><p>用于作业&#x2F;进程调度：用于进程调度</p></li><li><p>优缺点</p><ul><li>对各类型进程相对公平（FCFS的优点）；</li><li>每个新到达的进程都可以很快就得到响应（RR优点）；</li><li>短进程只用较少的时间就可完成（SPF优点）；</li><li>不必实现估程运时间（避用户作假）；</li><li>可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、IO密集型进程</li></ul><blockquote><p>拓展：可以将因I&#x2F;O而阻塞的进程重新放回原队列，这样I&#x2F;O型进程就可以保持较高优先级</p></blockquote></li><li><p>抢占式的算法；会导致饥饿</p><blockquote><p>在k级队列的进程运行过程中，若更上级的队列（1~k-1级）中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回k级队列队尾。</p></blockquote></li><li><p>例：</p></li><li><p>(2019年408第27题)系统采用二级反馈队列调度算法进行进程调度。就绪队列Q1采用时间片轮转调度算法，时间片为10ms；就绪队列Q2采用短进程优先调度算法，系统优先调度Q1队列中的进程，当Q1为空时系统才会调度Q2中的进程；新创建的进程首先进入Q1；Q1中的进程执行一个时间片后，若未结束，则转入Q2。若当前Q1、Q2为空，系统依次创建进程P1、P2后即开始进程调度，P1、P2需要的 CPU 时间分别为 30ms 和 20ms，则进程P1、P2在系统中的平均等待时间为( 15ms )。<br><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/77af69c8c9764a18b2b830d201c93f26.png" alt="img"></p><ul><li>P1等待时间 &#x3D; P1周转时间 - P1运行时间 &#x3D; 50-30 &#x3D; 20ms</li><li>P2等待时间 &#x3D; P2周转时间 - P2运行时间 &#x3D; 30-20 &#x3D; 10ms</li><li>P1、P2在系统中的平均等待时间 &#x3D; (P1等待时间+P2等待时间)&#x2F;2 &#x3D; 15ms</li></ul></li></ul></li></ol><table><thead><tr><th align="center"></th><th align="center">先来先服务</th><th align="center">短作业优先</th><th align="center">高响应比优先</th><th align="center">时间片轮转</th><th align="center">多级反馈队列</th></tr></thead><tbody><tr><td align="center">能否是可抢占</td><td align="center">否</td><td align="center">能</td><td align="center">能</td><td align="center">能</td><td align="center">队列内算法不一定</td></tr><tr><td align="center">能否是非抢占</td><td align="center">能</td><td align="center">能</td><td align="center">能</td><td align="center">否</td><td align="center">队列内算法不一定</td></tr><tr><td align="center">优点</td><td align="center">公平，实现简单</td><td align="center">平均等待时间最少，效率最高</td><td align="center">兼顾长短作业</td><td align="center">兼顾长短作业</td><td align="center">兼顾长短作业， 有较好的的响应时间， 可行性强</td></tr><tr><td align="center">缺点</td><td align="center">不利于短作业</td><td align="center">长作业会饥饿， 估计时间不易确定</td><td align="center">计算响应比的开销大</td><td align="center">平均等待时间较长， 上下文切换浪费时间</td><td align="center">无</td></tr><tr><td align="center">适用于</td><td align="center">无</td><td align="center">作业调度， 批处理系统</td><td align="center">无</td><td align="center">分时系统</td><td align="center">相当通用</td></tr><tr><td align="center">默认决策模式</td><td align="center">非抢占</td><td align="center">非抢占</td><td align="center">非抢占</td><td align="center">抢占</td><td align="center">抢占</td></tr></tbody></table><h3 id="2-3-同步与互斥"><a href="#2-3-同步与互斥" class="headerlink" title="2.3 同步与互斥"></a>2.3 同步与互斥</h3><h4 id="2-3-1-同步与互斥的基本概念"><a href="#2-3-1-同步与互斥的基本概念" class="headerlink" title="2.3.1 同步与互斥的基本概念"></a>2.3.1 同步与互斥的基本概念</h4><ol><li><p>临界资源：一次仅允许一个进程使用的资源</p><ul><li><p>类型：物理设备，如打印机等；可被进程共享的许多变量、数据等</p></li><li><p>临界区：访问临界资源的那段代码。</p><p>为了保证临界资源的正确使用，可把临界资源的访问过程分成4个部分：</p><ul><li>1）进入区。为了进入临界区使用临界资源，在进入区要检查可否进入临界区，若能进入临界区，则应设置正在访问临界区的标志，以阻止其他进程同时进入临界区。</li><li>2）临界区。进程中访问临界资源的那段代码，又称临界段。</li><li>3）退出区。将正在访问临界区的标志清除。</li><li>4）剩余区。代码中的其余部分。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    entry section;<span class="comment">//进入区</span></span><br><span class="line">    critical section;<span class="comment">//临界区</span></span><br><span class="line">    <span class="built_in">exit</span> section;<span class="comment">//退出区</span></span><br><span class="line">    remainder section;<span class="comment">//剩余区</span></span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>同步</p><ul><li>同步亦称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。</li><li>读进程和写进程并发地运行，由于并发必然导致异步性，因此“写数据”和“读数据”两个操作执行的先后顺序是不确定的。而实际应用中，又必须按照“写数据→读数据”的顺序来执行的。</li></ul><p>如何解决这种异步问题，就是“进程同步”所讨论的内容。</p></li><li><p>互斥</p><p> 互斥也称间接制约关系。当一个进程进入临界区使用临界资源，另一进程必须等待当占用临界资源的进程退出临界区后，另一进程才能访问此临界资源。</p><p>遵循原则：</p><ul><li><strong>空闲让进</strong>。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区；</li><li><strong>忙则等待</strong>。当已有进程进入临界区时，其他图进入临界区进必须等待</li><li><strong>有限等待</strong>。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）</li><li><strong>让权等待</strong>。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。</li></ul></li></ol><h4 id="2-3-2-实现临界区互斥的基本方法"><a href="#2-3-2-实现临界区互斥的基本方法" class="headerlink" title="2.3.2 实现临界区互斥的基本方法"></a>2.3.2 实现临界区互斥的基本方法</h4><p><strong>软件实现方法</strong></p><ol><li><p>单标志法（违背“空闲让进”原则）</p><p>两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程。也就是说每个进程进入临界区的权限只能被另一个进程赋予。</p><p>该算法设置一个公用整型变量turn，用于指示被允许进入临界区的进程编号。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911175422618.png" alt="image-20230911175422618"></p><p>若某个进程不再进入临界区，则另一个 进程也将无法进入临界区（违背”空闲让进”）。</p></li><li><p>双标志法先检查（违背“忙则等待”原则）</p><p>在每一个进程访问临界区资源之前，先查看一下临界区资源是否正被访问，若正被访问，该进程需等待：否则，进程才进入自己自己的临界区。</p><blockquote><p>设置一个布尔型数组flag[ ]，数组中各个元素用来标记各进程想进入临界区的意愿，比如“flag[0]&#x3D;ture”意味着0号进程P0现在想要进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志flag设为true，之后开始访问临界区。</p></blockquote><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230911175704256.png" alt="image-20230911175704256"></p><ul><li>优点：不用交替进入，可连续使用</li><li>缺点：按序列①⑤②⑥执行时，会同时进入临界区（违背“忙则等待”），Pi进程和Pj进程可能同时进入临界区；检查和修改操作不能一次进行。</li></ul></li><li><p>双标志法后检查</p><p>双标志先检查法的改版。前一个算法的问题是先“检查”后“上锁”，但是这两个操作又无法一气呵成，因此导致了两个进程同时进入临界区的问题。因此，人们又想到先“上锁”后“检查”的方法，来避免上述问题。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230912090727614.png" alt="image-20230912090727614"></p><ul><li>缺点：当两个进程几乎同时都想进入临界区时，它们分别将自己的标志值设置为TRUE，并且同时检测对方的状态，发现对方也要进入临界区，于是双方互相谦让，结果谁也进不了临界区，从而导致“饥饿”现象。违背了“空闲让进”和“有限等待”产生饥饿</li></ul></li><li><p>Peterson算法</p><p>结合双标志法、单标志法的思想。如果双方都争着想进入临界区，那可以让进程尝试“孔融让梨”（谦让）。做一个有礼貌的进程。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230912091559736.png" alt="image-20230912091559736"></p><ul><li>为了防止两个进程为进入临界区而无限期等待，又设置了变量turn，每个进程在先设置自己的标志后再设置turn标志。这时，再同时检测另一个进程状态标志和允许进入标志，以便保证两个进程同时要求进入临界区时，只允许一个进程进入临界区。</li><li>进程在进入区要做的步骤： ① 主动争取 ② 主动谦让 ③ 检查对方是否也想使用，且最后一次是不是自己说了客气话</li><li><strong>存在问题</strong>：Peterson 算法用软件方法解决了进程互斥问题， 遵循 “空闲让进”、“忙则等待”、“有限等待” 三个原则，但是依然 未遵循 “让权等待” 的原则。</li></ul></li><li><p>软件方法总结</p><table><thead><tr><th align="center"></th><th align="center">单标志法</th><th align="center">双标志先检查</th><th align="center">双标志后检查</th><th align="center">Peterson 算法</th></tr></thead><tbody><tr><td align="center">算法</td><td align="center">在进入区只做“检查”，不”上锁“ 在退出区把临界区的使用权转交给另一个进程 (相当于在退出区既给另一进程”解锁”，又给自己”上锁”）</td><td align="center">在进入区先”检查”后”上锁”，退出区”解锁“</td><td align="center">在进入区先”加锁”后”检查”，退出区”解锁”</td><td align="center">在进入区”主动争取一主动谦让一检查对方是否想进、已方是否谦让“</td></tr><tr><td align="center">问题</td><td align="center">不遵循”空闲让进”</td><td align="center">不遵循”忙则等待”</td><td align="center">不遵循”空闲让进、有限等待”，可能导致”饥饿”</td><td align="center">不遵循”让权等待”，会发生”忙等”</td></tr></tbody></table></li></ol><p><strong>硬件实现方法</strong></p><ol><li><p>中断屏蔽方法</p><p>当一个进程正在使用处理机执行它的临界区代码时，要防止其他进程再进入其临界区访问的最简单的方法是：禁止一切中断发生，或称之为屏蔽中断、关中断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">关中断;</span><br><span class="line">临界区;</span><br><span class="line">开中断;</span><br></pre></td></tr></table></figure><ul><li><strong>优点</strong>：简单、高效</li><li><strong>缺点</strong>：不适用于多处理机；只适用于操作系统内核进程，不适用于用户进程（因为开&#x2F;关中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险）</li></ul></li><li><p>硬件指令法</p><ul><li><p><strong>TestAndSet指令</strong></p><p>简称TS指令，也有地方称为TestAndSetLock指令，或TSL指令TSL指令是用硬件实现的。TS是原子操作，执行的过程不允许被中断，只能一气呵成。以下是用C语言描述的逻辑。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/60e50d9e651143749a7b7cb181c5be6e.png" alt="img"></p><p>相比软件实现方法，TSL 指令把 上锁和检查操作 用硬件的方式变成了一气呵成的 原子操作 。</p><ul><li><strong>优点：</strong> 实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞。适用于多处理机环境。</li><li><strong>缺点：</strong> 不满足 “让权等待” 原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致 忙等。</li></ul></li><li><p><strong>Swap指令</strong></p><p>有的地方也叫Exchange指令，或简称XCHG指令。Swp指令是用硬件实现的，是原子操作，执行的过程不允许被中断，只能一气呵成。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/cb2807d1e20b4e40811a04bd8b394e0c.png" alt="img"></p></li></ul><blockquote><p>逻辑上来看 Swap 和 TSL 并无太大区别，都是先记录下此时临界区是否已经被上锁（记录在 old 变量上），再将上锁标记 lock 设置为 true，最后检查 old，如果 old 为 false 则说明之前没有别的进程对临界区上锁，则可跳出循环，进入临界区。Swap 指令优点缺点和TSL指令相同。</p></blockquote><ul><li>硬件方法的优点<ul><li>适用于任意数目的进程，不管是单处理机还是多处理机；简单、容易验证其正确性。</li><li>可以支持进程内有多个临界区，只需为每个临界区设立一个布尔变量。</li></ul></li><li>硬件方法的缺点<ul><li>进程等待进入临界区时要耗费处理时间，不能实现让权等待。</li><li>从等待进程中随机选择一个进入临界区，有进程可能一直选不上，从而导致“饥饿”现象。</li></ul></li></ul></li></ol><h4 id="2-3-3-互斥锁"><a href="#2-3-3-互斥锁" class="headerlink" title="2.3.3 互斥锁"></a>2.3.3 互斥锁</h4><p> 解决临界区最简单的工具就是互斥锁（mutex lock）。一个进程在进入临界区时获得锁；在退出临界区时释放锁。函数acquire()获得锁，而函数release()释放锁。acquire()和release()是原子操作，由硬件机制完成。</p><p> 每个互斥锁有一个布尔变量available，表示锁是否可用。如果锁是可用的，调用acquire()会成功，且锁不再可用。当一个进程试图获取不可用的锁时，会被阻塞，直到锁被释放。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">acquire()&#123;</span><br><span class="line">    <span class="keyword">while</span>(!available);<span class="comment">//忙等待</span></span><br><span class="line">    avilable = <span class="literal">false</span>;<span class="comment">//获得锁</span></span><br><span class="line">&#125;</span><br><span class="line">release()&#123;</span><br><span class="line">    available = <span class="literal">true</span>;<span class="comment">//释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优点：等待期间不用切换进程上下文，多处理器系统中，若上锁的时间短，则等待代价很低</li><li>缺点：需忙等，进程时间片用完才下处理机，违反“让权等待”；不太适用于单处理机系统，忙等的过程中不可能解锁</li></ul><h4 id="2-3-4-信号量"><a href="#2-3-4-信号量" class="headerlink" title="2.3.4 信号量"></a>2.3.4 信号量</h4><p> 信号量机制是一种功能较强的机制,可用来解决互斥与同步问题，它只能被两个标准的原语wait(S)和signal(S)访问，也可记为”P操作”和”V操作”。</p><p> 信号量其实就是一个变量（可以是一个整数，也可以是更复杂的记录型变量），可以用一个信号量来表示系统中某种资源的数量，比如：系统中只有一台打印机，就可以设置一个初值为1的信号量。</p><p> 原语是一种特殊的程序段，其执行只能一气呵成，不可被中断。原语是由关中断&#x2F;开中断指令实现的。软件解决方案的主要问题是由“进入区的各种操作无法一气呵成”，因此如果能把进入区、退出区的操作都用“原语”实现，使这些操作能“一气呵成”就能避免问题。</p><ol><li><p>整型信号量</p><p>用一个整数型的变量作为信号量，用来表示系统中某种资源的数量。wait(S)、signal(S)可描述为：</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/05a7f28db02e4a36bb38a305d656333e.png" alt="img"></p><blockquote><p>与普通整数变量的区别：对信号量的操作只有三种，即初始化、P操作、V操作</p></blockquote><p>wait(S) 原语，“检查”和“上锁”一气呵成，避免了并发、异步导致的问题。以申请使用打印机举例：</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/5f8b6961fc4046b08c5cc4f9cf72ac29.png" alt="img"></p><p><strong>存在的问题：</strong> 不满足 “让权等待” 原则，会发生 忙等。</p></li><li><p>记录型信号量</p><p>整型信号量存在“忙等”问题，因此人们又提出了“记录型信号量”，即用记录型数据结构表示的信号量。</p><p>除了需要用于代表资源数目的整型变量value外，再增加一个进程链表L，用于链接所有等待该资源的进程。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/9e380e703cce4e0e9b746339b92ef413.png" alt="img"></p><ul><li><p>wait：如果剩余资源数不够使用block原语使进程从运行态进入阻塞态，并把挂到信号量S的等待队列（即阻塞队列）中。</p></li><li><p>signal：释放资源后，若还有别的进程在等待这种资源，则使用wakeup原语唤醒等待队列中的一个进程，该进程从阻塞态变为就绪态。</p></li><li><p>S.value的初值表示系统中某种资源的数目。</p></li><li><p>P操作</p><p>：</p><ul><li>对信号量S的一次P操作意味着进程请求一个单位的该资源，因此需要执行S.value-，表示资源数减1</li><li>当S.value&lt;0时表示该类资源已分配完毕，因此进程应调用bock原语进行自我阻塞（当前运行的进程从运行态→阻塞态），主动放弃处理机，并插入该类资源的等待队列S.L中。</li><li>可见，该机制遵循了“让权等待”原则，不会出现“忙等”现象。</li></ul></li><li><p>V操作</p><p>：</p><ul><li>对信号量S的一次V操作意味进程释放一个单位的该资源，因此需要执行S.value.+，表示资源数加1，</li><li>若加1后仍是S.value&lt;&#x3D;0，表示依然有进程在等待该类资源，因此应调用wakeup原语唤醒等待队列中的第一个进程（被唤醒进程从阻塞态→就绪态）</li></ul></li></ul><blockquote><p>例：某计算机系统中有1台打印机，则可在初始化信号量 S 时将 S.value 的值设为 1，队列 S.L 设置为空。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/9ca601b23b2b4e8db55acc96c373d4a1.png" alt="img"></p><p>① CPU 为 P0 服务，S.value –，值为 0，P0开始使用打印机。<br>② CPU 为 P1 服务，S.value –，值为 -1，无资源执行 block 原语( wait原语 )。阻塞队列( P1 )，S.value &#x3D; -1 说明有1个进程在等待资源。<br>③ CPU 为 P2 服务，S.value –，值为 -2，无资源执行 block 原语。阻塞队列( P1→P2 )，S.value &#x3D; -2 说明有2个进程在等待资源。<br>④ CPU 为 P0 服务，S.value ++，S.value &#x3D; -1 ≤ 0，说明有进程在等待该资源。因此应调用 wakeup 原语(signal原语)唤醒等待队列中的第一个进程P1，将释放资源给 P1，P1从阻塞态变为就绪态，等待被 CPU 服务(CPU顺序执行)。阻塞队列( P2 )<br>⑤ CPU 为 P1 服务，P1 使用完打印机，S.value ++，S.value &#x3D; 0，调用 wakeup 原语唤醒 P2。阻塞队列()。<br>⑥ CPU 为 P2 服务， P2是用完打印机，S.value ++，S.value &#x3D; 1。</p></blockquote></li><li><p>信号量机制实现进程互斥</p><ul><li><p>伪代码如下所示：</p><p>设 S 为实现进程 P1、P2 互斥的信号量，由于只允许一个进程进入临界区，所以 S 的初值应设为 1。然后把临界区置于 P(S) 和 V(S) 之间，进入区之前申请资源（P操作），退出区之前释放资源（ V操作 ），即可实现两个进程对临界资源的互斥访问。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/7067be8a0612421391d204975ddda194.png" alt="img"></p></li><li><p>操作：</p><ul><li>1.分析并发进程的关键活动，划定临界区（如：对临界资源打印机的访问就应放在临界区）</li><li>2.设置互斥信号量mutex，初值为1</li><li>3.在进入区P（mutex）一一申请资源</li><li>4.在退出区V（mutex）一一释放资源</li></ul></li><li><p>注意</p><ul><li>对不同的临界资源需要设置不同的互斥信号量。</li><li>P、V操作必须成对出现。缺少P（mutex）就不能保证临界资源的互斥访问。缺少V（mutex）会导致资源永不被释放，等待进程永不被唤醒。</li></ul></li></ul></li><li><p>信号量机制实现进程同步</p><p>进程同步要让各并发进程按要求有序地推进。</p><ul><li><p>程序</p><p>保证了代码4一定是在代码2之后执行。</p></li><li><p>步骤：先V后P，后V前P</p><ul><li>1.分析什么地方需要实现“同步关系”，即必须保证“一前一后”执行的两个操作（或两句代码）</li><li>2.设置同步信号量S，初始为0</li><li>3.在“前操作”之后执行V（S）</li><li>4.在“后操作”之前执行P（S）</li></ul></li><li><p>注意</p><ul><li><strong>若先执行到V(S)操作</strong>，则S+后S&#x3D;1。之后当执行到P(S)操作时，由于S&#x3D;1，表示有可用资源，会执行S-，S的值变回0，P2进程不会执行block原语，而是继续往下执行代码4。</li><li><strong>若先执行到P(S)操作</strong>，由于S&#x3D;0，S-后S&#x3D;-1，表示此时没有可用资源，因此P操作中会执行bock原语，主动请求阻塞；当执行完代码2，继而执行V(S)操作，S+，使S变回0，由于此时有进程在该信号量对应的阻塞队列中，因此会在V操作中执行wakeup原语，唤醒P2进程。这样P2就可以继续执行代码4</li></ul></li></ul></li><li><p>信号量机制实现前驱关系</p><p>分析问题，画出前驱图，把每一对前驱关系都看成一个同步问题</p><ul><li><p>问题：下图是一个前驱图，其中 S1, S2, S3, … ,S6 是进程 P1, P2, P3,…, P6 中的程序段，这些程序段要求按如下前驱图所示的顺序来执行：</p></li><li><p>代码：</p></li><li><p>操作：</p><ul><li>1.要为每一对前驱关系各设置一个同步信号量</li><li>2.在“前操作”之后对相应的同步信号量执行V操作</li><li>3.在“后操作”之前对相应的同步信号量执行P操作</li></ul></li></ul></li><li><p>同步、互斥信号量总结</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/0cbb4aedf8ef4f60a9cb34d921efc7a0.png" alt="img"></p><p>注：互斥信号量初值一般为1，同步信号量的初始值要看对应资源的初始值是多少。</p></li></ol><h4 id="2-3-5-管程"><a href="#2-3-5-管程" class="headerlink" title="2.3.5 管程"></a>2.3.5 管程</h4><ol><li><p>引入管程原因</p><p>管程的引入让程序员写程序时不需要再关注复杂的PV操作，从而避免了传统信号量机制存在的很多问题。</p></li><li><p>定义：由一组数据及定义在这组数据之上的对这组数据的操作组成的软件模块，这组操作能初始化并改变管程中的数据和同步进程。</p></li><li><p>管程的组成</p><ul><li>局部于管程的共享数据结构说明</li><li>对该数据结构进行操作的一组过程（函数）</li><li>对局部于管程的共享数据设置初始值的语句</li><li>管程的名字</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">monitor Demo&#123;<span class="comment">//定义一个名称为&quot;Demo&quot;的管程</span></span><br><span class="line">    <span class="comment">//定义共享数据结构，对应系统中的某种共享资源</span></span><br><span class="line">    共享数据结构 S;</span><br><span class="line">    <span class="comment">//对共享数据结构初始化的语句</span></span><br><span class="line">    init_code()&#123;</span><br><span class="line">        S=<span class="number">5</span>;<span class="comment">//初始资源数等于5</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//过程1：申请一个资源</span></span><br><span class="line">    take_away()&#123;</span><br><span class="line">        对共享数据结构x的一系列处理;</span><br><span class="line">        s--;<span class="comment">//可用资源-1</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//过程2：归还一个资源</span></span><br><span class="line">    give_back()&#123;</span><br><span class="line">        对共享数据结构x的一系列处理;</span><br><span class="line">        s++;<span class="comment">//可用资源+1</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>管程的基本特征</p><ul><li>局部于管程的数据只能被局部于管程的过程所访问</li><li>一个进程只有通过调用管程内的过程才能进入管程访问共享数据</li><li>每次仅允许一个进程在管程内执行某个内部过程</li></ul><blockquote><p>注：过程其实就是函数，如下面这个 People 类，People 是管程的名字，username 和 str 是局部于管程的共享数据结构，login 方法是该数据结构进行操作的过程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">People</span>&#123;</span><br><span class="line"><span class="keyword">private</span> String username = <span class="string">&quot;admin&quot;</span>; <span class="comment">// 用户名</span></span><br><span class="line"><span class="keyword">private</span> String str= <span class="string">&quot;123456&quot;</span>; <span class="comment">// 密码</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">login</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="string">&quot;admin&quot;</span>.<span class="built_in">equals</span>(username) &amp;&amp; <span class="string">&quot;123456&quot;</span>.<span class="built_in">equals</span>(str))&#123;</span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="string">&quot;登录成功！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>条件变量</p><p>条件变量condition，是表示管程阻塞原因的变量。</p><p> 通常，一个进程被阻塞的原因可以有多个，因此在管程中设置了多个条件变量。每个条件变量保存了一个等待队列，用于记录因该条件变量而阻塞的所有进程，对条件变量只能进行两种操作，即wait和signal。</p><ul><li>x.wait：当x对应的条件不满足时，正在调用管程的进程调用x.wait将自己插入x条件的等待队列，并释放管程。此时其他进程可以使用该管程。</li><li>x.signal：x对应的条件发生了变化，则调用x.signal，唤醒一个因x条件而阻塞的进程。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">monitor Demo&#123;</span><br><span class="line">    共享数据结构 S;</span><br><span class="line">    condition x；<span class="comment">//定义一个条件变量x</span></span><br><span class="line">    init_code()&#123;...&#125;</span><br><span class="line">    take_away()&#123;</span><br><span class="line">        <span class="keyword">if</span>(S&lt;<span class="number">0</span>) x.wait();<span class="comment">//资源不够，在条件变量x上阻塞等待</span></span><br><span class="line">        资源足够，分配资源，做一系列处理；</span><br><span class="line">    &#125;</span><br><span class="line">    give_back()&#123;</span><br><span class="line">        归还资源，做一系列相应处理;</span><br><span class="line"><span class="keyword">if</span>(有进程在等待）x.signal();<span class="comment">//唤醒一个阻塞进程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>条件变量和信号量的比较：<ul><li><strong>相似点</strong>：条件变量的wait&#x2F;signal操作类似于信号量的P&#x2F;V操作，可以实现进程的阻塞&#x2F;唤醒。</li><li><strong>不同点</strong>：条件变量是“没有值”的，仅实现了“排队等待”功能；而信号量是“有值”的，信号量的值反映了剩余资源数，而在管程中，剩余资源数用共享数据结构记录。</li></ul></li></ul></li></ol><h4 id="2-3-6-经典同步问题"><a href="#2-3-6-经典同步问题" class="headerlink" title="2.3.6 经典同步问题"></a>2.3.6 经典同步问题</h4><ol><li><p><strong>生产者-消费者问题</strong></p><ul><li><p>问题描述</p><p>系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用。（注：这里的“产品”理解为某种数据）</p><p>生产者、消费者共享一个初始为空、大小为n的缓冲区。</p><ul><li>只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待。</li><li>只有缓冲区不空时，消费者才能从中取出产品，否则必须等待。</li></ul><p>缓冲区是临界资源，各进程必须互斥地访问。</p></li><li><p>问题分析</p><ul><li><p>1.<strong>关系分析</strong>。找出题目中描述的各个进程，分析它们之间的同步、互斥关系。</p><p>同步关系：缓冲区没满，生产者生产；缓冲区没空，消费者消费。</p><p>互斥关系：各进程互斥访问缓冲区。</p></li><li><p>2.<strong>整理思路</strong>。根据各进程的操作流程确定P、V操作的大致顺序。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/51a89fdf9e594fb384ae212d810f97af.png" alt="img"></p></li><li><p>3.<strong>设置信号量</strong>。并根据题目条件确定信号量初值。（互斥信号量初值一般为1，同步信号量的初始值要看对应资源的初始值是多少）</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>; <span class="comment">//互斥信号量，实现对缓冲区的互斥访问</span></span><br><span class="line">semaphore empty = n; <span class="comment">//同步信号量，表示空闲缓冲区的数量</span></span><br><span class="line">semaphore full = <span class="number">0</span>;  <span class="comment">//同步信号量，表示产品的数量，也即非空缓冲区的数量</span></span><br></pre></td></tr></table></figure></li><li><p>进程描述</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/fa5416e4f6dc4b718ab17bf8c38bd4b4.png" alt="img"></p></li><li><p>能否改变相邻P、V操作的顺序？</p><p>不能，会发生死锁</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/2c754dcb57824933b85650c2ff8b0bbf.png" alt="img"></p><p>若此时缓冲区内已经放满产品，则 empty&#x3D;0，full&#x3D;n。则生产者进程执行 ① 使mutex变为0，再执行②，由于已没有空闲缓冲区，因此生产者被阻塞。由于生产者阻塞，因此切换回消费者进程。消费者进程执行 ③，由于 mutex 为 0，即生产者还没释放对临界资源的 “锁”，因此消费者也被阻塞。生产者和消费者循环等待被对方唤醒，出现 死锁。</p><p> 因此 实现互斥的 P 操作一定要在实现同步的 P 操作之后。</p><p> V 操作不会导致进程阻塞，因此 两个 V 操作顺序可以交换。</p></li><li><p>能否只设置一个同步信号量</p><p>不能。原因在于：两个信号量 empty 和 full，其中 empty 用于制约生产者生产，full 用于制约消费者消费。如果只设置一个信号量，如 full，那么生产者会无限的生产，起不到制约作用。</p></li></ul></li><li><p><strong>多生产者多消费者问题</strong></p><ul><li><p>问题描述</p><p>桌子上有一只盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。只有盘子空时，爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。</p></li><li><p>问题分析</p><ul><li><p>1.<strong>关系分析</strong></p><p>同步关系：① 父亲将苹果放入盘子，女儿才能取苹果；<br>     ② 母亲将句子放入盘子，儿子才能取橘子；<br>     ③ 只有盘子为空，父亲或者母亲才能放水果。<br>互斥关系：对缓冲区(盘子)的访问要互斥的进行。</p></li><li><p>2.<strong>整理思路</strong></p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/715b4760323a46c1b97dcd79b01788e7.png" alt="img"></p><p>注：盘子为空这个事件可由儿子或者女儿触发，发生后父亲或母亲才可放水果。<br>分析同步要以 <strong>事件</strong> 的角度分析，不要以 <strong>进程</strong> 的角度分析。</p></li><li><p>3.<strong>信号量的设置</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;  <span class="comment">//实现互斥访问盘子（缓冲区）</span></span><br><span class="line">semaphore apple = <span class="number">0</span>;  <span class="comment">//盘子中有几个苹果</span></span><br><span class="line">semaphore orange = <span class="number">0</span>; <span class="comment">//盘子中有几个橘子</span></span><br><span class="line">semaphore plate = <span class="number">1</span>;  <span class="comment">//盘子中还可以放多少个水果</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>进程描述</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/03b5b144181941df8f7455a5350b5658.png" alt="img"></p></li><li><p>能否不用互斥信号量</p><p>如果缓冲区大小为1，在任何时刻，apple、orange、plate 三个信号量中最多只有一个是1。因此在任何时刻，最多只有一个进程的P操作不会被阻塞，并顺利地进入临界区。<br>  如果缓冲区大小大于1，数据可能存在相互覆盖的情况。如：父亲在向盘子放橘子的同时，母亲也可以往盘子里放橘子，有可能导致两个进程写入缓冲区的数据相互覆盖的情况。<br>  因此，当缓冲区大小等于1，有可能不设置互斥变量。当缓冲区大小大于1，必须设置互斥变量。是否不用设置互斥信号量主要观察，同一时刻信号量是否最多一个1，建议设置互斥信号量。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/3b52be6d997145738c875b31abacb69c.png" alt="img"></p><p>但需要注意的是，实现互斥的P操作一定要在实现同步的P操作之后，否则可能引起“死锁”。</p></li><li><p>分析</p><p>在分析同步问题（一前一后问题）的时候不能从单个进程行为的角度来分析，要把“一前一后”发生的事看做是两种“事件”的前后关系。</p><p>如果从 单个进程的角度 来考虑的话，会有以下结论：</p><ul><li>① 如果盘子里装有苹果，那么一定要女儿取走苹果后父亲或母亲才能再放入水果；</li><li>② 如果盘子里装有橘子，那么一定要儿子取走橘子后父亲或母亲才能再放入水果。</li></ul><p>这就意味着要 设置四个同步信号量 分别实现这 四个一前一后的关系，较为复杂。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/d17b09a31472491e98d081a335f1ef4a.png" alt="img"></p><p>若从 事件的角度 来考虑，我们可以把上述四对进程行为的前后关系抽象为 一对事件 的前后关系，即：盘子变空事件 → 放入水果事件。</p></li></ul></li><li><p><strong>读者-写者问题</strong></p><ul><li><p>问题描述</p><p>有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。因此要求：</p><ul><li>①允许多个读者可以同时对文件执行读操作</li><li>②只允许一个写者往文件中写信息</li><li>③任一写者在完成写操作之前不允许其他读者或写者工作</li><li>④写者执行写操作前，应让已有的读者和写者全部退出</li></ul></li><li><p>问题分析</p><ul><li>两类进程：写进程、读进程</li><li>互斥关系：写进程一写进程、写进程一读进程。读进程与读进程不存在互斥问题</li></ul><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/ec6a024d98d74f21a86025ca9a930ba1.png" alt="img"></p></li><li><p>进程描述</p><ul><li><p>方案1</p><p>方案设置 rw 和 mutex 两个信号量。rw 信号量 用于实现 读进程与写进程、写进程与写进程 对共享文件的互斥访问。mutex 信号量 用于保证对 count 变量的互斥访问。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/a62d7354ba5944ffb4ca05e7662404f1.png" alt="img"></p><p>若没有设置 mutex 信号量，两个读进程并发执行到 if 条件且都满足，都会执行 P(rw)，会造成其中一个读进程阻塞的情况。设置 mutex 信号量，使得 count 信号量的检查和赋值操作一气呵成，保证了对 count 信号量访问的互斥性。</p><p> <strong>方案 1 存在的问题：</strong> 只要有读进程还在读，写进程就要一直阻塞等待，可能 “饿死”。因此，这种算法中，读进程是优先的。</p></li><li><p>方案2</p><p>方案 2 是对方案 1 问题的修正，添加了 w 信号量，保证了 读写公平 。如：假设对共享文件的访问顺序是：读者1→读者2→ 写者1 → 读者3 ，读者 2 执行完后，写者 1 将会进行写文件，读者 3 进程将会被阻塞。待写者1写完文件后，读者 3 进行读写者 1 访问后的文件。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/2b29530b97b94604b6d6bcafa84d217c.png" alt="img"></p><p>算法 核心思想 在于设置了一个 计数器 count 用来记录当前正在访问共享文件的读进程数。我们可以用 count 的值来判断当前进入的进程是否是第一个&#x2F;最后一个读进程，从而做出不同的处理。另外，还需考虑 count 变量的互斥性。</p></li></ul></li><li><p>结论</p><p> 在这种算法中，连续进入的多个读者可以同时读文件；写者和其他进程不能同时访问文件；写者不会饥饿，但也并不是真正的“写优先”，而是相对公平的先来先服务原则。</p><p> 有的书上把这种算法称为“读写公平法”</p></li></ul></li><li><p>哲学家进餐问题</p><ul><li><p>问题描述</p><p>一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭。哲学家们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时，才试图拿起左、右两根筷子（一根一根地拿起）。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。</p></li><li><p>问题分析</p><ul><li><p><strong>1.关系分析</strong></p><p>系统中有5个哲学家进程，5位哲学家与左右邻居对其中间筷子的访问是互斥关系。</p></li><li><p><strong>2.整理思路</strong></p><p>哲学家进餐问题中 只有互斥关系，但与之前遇到的问题不同点在于，每个哲学家进程需要同时持有两个临界资源才能开始吃饭。如何避免临界资源分配不当造成的死锁现象，是哲学家问题的关键。</p></li><li><p><strong>3.信号量的设置</strong></p><p>定义互斥信号量数组 chopstick[5]&#x3D;{1,1,1,1,1} 用于实现对 5 个筷子的互斥访问。并对哲学家按0~4编号，哲学家 i 左边的筷子编号为 i，右边的筷子编号为 (i+1)%5。此外，还需要设置 互斥信号量mutex，用以保证哲学家进程左右两支筷子都可用。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/6c94f1c773ad4e12934447c004e912c8.png" alt="img"></p></li></ul></li><li><p>进程描述</p><p>算法保证，一个哲学家再拿到筷子拿到一半时被阻塞，也不会有别的哲学家尝试拿筷子，即至少有一个哲学家进程不阻塞。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/0f12c4e77b7b47388efa55b690a67e02.png" alt="img"></p><blockquote><p>其他方案：<br>① 对哲学家进程施加一些限制条件，如最多允许四个哲学家同时进餐。这样可以保证至少有一个哲学家是可以拿到左右两只筷子的。<br>② 要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子，另一个会直接阻塞。这就避免了占有一支后再等待另一只的情况。</p></blockquote></li></ul></li><li><p><strong>吸烟者问题</strong></p><ul><li><p>问题描述</p><p>假设一个系统有 三个抽烟者进程 和 一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一支烟，抽烟者需要有三种材料：烟草、纸和胶水。三个抽烟者中，第一个拥有烟草、第二个拥有纸、第三个拥有胶水。供应者进程无限地提供三种材料，供应者每次将两种材料放桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉完成了，供应者就会放另外两种材料在桌上，这个过程一直重复（让三个抽烟者轮流地抽烟）。</p></li><li><p>问题分析</p><ul><li><p><strong>1.关系分析</strong></p><p>同步关系：① 桌上有组合一，第一个抽烟者取走东西<br>     ② 桌上有组合二，第二个抽烟者取走东西<br>     ③ 桌上有组合三，第三个抽烟者取走东西<br>     ④ 抽烟者抽完发出完成信号，供应者将下一个组合放到桌上<br>互斥关系：对缓冲区的访问要互斥的进行。</p></li><li><p><strong>2.整理思路</strong></p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/a2e2be6b31ec48f6b9e4a63a7ce1cb20.png" alt="img"></p><blockquote><p>注：由于缓冲区大小为1，任意时刻同步信号量和互斥信号量最多只有一个1，因此互斥信号量可以不设置。</p></blockquote></li><li><p><strong>3.信号量的设置</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">semaphore offer1 = <span class="number">0</span>; <span class="comment">//桌上组合一的数量</span></span><br><span class="line">semaphore offer2 = <span class="number">0</span>; <span class="comment">//桌上组合二的数量</span></span><br><span class="line">semaphore offer3 = <span class="number">0</span>; <span class="comment">//桌上组合三的数量</span></span><br><span class="line">semaphore finish = <span class="number">0</span>; <span class="comment">//抽烟是否完成</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>; <span class="comment">//用于实现“三个抽烟者轮流抽烟”</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>进程描述</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/029d0f3880d441a5b46ae6b0db27b3ad.png" alt="img"></p></li><li><p>能否从进程角度思考？</p><p> 不可以。<br>    同多生产者多消费者问题，假设从进程角度思考，那么第一个抽烟者抽完后，供应者再将第一个组合放到桌上；第二个抽烟者抽完后，供应者再将第二个组合放到桌上；第三个抽烟者抽完后，供应者再将第三个组合放到桌上。这样相比于从事件考虑的一个一前一后的关系，多出了多个关系，并且较为复杂。因此要从事件的角度思考 PV 关系。</p></li></ul></li></ol><h3 id="2-4-死锁"><a href="#2-4-死锁" class="headerlink" title="2.4 死锁"></a>2.4 死锁</h3><h4 id="2-4-1-死锁的概念"><a href="#2-4-1-死锁的概念" class="headerlink" title="2.4.1 死锁的概念"></a>2.4.1 死锁的概念</h4><ol><li><p>死锁的定义</p><p> 在并发环境下，各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进的现象，就是“死锁”。发生死锁后若无外力干涉这些进程都将无法向前推进。</p></li><li><p>死锁、饥饿、死循环的区别</p><ul><li><p>共同点：都是进程无法顺利向前推进的现象（故意设计的死循环除外)</p></li><li><p>区别：</p><ul><li><p><strong>死锁</strong>：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。两个以上程序</p></li><li><p><strong>饥饿</strong>：由于长期得不到想要的资源，某进程无法向前推进的现象。单个程序</p><p>比如：在短进程优先（SPF）算法中，若有源源不断的短进程到来，则长进程将一直得不到处理机，从而发生长进程“饥饿”</p></li><li><p><strong>死循环</strong>：某进程执行过程中一直跳不出某个循环的现象。</p><p>有时是因为程序逻辑bug导致的，有时是程序员故意设计的。</p></li></ul></li></ul></li><li><p>死锁产生原因</p><ul><li><p><strong>对系统资源的竞争</strong></p><p>各进程对不可剥夺的资源（如打印机）的竞争可能引起死锁，对可剥夺的资源（CPU）的竞争是不会引起死锁的。</p></li><li><p><strong>进程推进顺序非法</strong></p><p>请求和释放资源的顺序不当，也同样会导致死锁。例如，并发执行的进程P1、P2分别申请并占有了资源R1、R2，之后进程P1又紧接着申请资源R2，而进程P2又申请资源R1，两者会因为申请的资源被对方占有而阻塞，从而发生死锁。</p></li><li><p><strong>信号量的使用不当也会造成死锁</strong></p><p>如生产者-消费者问题中，如果实现互斥的P操柞在实现同步的P操作之前，就有可能导致死锁。（可以把互斥信号量、同步信号量也看做是一种抽象的系统资源）</p></li></ul></li><li><p>死锁产出的必要条件</p><p>产生死锁 必须同时满足以下四个条件，只要其中任一条件不成立，死锁就不会发生。</p><ul><li>① 互斥条件：只有对必须 互斥使用的资源的争抢 才会导致死锁（如哲学家的筷子、打印机设备）。像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的（因为进程不用阻塞等待这种资源）。</li><li>② 不剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。</li><li>③ 请求和保持条件：进程已经 保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。</li><li>④ 循环等待条件：存在一种进程资源的 循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。</li></ul><p>注：发生死锁时一定有循环等待，但是发生循环等待时未必死锁，即 循环等待是死锁的必要不充分条件。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/8d5f352afa3940b1a3e13deab4bd1e7f.png" alt="img"></p><p>如果同类资源数大于1，则即使有循环等待，也未必发生死锁（如上图 Pn 可以同时请求 P1 或者 Pk 的资源，得到 Pk 资源后，不会发生死锁）。 但如果系统中每类资源都只有一个，那循环等待就是死锁的充分必要条件了。</p></li><li><p>死锁处理策略</p><ul><li><strong>死锁预防</strong>。设置某些限制条件，破坏产生死锁的4个必要条件中的一个或几个。</li><li><strong>避免死锁</strong>。在资源的动态分配过程中，用某种方法防止系统进入不安全状态。</li><li><strong>死锁的检测及解除</strong>。无须采取任何限制性措施，允许进程在运行过程中发生死锁。通过系统的检测机构及时地检测出死锁的发生，然后采取某种措施解除死锁。</li></ul><p>死锁的几种处理策略的比较见下表。</p><table><thead><tr><th align="center"></th><th align="center">资源分配策略</th><th align="center">各种可能模式</th><th align="center">主要优点</th><th align="center">主要缺点</th></tr></thead><tbody><tr><td align="center">死锁预防</td><td align="center">保守，宁可资源闲置</td><td align="center">一次请求所有资源，资源剥夺，资源按序分配</td><td align="center">适用于突发式处理的进程，不必进行剥夺</td><td align="center">效率低，进程初始化时间延长；剥夺次数过多；不便灵活申请新资源</td></tr><tr><td align="center">死锁避免</td><td align="center">是“预防”和“检测”的折中（在运行时判断是否可能死锁）</td><td align="center">寻找可能的安全允许顺序</td><td align="center">不必进行剥夺</td><td align="center">必须知道将来的资源需求；进程不能被长时间阻塞</td></tr><tr><td align="center">死锁检测</td><td align="center">宽松，只要允许就分配资源</td><td align="center">定期检查死锁是否已经发生</td><td align="center">不延长进程初始化时间，允许对死锁进行现场处理</td><td align="center">通过剥夺解除死锁，造成损失</td></tr></tbody></table></li></ol><h4 id="2-4-2-死锁预防"><a href="#2-4-2-死锁预防" class="headerlink" title="2.4.2 死锁预防"></a>2.4.2 死锁预防</h4><p>死锁的产生必须满足四个必要条件，只要其中一个或者几个条件不满足，死锁不会发生。</p><ol><li><p><strong>破坏互斥条件</strong></p><p>把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。如: SPOOLing技术。使用 SPOOLing 技术可以把 独占设备在逻辑上改造成共享设备。比如，用SPOOLing技术将打印机改造为共享设备…</p></li><li><p><strong>破坏不剥夺条件</strong></p><ul><li>提供两种方案：<ul><li>① 申请资源得不到时，主动释放所占有资源。</li><li>② 申请资源被其他进程占用时，由 OS 协助剥夺。</li></ul></li><li><strong>策略的缺点：</strong><ul><li>实现起来比较复杂；</li><li>释放已获得的资源可能造成前一阶段工作的失效，因此这种方法一般只适用于易保存和恢复状态的资源，如CPU；</li><li>反复地申请和释放资源会增加系统开销，降低系统吞吐量；</li><li>方案 ① 可能导致进程饥饿。</li></ul></li></ul></li><li><p><strong>破坏请求和保持条件</strong></p><p>采用 静态分配方法，即进程 在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行。一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源了。</p><p><strong>策略的缺点：</strong> 进程在整个运行期间都一直保持着所有资源，就会造成严重的资源浪费，资源利用率极低。另外，该策略也有 可能导致某些进程饥饿。</p></li><li><p><strong>破坏循环等待条件</strong></p><p>采用 顺序资源分配法。首先给系统中的资源编号，要求进程只能按编号递增顺序请求资源。</p><p><strong>原理分析</strong>： 一个进程只有已占有小编号的资源时，才有资格申请更大编号的资源。按此规则，已持有大编号资源的进程不可能逆向地回来申请小编号的资源，从而就不会产生循环等待的现象(类比拓扑排序)。</p><p><strong>策略的缺点</strong>： 不方便增加新的设备，因为可能需要重新分配所有的编号；进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源浪费；必须按规定次序申请资源，用户编程麻烦。</p></li></ol><h4 id="2-4-3-死锁避免"><a href="#2-4-3-死锁避免" class="headerlink" title="2.4.3 死锁避免"></a>2.4.3 死锁避免</h4><p> 死锁的避免是在资源动态分配过程中，防止系统进入不安全状态，以避免发生死锁。</p><ol><li><p>系统安全状态</p><ul><li>安全序列：是指如果系统按照这种序列分配资源，则每个进程都能顺利完成。</li><li>安全状态：系统如果存在安全序列，则处于<strong>安全状态</strong>，安全状态一定不发生死锁。安全序列可能有多个。</li><li>不安全状态：如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了<strong>不安全状态</strong>。可能发生死锁（处于不安全状态未必就是发生了死锁，但发生死锁时一定是在不安全状态）</li></ul><blockquote><p><strong>安全序列的计算方法：</strong></p><p>已知现有三个进程的资源分配表如下(可用代表系统还剩有 3 个资源)，现假设可用资源每次分配都是全部分配，并且分配给进程的资源总数应满足进程最多还需求的资源数目(如：可用资源有 3 个，由于 P2 进程还需要 2 个资源，因此只能满足 P2)，分配完后回收该进程所拥有的全部资源。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/a8fd403d874141cfbece5486934dc73a.png" alt="img"></p><p>计算步骤如下：</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/9241e0fb8dfa413d807a6f11194279f0.png" alt="img"></p><p>因此得到安全序列是 {P2, P1, P3}。</p><hr><p>如果计算到 P3 时，可用资源无法满足 P3 的最大需求，即还需要的资源数目多于可用资源数目，那么就不存在安全序列。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/a1fbffe7bdad4cc99de2dd8f1d28e8f4.png" alt="img"></p><p>注：死锁状态一定是不安全状态，不安全状态不一定是死锁状态，即：死锁状态 ⇒ 不安全状态。</p><p>如：A 进程需 10 个资源，而可用资源有 5 个。若 A 还未提出申请，则不会进入死锁状态。</p><p>系统进入不安全状态后，便可能进入死锁状态；反之，只要系统处于安全状态，系统变可避免进入死锁。</p></blockquote></li><li><p>银行家算法</p><p><strong>核心思想：</strong> 在分配资源前，预先判断这次分配是否会导致系统进入不安全状态，以此来决定是否答应资源分配请求，从而使得系统避免死锁。</p><ul><li><p><strong>数据结构描述：</strong></p><ul><li>①可利用资源向量$Available$（一维数据）</li><li>②最大需求矩阵$Max$</li><li>③分配矩阵$Allocation$</li><li>④需求矩阵$Need$</li></ul><p>其中，$Need&#x3D;Max-Allocation$</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/c49ba6619b9b4d5aa0a933ee740b8493.png" alt="img"></p><p>注：$Available(A,B,C)&#x3D;(3,3,2)$代表可用的 A 类资源数目有 3 个，B 类资源数目有3个，C 类资源数目有 2 个。</p></li><li><p><strong>银行家算法描述</strong></p><p>设$Request_i$是进程Pi的请求向量，$Request_i[j]&#x3D;K$表示进程$Pi$需要$j$类资源$K$个。</p><ul><li><p>①若$Request_i[j]≤Need[i，j]$，检查此次申请是否超过最多还需求数。</p></li><li><p>②若$Request_i[j]≤Available[j]$，检查系统的可用资源是否还能满足此次需求。</p></li><li><p>③系统试探着把资源分配给$Pi$，并修改下面数据结构的数值：</p><p>$Available&#x3D;Available-Request_i$，修改i进程剩余可用资源数</p><p>$Allocation[i，j]&#x3D;Allocation[i，j]+Request_i[j]$，i进程已分配资源数加上本次请求资源数</p><p>$Need[i，j]&#x3D;Need[i，j]-Request_i[j]$，i进程还需的资源数减去本次请求的资源数</p></li><li><p>④执行安全性算法，检查系统是否处于安全状态，即检查当前系统是否存在安全序列。</p></li></ul><p>若系统安全，才正式将资源分配给$Pi$；否则此次试探分配作废，恢复原来分配状态。</p><p>注：安全性算法是银行家算法的核心。</p></li><li><p><strong>安全性算法描述</strong></p><p>设置工作向量$Work$，表示系统中剩余可用资源数目。算法执行开始时，$Work&#x3D;Available$</p><ul><li>①初始时安全序列为空。</li><li>②检查当前的剩余资源是否能满足某个进程的最大需求。如果可以就将它加入安全序列；若找不到执行步骤④</li><li>③把该进程持有资源全部回收，返回步骤②</li><li>④若此时安全序列中已有所有进程，则系统处于安全状态，否则处于不安全状态。</li></ul></li><li><p>例题</p><p>假设当前系统中资源分配和剩余情况如下表所示，现$P1$发出请求向量$Request_1(1，0，2)$，判断此次请求是否分配成功。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/c49ba6619b9b4d5aa0a933ee740b8493.png" alt="img"></p><ul><li><p>① 系统按银行家算法进行检查：</p><p>$Request_1(1,0,2)≤Need_1(1,2,2)$，$Request_1(1,0,2)≤Available(3,2,2)$</p><p>此次申请未超过$P1$进程最多还需求数,并且当前可用资源数可满足此次申请,则可试探的为$P1$分配资源,并修改:</p><p>$Available&#x3D;Available-Request_1&#x3D;(2,3,0)$<br>$Allocation_1&#x3D;Allocation_1+Request_1&#x3D;(3,0,2)$<br>$Need_1&#x3D;Need_1-Request_1&#x3D;(0,2,0)$</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/8fe6c5cad74c4e598da0d01b2a5f4054.png" alt="img"></p></li><li><p>② 系统执行安全性算法检查安全状态：</p><p>令$Work&#x3D;Available&#x3D;(2,3,0)$，执行安全性算法，如下表所示：</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/9bab9019c27e4561adcb1d022b605be9.png" alt="img"></p><p>由安全性检查而知，可以找到一个安全序列 { P1, P3, P4, P0, P2 }，因此系统是安全的，可以将P1所申请的资源分配给他。</p></li></ul><p><strong>王道书解法</strong>：</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230913154241862.png" alt="image-20230913154241862"></p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230913154306033.png" alt="image-20230913154306033"></p></li></ul></li></ol><h4 id="2-4-4-死锁检测和解除"><a href="#2-4-4-死锁检测和解除" class="headerlink" title="2.4.4 死锁检测和解除"></a>2.4.4 死锁检测和解除</h4><p> 如果系统既不采取预防死锁的措施，也不采取避免死锁的措施，系统就很可能发生死锁。在这种情况下，系统应当提供死锁检测和解除的手段。</p><ol><li><p>资源分配图</p><p>系统死锁可利用 资源分配图 来描述。圆代表一个进程，框代表一类资源，框中一个圆代表一类资源中的一个资源。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/ad8c5ea4cdbd48d99508aeb1f00065a8.png" alt="img"></p><ul><li>两种结点：<ul><li>进程结点：对应一个进程</li><li>资源结点：对应一类资源，一类资源可能有多个</li></ul></li><li>两种边：<ul><li>请求边：表示进程想申请几个资源（每条边代表一个）</li><li>分配边：表示已经为进程分配了几个资源（每条边代表一个）</li></ul></li></ul></li><li><p>死锁定理</p><p>简化资源分配图可检测系统状态是否为死锁状态。简化方法如下：</p><p>① 在资源分配图中，找出 既不阻塞又不是孤点的进程 Pi。</p><ul><li>不阻塞：表示进程申请的资源可以被满足，如 P1 进程。由于 R2 资源除分配给 P2 进程一个资源外，还剩有一个资源，因此 P1 进程申请的 R2 资源可以被满足。相反，P2 进程申请 R1 资源则不会被满足，由于 R1 资源全部被分配完。</li><li>不是孤点：表示与该进程节点至少一个边相连。</li></ul><p>② 消去进程所有的请求边和分配边，使之成为孤点。</p><p>重复以上步骤，若能消去图中所有的边，则称该图是可完全简化的。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/cda1e353f29f4499baeed8c070096631.png" alt="img"></p><p>注：并不是系统中所有的进程都是死锁状态，用死锁检测算法 化简资源分配图后，还连着边的那些进程就是死锁进程。</p><p>死锁定理：如果某时刻系统的资源分配图是不可完全简化的，那么此时系统死锁</p></li><li><p>死锁解除</p><p>一旦检测出死锁的发生，就应该立即解除死锁。解除死锁的主要方法有：</p><ul><li><p>资源剥夺法</p><p>挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是 应防止被挂起的进程长时间得不到资源而饥饿。</p></li><li><p>撤销进程法（或称终止进程法）</p><p>强制撤销部分甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，已经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来。撤销的原则可以按进程优先级和撤销进程代价的高低进行。</p></li><li><p>进程回退法</p><p>让一个或多个死锁进程回退到足以避免死锁的地步。进程回退时，自愿释放资源而非剥夺。这就要求系统要记录进程的历史信息，设置还原点。</p></li></ul><blockquote><p>注：撤销进程法中参考的优先级，应考虑：进程优先级、已执行多长时间、还要多久能完成、进程已经使用了多少资源、进程是交互式的还是批处理式的等因素。</p></blockquote></li></ol><h2 id="3-内存管理"><a href="#3-内存管理" class="headerlink" title="3 内存管理"></a>3 内存管理</h2><h3 id="3-1-内存管理概念"><a href="#3-1-内存管理概念" class="headerlink" title="3.1 内存管理概念"></a>3.1 内存管理概念</h3><h4 id="3-1-1-内存管理的基本原理和要求"><a href="#3-1-1-内存管理的基本原理和要求" class="headerlink" title="3.1.1 内存管理的基本原理和要求"></a>3.1.1 内存管理的基本原理和要求</h4><ol><li><p>内存管理的概念</p><p> 虽然计算机技术飞速发展，内存容量也在不断扩大，但仍然不可能将所有用户进程和系统所需的全部程序与数据放入内存，因此操作系统对内存空间进行合理的划分和有效的动态分配。操作系统对内存的划分和动态分配，就是内存管理的概念。</p><p>内存空间的主要功能有：</p><ul><li>① <strong>内存空间的分配与回收</strong>：OS 要怎么记录哪些内存区域已经被分配出去了，哪些又还空闲；当进程运行结束之后，如何将进程占用的内存空间回收。</li><li>② <strong>内存空间的扩充</strong>：OS 利用虚拟内存技术或自动覆盖技术使得系统运行很大的程序，从逻辑上扩充内存。</li><li>③ <strong>地址转换</strong>：为了使编程更方便，程序员写程序时应该只需要关注指令、数据的逻辑地址。而 逻辑地址到物理地址的转换（这个过程称为地址重定位）应该由操作系统负责，其中地址重定位有三种方式。</li><li>④ <strong>内存保护</strong>：保证各进程在各自存储空间内运行，互不干扰。</li></ul></li><li><p>程序执行过程</p><p> 创建进程首先要将程序和数据装入内存。将用户源程序变为可在内存中执行的程序，通常需要以下几个步骤：</p><ul><li><strong>编译</strong>：由编译程序将用户源代码编译成若干目标模块，编译就是把高级语言翻译为机器语言。</li><li><strong>链接</strong>：由链接程序将编译后形成的一组目标模块及它们所需的库函数链接在一起，形成一个完整的装入模块。</li><li><strong>装入</strong>：由装入程序将装入模块装入内存运行。</li></ul><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/eee4ab27320e4dd5a28a1cd12d9e01a6.png" alt="img"></p><blockquote><p> 编译后，每个目标模块都是从 0 号单元开始编址，这称为该目标模块的 逻辑地址 (或相对地址)。当链接程序将各个模块连接成一个完整的可执行目标程序时，链接程序顺序依次按各个模块的相对地址构成统一的从 0 号单元开始编制的 逻辑地址空间。用户程序和程序员只需知道逻辑地址，而内存管理的具体机制则是完全透明的，只有系统编程人员才会涉及内存管理的具体机制。不同进程可以有相同的逻辑地址，因为这些相同的逻辑地址可以映射到内存的不同位置。<br>  物理地址空间 是指内存中物理单元的集合，它是地址转换的最终地址。进程在运行时执行指令和访问数据，最后都要通过物理地址从主存中存取。当装入程序将可执行代码装入内存时，必须通过地址转换将逻辑地址转换成物理地址(动态重定位是地址转换推迟到程序真正要执行时才进行)，这个过程称为 地址重定位。</p></blockquote></li><li><p>程序的链接</p><ul><li><p>静态链接</p><p>在程序运行之前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件(装入模块)，之后不再拆开。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/2b2053b9b6f44772a4b309c85d4998ff.png" alt="img"></p></li><li><p>装入时动态链接</p><p>将各 目标模块装入内存时，边装入边链接的链接方式。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/cd21652741714cca8732c044a2eaa684.png" alt="img"></p></li><li><p>运行时动态链接</p><p>在程序执行中需要该目标模块时，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/6c5ae35d6a89479cbcf34b99d4fd4435.png" alt="img"></p></li></ul></li><li><p>程序的装入</p><ul><li><p>绝对装入</p><p>在编译与链接后，得到的装入模块指定 直接使用了绝对地址。</p></li><li><p>可重定位装入</p><p>装入时对地址进行重定位，即将逻辑地址变换为物理地址，地址变换是在装入时一次完成的。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/979dcf9791c34d428a2380f0c422f754.png" alt="img"></p><p><strong>静态重定位的特点：</strong> 在一个作业装入内存时，必须分配其要求的全部内存空间，如果没有足够的内存，就不能装入该作业。作业一旦进入内存后，在运行期间就不能再移动，也不能再申请内存空间。</p></li><li><p>动态运行时装入</p><p>装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址(装入时依然保持使用逻辑地址)，而是把地址转换推迟到程序真正要执行时才进行。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个重定位寄存器的支持。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/5768b6cbd3844ce2929672b40f3e7bf7.png" alt="img"></p><p><strong>动态重定位特点：</strong> 可以将程序分配到不连续的存储区中；在程序运行前只需装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存；便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间；采用动态重定位时允许程序在内存中发生移动。</p></li></ul><blockquote><p>注：链接的作用是形成了完整的装入模块与逻辑地址，但逻辑地址到物理地址的转换过程是重定位，而不是装入。</p></blockquote></li><li><p>内存映像</p><p> 不同于存放在硬盘上的可执行程序文件，当一个程序调入内存运行时，就构成了进程的内存映像。一个进程的内存映像一般有几个要素：</p><ul><li><strong>代码段</strong>：即程序的二进制代码，代码段是只读的，可以被多个进程共享。</li><li><strong>数据段</strong>：即程序运行时加工处理的对象，包括全局变量和静态变量。</li><li><strong>进程控制块（PCB）</strong>：存放在系统区。操作系统通过PCB来控制和管理进程。</li><li><strong>堆</strong>：用来存放动态分配的变量。通过调用malloc 函数动态地向高地址分配空间。</li><li><strong>栈</strong>：用来实现函数调用。从用户空间的最大地址往低地址方向增长。</li></ul><blockquote><p>代码段和数据段在程序调入内存时就指定了大小，而堆和栈不一样。</p><p>当调用像malloc和free这样的C标准库函数时，堆可以在运行时动态地扩展和收缩。</p><p>用户栈在程序运行期间也可以动态地扩展和收缩，每次调用一个函数，栈就会增长；从一个函数返回时，栈就会收缩。</p></blockquote><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230914155418540.png" alt="image-20230914155418540"></p><p> 上图是一个进程在内存中的映像。</p><ul><li>其中，共享库用来存放进程用到的共享函数库代码，如printf函数等。</li><li>在只读代码段中，.iit是程序初始化时调用的_init函数；.text是用户程序的机器代码；.rodata是只读数据。</li><li>在读&#x2F;写数据段中，.data是已初始化的全局变量和静态变量；.bss是未初始化及所有初始化为0的全局变量和静态变量。</li></ul></li><li><p>内存保护</p><p> 确保每个进程都有一个<strong>单独的内存空间</strong>。内存分配前，需要保护操作系统不受用户进程的影响，同时保护用户进程不受其他用户进程的影响。内存保护可采取两种方法：</p><ul><li><p>在CPU中设置一对上、下限寄存器，存放用户作业在主存中的下限和上限地址，每当CPU要访问一个地址时，分别和两个寄存器的值相比，判断有无越界。</p></li><li><p>采用重定位寄存器（又称基地址寄存器）和界地址寄存器（又称限长寄存器）来实现这种保护。</p><p><strong>重定位寄存器</strong>含最小的物理地址值，<strong>界地址寄存器</strong>含逻辑地址的最大值。内存管理机构动态地将逻辑地址与界地址寄存器进行比较，若未发生地址越界，则加上重定位寄存器的值后映射成物理地址，再送交内存单元，如下图所示。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230914160656627.png" alt="image-20230914160656627"></p><blockquote><p>重定位寄存器是用来“加”的，逻辑地址加上重定位寄存器中的值就能得到物理地址；</p><p>界地址寄存器是用来“比”的，通过比较界地址寄存器中的值与逻辑地址的值来判断是否越界。</p></blockquote><p> 加载重定位寄存器和界地址寄存器时必须使用特权指令，只有操作系统内核才可以加载这<br>两个存储器。这种方案允许操作系统内核修改这两个寄存器的值，而不允许用户程序修改。</p></li></ul></li><li><p>内存共享</p><p> 并不是所有的进程内存空间都适合共享，只有那些只读的区域才可以共享。</p><p> 可重入代码又称纯代码，是一种允许多个进程同时访问但不允许被任何进程修改的代码。</p><p> 在实际运行时，每个进程有自己的私有数据段，可以更改自己私有的数据区数据，不可改变共享的代码。</p><blockquote><p>例：考虑一个可以同时容纳40个用户的多用户系统，他们同时执行一个文本编辑程序，若该程序有160KB代码区和40KB数据区，则共需8000KB的内存空间来支持40个用户。如果160KB代码是可分享的纯代码，则不论是在分页系统中还是在分段系统中，整个系统只需保留一份副本即可，此时所需的内存空间仅为40KB×40+160KB&#x3D;1760KB。</p><p>对于分页系统，假设页面大小为4KB，则代码区占用40个页面、数据区占用10个页面。为实现代码共享，应在每个进程的页表中都建立40个页表项，它们都指向共享代码区的物理页号。此外，每个进程还要为自己的数据区建立10个页表项，指向私有数据区的物理页号。</p><p>对于分段系统，由于是以段为分配单位的，不管该段有多大，都只需为该段设置一个段表项（指向共享代码段始址，以及段长160KB）。由此可见，段的共享非常简单易行。</p></blockquote></li><li><p>内存分配与回收</p><p> 在操作系统由单道向多道发展时，存储管理方式便由单一连续分配发展为固定分区分配。为了能更好地适应不同大小的程序要求，又从固定分区分配发展到动态分区分配。</p><p> 为了更好地提高内存的利用率，进而从连续分配方式发展到离散分配方式一一页式存储管理。</p><p> 引入分段存储管理的目的，主要是为了满足用户在编程和使用方面的要求，其中某些要求是其他几种存储管理方式难以满足的。</p></li></ol><h4 id="3-1-2-覆盖与交换"><a href="#3-1-2-覆盖与交换" class="headerlink" title="3.1.2 覆盖与交换"></a>3.1.2 覆盖与交换</h4><p> 覆盖与交换技术是在多道程序环境下用来扩充内存的两种方法。</p><ol><li><p>覆盖</p><ul><li><p>基本思想：由于程序运行时并非任何时候都要访问程序及数据的各个部分（尤其是大程序），因此可把用户空间分成一个</p><p>固定区</p><p>和若干</p><p>覆盖区</p><p>。</p><ul><li>将经常活跃的部分放在固定区，其余部分按调用关系分段。</li><li>首先将那些即将要访问的段放入覆盖区，其他段放在外存中，在需要调用前，系统再将其调入覆盖区，替换覆盖区中原有的段。</li></ul></li><li><p>特点：</p><ul><li>打破了必须将一个进程的全部信息装入主存后才能运行的限制，但当同时运行程序的代码量大于主存时仍不能运行；</li><li>内存中能够更新的地方只有覆盖区的段，不在覆盖区中的段会常驻内存；</li><li>覆盖技术对用户和程序员不透明。</li></ul></li></ul></li><li><p>交换</p><ul><li>基本思想：把处于等待状态（或在CPU调度原则下被剥夺运行权利）的程序从内存移到辅存，把内存空间腾出来，这一过程又称换出；把准备好竞争CPU运行的程序从辅存移到内存，这一过程又称换入。</li><li>交换过程：例如，有一个CPU采用时间片轮转调度算法的多道程序环境。时间片到，内存管理器将刚刚执行过的进程换出，将另一进程换入刚刚释放的内存空间。同时，CPU调度器可以将时间片分配给其他已在内存中的进程。每个进程用完时间片都与另一进程交换。在理想情况下，内存管理器的交换过程速度足够快，总有进程在内存中可以执行。</li><li>问题：<ul><li>交换需要备份存储，通常是磁盘。它必须足够大，并提供对这些内存映像的直接访问。</li><li>为了有效使用CPU，需要使每个进程的执行时间比交换时间长。</li><li>若换出进程，则必须确保该进程完全处于空闲状态。</li><li>交换空间通常作为磁盘的一整块，且独立于文件系统，因此使用起来可能很快。</li><li>交换通常在有许多进程运行且内存空间吃紧时开始启动，而在系统负荷降低时就暂停。</li><li>普通的交换使用不多，但交换策略的某些变体在许多系统（如UNX）中仍发挥作用。</li></ul></li></ul></li><li><p>区别</p><p> 交换技术主要在<strong>不同进程（或作业）之间</strong>进行，而覆盖则用于<strong>同一个程序或进程</strong>中。对于主存无法存放用户程序的矛盾，现代操作系统是通过<strong>虚拟内存技术</strong>来解决的，覆盖技术则已成为历史；而交换技术在现代操作系统中仍具有较强的生命力。</p></li></ol><h4 id="3-1-3-连续分配管理方式"><a href="#3-1-3-连续分配管理方式" class="headerlink" title="3.1.3 连续分配管理方式"></a>3.1.3 连续分配管理方式</h4><p> 连续分配方式是指为一个用户程序分配一个连续的内存空间，包括单一连续分配、固定分区分配和动态分区分配。</p><ol><li><p>单一连续分配</p><p> 在单一连续分配方式中，内存被分为 系统区和用户区。系统区通常位于内存的低地址部分，用于存放操作系统相关数据；用户区用于存放用户进程相关数据。内存中只能有一道用户程序，用户程序独占整个用户区空间。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/49406fbc9608493b9b36588ed2a17485.png" alt="img"></p><p><strong>优点：</strong> 实现简单；无外部碎片；可以采用覆盖技术扩充内存；无需采取内存保护，因为内存中永远只有一道程序。</p><p><strong>缺点：</strong>只能用于单用户、单任务的操作系统中；有内部碎片；存储器利用率极低。</p><blockquote><p>内部碎片：分配给某进程的内存区域中，如果有些部分没有用上。</p><p>外部碎片：是指内存中的某些空闲分区由于太小而难以利用。</p></blockquote></li><li><p>固定分区分配</p><p>固定分区分配是最简单的一种多道程序存储管理方式，它将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业。当有空闲分区时，便可从外存的后备作业队列中选择适当大小的作业装入该分区，如此循环。划分分区有两种方法：</p><ul><li>分区大小相等。程序太小会造成浪费，程序太大又无法装入，缺乏灵活性。</li><li>分区大小不等。划分为多个较小的分区、适量的中等分区和少量大分区，增加了灵活性。</li></ul><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/8a164fe40fa0477eaeaa4ef304967362.png" alt="img"></p><p> 为了便于分配，建立一张分区使用表，通常按分区大小排队，各表项包括每个分区的起始地址、大小及状态（是否已分配），如下图所示。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230915143014357.png" alt="image-20230915143014357"></p><blockquote><p>分配内存时，便检索该表，以找到一个能满足要求且尚未分配的分区分配给装入程序，并将对应表项的状态置为“已分配”；若找不到这样的分区，则拒绝分配。</p><p>回收内存时，只需将对应表项的状态置为“未分配”即可。</p></blockquote><p><strong>优点：</strong> 实现简单，无外部碎片。</p><p><strong>缺点：</strong> 当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采用覆盖技术来解决，但这又会降低性能；会产生内部碎片，内存利用率低。</p></li><li><p>动态分区分配</p><p>动态分区分配 又称为 可变分区分配。这种分配方式不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此，系统分区的大小和数目是可变的。</p><blockquote><p>例：如图所示，系统有64MB内存空间，其中低8MB固定分配给操作系统，其余为用户可用内存。</p><p>开始时装入前三个进程，它们分别分配到所需的空间后，内存仅剩4MB，进程4无法装入。</p><p>在某个时刻，内存中没有一个就绪进程，CPU出现空闲，操作系统就换出进程2，换入进程4。由于进程4比进程2小，这样在主存中就产生了一个6MB的内存块。</p><p>之后CPU又出现空闲，需要换入进程2，而主存无法容纳进程2，操作系统就换出进程1，换入进程2。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230915143834058.png" alt="image-20230915143834058"></p></blockquote><p>紧凑技术：动态分区在开始时是很好的，但随着时间的推移，内存中会产生越来越多的外部碎片。需要通过紧凑技术来解决，即操作系统不时地对进程进行移动和整理。但这需要动态重定位寄存器的支持，且相对费时。</p><p> 在进程装入或换入主存时，若内存中有多个足够大的空闲块，则操作系统必须确定分配哪个内存块给进程使用，这就是动态分区的分配策略。考虑以下几种算法：</p><ul><li><p>首次适应（FirstFit）算法</p><ul><li><strong>算法思想</strong>：每次都从低地址开始查找，找到第一个能满足大小的空闲分区。</li><li><strong>如何实现</strong>：空闲分区以地址递增的次序链接。分配内存时，从链首开始顺序查找，找到大小能满足要求的第一个空闲分区分配给作业。</li><li>算法简单，最好最快，回收分区后一般不需要对空闲分区队列重新排序</li></ul></li><li><p>最佳适应（BestFit）算法</p><ul><li><strong>算法思想：</strong>优先使用更小的分区，以保留更多大分区。</li><li><strong>如何实现：</strong>空闲分区按容量递增的次序形成空闲分区链，找到第一个能满足要求且最小的空闲分区分配给作业，避免“大材小用”。</li><li><strong>缺点：</strong>产生大量小的、难以利用的外部碎片</li></ul></li><li><p>最坏适应（WorstFit）算法</p><p>（最大适应算法）</p><ul><li><strong>算法思想：</strong>优先使用更大的分区，以防止产生太小的不可用的碎片。</li><li><strong>如何实现：</strong>空闲分区以容量递减的次序链接，找到第一个能满足要求的，即最大的分区，从中分割一部分存储空间给作业。</li><li><strong>缺点：</strong>如果之后有“大进程”到达，无足够大连续内存空间分配。</li></ul></li><li><p>邻近适应（NextFit）算法</p><p>（循环首次适应算法）</p><ul><li><strong>算法思想：</strong>由首次适应演变而来，每次从上次查找结束位置开始查找。</li><li><strong>如何实现：</strong>空闲分区以地址递增的顺序排列（可排成一个循环链表）。每次分配内存时从上次查找结束的位置开始查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</li><li><strong>缺点：</strong>导致无论低地址、高地址部分的空闲分区都有相同的概率被使用，也就导致了高地址部分的大分区更可能被使用，划分为小分区，最后导致无大分区可用。</li></ul></li></ul><table><thead><tr><th align="center">算法</th><th align="center">算法思想</th><th align="center">分区排列顺序</th><th align="center">优点</th><th align="center">缺点</th></tr></thead><tbody><tr><td align="center">首次适应</td><td align="center">从头到尾找适合的分区</td><td align="center">空闲分区以地址递增次序排列</td><td align="center">性能最好 算法开销小</td><td align="center"></td></tr><tr><td align="center">最佳适应</td><td align="center">优先使用更小的分区</td><td align="center">空闲分区以容量递增次序排列</td><td align="center">保留更大分区</td><td align="center">产生大量碎小的外部碎片；算法开销大</td></tr><tr><td align="center">最坏适应</td><td align="center">优先使用更大的分区</td><td align="center">空闲分区以容量递减次序排列</td><td align="center">减少难以利用的碎片</td><td align="center">大分区容易被用完；算法开销大</td></tr><tr><td align="center">邻近适应</td><td align="center">每次从上次查找结束位置开始查找</td><td align="center">空闲分区以地址递增次序排列（可排列成循环链表)</td><td align="center">空闲分区有相同概率被使用，算法开销小</td><td align="center">使高地址大分区也被用完</td></tr></tbody></table><blockquote><p>注：动态分区分配没有内部碎片，但是有外部碎片。</p></blockquote></li><li><p>分区的分配与回收</p><p>回收内存分区时，有可能遇到四种情况：</p><ul><li>① 回收区的后面有一个相邻的空闲分区。</li><li>② 回收区的前面有一个相邻的空闲分区。</li><li>③ 回收区的前、后各有一个相邻的空闲分区。</li><li>④ 回收区的前、后都没有相邻的空闲分区。</li></ul><p>无论那种情况，都要遵循相邻的空闲分区要合并的原则。</p></li></ol><h4 id="3-1-4-基本分页存储管理"><a href="#3-1-4-基本分页存储管理" class="headerlink" title="3.1.4 基本分页存储管理"></a>3.1.4 基本分页存储管理</h4><p> 固定分区会产生内部碎片，动态分区会产生外部碎片，这两种技术对内存的利用率都比较低。为了避免碎片的产出，引出了分页的思想。<br>​ <strong>分页的思想</strong>：把主存空间划分为大小相等且固定的块，块相对较小，作为主存的基本单位。每个进程也以块为单位进行划分，进程在执行时，以块为单位逐个申请主存中的块空间。</p><p> 分页管理与固定分区类似，不会产生外部碎片；进程运行按块申请主存空间，只会在最后一块有内部碎片，每个进程平均只有半个块的内部碎片（页内碎片）。</p><ol><li><p>基本概念</p><ul><li><p>页面和页面大小</p><ul><li>进程中的块称为页或页面（Page)，</li><li>内存中的块称为页框或页帧（Page Frame)</li><li>外存也以同样的单位进行划分，直接称为块或盘块（Block)。</li></ul><p>进程在执行时需要为每个页面分配主存中的可用页框，这就产生了页和页框的一一对应。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/e149642fce4145539ec3871fc85f2e86.png" alt="img"></p><blockquote><ul><li>将内存空间分为一个个大小相等的分区，每个分区就是一个页框 。每个页框有一个编号，即 页框号，页框号 从 0 开始。</li><li>将进程的逻辑地址空间也分为与页框大小相等的一个个部分，每个部分称为一个 页或页面。每个页面也有一个编号，即 页号，页号也是 从 0 开始。</li></ul><p>页框&#x3D;页帧&#x3D;内存块&#x3D;物理块&#x3D;物理页面</p></blockquote><p>为方便地址转换，页面大小应是2的整数幂。同时页面大小应该适中，</p><ul><li>页面太小会使进程的页面数过多，这样页表就会过长，占用大量内存，而且也会增加硬件地址转换的开销，降低页面换入&#x2F;换出的效率；</li><li>页面过大又会使页内碎片增多，降低内存的利用率。</li></ul></li><li><p>地址结构</p><p> 地址结构决定了虚拟内存的寻址空间有多大。</p><p>分页存储管理的 逻辑地址结构 如下所示：</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/000c51965bd3456dbf10934cd923bd7c.png" alt="img"></p><p> 地址结构包含两个部分：前一部分为页号，后一部分为页内偏移量 W。</p><p> 在上图所示的例子中，地址长度为 32 位，其中 0 ~ 11位 为页内偏移量(或称页内地址)，即每页大小为 4KB；12~31 位为页号，进程地址空间最多允许 220 页。</p></li><li><p>页表</p><p>为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一张 页表。页表通常存在 PCB (进程控制块，在操作系统的内核地址空间)中。页表记录进程 页面 和实际存放的 内存块 之间的 映射关系。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/187e4f5ea97449f9a859d715237d41d8.png" alt="img"></p><ul><li>①一个进程对应一张页表。</li><li>②进程的每个页面对应一个页表项。</li><li>③每个页表项由页号和块号组成。</li><li>④每个页表项的长度是相同的。</li></ul><blockquote><p>例：假设某系统物理内存大小为 4 GB，页面大小为 4 KB，则每个页表项至少应该为多少字节？</p><ul><li>内存块大小&#x3D;页面大小&#x3D;4KB&#x3D;212B</li><li>4GB的内存总共会被分为232／212&#x3D;220个内存块</li><li>内存块号的范围应该是0～220-1</li><li>内存块号至少要用20 bit来表示</li><li>至少要用3B来表示块号（3＊8&#x3D;24 bit＞20bit）</li></ul><p>页表项在内存中是连续存放，因此页号是可以隐藏的，不占内存空间，页表项占 3 个字节。</p></blockquote><p>注：如果未特别强调，默认计算机按字节编址。</p></li><li><p>地址转换</p><p><strong>分页存储特点：</strong> 虽然进程的各个页面是离散存放的，但是页面内部是连续存放的。</p><p>页号 &#x3D; 逻辑地址 &#x2F; 页面长度<br>页内偏移量 &#x3D; 逻辑地址 % 页面长度</p><p>如果要访问逻辑地址 A 的物理块，则</p><ul><li>① 确定逻辑地址 A 对应的页号 P</li><li>② 找到 P 号页面在内存中的起始地址（需要查页表）</li><li>③ 确定逻辑地址 A 的页内偏移量 W</li></ul></li></ul></li><li><p>基本地址变换机构</p><p>基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址。变换机构如下图所示。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230915162458487.png" alt="image-20230915162458487"></p><p>通常会在系统中设置一个 页表寄存器(PTR)，存放 页表在内存中的起始地址 F 和页表长度 M。<br>进程未执行时，页表的始址 和 页表长度 放在进程控制块(PCB)中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。</p><ul><li><p>设页面大小为 L ，逻辑地址 A 到物理地址 E 的变换过程如下：</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/d3e7e501b58f4f1da9a028a072074163.png" alt="img"></p><ul><li><p>①<strong>计算页号P和页内偏移量W</strong></p><p>如果用十进制数手算，则$P&#x3D;A&#x2F;L，W&#x3D;A%L$；但是在计算机实际运行时，逻辑地址结构是固定不变的，因此计算机硬件可以更快地得到二进制表示的页号、页内偏移量</p></li><li><p>②<strong>判断页号是否越界</strong></p><p>比较页号P和页表长度M，若P≥M，则产生越界中断，否则继续执行。</p><p>注意：页号是从0开始的，而页表长度至少是1，因此P&#x3D;M时也会越界</p></li><li><p>③<strong>查页表，找页号对应的页表项，确定内存块号</strong><br>$$<br>页表中页号P对应的页表项地址&#x3D;页表起始地址F+页号P*页表项长度<br>$$<br>取出该页表项内容b，即为内存块号。</p><blockquote><p><strong>注意区分页表项长度、页表长度、页面大小的区别。</strong></p><p>页表长度指的是这个页表中总共有几个页表项，即总共有几个页；</p><p>页表项长度指的是每个页表项占多大的存储空间；</p><p>页面大小指的是一个页面占多大的存储空间</p></blockquote></li><li><p>④<strong>用内存块号和偏移量得到物理地址</strong></p><p>计算$E&#x3D;b*L+W$，用得到的物理地址E去访存。</p><p>如果内存块号、页面偏移量是用二进制表示的，那么把二者拼接起来就是最终的物理地址了</p></li><li><p>⑤<strong>访问目标内存单元</strong></p></li></ul></li></ul><p> 在分页存储管理（页式管理）的系统中，页是信息的物理单位，分页完全是系统行为，因此 页的大小由系统决定，逻辑地址在计算机的视角很好确定。所以，页式管理中地址是一维的。即，只要给出一个逻辑地址，系统就可以自动地算出页号、页内偏移量 两个部分，并不需要显式地告诉系统这个逻辑地址中，页内偏移量占多少位。</p></li><li><p>具有快表的地址变换机构</p><p>快表，又称联想寄存器(TLB)，是一种 访问速度比内存快很多的高速缓存器，用来存放最近访问的页表项的副本，可以加速地址变换的速度。与此对应，内存中的页表常称为慢表。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230915170102254.png" alt="image-20230915170102254"></p><blockquote><p>注：TLB 不是内存；快表与 Cache(高速缓冲器) 的区别在于，块表中只有页表项的副本，而普通 Cache 中可能有其他各种数据的副本，可以把快表理解为一种特殊的 Cache。</p></blockquote><ul><li><p>设某进程执行过程中要访问 (0,4) 这个逻辑地址，访问过程如下：</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/09cdc9c2ed774334998cb93421ffc158.png" alt="img"></p><ul><li>① CPU 给出逻辑地址，由硬件进行地址转换，将页号与快表中的所有页号进行比较。</li><li>② 如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后再访存。因此，若快表命中，存取数据仅一次访存。</li><li>③ 如果没有找到匹配的页号，则需要访问内存中的页表。找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后再访存。因此，若快表未命中，存取数据需两次访存。</li></ul></li></ul><p>注：在找到页表项后，应同时将其存入快表，以便后面可能的再次访问。但若快表已满，则必须按照一定算法对旧的页表项进行替换（局部性原理）。</p></li><li><p>两级页表</p><p>两级页表的分配管理方式属于基本分页存储管理范畴，其用于解决页表项占据连续页框的问题。</p><ul><li><p>单级页表存在的问题</p><p><strong>问题一</strong>：页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框。</p><p><strong>解决</strong>：可建立两级页表，一级页表为页目录表，二级页表离散存储。</p><p><strong>问题二</strong>：没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面。</p><p><strong>解决</strong>：可以在需要访问页面时才把页面调入内存（虚拟存储技术）。可以在页表项中增加一个标志位，用于表示该页面是否已经调入内存</p></li><li><p>两级页表的原理、地址结构</p><p>二级页表实际上是在原有页表结构上再加上一层页表，如下图所示。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230915175632539.png" alt="image-20230915175632539"></p><p> 建立多级页表的目的在于建立索引，以便不用浪费主存空间去存储无用的页表项，也不用盲目地顺序式查找页表项。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/9784e5f0c318438a9412c145206cff78.png" alt="img"></p><blockquote><p>例：某系统按字节寻址，支持 30 位的逻辑地址，采用分页存储管理，页面大小为 4KB，页表项长度为 4B，试问逻辑地址的结构。</p><p>页面大小为4KB&#x3D;212B，则页内偏移量要用12位表示。</p><p>30-12&#x3D;18，则顷号用18位表示，即进程最多有218个页面，一共需要218个页表项来记录这些页面与物理块的映射关系，且页号范围是：0~218-1。</p><p>页表项长度是4B，一个内存块（页框）最多存储4K&#x2F;4&#x3D;212&#x2F;4&#x3D;210个页表项。</p><p>218个页表项则需要218&#x2F;210&#x3D;28个内存块才能存储。</p><p>即需要专门给进程分配28&#x3D;256个连续的物理块（页框）来存放它的页表。</p><p>为避免连续占用内存块问题，可以设置28&#x3D;256个二级页表，并用一级页表来记录这些二级页表，因此一级页号占8位。</p></blockquote></li><li><p>地址变换</p><p><strong>例：</strong> 将逻辑地址 (00000000,0000000001,111111111111) 转换为物理地址（用十进制表示）。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/82c7749b04fb4c8a9c8fdf8efd4206ad.png" alt="img"></p><p>首先，按照地址结构将逻辑地址拆分成三部分</p><ul><li>① 从 PCB 中读出页目录表始址，再根据一级页号查页目录表，找到下一级页表在内存中的存放位置。</li><li>② 根据二级页号查二级页表，找到最终想访问的内存块号。</li><li>③ 结合页内偏移量得到物理地址。</li></ul><p>最终要访问的内存块号为 4，该内存块的起始地址为 4*4096 &#x3D; 16384 页内偏移量为 4095。</p><p>最终的物理地址为：16384 + 4095&#x3D; 20479。</p><blockquote><p><strong>两次页表，若采用“快表”，需要3次访存。</strong></p><ul><li>第一次：访问页目录表。</li><li>第二次：访问内存中的二级页表。</li><li>第三次：访问目标内存单元。</li></ul></blockquote></li><li><p>多级页表</p><p>若分为两级页表后，页表依然很长，则可以采用更多级页表。并且，若采用多级页表机制，则各级页表的大小不能超过一个页面。</p><blockquote><p>例：某系统按字节编址，采用 40 位逻辑地址，页面大小为 4KB，页表项大小为 4B，假设采用纯页式存储，则要采用 (   ) 级页表，页内偏移量为 (   ) 位？</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/1becafe302474e46b71ec544f94aca3e.png" alt="img"></p><p>页面大小&#x3D;4KB&#x3D;212B，按字节编址，因此页内偏移量为12位。</p><p>页号&#x3D;40-12&#x3D;28位</p><p>页面大小&#x3D;212B，页表项大小&#x3D;4B，则每个页面可存放212&#x2F;4&#x3D;210个页表项。</p><p>因此，各级页表最多包含210个页表项，需要10位二进制位才能映射到210个页表项。</p><p>因此每一级的页表对应页号应为10位。总共28位的页号至少要分为3级。</p></blockquote><p>此外，若未用“快表”，N 级页表机制，需要 N+1 次访问内存。</p></li></ul></li></ol><h4 id="3-1-5-基本分段式存储管理"><a href="#3-1-5-基本分段式存储管理" class="headerlink" title="3.1.5 基本分段式存储管理"></a>3.1.5 基本分段式存储管理</h4><p> 分页管理方式是从计算机的角度考虑设计的，目的是提高内存的利用率，提升计算机的性能。分页通过硬件机制实现，对用户完全透明。</p><p> 分段管理方式的提出则考虑了用户和程序员，以满足方便编程、信息保护和共享、动态增长及动态链接等多方面的需要。</p><ol><li><p>分段</p><p>段式管理方式按照用户进程中的自然段划分逻辑空间。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/e7ee7ecc5347417c91887ff7bb1416b5.png" alt="img"></p><blockquote><p>例如，用户进程由主程序段、两个子程序段、栈段和数据段组成，于是可以把这个用户进程划分为5段，每段从0开始编址，并分配一段连续的地址空间。</p></blockquote><p>段内要求连续，段间不要求连续，因此整个作业的地址空间是二维的。</p><p>其逻辑地址由段号S与段内偏移量W两部分组成，如下图所示分段系统中的逻辑地址结构。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230918092323039.png#pic_center" alt="image-20230918092323039"></p><p>其中，段号为16位，段内偏移量为16位，因此一个作业最多有216&#x3D;65536段，最大段长为64KB。</p><blockquote><p>在页式系统中，逻辑地址的页号和页内偏移量对用户是透明的，但在段式系统中，段号和段内偏移量必须由用户显式提供，在高级程序设计语言中，这个工作由编译程序完成。</p></blockquote></li><li><p>段表</p><p>程序分多个段，各段离散地装入内存，为了保证程序能正常运行，就必须能从物理内存中找到各个逻辑段的存放位置。为此，需为每个进程建立一张段映射表，简称段表。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/26729d8d16904859a5c212627606ade2.png" alt="img"></p><p>段表用于实现从逻辑段到物理内存区的映射。</p><p>特点：</p><ul><li>① 每个段对应一个段表项，其中 记录了该段在内存中的起始位置（又称“基址”）和段的长度。</li><li>② 各个段表项的长度是相同的。</li><li>③ 由于段表项长度相同，在内存中是连续存放，因此段号可以是隐含的，不占存储空间。</li><li>④ 段内要求连续，段间不要求连续，因此整个作业的地址空间是二维的。</li></ul></li><li><p>地址变换机构</p><p> 分段系统的地址变换过程如图所示。为了实现进程从逻辑地址到物理地址的变换功能，在系统中设置了段表寄存器，用于存放段表始址F和段表长度M。从逻辑地址A到物理地址E之间的地址变换过程如下：</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/1d8a08763d62462fb2c79df0f70e258a.png" alt="img"></p><ul><li><p>① <strong>根据逻辑地址得到段号，段内地址</strong></p><p>从逻辑地址A中取出前几位为段号S，后几位为段内偏移量W。</p></li><li><p>② <strong>判断段号是否越界</strong></p><p>比较段号S和段表长度M，若 $段号S≥段表长度M$ ，则产生越界中断，否则继续执行。</p></li><li><p>③ <strong>查询段表，找到对应段表项</strong></p><p>段表中段号S对应的 $段表项地址&#x3D;段表始址F+段号S×段表项长度$ 。</p></li><li><p>④ <strong>检查段内地址是否超过段长</strong></p><p>取出该段表项的前几位得到段长C。若$段内偏移量W≥段长C$，则产生越界中断，否则继续执行。</p></li><li><p>⑤ <strong>计算得到物理地址</strong></p><p>取出段表项中该段的始址b，计算 $物理地址E&#x3D;段基址b+偏移量W$ ，得到物理地址E。</p></li><li><p>⑥ <strong>访问目标内存单元</strong></p><p>用得到的物理地址E去访问内存。</p></li></ul></li><li><p>段的共享与保护</p><ul><li><p>共享</p><p>在分段系统中，段的共享是通过两个作业的段表中相应表项指向被共享的段的同一个物理副本来实现的。</p><p>不能修改的代码称为纯代码或可重入代码（它不属于临界资源），这样的代码和不能修改的数据可以共享，而可修改的代码和数据不能共享。</p></li><li><p>保护</p><p>分段管理的保护方法主要有两种：一种是存取控制保护，另一种是地址越界保护。</p><ul><li><strong>存取控制保护</strong>：指在段表的每个表项中，设置“存取控制”字段，规定对该段的访问方式。</li><li><strong>地址越界保护</strong>：指在进行存储访问时，要检查逻辑地址是否超出了进程的地址空间。</li></ul></li></ul></li><li><p>分段、分页管理的对比</p><table><thead><tr><th align="center"></th><th align="center">存储信息</th><th align="center">地址空间</th><th align="center">信息保护</th><th align="center">访存次数</th></tr></thead><tbody><tr><td align="center">分页管理</td><td align="center">页是信息的物理单位 对用户透明 系统行为</td><td align="center">一维 记忆符(<A>)</td><td align="center">不易</td><td align="center">分页(单级页表)需两次访问 页表+目标内存单元</td></tr><tr><td align="center">分段管理</td><td align="center">段是信息的逻辑单位 对用户可见 用户需求</td><td align="center">二维 段名+段内地址([D]|<A>)</td><td align="center">容易 纯代码</td><td align="center">分段需两次访问 段表+目标内存单元</td></tr></tbody></table></li></ol><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/d61d4a9c2bdc45768ec8e3b1b1af43fa.png" alt="img"></p><h4 id="3-1-6-段页式管理"><a href="#3-1-6-段页式管理" class="headerlink" title="3.1.6 段页式管理"></a>3.1.6 段页式管理</h4><ol><li><p>段页式管理结构</p><p> 分页存储管理能有效地提高内存利用率，而分段存储管理能反映程序的逻辑结构并有利于段的共享和保护。将这两种存储管理方法结合起来，便形成了段页式存储管理方式。</p><p> 段页式存储管理方式，将作业的地址空间首先被分成若干逻辑段，每段都有自己的段号，然后将每个段分成若干大小固定的页，内存空间分为大小一个个大小相等的分区。如下图所示。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230918135016046.png" alt="image-20230918135016046"></p><p> 在段页式系统中，作业的逻辑地址分为三部分：段号、页号和页内偏移量。如下图所示。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230918135200702.png" alt="image-20230918135200702"></p><p> 段号的位数决定了每个进程最多可以分几个段，页号位数决定了每个段最大有多少页，页内偏移量决定了页面大小、内存块大小是多少。</p><p> 在一个进程中，段表只有一个，而页表可能有多个。</p><blockquote><p>例：如下图所示的段页式格式，</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/3528a43d260646b9ba48507c2d18725f.png" alt="img"></p><ul><li>段号16位，因此进程中最多有216&#x3D;64K个段。</li><li>页号4位，因此每个段最多有24&#x3D;16页。</li><li>页内偏移量有12位，因此每个内存块大小为212&#x3D;2KB</li></ul></blockquote><p>分段对用户是可见的，程序员编程时需要显式地给出段号、段内地址。而将各段分页对用户是不可见的。系统会根据段内地址自动划分页号和页内偏移量。因此，段页式管理的地址结构是二维的。</p></li><li><p>地址转换</p><p> 在进行地址变换时，首先通过段表查到页表始址，然后通过页表找到页号，最后形成物理地址。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230918140200214.png" alt="image-20230918140200214"></p><p> 如下图所示，进行一次访问实际需要三次访问主存，这里同样可以使用快表来加快查找速度，其关键字由段号、页号组成，值是对应的页帧号和保护码。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/6bc46dbddfdb4cab8e5f184094540a0b.png" alt="img"></p><ul><li>① 根据逻辑地址得到段号、页号、页内偏移量</li><li>② 判断段号是否越界若S≥M，则产生越界中断，否则继续执行</li><li>③ 查询段表找到对应的段表项，段表项的存放地址为$F+S×段表顶长度$</li><li>④ 检查页号是香越界，若页号≥页表长度，则发生越界中断，否则继续执行</li><li>⑤ 根据页表存放块号、页号查询页表找到对应页表项</li><li>⑥ 根据内存块号页内偏移量得到最终的物理地址</li><li>⑦ 访问目标内存单元</li></ul></li></ol><h3 id="3-2-虚拟内存管理"><a href="#3-2-虚拟内存管理" class="headerlink" title="3.2 虚拟内存管理"></a>3.2 虚拟内存管理</h3><h4 id="3-2-1-虚拟内存的基本概念"><a href="#3-2-1-虚拟内存的基本概念" class="headerlink" title="3.2.1 虚拟内存的基本概念"></a>3.2.1 虚拟内存的基本概念</h4><ol><li><p>传统存储管理方式的特征</p><ul><li>传统存储管理方式<ul><li>连续分配<ul><li>单一连续分配</li><li>固定分区分配</li><li>动态分区分配</li></ul></li><li>非连续分配<ul><li>基本分页存储管理</li><li>基本分段存储管理</li><li>基本段页式存储管理</li></ul></li></ul></li></ul><p><strong>特征</strong>：</p><ul><li><p>一次性</p><p>：</p><p>作业必须一次性全部装入内存后，才能开始运行</p><p>。这会导致两种情况：</p><ul><li>①当作业很大而不能全部被装入内存时，将使该作业无法运行；</li><li>②当大量作业要求运行时，由于内存不足以容纳所有作业，只能使少数作业先运行，导致多道程序度的下降。</li></ul></li><li><p><strong>驻留性</strong>：作业被装入内存后，就一直驻留在内存中，其任何部分都不会被换出，直至作业运行结束。运行中的进程会因等待IO而被阻塞，可能处于长期等待状态。</p></li></ul><p> 由以上分析可知，许多在程序运行中不用或暂时不用的程序（数据）占据了大量的内存空间，而一些需要运行的作业又无法装入运行，显然浪费了宝贵的内存资源。</p></li><li><p>局部性原理</p><p>快表、页高速缓存及虚拟内存技术都属于高速缓存技术，这个技术所依赖的原理就是局部性原理。</p><ul><li><p><strong>时间局部性</strong>。</p><p>程序中的某条指令一且执行，不久后该指令可能再次执行；某数据被访问过，不久后该数据可能再次被访问。产生的原因是程序中存在着大量的循环操作。</p></li><li><p><strong>空间局部性</strong>。</p><p>一旦程序访问了某个存储单元，在不久后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式聚存储的。</p></li></ul></li><li><p>虚拟存储器的定义和特征</p><p>程序不需全部装入即可运行，运行时根据需要动态调入数据，若内存不够，还需换出一些数据。系统好像为用户提供了一个比实际内存容量大得多的存储器，称为虚拟存储器。</p><ul><li><strong>多次性</strong>：无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存。</li><li><strong>对换性</strong>：无需在作业运行时一直常驻内存，而是允许在作业运行过程中，将作业换入、换出。</li><li><strong>虚拟性</strong>：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量。</li></ul></li><li><p>虚拟内存技术的实现</p><p>虚拟内存的实现需要建立在离散分配的内存管理方式的基础上。</p><p>访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存（请求调页功能）</p><p>内存空间不够时，将内存中暂时用不到的信息换出到外存（页面置换功能）</p><ul><li><p>虚拟内存的实现方式</p><ul><li>请求分页存储管理</li><li>请求分段存储管理</li><li>请求段页式存储管理</li></ul></li><li><p>所需要的</p><p>硬件支持</p><ul><li>一定容量的内存和外存。</li><li>页表机制（或段表机制），作为主要的数据结构。</li><li>中断机构，当用户程序要访问的部分尚未调入内存时，则产生中断。</li><li>地址变换机构，逻辑地址到物理地址的变换。</li></ul></li></ul></li></ol><h4 id="3-2-2-请求分页管理方式"><a href="#3-2-2-请求分页管理方式" class="headerlink" title="3.2.2 请求分页管理方式"></a>3.2.2 请求分页管理方式</h4><p> 请求分页系统建立在基本分页系统基础之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。</p><ol><li><p>页表机制</p><p> 请求分页系统在一个作业运行之前不要求全部一次性调入内存，因此在作业的运行过程中，必然会出现要访问的页面不在内存中的情况。因此在请求页表项中增加了 4个字段，如下图所示。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230918151653087.png" alt="image-20230918151653087"></p><ul><li><strong>状态位P</strong>：用于指示该页是否已调入内存，供程序访问时参考。</li><li><strong>访问字段A</strong>：用于记录本页在一段时间内被访问的次数，或记录本页最近已有多长时间未被访问，供置换算法换出页面时参考。</li><li><strong>修改位M</strong>：标识该页在调入内存后是否被修改过，以确定页面置换时是否写回外存。</li><li><strong>外存地址</strong>：用于指出该页在外存上的地址，通常是物理块号，供调入该页时参考。</li></ul></li><li><p>缺页中断机构</p><p> 在请求分页系统中，每当所要访问的页面不在内存中时，便产生一个缺页中断，请求操作系统将所缺的页调入内存。</p><ul><li><strong>缺页中断执行过程</strong><ul><li>先将缺页的进程阻塞（调页完成唤醒)，</li><li>若内存中有空闲块，则分配一个块，将要调入的页装入该块，并修改页表中的相应页表项，</li><li>若此时内存中没有空闲块，则要淘汰某页（若被淘汰页在内存期间被修改过，则要将其写回外存）。</li></ul></li><li><strong>缺页中断和一般中断的区别</strong>：<ul><li>在指令执行期间而非一条指令执行完后产生和处理中断信号，属于内部异常。</li><li>一条指令在执行期间，可能产生多次缺页中断。</li></ul></li></ul></li><li><p>地址变换机构</p><p> 请求分页系统中的地址变换机构，是在分页系统地址变换机构的基础上，为实现虚拟内存，又增加了某些功能而形成的，如产生和处理缺页中断，及从内存中换出一页的功能等等。</p><ul><li>新增步骤1：请求调页（查到页表项时进行判断）</li><li>新增步骤2：页面置换（需要调入页面，但没有空闲内存块时进行)</li><li>新增步骤3：需要修改请求页表中新增的表项</li></ul><p>请求分页管理的地址变换过程，如下图所示，红框部分为新增步骤：</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230918154105795.png" alt="image-20230918154105795"></p><p>①只有“写指令”才需要修改“修改位”。并且，一般来说只需修改快表中的数据，只有要将快表项删除时才需要写回内存中的慢表。这样可以减少访存次数。</p><p>②和普通的中断处理一样，缺页中断处理依然需要保留CPU现场。</p><p>③需要用某种“页面置换算法”来决定一个换出页面（下节内容）</p><p>④换入&#x2F;换出页面都需要启动慢速的I&#x2F;O操作，可见，如果换入换出太频繁，会有很大的开销。</p><p>⑤页面调入内存后，需要修改慢表，同时也需要将表项复制到快表中。</p></li></ol><h4 id="3-2-3-页框分配"><a href="#3-2-3-页框分配" class="headerlink" title="3.2.3 页框分配"></a>3.2.3 页框分配</h4><ol><li><p>驻留集大小</p><p>给一个进程分配的物理页框的集合就是这个进程的驻留集。</p><ul><li>分配给一个进程的页框越少，驻留在主存中的进程就越多，从而可提高CPU的利用率。</li><li>若一个进程在主存中的页面过少，则尽管有局部性原理，缺页率仍相对较高。</li><li>若分配的页框过多，则由于局部性原理，对该进程的缺页率没有太明显的影响。</li></ul></li><li><p>内存分配策略</p><p> 在请求分页系统中，可采取两种内存分配策略，即固定和可变分配策略。在进行置换时，也可采取两种策略，即全局置换和局部置换。</p><ul><li><strong>固定分配</strong>：操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不再改变。即，驻留集大小不变</li><li><strong>可变分配</strong>：先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少。即驻留集大小可变</li><li><strong>局部置换</strong>：发生缺页时只能选进程自己的物理块进行置换。</li><li><strong>全局置换</strong>：可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程。</li></ul><blockquote><p>固定分配VS可变分配：区别在于进程运行期间驻留集大小是否可变</p><p>局部置换VS全局置换：区别在于发生缺页时是否只能从进程自己的页面中选择一个换出</p></blockquote><p>三种组合方案：</p><ul><li><p><strong>固定分配局部置换</strong></p><p>它为每个进程分配一定数目的物理块，在整个运行期间都不改变。</p><p>若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面。</p></li><li><p><strong>可变分配全局置换</strong></p><p>为系统中的每个进程分配一定数目的物理块，操作系统自身也保持一个空闲物理块队列。</p><p>当某进程发生缺页时，系统从空闲物理块队列中取出物理块分配给该进程，井将欲调入的页装入其中。</p></li><li><p><strong>可变分配局部置换</strong></p><p>它为每个进程分配一定数目的物理块，当某进程发生缺页时，只允许从该进程在内存的页面中选出一页换出动态变换，频繁缺页，分配物理块，缺页率低，减少物理块</p></li></ul></li><li><p>物理块调入算法</p><p>采用固定分配策略时，将系统中的空闲物理块分配给各个进程，可采用下述几种算法。</p><ul><li><strong>平均分配算法</strong>，将系统中所有可供分配的物理块平均分配给各个进程。</li><li><strong>按比例分配算法</strong>，根据进程的大小按比例分配物理块。</li><li><strong>优先权分配算法</strong>，为重要和紧迫的进程分配较多的物理块。通常采取的方法是把所有可分配的物理块分成两部分：一部分按比例分配给各个进程；一部分则根据优先权分配。</li></ul></li><li><p>调入页面的时机</p><p>为确定系统将进程运行时所缺的页面调入内存的时机，可采取以下两种调页策略：</p><ul><li><strong>预调页策略：</strong>将预计在不久后便会被访问的页面预先调入内存；主要用于进程的首次调入，由程序员指出应先调入哪些页。</li><li><strong>请求调页策略：</strong>进程在运行中需要访问的页面不再内存而提出请求，由系统将所需页面调入内存。每次仅调入一页，增加了磁盘I&#x2F;O开销。</li></ul></li><li><p>从何处调入页面</p><p> 请求分页系统中的外存分为两部分：用于存放文件的文件区和用于存放对换页面的对换区。</p><p> 对换区采用连续分配方式，而文件区采用离散分配方式，因此对换区的磁盘IO速度比文件区的更快。这样，当发生缺页请求时，系统从何处将缺页调入内存就分为三种情况：</p><ul><li><p><strong>系统拥有足够的对换区空间</strong></p><p>可以全部从对换区调入所需页面，以提高调页速度。为此，在进程运行前，需将与该进程有关的文件从文件区复制到对换区。</p></li><li><p><strong>系统缺少足够的对换区空间</strong></p><p>凡是不会被修改的文件都直接从文件区调入；而当换出这些页面时，由于它们未被修改而不必再将它们换出。但对于那些可能被修改的部分，在将它们换出时须调到对换区，以后需要时再从对换区调入（因为读比写的速度快）。</p></li><li><p><strong>UNIX方式</strong></p><p>运行之前进程有关的数据全部放在文件区，故未使用过的页面，都可从文件区调入。若被使用过的页面需要换出，则写回对换区，下次需要时从对换区调入。进程请求的共享页面若被其他进程调入内存，则无须再从对换区调入。</p></li></ul></li><li><p>如何调入页面</p><ul><li><p>当进程所访问的页面不在内存中时（存在位为0)，便向CPU发出缺页中断，中断响应后便转入缺页中断处理程序。</p></li><li><p>该程序通过查找页表得到该页的物理块，此时如果内存未满，则启动磁盘I&#x2F;O，将所缺页调入内存，并修改页表。</p></li><li><p>如果内存已满，则先按某种置换算法从内存中选出一页准备换出；</p><ul><li>如果该页未被修改过（修改位为0)，则无须将该页写回磁盘；</li><li>如果该页已被修改（修改位为1)，则必须将该页写回磁盘，</li></ul><p>然后将所缺页调入内存，并修改页表中的相应表项，置其存在位为1。</p></li><li><p>调入完成后，进程就可利用修改后的页表形成所要访问数据的内存地址。</p></li></ul></li></ol><h4 id="3-2-4-页面置换算法"><a href="#3-2-4-页面置换算法" class="headerlink" title="3.2.4 页面置换算法"></a>3.2.4 页面置换算法</h4><p> 进程运行时，若其访问的页面不在内存中而需将其调入，但内存已无空闲空间时，就需要从内存中调出一页程序或数据，送入磁盘的对换区，选择调出页面的算法就称为页面置换算法。</p><ol><li><p>最佳置换算法（OPT）</p><p> 选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/71a285fc3367ccf50d377f44e700f4fb.png" alt="img"></p><p>但由于人们目前无法预知进程在内存下的页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。</p></li><li><p>先进先出置换算法（FIFO）</p><p>优先淘汰最早进入内存的页面，即在内存中驻留时间最久的页面。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/047d308ca4a04dde65345bc9d2326f20.png" alt="img"></p><p>该算法实现简单，只需把调入内存的页面根据先后次序链接成队列，设置一个指针总指向最早的页面。</p><ul><li><p>Belady异常一一当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。</p><p>只有FIFO算法回产生Belady异常，算法性能差。</p><p>该算法与进程实际运行时的规律不适应，因为在进程中，有的页面经常被访问。</p></li></ul></li><li><p>最近最久未使用置换算法（LRU）</p><p> 选择最近最长时间未访问过的页面予以淘汰，它认为过去一段时间内未访问过的页面，在最近的将来可能也不会被访问。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/00d4372fa2790806a982d58b47a32b42.png" alt="img"></p><p> 该算法为每个页面设置一个访问字段，来记录页面自上次被访问以来所经历的时间，淘汰页面时选择现有页面中值最大的予以淘汰。</p><p> 该算法的实现需要专门的硬件支持，虽然算法性能好，但是实现困难，开销大。</p></li><li><p>时钟置换算法（CLOCK）&#x2F;最近未用算法（NRU）</p><p>简单的CLOCK算法实现方法：</p><ul><li>为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个循环队列。</li><li>当某页被访问时，其访问位置为1。</li><li>当需要淘汰一个页面时，只需检查页的访问位。如果是0，就选择该页换出；如果是1，则将它置为0，暂不换出，继续检查下一个页面，</li><li>若第一轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描（第二轮扫描中一定会有访问位为0的页面，因此简单的CLOCK算法选择一个淘汰页面最多会经过两轮扫描）</li></ul><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/aabbed4621bdebbcc188e9f10763e92c.png" alt="img"></p></li><li><p>改进型的时钟置换算法</p><ul><li><p>简单时钟问题：简单的时钟置换算法仅考虑到一个页面最近是否被访问过。事实上，如果被淘汰的页面没有被修改过，就不需要执行I&#x2F;O操作写回外存。只有被淘汰的页面被修改过时，才需要写回外存。</p><p>因此，除了考虑一个页面最近有没有被访问过之外，操作系统还应考虑页面有没有被修改过。在其他条件都相同时，应优先淘汰没有修改过的页面，避免I&#x2F;O操作。这就是改进型的时钟置换算法的思想。</p><p>修改位&#x3D;0，表示页面没有被修改过：修改位&#x3D;1，表示页面被修改过。</p></li><li><p>算法规则：将所有可能被置换的页面排成一个循环队列，用（访问位A，修改位M）表示各页面状态。</p><blockquote><p>替换帧优先级：</p><ul><li>1类A&#x3D;0，M&#x3D;0：最近未被访问且未被修改，是最佳淘汰页。</li><li>2类A&#x3D;0，M&#x3D;1：最近未被访问，但已被修改，不是很好的淘汰页。</li><li>3类A&#x3D;1，M&#x3D;0：最近已被访问，但未被修改，可能再被访问。</li><li>4类A&#x3D;1，M&#x3D;1：最近已被访问且已被修改，可能再被访问。</li></ul></blockquote><ul><li><p><strong>第一轮</strong>：第一优先级——最近设访问，且没修改的页面</p><p>从当前位置开始扫描到第一个(0，0)的帧用于替换。本轮扫描不修改任何标志位</p></li><li><p><strong>第二轮</strong>：第二优先级——最近没访问，但修改过的页面</p><p>若第一轮扫描失败，则重新扫描，查找第一个（0，1）的帧用于替换。本轮将所有扫描过的帧访问位设为0</p></li><li><p><strong>第三轮</strong>：第三优先级——最近访问过，但没修改的页面</p><p>若第二轮扫描失败，则重新扫描，查找第一个（0，0）的帧用于替换。本轮扫描不修改任何标志位</p></li><li><p><strong>第四轮</strong>：第四优先级——最近访问过，且修改过的页面</p><p>若第三轮扫描失败，则重新扫描，查找第一个（0，1）的帧用于替换。</p></li></ul><p>由于第二轮己将所有帧的访问位设为0，因此经过第三轮、第四轮扫描定会有一个帧被选中，因此改进型CLOCK置换算法选择一个淘汰页面最多会进行四轮扫描。</p></li><li><p>性能：算法开销较小，性能也不错</p></li></ul></li></ol><h4 id="3-2-5-抖动和工作集"><a href="#3-2-5-抖动和工作集" class="headerlink" title="3.2.5 抖动和工作集"></a>3.2.5 抖动和工作集</h4><ol><li><p>抖动</p><ul><li>定义：抖动，又称颠簸，指在页面置换过程中，刚刚换出的页面马上又要换入主存，刚刚换入的页面马上又要换出主存。</li><li>抖动发生的原因：系统中同时运行的进程太多，由此分配给每个进程的物理块太少，不能满足进程正常运行的基本要求，致使每个进程在运行时频繁地出现缺页，必须请求系统将所缺页面调入内存。</li><li>抖动的危害：<ul><li>使得在系统中排队等待页面调入&#x2F;调出的进程数目增加。</li><li>对磁盘的有效访问时间也随之急剧增加，造成每个进程的大部分时间都用于页面的换入&#x2F;换出，而几乎不能再去做任何有效的工作，</li><li>进而导致发生处理机的利用率急剧下降并趋于零的情况。</li></ul></li></ul></li><li><p>工作集</p><p>由于抖动的发生与系统为进程分配物理块的多少有关，于是又提出了关于进程工作集的概念。</p><p>工作集是指在某段时间间隔内，进程要访问的页面集合。</p><p> 基于局部性原理，可以用最近访问过的页面来确定工作集。一般来说，工作集$W$可由时间$t$和工作集窗口大小$Δ$来确定。例如，某进程对页面的访问次序如下：</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230918174429395.png" alt="image-20230918174429395"></p><p> 假设系统为该进程设定的工作集窗口大小$Δ$为5，则在$t_1$时刻，进程的工作集为{2,3,5}，在$t_2$时刻，进程的工作集为{1,2,3,4}。</p><p> 工作集大小一般会比窗口小很多，工作集反映了进程在接下来的一段时间内很有可能会频繁访问的页面集合，因此，若分配给进程的物理块小于工作集大小，则该进程就很有可能频繁缺页。</p><p> 一般来说分配给进程的物理块数（即驻留集大小）要大于工作集大小。</p></li></ol><h4 id="3-2-6-内存映射文件"><a href="#3-2-6-内存映射文件" class="headerlink" title="3.2.6 内存映射文件"></a>3.2.6 内存映射文件</h4><p> 内存映射文件（Memory-MappedFiles）与虚拟内存有些相似，将磁盘文件的全部或部分内容与进程虚拟地址空间的某个区域建立映射关系，便可以直接访问被映射的文件，而不必执行文件 I&#x2F;O 操作，也无须对文件内容进行缓存处理。这种特性非常适合用来管理大尺寸文件。</p><ol><li><p>特性</p><ul><li>进程可使用系统调用，请求操作系统将文件映射到进程的虚拟地址空间</li><li>以访问内存的方式读写文件</li><li>进程关闭文件时，操作系统负责将文件数据写回磁盘，并解除内存映射</li><li>多个进程可以映射同一个文件，方便共享</li></ul><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230918175326496.png" alt="image-20230918175326496"></p></li><li><p>优点</p><ul><li>程序员编程更简单，已建立映射的文件，只需按访问内存的方式读写即可</li><li>文件数据的读入&#x2F;写出完全由操作系统负责，I\O效率可以由操作系统负责优化</li></ul></li></ol><h4 id="3-2-7-虚拟存储器性能影响因素"><a href="#3-2-7-虚拟存储器性能影响因素" class="headerlink" title="3.2.7 虚拟存储器性能影响因素"></a>3.2.7 虚拟存储器性能影响因素</h4><ol><li><p>页面大小</p><p>根据局部性原理，页面较大则缺页率较低，页面较小则缺页率较高。</p><ul><li>页面较小时，一方面减少了内存碎片，有利于提高内存利用率；另一方面，也会使每个进程要求较多的页面，导致页表过长，占用大量内存。</li><li>页面较大时，虽然可以减少页表长度，但会使页内碎片增大。</li></ul></li><li><p>分配给进程的物理块</p><p>分配给进程的物理块数越多，缺页率就越低，但是当物理块超过某个数目时，再为进程增加一个物理块对缺页率的改善是不明显的。</p></li><li><p>页面置换算法</p><p>好的页面置换算法可使进程在运行过程中具有较低的缺页率。</p><p>选择LRU、CLOCK等置换算法，将未来有可能访问的页面尽量保留在内存中，从而提高页面的访问速度。</p></li><li><p>写回磁盘的频率</p><p>换出已修改过的页面时，应当写回磁盘，如果每当一个页面被换出时就将它写回磁盘，那么每换出一个页面就需要启动一次磁盘，效率极低。</p><p>建立一个已修改换出页面的链表，对每个要被换出的页面（已修改），可以暂不将它们写回磁盘，而将它们挂在该链表上，仅当被换出页面数达到给定值时，才将其写回磁盘。</p></li><li><p>局部化程度</p><p>编写程序的局部化程度越高，执行时的缺页率就越低。如果存储采用的是按行存储，访问时就要尽量采用相同的访问方式，避免按列访问造成缺页率过高的现象。</p></li></ol><h4 id="3-2-8-地址翻译"><a href="#3-2-8-地址翻译" class="headerlink" title="3.2.8 地址翻译"></a>3.2.8 地址翻译</h4><p>设某系统满足以下条件：</p><ul><li>有一个TLB与一个data Cache</li><li>存储器以字节为编址单位</li><li>虚拟地址14位</li><li>物理地址12位</li><li>页面大小为64B</li><li>TLB为四路组相联，共有16个条目</li><li>data Cache是物理寻址、直接映射的，行大小为4B，共有16组</li></ul><p>写出访问地址为0x03d4, 0x00f1和0x0229的过程。</p><ol><li><p><strong>写出其地址结构</strong></p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230919094611325.png" alt="image-20230919094611325"></p><ul><li><p><strong>根据页面大小求页内偏移量与页号长度</strong></p><p>本系统以字节编址，页面大小为64B，则页内偏移量为$log_2(64B&#x2F;1B)&#x3D;6位$，所以虚拟页号为$14-6&#x3D;8位$，物理页号为$12-6&#x3D;6位$。</p></li><li><p><strong>根据TLB结构求虚拟页号地址结构</strong></p><p>因为TLB为四路组相联，共有16个条目，则TLB有16&#x2F;4&#x3D;4组，因此虚拟页号低$log_24&#x3D;2位$就为组索引，高6位为TLB标记。</p></li><li><p><strong>根据Cache机构求物理页号地址结构</strong></p><p>因为Cache行大小为4B，因此物理地址中低$log_24&#x3D;2位$为块索引，Cache共有16组，可知接下来$log_216&#x3D;4位$为组索引，剩下高6位作为标记。</p></li></ul></li><li><p><strong>根据TLB、页表寻找物理页号</strong></p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230919094851074.png" alt="image-20230919094851074"></p><p>先把十六进制的虚拟地址0x03d4, 0x00f1和0x0229转化为二进制形式，如下表所示。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230919095151415.png" alt="image-20230919095151415"></p><p>得到每个地址的组索引和TLB标记，接下来就要找出每个地址的页面在不在主存中，若在主存中，则还要找出物理地址。</p><ul><li>查TLB得到物理块号<ul><li>对于0x03d4，组索引为3，TLB标记为0x03。</li><li>查TLB表，第3组中有标记为03的项，且有效位为1，找到物理块0D。</li><li>拼接页内地址（010100），得到物理地址为0x354。</li></ul></li><li>查TLB未得到物理块号，查页表得到物理块号<ul><li>对于0x00f1，组索引为3，TLB标记为0x00。</li><li>查TLB表，第3组未找到有标记为00的项。</li><li>访存查页表，根据虚拟页号0x03，找到物理块号02，且有有效位为1。</li><li>拼接页内地址（110001），得到物理地址为0x0b1。</li></ul></li><li>查TLB未得到物理块号，查页表也未得到物理块号<ul><li>对于0x0229，组索引为0，TLB标记为0x02。</li><li>查TLB表，第0组未找到有标记为02的项。</li><li>访存查页表，根据虚拟页号0x08，页表08项有效位为0，页面不在主存中，产生缺页中断。</li></ul></li></ul></li><li><p>根据Cache寻找内存地址</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230919094903450.png" alt="image-20230919094903450"></p><p> 找出在主存中的页面的物理地址后，就要通过物理地址访问数据，接下来要找该物理地址的 内容在不在Cache中，物理地址结构如下表所示。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230919101554108.png" alt="image-20230919101554108"></p><ul><li>Cache块命中<ul><li>对于0x354，Cache索引为5，Cache标记为0x0d。</li><li>查询Cache索引为5的行，标记为0d，有效位为1，则该块在Cache中。</li><li>偏移为0，即块0，可得虚拟地址0x03d4的内容为36H。</li></ul></li><li>Cache块未命中<ul><li>对于0x0b1，Cache索引为C，Cache标记为0x02。</li><li>查询Cache索引为C的行，标记为02，有效位为0，则该块不在Cache中。</li><li>需去访问主存查找，物理页号为2、偏移为0x31的内容。</li></ul></li></ul></li><li><p>虚拟地址寻址总流程</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/b0b9bc36ae3ba18efd06a04216caa7f.jpg" alt="b0b9bc36ae3ba18efd06a04216caa7f"></p></li></ol><h2 id="4-文件管理"><a href="#4-文件管理" class="headerlink" title="4 文件管理"></a>4 文件管理</h2><h3 id="4-1-文件系统基础"><a href="#4-1-文件系统基础" class="headerlink" title="4.1 文件系统基础"></a>4.1 文件系统基础</h3><h4 id="4-1-1-文件的基本概念"><a href="#4-1-1-文件的基本概念" class="headerlink" title="4.1.1 文件的基本概念"></a>4.1.1 文件的基本概念</h4><ol><li><p>定义</p><p>文件是以计算机硬盘为载体的存储在计算机上的信息集合，在用户进行的输入、输出中，以文件位基本单位。</p><p>文件管理系统是实现的文件的访问、修改和保存，对文件维护管理的系统。</p></li><li><p>文件的组成</p><ul><li>存储空间：用于存储数据</li><li>标签：便于对数据的分类和索引</li><li>访问权限：不同用户对数据有不同的访问权限</li></ul></li><li><p>文件的结构</p><ul><li><p>数据项</p><p>：是文件系统中最低级的数据组织形式，可分为以下两种类型：</p><ul><li>基本数据项：用于描述一个对象的某种属性的一个值，是数据中的最小逻辑单位。</li><li>组合数据项：由多个基本数据项组成。</li></ul></li><li><p><strong>记录</strong>：是一组相关的数据项的集合，用于描述一个对象在某方面的属性。</p></li><li><p>文件</p><p>：是指由创建者所定义的、具有文件名的一组相关元素的集合，分为有结构文件和无结构文件两种。</p><ul><li>在有结构的文件中，文件由若干个相似的记录组成，如一个班的学生记录；</li><li>无结构文件则被视为一个字符流，比如一个二进制文件或字符文件。</li></ul></li></ul></li></ol><h4 id="4-1-2-文件控制块和索引结点"><a href="#4-1-2-文件控制块和索引结点" class="headerlink" title="4.1.2 文件控制块和索引结点"></a>4.1.2 文件控制块和索引结点</h4><ol><li><p>文件的属性</p><ul><li>文件名：由创建文件的用户决定文件名，主要是为了方便用户找到文件，同一目录下不允许有重名文件</li><li>标识符：一个系统内的各文件标识符唯一，对用户来说毫无可读性，因此标识符只是操作系统用于区分各个文件的一种内部名称。</li><li>类型：指明文件的类型</li><li>位置：文件存放的路径（让用户使用）、在外存中的地址（操作系统使用，对用户不可见）</li><li>大小：指明文件大小</li><li>保护信息：对文件进行保护的访问控制信息</li><li>创建时间、最后一次修改时间和最后一次存取时间：文件创建、上次修改和上次访问的相关信息，用于保护和跟踪文件的使用。</li></ul></li><li><p>文件控制块FCB</p><p>文件控制块（FCB）是用来存放控制文件需要的各种信息的数据结构，以实现“按名存取”。</p><p>操作系统通过文件控制块（FCB）来维护文件元数据。FCB的有序集合称为文件目录，一个FCB就是一个文件目录项。下图为一个典型的FCB。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230919110034223.png" alt="image-20230919110034223"></p><p>FCB包含以下信息：</p><ul><li><strong>基本信息</strong>：如文件名、文件的物理位置、文件的逻辑结构、文件的物理结构等。</li><li><strong>存取控制信息</strong>：包括文件主的存取权限、核准用户的存取权限以及一般用户的存取权限。</li><li><strong>使用信息</strong>：如文件建立时间、上次修改时间等。</li></ul><blockquote><p>一个文件目录也被视为一个文件，称为目录文件。</p></blockquote></li><li><p>索引结点</p><p> 在检索目录时，只用到了文件名，因此有的系统采用文件名与文件描述分开的方法，使文件描述信息单独形成一个称为索引结点的数据结构，简称 i 结点（inode)。</p><p> 在文件目录中的每个目录项仅由文件名和指向该文件所对应的i结点的指针构成。</p><blockquote><p>假设一个FCB为64B，盘块大小是1KB，则每个盘块中可以存放16个FCB（FCB必须连续存放），若一个文件目录共有640个FCB，则查找文件平均需要启动磁盘20次。</p><p>而在UNIX系统中，一个目录项仅占16B，其中14B是文件名，2B是 i 结点指针。在1KB的盘块中可存放64个目录项。这样，可使查找文件的平均启动磁盘次数减少到原来的1&#x2F;4，大大节省了系统开销。</p></blockquote><ul><li><p>磁盘索引结点</p><p>它是指存放在磁盘上的索引结点。每个文件有一个唯一的磁盘索引结点，主要包括以下内容：</p><ul><li><strong>文件主标识符</strong>，拥有该文件的个人或小组的标识符。</li><li><strong>文件类型</strong>，包括普通文件、目录文件或特别文件。</li><li><strong>文件存取权限</strong>，各类用户对该文件的存取权限。</li><li><strong>文件物理地址</strong>，每个索引结点中含有13个地址项，即iaddr(0)～iaddr(12)，它们以直接或间接方式给出数据文件所在盘块的编号。</li><li><strong>文件长度</strong>，指以字节为单位的文件长度。</li><li><strong>文件链接计教</strong>，在本文件系统中所有指向该文件的文件名的指针计数。</li><li><strong>文件存取时间</strong>，本文件最近被进程存取的时间、最近被修改的时间及索引结点最近被修改的时间。</li></ul></li><li><p>内存索引结点</p><p>它是指存放在内存中的索引结点。当文件被打开时，要将磁盘索引结点复制到内存的索引结点中，便于以后使用。在内存索引结点中增加了以下内容：</p><ul><li><strong>索引结点编号</strong>，用于标识内存索引结点。</li><li><strong>状态</strong>，指示 i 结点是否上锁或被修改。</li><li><strong>访问计数</strong>，每当有一进程要访问此 i 结点时，计数加1；访问结束减1。</li><li><strong>逻辑设备号</strong>，文件所属文件系统的逻辑设备号。</li><li><strong>链接指针</strong>，设置分别指向空闲链表和散列队列的指针。</li></ul></li></ul></li></ol><h4 id="4-1-3-文件的操作"><a href="#4-1-3-文件的操作" class="headerlink" title="4.1.3 文件的操作"></a>4.1.3 文件的操作</h4><ol><li><p>文件的基本操作</p><p> 文件属于抽象数据类型。为了正确地定义文件，需要考虑可以对文件执行的操作。操作系统提供系统调用，它对文件进行创建、写、读、重定位、删除和截断等操作。</p><ul><li><p><strong>创建文件（create系统调用）</strong></p><ul><li>为新文件分配必要的外存空间；</li><li>在目录 中为之创建一个目录项，目录项记录了新文件名、在外存中的地址及其他可能的信息。</li></ul></li><li><p><strong>删除文件（delete系统调用）</strong></p><ul><li>先从目录中检索指定文件名的目录项</li><li>然后释放该文件所占的存储空间，以便可被其他文件重复使用，并删除目录条目。</li></ul></li><li><p><strong>读文件（read系统调用）</strong></p><ul><li>对于给定文件名，搜索目录以查找文件位置。</li><li>系统维护一个读位置的指针。</li><li>每当发生读操作时，更新读指针。</li></ul></li><li><p><strong>写文件（write系统调用）</strong></p><ul><li>对于给定文件名，搜索目录以查找文件位置。</li><li>系统必须为该文件维护一个写位置的指针。</li><li>每当发生写操作时，便更新写指针。</li></ul><blockquote><p>一个进程通常只对一个文件读或写，因此当前操作位置可作为每个进程当前文件位置的指针。</p><p>由于读和写操作都使用同一指针，因此节省了空间，也降低了系统复杂度。</p></blockquote></li><li><p><strong>重新定位文件</strong></p><p>也称文件定位。搜索目录以找到适当的条目，并将当前文件位置指针重新定位到给定值。</p><p>重新定位文件不涉及读、写文件。</p></li><li><p><strong>截断文件</strong></p><p>允许文件所有属性不变，并删除文件内容，将其长度置为0并释放其空间。</p></li></ul><p>这6个基本操作可以组合起来执行其他文件操作。例如，一个文件的复制，可以创建新文件、从旧文件读出并写入新文件。</p></li><li><p>文件的打开与关闭</p><ul><li><p><strong>打开文件（open系统调用）</strong></p><ul><li>过程：调用open根据文件名搜索目录，将指明文件的属性（包括该文件在外存上的物理位置)，从外存复制到内存打开文件表的一个表目中，并将该表目的编号（也称索引）返回给用户。</li></ul><blockquote><p>打开文件时并不会把文件数据直接读入内存。“索引号”也称“文件描述符”。</p></blockquote><p>打开文件之后，对文件的操作不再需要每次都查询目录，可以根据内存中的打开文件表进行操作。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230919114840253.png" alt="image-20230919114840253"></p><p>如上图所示，在多个不同进程同时打开文件的操作系统中，通常采用两级表：整个系统表和每个进程表。</p><ul><li>整个系统的打开文件表包含FCB的副本及其他信息。</li><li>每个进程的打开文件表根据它打开的所有文件，包含指向系统表中适当条目的指针。</li></ul><p>一旦有进程打开了一个文件，系统表就包含该文件的条目。当另一个进程执行调用open时，只不过是在其文件打开表中增加一个条目，并指向系统表的相应条目。</p></li><li><p><strong>关闭文件（close系统调用）</strong></p><ul><li>1.将进程的打开文件表相应表项删除</li><li>2.回收分配给该文件的内存空间等资源</li><li>3.系统打开文件表的打开计数器count减1，若count&#x3D;0，则删除对应表项。</li></ul></li></ul><p>系统打开文件表为每个文件关联一个打开计数器（OpenCount)，以记录多少进程打开了该文件。</p><blockquote><p>文件名不必是打开文件表的一部分，因为一且完成对FCB在磁盘上的定位，系统就不再使用文件名。对于访问打开文件表的索引，UNIX称之为文件描述符，而Windows称之为文件句柄。<br>因此，只要文件未被关闭，所有文件操作就通过打开文件表来进行。</p></blockquote><ul><li>打开文件信息<ul><li><strong>文件指针</strong>。系统跟踪上次的读写位置作为当前文件位置的指针，这种指针对打开文件的某个进程来说是唯一的，因此必须与磁盘文件属性分开保存。</li><li><strong>文件打开计数</strong>。计数器跟踪当前文件打开和关闭的数量。因为多个进程可能打开同一个文件，所以系统在删除打开文件条目之前，必须等待最后一个进程关闭文件。</li><li><strong>文件磁盘位置</strong>。大多数文件操作要求系统修改文件数据。查找磁盘上的文件所需的信息保存在内存中，以便系统不必为每个操作都从磁盘上读取该信息。</li><li><strong>访问权限</strong>。每个进程打开文件都需要有一个访问模式（创建、只读、读写、添加等）。该信息保存在进程的打开文件表中，以便操作系统能够允许或拒绝后续的I&#x2F;O请求。</li></ul></li></ul></li></ol><h4 id="4-1-4-文件保护"><a href="#4-1-4-文件保护" class="headerlink" title="4.1.4 文件保护"></a>4.1.4 文件保护</h4><p> 文件保护通过口令保护、加密保护和访问控制等方式实现。其中，口令和加密是为了防止用户文件被他人存取或窃取，而访问控制则用于控制用户对文件的访问方式。</p><ol><li><p>口令保护</p><p>为文件设置一个“口令”，用户想要访问文件时需要提供口令，由系统验证口令是否正确。</p><p>实现开销小，但“口令”一般存放在FCB或索引结点中（也就是存放在系统中）因此不太安全</p></li><li><p>加密保护</p><p>用一个“密码“对文件加密，用户想要访问文件时，需要提供相同的“密码“才能正确的解密</p><p>安全性高，但加密解密需要耗费一定的时间（Eg：异或加密）</p></li><li><p>访问控制</p><ul><li><p>访问类型</p><p>对文件的保护可从限制对文件的访问类型中出发。可加以控制的访问类型主要有以下几种。</p><ul><li>读。从文件中读。</li><li>写。向文件中写。</li><li>执行。将文件装入内存并执行。</li><li>添加。将新信息添加到文件结尾部分。</li><li>删除。删除文件，释放空间。</li><li>列表清单。列出文件名和文件属性。</li></ul><p>此外还可以对文件的重命名、复制、编辑等加以控制。这些高层的功能可以通过系统程序调用低层系统调用来实现。保护可以只在低层提供。</p></li><li><p>访问控制</p><p> 解决访问控制最常用的方法是根据用户身份进行控制。而实现基于身份访问的最为普通的方法是，为每个文件和目录增加一个访问控制列表（Access-Control List，ACL），以规定每个用户名及其所允许的访问类型。</p><ul><li>优点：可以使用复杂的访问方法，</li><li>缺点：长度无法预计并且可能导致复杂的空间管理，</li></ul><p>使用精简的访问列表可以解决这个问题，精简的访问列表采用拥有者、组和其他三种用户类型。</p><ul><li>拥有者。创建文件的用户。</li><li>组。一组需要共享文件且具有类似访问的用户。</li><li>其他。系统内的所有其他用户。</li></ul><p>文件主在创建文件时，说明创建者用户名及所在的组名，系统在创建文件时也将文件主的名字、所属组名列在该文件的FCB中。用户访问该文件时，</p><ul><li>若用户是文件主，按照文件主所拥有的权限访问文件；</li><li>若用户和文件主在同一个用户组，则按照同组权限访问，</li><li>否则只能按其他用户权限访问。</li></ul></li></ul></li></ol><h4 id="4-1-5-文件的逻辑结构"><a href="#4-1-5-文件的逻辑结构" class="headerlink" title="4.1.5 文件的逻辑结构"></a>4.1.5 文件的逻辑结构</h4><p> 文件的逻辑结构是从用户观点出发看到的文件的组织形式。文件的物理结构（存储结构）是从实现观点出发看到的文件在外存上的存储组织形式。</p><p> 文件的逻辑结构与存储介质特性无关，它实际上是指在文件的内部，数据逻辑上是如何组织起来的。</p><ol><li><p>无结构文件（流式文件）</p><p>无结构文件将数据按顺序组织成记录并积累、保存，它是有序相关信息项的集合，以字节（Byte）为单位。</p><ul><li>只能通过穷举搜索的方式访问记录。</li><li>其管理简单，用户操作方便。</li><li>对基本信息单位操作不多的文件适于采用字符流的无结构文件。例如源程序文件、目标代码文件等。</li></ul></li><li><p>有结构文件（记录式文件）</p><ul><li><p>顺序文件</p><p>文件中的记录一个接一个地顺序排列（逻辑上），记录可以是定长的或可变长的。</p><p>各个记录在物理上可以顺序存储或链式存储。</p><ul><li><p>链式存储：无论是定长何变长记录，都无法实现随机存取，每次只能从第一个记录开始依次往后查找</p></li><li><p>顺序存储：</p><p>可实现随机存取，记录长度为L，则第ⅰ个记录存放的相对位置是i*L</p><p>若采用串结构，记录之间的顺序与关键字无关，无法快速找到某关键字对应的记录</p><p>若采用顺序结构，可以快速找到某关键字对应的记录（如折半查找）</p></li></ul><blockquote><p>定长记录的顺序文件，若物理上采用顺序存储，则可实现随机存取：若能再保证记录的顺序结构，则可实现快速检索（即根据关键字快速找到对应记录）</p></blockquote><p>优点：读写一大批文件时，效率最高。适用于顺序存储设备（磁带）</p><p>缺点：不方便增加、删除记录</p></li><li><p>索引文件</p><ul><li><p>索引表：高效查询变长记录文件。索引表本身是定长记录的顺序文件，因此可以快速找到第ⅰ个记录对应的索引项。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230920095845915.png" alt="image-20230920095845915"></p></li><li><p>方式：可将关键字作为索引号内容，若按关键字顺序排列，则还可以支持按照关键字折半查找</p><p>每当要增加&#x2F;删除一个记录时，需要对索引表进行修改。由于索引文件有很快的检索速度，因此主要用于对信息处理的及时性要求比较高的场合。</p></li></ul></li><li><p>索引顺序文件</p><p>索引顺序文件是索引文件和顺序文件思想的结合。索引顺序文件中，同样会为文件建立一张索引表，但不同的是：并不是每个记录对应一个索引表项，而是一组记录对应一个索引表项。</p><ul><li>将记录分组，每组对应一个素引表项</li><li>检素记录时先顺序查索引表，找到分组，再顺序查找分组</li><li>当记录过多时，可建立多级素引表</li></ul><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230920100345089.png" alt="image-20230920100345089"></p><p>如上图所示，主文件名包含姓名和其他数据项。</p><ul><li>姓名为关键字，索引表中为每组的第一条记录（不是每条记录）的关键字值，用指针指向主文件中该记录的起始位置。</li><li>索引表只包含关键字和指针两个数据项，所有姓名关键字递增排列。</li><li>主文件中记录分组排列，同一个组中的关键字可以无序，但组与组之间的关键字必须有序。</li><li>查找一条记录时，首先通过索引表找到其所在的组，然后在该组中使用顺序查找，就能很快地找到记录。</li></ul></li><li><p>直接文件或散列文件（Hash File）</p><p> 给定记录的键值或通过散列函数转换的键值直接决定记录的物理地址。这种映射结构不同于顺序文件或索引文件，没有顺序的特性。</p><p> 散列文件有很高的存取速度，但是会引起冲突，即不同关键字的散列函数值相同。</p></li></ul></li></ol><h4 id="4-1-6-文件的物理结构"><a href="#4-1-6-文件的物理结构" class="headerlink" title="4.1.6 文件的物理结构"></a>4.1.6 文件的物理结构</h4><p> 文件的物理结构就是研究文件的实现，即文件数据在物理存储设备上是如何分布和组织的。</p><p> 文件分配对应于文件的物理结构，是指如何为文件分配磁盘块。常用的磁盘空间分配方法有三种：连续分配、链接分配和索引分配。</p><ol><li><p>连续分配</p><p>连续分配方法要求每个文件在磁盘上占有一组连续的块。磁盘地址定义了磁盘上的一个线性排序，这种排序使作业访问磁盘时需要的寻道数和寻道时间最小。</p><ul><li>物理块号&#x3D;起始块号+逻辑块号</li><li>优点：支持顺序访问和直接访问（即随机访问）；连续分配的文件在顺序访问时速度最快。</li><li>缺点：不方便文件拓展、存储空间利用率低、会产生磁盘碎片（外部碎片）。<ul><li>①文件长度不宜动态增加，因为一个文件末尾后的盘块可能已分配给其他文件，一旦需要增加，就需要大量移动盘块。</li><li>②为保持文件的有序性，删除和插入记录时，需要对相邻的记录做物理上的移动，还会动态改变文件的长度。</li><li>③反复增删文件后会产生外部碎片（与内存管理分配方式中的碎片相似）。</li><li>④很难确定一个文件需要的空间大小，因而只适用于长度固定的文件。</li></ul></li><li>访存次数：访问第n条记录需访问磁盘1次</li></ul></li><li><p>链接分配</p><p>链接分配采取离散分配的方式，可以为文件分配离散的磁盘块。分为隐式链接和显式链接两种。</p><p>访问第n条记录需访问磁盘n次</p><ul><li><p>隐式链接</p><p>除文件的最后一个盘块之外，每个盘块中都存有指向下一个盘块的指针。文件目录包括文件第一块的指针和最后一块的指针。</p><ul><li>优点：很方便文件拓展，不会有碎片问题，外存利用率高。</li><li>缺点：只支持顺序访问，不支持随机访问，查找效率低，指向下一个盘块的指针也需要耗费少量的存储空间。</li><li>结论：采用隐式链接的链接分配方式，很方便文件拓展。另外，所有的空闲磁盘块都可以被利用，不会有碎片问题，外存利用率高</li></ul></li><li><p>显式链接</p><p>把用于链接文件各物理块的指针显式地存放在文件分配表（FAT）中。一个磁盘只会建立一张文件分配表。开机时文件分配表放入内存，并常驻内存。</p><ul><li>优点：很方便文件拓展，不会有碎片问题，外存利用率高，并且支持随机访问。相比于隐式链接来说，地址转换时不需要访问磁盘，因此文件的访问效率更高。</li><li>缺点：文件分配表的需要占用一定的存储空间。</li><li>结论：采用链式分配（显式链接）方式的文件，支持顺序访问，也支持随机访问（想访问ⅰ号逻辑块时，并不需要依次访问之前的0~ｉ-1号逻辑块），由于块号转换的过程不需要访问磁盘，因此相比于隐式链接来说，访问速度快很多。</li></ul></li><li><p><strong>文件分配表</strong>：FAT不仅记录了文件分配信息（显示链接），还“兼职”做了空闲块管理</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230920103528057.png" alt="image-20230920103528057"></p></li></ul></li><li><p>索引分配</p><p> 索引分配允许文件离散地分配在各个磁盘块中，系统会为每个文件建立一张索引表，索引表中记录了文件的各个逻辑块对应的物理块。索引表存放的磁盘块称为索引块。文件数据存放的磁盘块称为数据块。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/0a98951136ab4d348376f0bfdb20fd61.png" alt="img"></p><blockquote><p>索引表的 逻辑块号 可以是隐含的，进一步节约空间；</p></blockquote><ul><li><p>链接方案</p><p>如果索引表太大，一个索引块装不下，那么可以将多个索引块链接起来存放。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/976b1da9f7334755956429610f98eb56.png" alt="img"></p><p>缺点：需要顺序访问，当文件很大时，查我效率低下</p></li><li><p>多层索引</p><p>建立多层索引（原理类似于多级页表）。使第一层索引块指向第二层的索引块。还可根据文件大小的要求再建立第三层、第四层索引块。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/f241b98d0efd44f781d5b6bab1274f48.png" alt="img"></p><p>采用K层索引结构，且顶级索引表未调入内存，则访问一个数据块只需要K+1次读磁盘操作</p><p>缺点：即使是小文件，访问数据块也需受K+1次读磁盘</p></li><li><p>混合索引</p><p>多种索引分配方式的结合。例如，一个文件的顶级索引表中，既包含直接地址索引（直接指向数据块），又包含一级间接索引（指向单层索引表）、还包含两级间接索引（指向两层索引表）。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/3c0e2e9e2293438a8f04ccf0557fa50e.png" alt="img"></p><p>所允许的文件最大长度：设有N0个直接地址项；N1个一次间接地址项；N2个二次间接地址项；每个盘块大小M字节；盘块号占m个字节，公式如下：<br>$$<br>文件最大长度&#x3D;(N_0 + N_1·\frac{M}{m}+N_2·(\frac{M}{m})^2)·M<br>$$<br>优点：对于小文件，只需较少的读磁盘次数就可以访问目标数据块。（一般计算机中小文件更多）</p></li><li><p>总结</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/e4cbd52e0f934cf296bd2ace1d87ac5b.png" alt="img"></p></li></ul></li></ol><h3 id="4-2-目录"><a href="#4-2-目录" class="headerlink" title="4.2 目录"></a>4.2 目录</h3><h4 id="4-2-1-目录的基本概念"><a href="#4-2-1-目录的基本概念" class="headerlink" title="4.2.1 目录的基本概念"></a>4.2.1 目录的基本概念</h4><p> 文件目录指FCB的有序集合，一个FCB就是一个文件的目录项。与文件管理系统和文件集合相关联的是文件目录，它包含有关文件的属性、位置和所有权等。</p><ul><li>目录管理的基本要求：<ul><li>从用户的角度看，目录在用户（应用程序）所需要的文件名和文件之间提供一种映射，所以目录管理要实现“按名存取”；</li><li>目录存取的效率直接影响到系统的性能，所以要提高对目录的检索速度；</li><li>在多用户系统中，应允许多个用户共享一个文件，因此目录还需要提供用于控制访问文件的信息。</li><li>此外，应允许不同用户对不同文件采用相同的名字，以便于用户按自己的习惯给文件命名，目录管理通过树形结构来解决和实现。</li></ul></li></ul><h4 id="4-2-2-目录结构"><a href="#4-2-2-目录结构" class="headerlink" title="4.2.2 目录结构"></a>4.2.2 目录结构</h4><ol><li><p>单级目录结构</p><p>在整个文件系统中只建立一张目录表，每个文件占一个目录项，不允许文件重名，如下图所示。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230920114101960.png" alt="image-20230920114101960"></p><p>当访问一个文件时，先按文件名在该目录中查找到相应的FCB，经合法性检查后执行相应的操作。</p><p>当建立一个新文件时，必须先检索所有目录项，以确保没有“重名”的情况，然后在该目录中增设一项，把新文件的属性信息填入到该项中。</p></li><li><p>两级目录结构</p><p> 将文件目录分成主文件目录（MFD）和用户文件目录（UFD）两级，不同用户的文件可以重名，但不能对文件分类。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230920114603663.png" alt="image-20230920114603663"></p><p>主文件目录项记录用户名及相应用户文件目录所在的存储位置。</p><p>用户文件目录项记录该用户文件的FCB信息。</p></li><li><p>树形目录结构</p><p>不同目录下的文件可以重名，可以对文件进行分类，不方便共享。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230920114906657.png" alt="image-20230920114906657"></p><p>根据“文件路径”找到目标文件。用户（或用户进程）要访问某个文件时要用文件路径名标识文件，文件路径名是个字符串。各级日录之间用“&#x2F;”隔开。从根目录出发的路径称为绝对路径。</p><blockquote><p>例如：自拍.jpg的绝对路径是“&#x2F;照片&#x2F;2015-08&#x2F;自拍jpg”</p><p>系统根据绝对路径一层一层地找到下一级目录。刚开始从外存读入根目录的目录表；找到“照片”目录的存放位置后，从外存读入对应的目录表；再找到“2015-08”目录的存放位置，再从外存读入对应目录表；最后才找到文件“自拍Jpg”的存放位置。整个过程需要3次读磁盘I&#x2F;O操作。</p></blockquote><p>引入“当前目录”和“相对路径”后，磁盘I&#x2F;O的次数减少了。这就提升了访问文件的效率。</p><p>从根目录出发是绝对路径；从当前目录出发是相对路径。</p></li><li><p>无环图目录结构</p><p>在树形目录的基础上，增加一些指向同一结点的有向边，使整个目录成为一个有向无环图，实现文件的共享。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230920134102332.png" alt="image-20230920134102332"></p><p>为共享结点设置一个共享计数器，计数器为0时才真正删除该结点。</p><p>对于共享文件，只存在一个真正的文件，任何改变都会为其他用户所见。</p></li></ol><h4 id="4-2-3-目录的操作"><a href="#4-2-3-目录的操作" class="headerlink" title="4.2.3 目录的操作"></a>4.2.3 目录的操作</h4><ul><li><strong>搜索</strong>。当用户使用一个文件时，需要搜索目录，以找到该文件的对应目录项。</li><li><strong>创建文件</strong>。当创建一个新文件时，需要在目录中增加一个目录项。</li><li><strong>删除文件</strong>。当删除一个文件时，需要在目录中删除相应的目录项。</li><li><strong>创建目录</strong>。在树形目录结构中，用户可创建自己的用户文件目录，并可再创建子目录。</li><li><strong>删除目录</strong>。有两种方式：①不删除非空目录，删除时要先删除目录中的所有文件，并递归地删除子目录。②可删除非空目录，目录中的文件和子目录同时被删除。</li><li><strong>移动目录</strong>。将文件或子目录在不同的父目录之间移动，文件的路径名也会随之改变。</li><li><strong>显示目录</strong>。用户可以请求显示目录的内容，如显示该用户目录中的所有文件及属性。</li><li><strong>修改目录</strong>。某些文件属性保存在目录中，因而这些属性的变化需要改变相应的目录项。</li></ul><h4 id="4-2-4-目录实现"><a href="#4-2-4-目录实现" class="headerlink" title="4.2.4 目录实现"></a>4.2.4 目录实现</h4><p> 目录实现有线性列表和哈希表两种方式，线性列表实现对应线性查找，哈希表的实现对应散列查找。</p><ol><li><p>线性列表</p><p>最简单的目录实现方法是，采用文件名和数据块指针的线性列表。</p><ul><li><p>当创建新文件时，必须首先搜索目录以确定没有同名的文件存在，然后在目录中增加一个新的目录项。</p></li><li><p>当删除文件时，则根据给定的文件名搜索目录，然后释放分配给它的空间。</p></li><li><p>当要</p><p>重用目录项</p><p>时有许多种方法：</p><ul><li>可以将目录项标记为不再使用，或将它加到空闲目录项的列表上，</li><li>还可以将目录的最后一个目录项复制到空闲位置，并减少目录的长度。</li></ul></li></ul><p>采用链表结构可以减少删除文件的时间。</p><p>线性列表的优点在于实现简单，不过由于线性表的特殊性，查我比较费时。</p></li><li><p>哈希表</p><p>哈希表根据文件名得到一个值，并返回一个指向线性列表中元素的指针。</p><ul><li>优点：查找非常迅速，插入和删除也较简单，</li><li>问题：需要一些措施来避免冲突（两个文件名称哈希到同一位置）。</li></ul></li></ol><p> 为了减少I&#x2F;O操作，把当前使用的文件目录复制到内存，以后要使用该文件时只需在内存中操作，因此降低了磁盘操作次数，提高了系统速度。</p><h4 id="4-2-5-文件共享"><a href="#4-2-5-文件共享" class="headerlink" title="4.2.5 文件共享"></a>4.2.5 文件共享</h4><p> 文件共享使多个用户共享同一个文件，系统中只需保留该文件的一个副本。</p><ol><li><p>基于索引结点的共享方式（硬链接）</p><p>各个用户的目录项指向同一个索引结点，索引结点中需要链接计数count，用于表示链接到本索引结点上的用户目录项数。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230920140425794.png" alt="image-20230920140425794"></p><p>某用户删除文件只是删除该用户的目录项，count–</p><p>只有count&#x3D;&#x3D;0才能真正删除文件数据和索引结点。</p></li><li><p>利用符号链实现文件共享（软链接）</p><p>为使用户B能共享用户A的一个文件F,可以由系统创建一个LINK类型的新文件，也取名为F，并将该文件写入用户B的目录中，以实现用户B的目录与文件F的链接。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230920140838755.png" alt="image-20230920140838755"></p><p>在一个Link型的文件中记录共享文件的存放路径（Windows快捷方式），操作系统根据路径一层层查找目录，最终找到共享文件。</p><blockquote><p>当User3访问“ccc”时，操作系统判断文件“ccc”属于Link类型文件，于是会根据其中记录的路径层层查找目录，最终找到User1的目录表中的“aaa”表项，于是就找到了文件1的索引结点。</p></blockquote><p>即使软链接指向的共享文件已被删除，Link型文件依然存在，只是通过Link型文件中的路径去查找共享文件会失败（找不到对应目录项）。</p><p>由于用软链接的方式访问共享文件时要查询多级目录，会有多次磁盘I&#x2F;O，因此用软链接访问的速度要比硬链接更慢。</p></li></ol><p> 硬链接和软链接都是文件系统中的静态共享方法，在文件系统中还存在着另外的共享需求，即两个进程同时对同一个文件进行操作，这样的共享称为动态共享。</p><h3 id="4-3-文件系统"><a href="#4-3-文件系统" class="headerlink" title="4.3 文件系统"></a>4.3 文件系统</h3><h4 id="4-3-1-文件系统结构"><a href="#4-3-1-文件系统结构" class="headerlink" title="4.3.1 文件系统结构"></a>4.3.1 文件系统结构</h4><p> 文件系统(File system)提供高效和便捷的磁盘访问，以便允许存储、定位、提取数据。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/81e5fc0bafd94c1780f0e4302f4bfc50.png" alt="img"></p><p>用一个例子来辅助记忆文件系统的层次结构：<br>假设某用户请求删除文件”D:&#x2F;工作目录&#x2F;学生信息.xIsx”的最后100条记录。</p><ol><li>用户需要通过操作系统提供的接口发出上述请求一一用户接口</li><li>由于用户提供的是文件的存放路径，因此需要操作系统一层一层地查找目录，找到对应的目录项一一文件目录系统</li><li>不同的用户对文件有不同的操作权限，因此为了保证安全，需要检查用户是否有访问权限一一存取控制模块（存取控制验证层）</li><li>验证了用户的访问权限之后，需要把用户提供的“记录号”转变为对应的逻辑地址一一逻辑文件系统与文件信息缓冲区</li><li>知道了标记录对应的逻辑地址后，还需要转换成实际的物理地址一一物理文件系统</li><li>要删除这条记录，必定要对磁盘设备发出请求一一设备管理程序模块</li><li>删除这些记录后，会有一些盘块空闲，因此要将这些空闲盘块回收一一辅助分配模块</li></ol><h4 id="4-3-2-文件系统布局"><a href="#4-3-2-文件系统布局" class="headerlink" title="4.3.2 文件系统布局"></a>4.3.2 文件系统布局</h4><ol><li><p>文件系统在磁盘中的结构</p><p> 文件系统存放在磁盘上，多数磁盘划分为一个或多个分区，每个分区中有一个独立的文件系统。文件系统可能包括如下信息：启动存储在那里的操作系统的方式、总的块数、空闲块的数量和位置、目录结构以及各个具体文件等。如下图所示。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230920143351257.png" alt="image-20230920143351257"></p><ul><li><p>**主引导记录（MasterBootRecord，MBR)**，位于磁盘的0号扇区，用来引导计算机，MBR后面是分区表，该表给出每个分区的起始和结束地址。表中的一个分区被标记为活动分区，当计算机启动时，BIOS读入并执行MBR。MBR做的第一件事是确定活动分区，读入它的第一块，即引导块。</p></li><li><p>**引导块（bootblock)**，MBR执行引导块中的程序后，该程序负责启动该分区中的操作系统。为统一起见，每个分区都从一个引导块开始，即使它不含有一个可启动的操作系统，也不排除以后会在该分区安装一个操作系统。Windows系统称之为分区引导扇区。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/c237ab8ed54f45d396996f02e460113b.png" alt="img"></p><p>除了从引导块开始，磁盘分区的布局是随着文件系统的不同而变化的。文件系统经常包含有如上图所列的一些项目。</p></li><li><p>**超级块（superblock)**，包含文件系统的所有关键信息，在计算机启动时，或者在该文件系统首次使用时，超级块会被读入内存。超级块中的典型信息包括分区的块的数量、块的大小、空闲块的数量和指针、空闲的FCB数量和FCB指针等。</p></li><li><p><strong>文件系统中空闲块的信息</strong>，可以使用位示图或指针链接的形式给出。</p></li><li><p><strong>i 结点</strong>。索引结点，连续存放，每个文件对应一个结点，可以把 i 结点区看成一个大数组；</p></li><li><p><strong>根目录</strong>，它存放文件系统目录树的根部。</p></li><li><p><strong>其他部分</strong>，存放了其他所有的目录和文件。</p></li></ul></li><li><p>文件系统在内存中的结构</p><p> 内存中的信息用于管理文件系统并通过缓存来提高性能。这些数据在安装文件系统时被加载，在文件系统操作期间被更新，在卸载时被丢弃。这些结构的类型可能包括：</p><ul><li>**内存中的安装表(mount table)**，包含每个己安装文件系统分区的有关信息。</li><li><strong>内存中的目录结构的缓存</strong>，包含最近访问目录的信息。对安装分区的目录，它可以包括一个指向分区表的指针。</li><li><strong>整个系统的打开文件表</strong>，包含每个打开文件的FCB副本及其他信息。</li><li><strong>每个进程的打开文件表</strong>，包含一个指向整个系统的打开文件表中的适当条目的指针，以及其他信息。</li></ul><p><strong>进程创建：</strong></p><p> 为了创建新的文件，应用程序调用逻辑文件系统。逻辑文件系统知道目录结构的格式，它将为文件分配一个新的FCB。然后，系统将相应的目录读入内存，使用新的文件名和FCB进行更新，并将它写回磁盘。</p><p>一旦文件被创建，它就能用于I&#x2F;O，不过，首先要打开文件。系统调用open()将文件名传递给逻辑文件系统。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/dde627283c6e4edd9bbba2670d4c5ad7.png" alt="img"></p><ul><li><p>调用open()首先</p><p>搜索整个系统的打开文件表</p><p>，以确定这个文件是否已被其他进程使用。</p><ul><li>如果<strong>已被使用</strong>，则在单个进程的打开文件表中创建一个条目，让其指向现有整个系统的打开文件表的相应条目。该算法在文件已打开时，能节省大量开销。</li><li>如果这个文件<strong>尚未打开</strong>，则根据给定文件名来搜索目录结构。部分目录结构通常缓存在内存中，以加快目录操作。</li></ul></li><li><p>找到文件后，它的FCB会复制到整个系统的打开文件表中；该表不但存储FCB，而且跟踪打开该文件的进程的数量。</p></li><li><p>然后，在单个进程的打开文件表中创建一个条目，并且通过指针将整个系统打开文件表的条目与其他域（如文件当前位置的指针和文件访问模式等）相连。</p></li><li><p>调用open()返回的是一个指向单个进程的打开文件表中的适当条自的指针。以后，所有文件操作都通过该指针执行。</p></li><li><p>一旦文件被打开，内核就不再使用文件名来访问文件，而使用文件描述符（Windows称之为文件句柄）</p></li></ul><p><strong>进程关闭：</strong></p><p> 当进程关闭一个文件时，就会删除单个进程打开文件表中的相应条目，整个系统的打开文件表的文件打开数量也会递减。当所有打开某个文件的用户都关闭该文件后，任何更新的元数据将复制到磁盘的目录结构中，并且整个系统的打开文件表的对应条目也会被删除。</p></li></ol><h4 id="4-3-3-外存空闲空间管理"><a href="#4-3-3-外存空闲空间管理" class="headerlink" title="4.3.3 外存空闲空间管理"></a>4.3.3 外存空闲空间管理</h4><p> 一个存储设备可以按整体用于文件系统，也可以细分。例如，一个磁盘可以划分为4个分区，每个分区都可以有单独的文件系统。包含文件系统的分区通常称为卷（volumme)。卷可以是磁盘的一部分，也可以是整个磁盘，还可以是多个磁盘组成RAID集，如图所示。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230920152153475.png" alt="image-20230920152153475"></p><p> 在一个卷中，存放文件数据的空间（文件区）和FCB的空间（目录区）是分离的。</p><p> 文件存储设备分成许多大小相同的物理块，并以块为单位交换信息，因此，文件存储设备的管理实质上是对空闲块的组织和管理，它包括空闲块的组织、分配与回收等问题。</p><ol><li><p>空闲表法</p><p>空闲表法属于连续分配方式，它与内存的动态分配方式类似，为每个文件分配一块连续的存储空间。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/93dd888cea6b48c99149a8f3a8383581.png" alt="img"></p><ul><li><p>盘块的分配</p><p>与内存管理中的动态分区分配很类似，为一个文件分配连续的存储空间。</p><p>同样可采用首次适应、最佳适应、最坏适应等算法来决定要为文件分配哪个区间。</p></li><li><p>盘块的回收</p><p>与内存管理中的动态分区分配很类似，当回收某个存储区时需要有四种情况：</p><ul><li>①回收区的前后都没有相邻空闲区</li><li>②回收区的前后都是空闲区</li><li>③回收区前面是空闲区</li><li>④回收区后面是空闲区</li></ul><p>总之，回收时需要注意表项的合并问题</p></li></ul></li><li><p>空闲链表法</p><p>将所有空闲盘区拉成一条空闲链。根据构成链所用基本元素的不同，分为两种形式：</p><ul><li><p>空闲盘块链：将磁盘上的所有空闲空间以盘块为单位拉成一条链。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/a5cfd4f93acb44e6a4ee4090ad9c3463.png" alt="img"></p><p>操作系统保存着链头、链尾指针。</p><ul><li>如何分配：若某文件申请K个盘块，则从链头开始依次摘下K个盘块分配，并修改空闲链的链头指针。</li><li>如何回收：回收的盘块依次挂到链尾，并修改空闲链的链尾指针。</li></ul><p>适用于离散分配的物理结构。为文件分配多个盘块时可能要重复多次操作</p></li><li><p>空闲盘区链：将磁盘上的所有空闲盘区（每个盘区可包含若干个盘块）拉成一条链。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/5b4399a136fb42f789c07166813e9282.png" alt="img"></p><p>操作系统保存着链头、链尾指针。</p><ul><li><p>如何分配：</p><p>若某文件申请K个盘块，则可以采用首次适应、最佳适应等算法，从链头开始检索，按照算法规则找到一个大小符合要求的空闲盘区，分配给文件。</p><p>若没有合适的连续空闲块，也可以将不同盘区的盘块同时分配给一个文件，注意分配后可能要修改相应的链指针、盘区大小等数据。</p></li><li><p>如何回收：若回收区和某个空闲盘区相邻，则需要将回收区合并到空闲盘区中。若回收区没有和任何空闲区相邻，将回收区作为单独的一个空闲盘区挂到链尾。</p></li></ul><p>离散分配、连续分配都适用。为一个文件分配多个盘块时效率更高。</p></li></ul></li><li><p>位示图法</p><p> 位示图是利用二进制的一位来表示磁盘中一个盘块的使用情况，磁盘上所有的盘块都有一个二进制位与之对应。当其值为“0”时，表示对应的盘块空闲；为“1”时，表示已分配。</p><p> 这样，一个m×n位组成的位示图就可用来表示m×n个盘块的使用情况，如图所示。行为位号，列为字号</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230920153912806.png" alt="image-20230920153912806"></p><blockquote><p>注意：盘块号、字号、位号到底是从0开始，还是从1开始。两者计算盘块号方式不同。</p></blockquote><ul><li>盘块的分配<ul><li>顺序扫描位示图，从中找出一个或一组其值为“0”的二进制位。</li><li>将找到的一个或一组二进制位，转换成与之对应的盘块号。若找到的其值为“0”的二进制位位于位示图的第i行、第j列，则其相应的盘块号应按下式计算（n为每行位数）：<br>$$<br>\begin{cases}b&#x3D;n(i-1)+j, &amp; \text{字、位、盘块号从1开始}<br>b&#x3D;ni+j&amp; \text{字、位、盘块号从0开始}\end{cases}<br>$$</li><li>修改位示图，令$map[i,j]&#x3D;1$</li></ul></li><li>盘块的回收<ul><li>将回收盘块的盘块号转换成位示图中的行号和列号。转换公式为<br>$$<br>\begin{cases}i&#x3D;(b-1)&#x2F;n+1;j&#x3D;(b-1)% n+1, &amp; \text{字、位、盘块号从1开始}<br>i&#x3D;b&#x2F;n;j&#x3D;b% n, &amp; \text{字、位、盘块号从0开始}\end{cases}<br>$$</li><li>修改位示图，令$map[i,j]&#x3D;0$。</li></ul></li></ul><p>空闲表法和空闲链表法都不适用于大型文件系统，因为这会使空闲表或空闲链表太大。</p></li><li><p>成组链接法</p><p> 在UNIX系统中采用的是成组链接法，这种方法结合了空闲表和空闲链表两种方法，它具有上述两种方法的优点，克服了两种方法均有的表太长的缺点。</p><p> 文件卷的目录区中专门用一个磁盘块作为“超级块”，当系统启动时需要将超级块读入内存。并且要保<br>证内存与外存中的“超级块”数据一致。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/f5ec3f528eff44cc93ab2a804ffd73ab.png" alt="img"></p><p>用来存放一组空闲盘块号（空闲盘块的块号）的盘块称为成组链块。</p><ul><li><p><strong>成组链接思想</strong>：把顺序的n个空闲盘块号保存在第一个成组链块中，其最后一个空闲盘块（作为成组链块）则用于保存另一组空闲盘块号，如此继续，直至所有空闲盘块均予以链接。</p></li><li><p>盘块的分配</p><p><strong>分配1个空闲块</strong>：</p><ul><li>①检查第一个分组的块数是否足够。1＜100，是足够的。</li><li>②分配第一个分组中的1个空闲块，并修改相应数据</li></ul><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/c25a6835e1f145e9a9f45c8590e26aff.png" alt="img"></p><p><strong>分配100个空闲块</strong>：</p><ul><li>①检查第一个分组的块数是否足够。100&#x3D;100，是足够的。</li><li>②分配第一个分组中的100个空闲块。但是由于300号块内存放了再下一组的信息，因此300号块的数据需要复制到超级块中</li></ul><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/5042968c565b49ee955245784c5f5581.png" alt="img"></p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/23e43a6a09a1454c81b5859c93b40cfa.png" alt="img"></p></li><li><p>盘块的回收</p><p>需要将超级块中的数据复制到新回收的块中，并修改超级块的内容，让新回收的块成为第一个分组。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/5daaee59628e44c7a7e8fddd7898c903.png" alt="img"></p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/05001072ac594a3e87f570af49c7a259.png" alt="img"></p></li></ul></li></ol><h4 id="4-3-4-虚拟文件系统"><a href="#4-3-4-虚拟文件系统" class="headerlink" title="4.3.4 虚拟文件系统"></a>4.3.4 虚拟文件系统</h4><p> 虚拟文件系统（VFS）为用户程序提供了文件系统操作的统一接口，屏蔽了不同文件系统的差异和操作细节。</p><ol><li><p>普通文件系统</p><p> 下图普通的文件系统，不同的外部存储设备，它的文件系统可能是不相同的，对于同一个操作的函数方法定义也许也各不相同；</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/101097bd7cd54bb7a124846abb561dfa.png" alt="img"></p></li><li><p>虚拟文件系统</p><p> 下图为虚拟文件系统，用户程序可以通过VFS提供的统一调用函数（如open()等）来操作不同文件系统的文件，而无须考虑具体的文件系统和实际的存储介质。</p><p> 虚拟文件系统采用了面向对象的思想，它抽象出一个通用的文件系统模型，定义了通用文件系统都支持的接口。新的文件系统只要支持并实现这些接口，即可安装和使用。</p><p> 为了实现VFS，Linux主要抽象了四种对象类型。每个VFS对象都存放在一个适当的数据结构中，其中包括对象的属性和指向对象方法（函数）表的指针。</p><ul><li>超级块对象：表示一个已安装（或称挂载）的特定文件系统。</li><li>索引结点对象：表示一个特定的文件。</li><li>目录项对象：表示一个特定的目录项。</li><li>文件对象：表示一个与进程相关的已打开文件。</li></ul><p>进程与VFS对象之间的交互如下图所示。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230920163914222.png" alt="image-20230920163914222"></p><blockquote><p>三个不同的进程已打开了同一个文件，其中两个进程使用同一个硬链接。</p><p>在这种情况下，每个进程都使用自己的文件对象，但只需要两个目录项对象，每个硬链接对应一个目录项对象。这两个目录项对象指向同一个索引结点对象, 这个索引结点对象标识的是超级块对象及随后的普通磁盘文件。</p></blockquote><p> 对于不同文件系统的数据结构，VFS 在每打开一个文件，就在主存建立一个vnode，用统一的数据结构表示文件；</p><p>打开文件后，创建vnode，并将文件信息复制到vnode中，vnode的功能指针指向具体文件系统的函数功能</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/146a6f2e812b416b9131a7042e879a4b.png" alt="img"></p><blockquote><p>vnode只存在于主存中，而inode既会被调入主存，也会在外存中存储</p></blockquote><p><strong>特点：</strong></p><ul><li>①向上层用户进程提供统一标准的系统调用接口，屏蔽底层具体文件系统的实现差异</li><li>②VFS要求下层的文件系统必须实现某些规定的函数功能，如：open&#x2F;read&#x2F;write。一个新的文件系统想要在某操作系统上被使用，就必须满足该操作系统VFS的要求</li><li>③每打开一个文件，VFS就在主存中新建一个vnode，用统一的数据结构表示文件，无论该文件存储在哪个文件系统</li></ul></li></ol><h4 id="4-3-5-分区和安装"><a href="#4-3-5-分区和安装" class="headerlink" title="4.3.5 分区和安装"></a>4.3.5 分区和安装</h4><ol><li><p>分区</p><ul><li><p>物理格式化（低级格式化）：划分扇区、检测坏扇区、用备用扇区替换坏扇区；当要访问某一块坏扇区时，会使用备用扇区，默默完成替换工作；</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/bb2de2422d474017b034aab701652aab.png" alt="img"></p></li><li><p>逻辑格式化（高级格式化）：磁盘分区；每个区的大小、地址范围等信息，会使用 分区表 来记录；</p><p>在每个区里可以建立各自独立的文件系统 ，例如在C盘里建立UNIZX文件系统；</p><p>分区的第一部分是引导块，里面存储着引导信息，它有自身的格式，因为在引导时系统并未 加载文件系统代码，因此不能解释文件系统的格式。下图为一个典型的Linux分区。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230920164945003.png" alt="image-20230920164945003"></p></li></ul></li><li><p>安装</p><p>文件系统在进程使用前必须先安装，也称挂载，任务是将一个文件系统挂载到操作系统中。</p><p><strong>功能：</strong></p><ul><li>①在VFS中注册新挂载的文件系统。内存中的挂载表（mount table）包含每个文件系统的相关信息，包括文件系统类型、容量大小等。</li><li>②新挂载的文件系统，要向VFS提供一个函数地址列表</li><li>③将新文件系统加到挂载点（mountpoint），也就是将新文件系统挂载在某个父目录下</li></ul><blockquote><p>UNIX本身是一个固定的目录树，只要安装就有，但是如果不给它分配存储空间，就不能对它进行操作，所以首先要给根目录分配空间，这样才能操作这个目录树。</p></blockquote></li></ol><h2 id="5-输入-输出（I-O）管理"><a href="#5-输入-输出（I-O）管理" class="headerlink" title="5 输入&#x2F;输出（I&#x2F;O）管理"></a>5 输入&#x2F;输出（I&#x2F;O）管理</h2><h3 id="5-1-I-O管理概述"><a href="#5-1-I-O管理概述" class="headerlink" title="5.1 I&#x2F;O管理概述"></a>5.1 I&#x2F;O管理概述</h3><h4 id="5-1-1-I-O设备"><a href="#5-1-1-I-O设备" class="headerlink" title="5.1.1 I&#x2F;O设备"></a>5.1.1 I&#x2F;O设备</h4><p> I&#x2F;O设备是将数据输入到计算机中，或者可以接收计算机输出数据的外部设备，属于计算机中的硬件部件；</p><ol><li><p>设备的分类</p><ul><li>按使用特性分类：<ul><li>人机交互类外部设备：鼠标、键盘、打印机等，用于人机交互。数据传输速度慢。</li><li>存储设备：移动硬盘、光盘等，用于数据存储。数据传输速度快。</li><li>网络通信设备：调制解调器等，用于网络通信。数据传输速度介于上述二者之间。</li></ul></li><li>按信息交换的单位分类：<ul><li>块设备。信息交换以数据块为单位。它属于有结构设备，如磁盘等。磁盘设备的基本特征是传输速率较高、可寻址，即对它可随机地读&#x2F;写任意一块。</li><li>字符设备。信息交换以字符为单位。它属于无结构类型，如交互式终端机、打印机等。</li></ul></li><li>按传输速率分类：<ul><li>低速设备。传输速率仅为每秒几字节到数百字节的一类设备，如键盘、鼠标等。</li><li>中速设备。传输速率为每秒数千字节至数万字节的一类设备，如激光打印机等。</li><li>高速设备。传输速率在数百千字节至千兆字节的一类设备，如磁盘机、光盘机等。</li></ul></li></ul></li><li><p>I&#x2F;O接口</p><p> I&#x2F;O接口（设备控制器）位于CPU与设备之间，它既要与CPU通信，又要与设备通信，还要具有按CPU发来的命令去控制设备工作的功能，主要由三部分组成，如下图所示。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230921092426001.png" alt="image-20230921092426001"></p><ul><li><p>组成部分：</p><ul><li><p><strong>设备控制器与CPU的接口</strong>：实现控制器与CPU之间的通信</p><p>该接口有三类信号线：数据线、地址线和控制线。</p><p>数据线与两类寄存器相连：数据寄存器（存放从设备送来的输入数据或从CPU送来的输出数据）和控制&#x2F;状态寄存器（存放从CPU送来的控制信息或设备的状态信息）。</p></li><li><p><strong>设备控制器与设备的接口</strong>：实现控制器与设备之间的通信</p><p>一个设备控制器可以连接一个或多个设备，因此控制器中有一个或多个设备接口。</p><p>每个接口中都存在数据、控制和状态三种类型的信号。</p></li><li><p><strong>I&#x2F;O逻辑</strong>：负责识别CPU发出的命令，并向设备发出命令</p><p>用于实现对设备的控制。它通过一组控制线与CPU交互，对从CPU收到的I&#x2F;O命令进行译码。</p><p>CPU启动设备时，将启动命令发送给控制器，同时通过地址线把地址发送给控制器，由控制器的I&#x2F;O逻辑对地址进行译码，并相应地对所选设备进行控制。</p></li></ul></li><li><p>主要功能：</p><ul><li>接受和识别CPU发出的指令（控制寄存器）</li><li>向CPU报告设备的状态（状态寄存器）</li><li>数据交换（数据寄存器暂存数据）</li><li>地址识别（由I&#x2F;O逻辑实现）</li><li>数据缓冲</li><li>差错控制</li></ul></li></ul></li><li><p>I&#x2F;O端口</p><p>I&#x2F;O端口是指设备控制器中可被CPU直接访问的寄存器，主要有以下三类寄存器。</p><ul><li><p>寄存器类型：</p><ul><li><strong>数据寄存器</strong>：实现CPU和外设之间的数据缓冲。</li><li><strong>状态寄存器</strong>：获取执行结果和设备的状态信息，以让CPU知道是否准备好。</li><li><strong>控制寄存器</strong>：由CPU写入，以便启动命令或更改设备模式。</li></ul></li><li><p>实现I&#x2F;O端口通信，有两种编址方法：</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230921095553061.png" alt="image-20230921095553061"></p><ul><li><strong>独立编址</strong>。为每个端口分配一个I&#x2F;O端口号，所有I&#x2F;O端口形成I&#x2F;O端口空间，普通用户程序不能对其进行访问，只有操作系统使用特殊的I&#x2F;O指令才能访问端口。</li><li><strong>统一编址</strong>。又称内存映射I&#x2F;O，每个端口被分配唯一的内存地址，且不会有内存被分配这地址，通常分配给端口的地址靠近地址空间的顶端。</li></ul></li></ul></li></ol><h4 id="5-1-2-I-O控制方式"><a href="#5-1-2-I-O控制方式" class="headerlink" title="5.1.2 I&#x2F;O控制方式"></a>5.1.2 I&#x2F;O控制方式</h4><p> 设备管理的主要任务之一是控制设备和内存或CPU之间的数据传送。外围设备与内存之间的输入&#x2F;输出控制方式有以下4种。</p><ol><li><p>程序直接控制方式</p><p> 如下图所示，计算机从外部设备读取的每个字，CPU需要对外设状态进行循环检查，直到确定该字已经在I&#x2F;O控制器的数据寄存器中。</p><ul><li><p>工作流程：</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/b0bd7062507d4d8aa46dc9baae5af73d.png" alt="img"></p></li><li><p>CPU干预的频率：很频繁，I&#x2F;O操作开始之前、完成之后需要CPU介入，并且在等待I&#x2F;O完成的过程中CPU需要不断地轮询检查。</p></li><li><p>数据传送的单位：每次读&#x2F;写一个字</p></li><li><p>数据的流向：</p><ul><li>读操作（数据输入）：I&#x2F;O设备→CPU→内存</li><li>写操作（数据输出）：内存→CPU→I&#x2F;O设备</li><li>每个字的读&#x2F;写都需要CPU的帮助</li></ul></li><li><p>优点：实现简单。在读&#x2F;写指令之后，加上实现循环检查的一系列指令即可</p></li><li><p>缺点：CPU和I&#x2F;O设备只能串行工作，CPU需要一直轮询检查，长期处于“忙等”状态，CPU利用率低。</p></li></ul></li><li><p>中断驱动方式</p><p> 中断驱动方式的思想是，允许I&#x2F;O设备主动打断CPU的运行并请求服务，从而”解放” CPU，使得其向I&#x2F;O控制器发送读命令后可以继续做其他有用的工作。</p><ul><li>工作流程：<ul><li>引入中断机制。由于I&#x2F;O设备速度很慢，因此在CPU发出读&#x2F;写命令后，可将等待I&#x2F;O的进程阻塞，先切换到别的进程执行。</li><li>当I&#x2F;O完成后，控制器会向CPU发出一个中断信号，CPU检测到中断信号后，会保存当前进程的运行环境信息，转去执行中断处理程序处理该中断。</li><li>处理中断的过程中，CPU从I&#x2F;O控制器读一个字的数据传送到CPU寄存器，再写入主存。接着，CPU恢复等待I&#x2F;O的进程（或其他进程）的运行环境，然后继续执行。</li></ul></li></ul><blockquote><p>①CPU会在每个指令周期的末尾检查中断：<br>②中断处理过程中需要保存、恢复进程的运行环境，这个过程是需要一定时间开销的。可见，如果中断发生的须率太高，也会降低系统性能。</p></blockquote><ul><li>CPU干预的频率：每次I&#x2F;O操作开始之前、完成之后需要CPU介入。等待I&#x2F;O完成的过程中CPU可以切换到别的进程执行。</li><li>数据传送单位：每次读&#x2F;写一个字</li><li>数据流向：<ul><li>读操作（数据输入）：I&#x2F;O设备→CPU→内存</li><li>写操作（数据输出）：内存→CPU→I&#x2F;O设备</li></ul></li><li>优点：与“程序直接控制方式”相比，在“中断驱动方式”中，I&#x2F;O控制器会通过中断信号主动报告I&#x2F;O已完成，CPU不再需要不停地轮询。CPU和I&#x2F;O设备可并行工作，CPU利用率得到明显提升。</li><li>缺点：每个字在I&#x2F;O设备与内存之间的传输，都需要经过CPU。而频繁的中断处理会消耗较多的CPU时间。</li></ul></li><li><p>DMA方式</p><p> DMA（直接存储器存取）方式的基本思想是在I&#x2F;O设备和内存之间开辟直接的数据交换通路，彻底“解放”CPU。下图为DMA工作流程。</p><ul><li><p>与“中断驱动方式”相比，DMA方式有这样几个改进：</p><ul><li>①数据的传送单位是“块”。不再是一个字、一个字的传送：</li><li>②数据的流向是从设备直接放入内存，或者从内存直接到设备。不再需要CPU作为“快递小哥”。</li><li>③仅在传送一个或多个数据块的开始和结束时，才需要CPU干预，数据传送通过DMA控制器完成。</li></ul></li><li><p>DMA控制器组成：</p><p>下图为DMA控制器的组成。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230921102823702.png" alt="image-20230921102823702"></p><p>DMA控制器中设置如下4类寄存器：</p><ul><li><strong>数据寄存器（DR）</strong>。暂存从设备到内存或从内存到设备的数据。</li><li><strong>内存地址寄存器（MAR）</strong>。在输入时，它存放把数据从设备传送到内存的起始目标地址；在输出时，它存放由内存到设备的内存源地址。</li><li><strong>数据计数器（DC）</strong>。存放本次要传送的字（节）数，剩余要读&#x2F;写的字节数。</li><li><strong>命令&#x2F;状态寄存器（CR）</strong>。接收从CPU发来的I&#x2F;O命令、有关控制信息，或设备的状态。</li></ul></li><li><p>CPU干预的频率：仅在传送一个或多个数据块的开始和结束时，才需要CPU干预。</p></li><li><p>数据传送单位：每次读&#x2F;写一个或多个块（注意：每次读写的只能是连续的多个块，且这些块读入内存后在内存中也必须是连续的）</p></li><li><p>数据流向：</p><ul><li>读操作（数据输入）：I&#x2F;O设备→内存</li><li>写操作（数据输出）：内存→I&#x2F;O设备</li></ul></li><li><p>优点：数据传输以“块”为单位，CPU介入频率进一步降低。数据的传输不再需要先经过CPU再写入内存，数据传输效率进一步增加。CPU和I&#x2F;O设备的并行性得到提升。</p></li><li><p>缺点：CPU每发出一条I&#x2F;O指令，只能读&#x2F;写一个或多个连续的数据块。如果要读&#x2F;写多个离散存储的数据块，或者要将数据分别写到不同的内存区域时，CPU要发出多条I&#x2F;O指令，进行多次中断处理才能完成。</p></li></ul></li><li><p>通道控制方式</p><p>通道：I&#x2F;O通道是指专门负责输入输出的处理机。是一种硬件，可以理解为是“弱鸡版的CPU”。通道可以识别并执行一系列通道指令。</p><blockquote><p>与CPU相比，通道可以执行的指令很单一，并且通道程序是放在主机内存中的，也就是说通道与CPU共享内存</p></blockquote><ul><li><p>完成一次读写流程：</p></li><li><p>CPU干预的频率：极低，通道会根据CPU的指示执行相应的通道程序，只有完成一组数据块的读&#x2F;写后才需要发出中断信号，请求CPU干预。</p></li><li><p>数据传送的单位：每次读&#x2F;写一组数据块</p></li><li><p>数据的流向（在通道的控制下进行）</p><ul><li>读操作（数据输入）：I&#x2F;O设备→内存</li><li>写操作（数据输出）：内存→I&#x2F;O设备</li></ul></li><li><p>缺点：实现复杂，需要专门的通道硬件支持</p></li><li><p>优点：CPU、通道、I&#x2F;O设备可并行工作，资源利用率很高。</p></li></ul></li></ol><h4 id="5-1-4-I-O软件层次结构"><a href="#5-1-4-I-O软件层次结构" class="headerlink" title="5.1.4 I&#x2F;O软件层次结构"></a>5.1.4 I&#x2F;O软件层次结构</h4><p> 为了更好地设计 I&#x2F;O 软件，采用 层次式结构 的 I&#x2F;O 软件；</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230921104928744.png" alt="image-20230921104928744"></p><p> 一个比较合理的层次划分如上图所示。整个I&#x2F;O软件可以视为具有4个层次的系统结构，各层次功能如下：</p><ol><li><p>用户层软件</p><p> 实现了与用户交互的接口，用户可直接使用该层提供的、与I&#x2F;O操作相关的库函数对设备进行操作。</p><p> 用户层软件将用户请求翻译成格式化的I&#x2F;O请求，并通过“系统调用”请求操作系统内核的服务</p></li><li><p>设备独立性软件</p><p> 设备独立性软件，又称设备无关性软件。与设备的硬件特性无关的功能几乎都在这一层实现。</p><ul><li><p>功能：</p><ul><li>① 向上层提供统一的调用接口（如read&#x2F;write系统调用）</li><li>② 设备的保护</li><li>③ 差错处理</li><li>④ 设备的分配与可收</li><li>⑤ 数据缓冲区管理</li><li>⑥ 建立逻辑设备名到物理设备名的映射关系；根据设备类型选择调用相应的驱动程序</li></ul></li><li><p>逻辑设备</p><p> 为实现设备独立性而引入了逻辑设备和物理设备这两个概念。在应用程序中，使用逻辑设备名来请求使用某类设备；而在系统实际执行时，必须将逻辑设备名映射成物理设备名使用。</p><p><strong>使用逻辑设备名好处</strong>：</p><ul><li>①增加设备分配的灵活性</li><li>②易于实现I&#x2F;O重定向，指用于I&#x2F;O操作的设备可以更换(即重定向)，而不必改变应用程序。</li></ul><p> 设备独立性软件需要通过“逻辑设备表（LUT，Logical Unit Table）”来确定逻辑设备对应的物理设备，并找到该设备对应的设备驱动程序。</p><blockquote><p>I&#x2F;O设备被当做一种特殊的文件；不同类型的I&#x2F;O设备需要有不同的驱动程序处理</p></blockquote><p>操作系统系统可以采用两种方式<strong>管理逻辑设备表（LUT）</strong>：</p><ul><li>第一种方式，整个系统只设置一张LUT，这就意味着所有用户不能使用相同的逻辑设备名，因此这种方式只适用于单用户操作系统。</li><li>第二种方式，为每个用户设置一张LUT，各个用户使用的逻辑设备名可以重复，适用于多用户操作系统。系统会在用户登录时为其建立一个用户管理进程，而LUT就存放在用户管理进程的PCB中。</li></ul></li></ul></li><li><p>设备驱动程序</p><p> 与硬件直接相关，负责具体实现系统对设备发出的操作指令，驱动I&#x2F;O设备工作的驱动程序。 将上层发出的一系列命令（如read&#x2F;write）转化成特定设备“能听得懂”的一系列操作。</p><p> 不同设备的内部硬件特性也不同，这些特性只有厂家才知道，因此厂家须提供与设备相对应的驱动程序，CPU执行驱动程序的指令序列，来完成设置设备寄存器，检查设备状态等工作。</p><p> 为I&#x2F;O内核子系统隐藏设备控制器之间的差异。</p></li><li><p>中断处理程序</p><p> 当I&#x2F;O任务完成时，I&#x2F;O控制器会发送一个中断信号，系统会根据中断信号类型找到相应的中断处理程序并执行。</p><ul><li><p>中断处理程序的处理流程如下：</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230901173205434.png#pic_center" alt="image-20230901173205434"></p></li><li><p>中断处理层的任务：</p><ul><li>进行进程上下文的切换，</li><li>对处理中断信号源进行测试，</li><li>读取设备状态和修改进程状态等。</li></ul></li></ul><blockquote><p>由于中断处理与硬件紧密相关，对用户而言，应尽量加以屏蔽，因此应放在操作系统的底层，系统的其余部分尽可能少地与之发生联系。</p></blockquote></li><li><p>总结</p><p>说明用户对设备的一次命令过程如下所示：</p><ul><li>①当用户要读取某设备的内容时，通过操作系统提供的read命令接口，这就经过了用户层。</li><li>②操作系统提供给用户使用的接口，一般是统一的通用接口，也就是几乎每个设备都可以响应的统一命令，如read命令，用户发出的read命令，首先经过设备独立层进行解析，然后交往下层。</li><li>③接下来，不同类型的设备对read命令的行为会有所不同，如磁盘接收read命令后的行为与打印机接收read命令后的行为是不同的。因此，需要针对不同的设备，把read命令解析成不同的指令，这就经过了设备驱动层。</li><li>④命令解析完毕后，需要中断正在运行的进程，转而执行read命令，这就需要中断处理程序。</li><li>⑤最后，命令真正抵达硬件设备，硬件设备的控制器按照上层传达的命令操控硬件设备，完成相应的功能。</li></ul><p>直接涉及到硬件其体细节、且与中断无关的操作肯定是在设备驱动程序层完成的；</p><p>没有涉及硬件的、对各种设备都需要进行的管理工作都是在设备独立性软件层完成的。</p></li></ol><h4 id="5-1-4-应用程序I-O接口"><a href="#5-1-4-应用程序I-O接口" class="headerlink" title="5.1.4 应用程序I&#x2F;O接口"></a>5.1.4 应用程序I&#x2F;O接口</h4><p> 在I&#x2F;O系统与高层之间的接口中，根据设备类型的不同，又进一步分为若干接口。</p><ol><li><p>字符设备接口</p><p> 字符设备是指数据的存取和传输是以字符为单位的设备，如键盘、打印机等。基本特征是传输速率较低、不可寻址，并且在输入输出时通常采用中断驱动方式。</p><ul><li><p>字符设备的操作</p><ul><li><strong>get和put操作</strong>。由于字符设备不可寻址，只能采取顺序存取方式，通常为字符设备建立一个字符缓冲区，用户程序通过get操作从缓冲区获取字符，通过put操作将字符输出到缓冲区。</li><li><strong>in-control指令</strong>。字符设备类型繁多，差异甚大，因此在接口中提供一种通用的in-control指令来处理它们（包含了许多参数，每个参数表示一个与具体设备相关的特定功能）。</li></ul><p>字符设备都属于独占设备，为此接口中还需要提供打开和关闭操作，以实现互斥共享。</p></li></ul></li><li><p>块设备接口</p><p> 块设备是指数据的存取和传输是以数据块为单位的设备，典型的块设备是磁盘。基本特征是传输速率较高、可寻址。磁盘设备的I&#x2F;O常采用DMA方式。</p><ul><li><strong>隐藏了磁盘的二维结构</strong>：在二维结构中，每个扇区的地址需要用磁道号和扇区号来表示。块设备接口将磁盘的所有扇区从0到n-1依次编号，这样，就将二维结构变为一种线性序列。</li><li><strong>将抽象命令映射为低层操作</strong>：块设备接口支持上层发来的对文件或设备的打开、读、写和关闭等抽象命令，该接口将上述命令映射为设备能识别的较低层的具体操作。</li><li><strong>内存映射接口</strong>：内存映射接口通过内存的字节数组来访问磁盘，而不提供读&#x2F;写磁盘操作。映射文件到内存的系统调用返回包含文件副本的一个虚拟内存地址。只在需要访问内存映像时，才由虚拟存储器实际调页。内存映射文件的访问如同内存读写一样简单，极大地方便了程序员。</li></ul></li><li><p>网络设备接口</p><p> 许多操作系统提供的网络I&#x2F;O接口为网络套接字接口，套接字接口的系统调用使应用程序创建的本地套接字连接到远程应用程序创建的套接字，通过此连接发送和接收数据。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/7dc576d4af9a4e769647e6d1773db343.png" alt="img"></p></li><li><p>阻塞&#x2F;非阻塞I&#x2F;O</p><ul><li><p><strong>阻塞I&#x2F;O：</strong>当用户进程调用I&#x2F;O操作时，进程就被阻塞，需要等待I&#x2F;O操作完成，进程才被唤醒继续执行。</p><p>eg：字符设备接口一一从键盘读一个字符get</p></li><li><p><strong>非阻塞I&#x2F;O</strong>：用户进程调用I&#x2F;O操作时，不阻塞该进程，该I&#x2F;O调用返回一个错误返回值，通常，进程需要通过轮询的方式来查询I&#x2F;O操作是否完成。</p><p>eg：块设备接口一一往磁盘写数据write</p></li></ul></li></ol><h3 id="5-2-设备独立性软件"><a href="#5-2-设备独立性软件" class="headerlink" title="5.2 设备独立性软件"></a>5.2 设备独立性软件</h3><h4 id="5-2-1-与设备无关的软件"><a href="#5-2-1-与设备无关的软件" class="headerlink" title="5.2.1 与设备无关的软件"></a>5.2.1 与设备无关的软件</h4><p> 与设备无关的软件是I&#x2F;O系统的最高层软件，它的下层是设备驱动程序。</p><ul><li>设备保护：<ul><li>操作系统需要实现文件保护功能，不同的用户对各个文件有不同的访问权限（如：只读、读和写等）</li><li>在UNIX系统中，设备被看做是一种特殊的文件，每个设备也会有对应的FCB。当用户请求访问某个设备时，系统根据FCB中记录的信息来判断该用户是否有相应的访问权限，以此实现“设备保护”的功能。</li></ul></li></ul><h4 id="5-2-2-高速缓存与缓冲区"><a href="#5-2-2-高速缓存与缓冲区" class="headerlink" title="5.2.2 高速缓存与缓冲区"></a>5.2.2 高速缓存与缓冲区</h4><ol><li><p>磁盘高速缓存（Disk Cache）</p><p>操作系统中使用磁盘高速缓存技术来提高磁盘的I&#x2F;O速度，对访问高速缓存要比访问原始磁盘数据更为高效。</p><p> 磁盘高速缓存技术不同于通常意义下的介于CPU与内存之间的小容量高速存储器，而是指利用内存中的存储空间来暂存从磁盘中读出的一系列盘块中的信息。因此，磁盘高速缓存逻辑上属于磁盘，物理上则是驻留在内存中的盘块。</p><ul><li>高速缓存在内存中分为两种形式：<ul><li>一种是在内存中开辟一个单独的空间作为磁盘高速缓存，大小固定</li><li>另一种是把未利用的内存空间作为一个缓冲池，供请求分页系统和磁盘I&#x2F;O时共享。</li></ul></li></ul></li><li><p>缓冲区（Buffer）</p><ul><li><p>概念：缓冲区是一个存储区域，可以由专门的硬件寄存器组成，也可利用内存作为缓冲区。</p><ul><li>硬件做缓冲区：使用硬件作为缓冲区的成本较高，容量也较小，一般仅用在对速度要求非常高的场合（如存储器管理中所用的联想寄存器，由于对页表的访问频率极高，因此使用速度很快的联想寄存器来存放页表项的副本）</li><li>内存做缓冲区：一般情况下，更多的是利用内存作为缓冲区，“设备独立性软件”的缓冲区管理就是要组织管理好这些缓冲区</li></ul></li><li><p>作用</p><ul><li>缓和CPU与I&#x2F;O设备之间速度不匹配的矛盾</li><li>减少对CPU的中断频率，放宽对CPU中断相应时间的限制</li><li>解决数据粒度不匹配的问题</li><li>提高CPU与I&#x2F;O设备之间的并行性</li></ul></li><li><p><strong>单缓冲</strong></p><p>若采用单缓冲的策略，操作系统会在主存中为其分配一个缓冲区（若题目中没有特别说明，一个缓冲区的大小就是一个块）。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230921143949738.png" alt="image-20230921143949738"></p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230921141924797.png" alt="image-20230921141924797"></p><blockquote><p>注意：当缓冲区数据非空时，不能往缓冲区冲入数据，只能从缓冲区把数据传出；当缓冲区为空时，可以往缓冲区冲入数据，但必须把缓冲区充满以后，才能从缓冲区把数据传出。</p></blockquote><p>设块设备输入缓冲区时间为T，缓冲区传送至工作区时间为M，CPU处理工作区时间为C：</p><ul><li>若T&gt;C，从初始状态到下一个开始状态，整个过程用时为M+T</li><li>若T&lt;C，从初始状态到下一个开始状态，整个过程用时为M+C</li></ul><p>结论：故单缓冲区处理每块数据的用时为$max(C,T)+M$。</p><p>若两个相互通信的机器只设置单缓冲区，在任一时刻只能实现数据的单向传输。</p></li><li><p><strong>双缓冲</strong></p><p>若采用双缓冲的策略，操作系统会在主存中为其分配两个缓冲区。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230921143131283.png" alt="image-20230921143131283"></p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230921144213776.png" alt="image-20230921144213776"></p><p>双缓冲题目中，假设初始状态为；工作区空，其中一个缓冲区满，另一个缓冲区空</p><ul><li>若T&gt;C+M，则处理一块数据的平均用时为T</li><li>若T&lt;C+M，意味着输入数据块速度要比处理机处理数据块速度更快，处理一个数据块的平均耗时为C+M</li></ul><p>结论：采用双缓冲策略，处理一个数据块的平均耗时为$Max(T,C+M)$</p><blockquote><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230921144605057.png" alt="image-20230921144605057"></p><p>若两个相互通信的机器只设置单缓冲区，在任一时刻只能实现数据的单向传输。</p><p>若两个相互通信的机器设置双缓冲区，则同一时刻可以实现双向的数据传输。</p></blockquote></li><li><p><strong>循环缓冲</strong></p><p>将多个大小相等的缓冲区链接成一个循环队列。</p><p>注：上图中，橙色表示已充满数据的缓冲区，绿色表示空缓冲区。</p></li><li><p><strong>缓冲池</strong></p><p> 缓冲池由系统中共用的缓冲区组成。</p><p>这些缓冲区按使用状况可以分为：</p><ul><li>空缓冲队列</li><li>装满输入数据的缓冲队列（输入队列）</li><li>装满输出数据的缓冲队列（输出队列）</li></ul><p>根据一个缓冲区在实际运算中扮演的功能不同，又设置了<strong>四种工作缓冲区</strong>：</p><ul><li>用于收容输入数据的工作缓冲区（hin）</li><li>用于提取输入数据的工作缓冲区（sin）</li><li>用于收容输出教据的工作绥冲区（hout）</li><li>用于提取输出数据的工作缓冲区（sout）</li></ul><p><strong>工作过程：</strong></p><ul><li><p><strong>① 输入进程请求输入数据</strong></p><p>从空缓冲队列中取出一块作为收容输入数据的工作缓冲区（hin）。冲满数据后将缓冲区挂到输入队列队尾</p></li><li><p><strong>② 计算进程想要取得一块输入数据</strong></p><p>从输入队列中取得一块冲满输入数据的缓冲区作为“提取输入数据的工作缓冲区（sin）”。缓冲区读空后挂到空缓冲区队列</p></li><li><p><strong>③ 计算进程想要将准备好的数据冲入缓冲区</strong></p><p>从空缓冲队列中取出一块作为“收容输出数据的工作缓冲区（hout）”，数据冲满后将缓冲区挂到输出队列队尾</p></li><li><p><strong>④ 输出进程请求输出数据</strong></p><p>从输出队列中取得一块冲满输出数据的缓冲区作为“提取输出数据的工作缓冲区（sout）”。缓冲区读空后挂到空缓冲区队列</p></li></ul></li></ul></li></ol><h4 id="5-2-3-设备的分配与回收"><a href="#5-2-3-设备的分配与回收" class="headerlink" title="5.2.3 设备的分配与回收"></a>5.2.3 设备的分配与回收</h4><ol><li><p>设备分配概述</p><p> 设备分配是指根据用户的I&#x2F;O请求分配所需的设备。分配的总原则是充分发挥设备的使用效率，尽可能地让设备忙碌，又要避免由于不合理的分配方法造成进程死锁。</p><p> 从设备特性来看，分为以下三种设备：</p><ul><li><strong>独占式使用设备</strong>。进程分配到独占设备后，便由其独占，直至该进程释放该设备。</li><li><strong>分时式共享使用设备</strong>。对于共享设备，可同时分配给多个进程，通过分时共享使用。</li><li><strong>以SPOOLing方式使用外部设备</strong>。SPOOLing技术实现了虚拟设备功能，可以将设备同时分配给多个进程。这种技术实质上就是实现了对设备的I&#x2F;O操作的批处理。</li></ul></li><li><p>设备分配的数据结构</p><p> 设备分配依据的主要数据结构有**设备控制表(DCT)<strong>、</strong>控制器控制表(COCT)<strong>、</strong>通道控制表 (CHCT)<strong>和</strong>系统设备表(SDT)**，各数据结构功能如下。</p><ul><li><p>设备控制表（DCT）：系统为每个设备配置一张DCT，用于记录设备情况</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230921152138973.png" alt="image-20230921152138973"></p></li><li><p>控制器控制表（COCT）：每个设备控制器都会对应一张COCT。操作系统根据COCT的信息对控制器进行操作和管理。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230921152213087.png" alt="image-20230921152213087"></p></li><li><p>通道控制表（CHCT）：每个通道都会对应一张CHCT。操作系统根据CHCT的信息对通道进行操作和管理。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230921152241283.png" alt="image-20230921152241283"></p></li><li><p>系统设备表（SDT）：记录了系统中全部设备的情况，每个设备对应一个表目。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230921152258475.png" alt="image-20230921152258475"></p></li></ul></li><li><p>设备分配的策略</p><ul><li><p><strong>设备分配原则</strong>。设备分配应根据设备特性、用户要求和系统配置情况。既要充分发挥设备的使用效率，又要避免造成进程死锁，还要将用户程序和具体设备隔离开。</p></li><li><p><strong>设备分配方式</strong>。设备分配方式有静态分配和动态分配两种。</p><ul><li><p>①静态分配：进程运行前为其分配全部所需资源，运行结束后归还资源。主要用于对独占设备的分配，它在用户作业开始执行前，由系统一次性分配该作业所要求的全部设备、控制器。</p><p>静态分配方式不会出现死锁，但设备的使用效率低。</p></li><li><p>②动态分配：进程运行过程中动态申请设备资源。在进程执行过程中根据执行需要进行。</p><p>这种方式有利于提高设备利用率，但若分配算法使用不当，则有可能造成进程死锁。</p></li></ul></li><li><p><strong>设备分配算法</strong>。常用的动态设备分配算法有先请求先分配、优先级高者优先等。</p></li></ul></li><li><p>设备分配的安全性</p><p>设备分配的安全性是指设备分配中应防止发生进程死锁。</p><ul><li><p><strong>安全分配方式</strong>。</p><ul><li>为进程分配一个设备后就将进程阻塞，本次I&#x2F;O完成后才将进程唤醒。一个时段内每个进程只能使用一个设备。</li><li>优点：破坏了“请求和保持”条件，不会死锁</li><li>缺点：对于一个进程来说，CPU和I&#x2F;O设备只能串行工作</li></ul></li><li><p><strong>不安全分配方式</strong>。</p><p>进程发出I&#x2F;O请求后，系统为其分配I&#x2F;O设备，进程可继续执行，之后还可以发出新的I&#x2F;O请求。只有某个I&#x2F;O请求得不到满足时才将进程阻塞。一个进程可以同时使用多个设备。</p><ul><li>优点：进程的计算任务和I&#x2F;O任务可以并行处理，使进程迅速推进</li><li>缺点：有可能发生死锁（死锁避免、死锁的检测和解除）</li></ul></li></ul></li><li><p>设备分配的步骤</p><ul><li><p>步骤</p><ul><li>① 根据进程请求的物理设备名查找SDT（注：物理设备名是进程请求分配设备时提供的参数）</li><li>② 根据SDT找到DCT，若设备忙碌则将进程PCB挂到设备等待队列中，不忙碌则将设备分配给进程。</li><li>③ 根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程。</li><li>④ 根据COCT找到CHCT，若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进程。</li></ul><blockquote><p>注：只有设备、控制器、通道三者都分配成功时，这次设备分配才算成功，之后便可启动I&#x2F;O设备进行数据传送</p></blockquote></li><li><p>缺点</p><ul><li>①用户编程时必须使用“物理设备名”，底层细节对用户不透明，不方便编程</li><li>②若换了一个物理设备，则程序无法运行</li><li>③若进程请求的物理设备正在忙碌，则即使系统中还有同类型的设备，进程也必须阻塞等待</li></ul></li></ul></li><li><p>设备分配步骤的改进</p><p>改进方法：建立逻辑设备名与物理设备名的映射机制，用户编程时只需提供逻辑设备名。</p><ul><li><p><strong>逻辑设备表（LUT）</strong></p><p>逻辑设备表（LUT）建立了逻辑设备名与物理设备名之间的映射关系。</p><p>某用户进程第一次使用设备时使用逻辑设备名向操作系统发出请求，操作系统根据用户进程指定的设备类型（逻辑设备名）查找系统设备表，找到一个空闲设备分配给进程，并在LUT中增加相应表项。</p><p>如果之后用户进程再次通过相同的逻辑设备名请求使用设备，则操作系统通过LUT表即可知道用户进程实际要使用的是哪个物理设备了，并且也能知道该设备的驱动程序入口地址。</p><ul><li><strong>整个系统只有一张LUT</strong>：各用户所用的逻辑设备名不允许重复，适用于单用户操作系统</li><li><strong>每个用户一张LUT</strong>：不同用户的逻辑设备名可重复，适用于多用户操作系统</li></ul></li><li><p>步骤</p><ul><li>① 根据进程请求的逻辑设备名查找SDT（注：用户编程时提供的逻辑设备名其实就是“设备类型”）</li><li>② 查找SDT，找到用户进程指定类型的、并且空闲的设备，将其分配给该进程。操作系统在逻辑设备表（LUT）中新增一个表项。</li><li>③ 根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程。</li><li>④ 根据COCT找到CHCT，若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进程</li></ul></li></ul></li></ol><h4 id="5-2-4-SPOOLing技术（假脱机技术）"><a href="#5-2-4-SPOOLing技术（假脱机技术）" class="headerlink" title="5.2.4 SPOOLing技术（假脱机技术）"></a>5.2.4 SPOOLing技术（假脱机技术）</h4><ol><li><p>概念</p><ul><li><p><strong>脱机技术</strong>：脱离主机的控制进行的输入&#x2F;输出操作。</p><p>批处理阶段引入了脱机输入&#x2F;输出技术（用磁带完成），在外围控制机的控制下，慢速输入设备的数据先被输入到更快速的磁带上。之后主机可以从快速的磁带上读入数据，从而缓解了速度矛盾。</p></li><li><p><strong>SPOOLing技术</strong>：“假脱机技术”，又称“SPOOLing技术”，用软件的方式模拟脱机技术。</p><p>要实现SPOOLing技术，必须要有多道程序技术的支持。系统会建立“输入进程”和“输出进程”</p></li></ul></li><li><p>原理</p><ul><li>输入井和输出井<ul><li>在磁盘上开辟出两个存储区域一一“输入井”和“输出井”</li><li>”输入井”模拟脱机输入时的磁带，用于收容I&#x2F;O设备输入的数据</li><li>“输出井”模拟脱机输出时的磁带，用于收容用户进程输出的数据</li></ul></li><li>输入进程和输出进程<ul><li>“输入进程”模拟脱机输入时的外围控制机</li><li>“输出进程”模拟脱机输出时的外围控制机</li></ul></li><li>输入缓冲区和输出缓冲区<ul><li>在输入进程的控制下，“输入缓冲区”用于暂存从输入设备输入的数据，之后再转存到输入井中</li><li>在输出进程的控制下，“输出缓冲区”用于暂存从输出井送来的数据，之后再传送到输出设备上</li><li>注意，输入缓冲区和输出缓冲区是在内存中的缓冲区</li></ul></li></ul></li><li><p>预读和滞后写</p><ul><li><p>预读（提前读）：</p><p>如果采用的顺序访问方式对文件进行访问，便可预知下一次要读的盘块。此时可采用预读策略，即在读当前块的同时，也将下一个盘块提前读入内存缓冲区，这样在访问下一个盘块时就不需要再启动磁盘，从而提升磁盘I&#x2F;O速度。</p></li><li><p>滞后写（延迟写）</p><p>滞后写是指缓冲区A中的数据本应立即写回磁盘，但考虑到其中的数据在不久之后有可能再次被访问，因此并不会立即把A中的数据写回磁盘，而是将缓冲区A挂到空闲缓冲区队列。如果有别的进程申请使用该缓冲区时，才把A中的数据写回磁盘。这样做的好处是，只要缓冲区A仍在队列中，任何访问该数据的进程，都可以直接读出其中的数据而不必访问磁盘。因而这种方式也可以减少磁盘I&#x2F;O次数，改善性能。</p></li></ul></li><li><p>共享打印机的原理分析</p><p>SPOOLing技术可以把一台物理设备虚拟成逻辑上的多台设备，可将独占式设备改造成共享设备。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230921163421824.png" alt="image-20230921163421824"></p><ul><li>当多个用户进程提出输出打印的请求时，系统会答应它们的请求，但是并不是真正把打印机分配给他们，而是由假脱机管理进程为每个进程做两件事：<ul><li>1）在磁盘输出井中为进程申请一个空闲缓冲区（也就是说，这个缓冲区是在磁盘上的），并将要打印的数据送入其中</li><li>2）为用户进程申请一张空白的打印请求表，并将用户的打印请求填入表中（其实就是用来说明用户的打印数据存放位置等信息的），再将该表挂到假脱机文件队列上。</li></ul></li></ul><p>当打印机空闲时，输出进程会从文件队列的队头取出一张打印请求表，并根据表中的要求将要打印的数据从输出井传送到输出缓冲区，再输出到打印机进行打印。用这种方式可依次处理完全部的打印任务。</p><blockquote><p>虽然系统中只有一个台打印机，但每个进程提出打印请求时，系统都会为在输出井中为其分配一个存储区（相当于分配了一个逻辑设备），使每个用户进程都觉得自己在独占一台打印机，从而实现对打印机的共享。</p></blockquote></li></ol><h4 id="5-2-5-设备驱动程序接口"><a href="#5-2-5-设备驱动程序接口" class="headerlink" title="5.2.5 设备驱动程序接口"></a>5.2.5 设备驱动程序接口</h4><p> 要求每个设备驱动程序与操作系统之间都有着相同或相近的接口。这样会使得添加一个新设备驱动程序变得很容易，同时也便于开发人员编制设备驱动程序。</p><p> 对于每种设备类型，例如磁盘，操作系统都要定义一组驱动程序必须支持的函数。</p><p> 与设备无关的软件还要负责将符号化的设备名映射到适当的驱动程序上。</p><p> 在UNIX和Windows中，设备是作为命名对象出现在文件系统中的，因此针对文件的常规保护规则也适用于I&#x2F;O设备。系统管理员可以为每个设备设置适当的访问权限。</p><h3 id="5-3-磁盘和固态硬盘"><a href="#5-3-磁盘和固态硬盘" class="headerlink" title="5.3 磁盘和固态硬盘"></a>5.3 磁盘和固态硬盘</h3><h4 id="5-3-1-磁盘"><a href="#5-3-1-磁盘" class="headerlink" title="5.3.1 磁盘"></a>5.3.1 磁盘</h4><ol><li><p>磁盘结构</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230921170548395.png" alt="image-20230921170548395"></p><ul><li><p>磁盘：磁盘的表面由一些磁性物质组成，可以用这些磁性物质来记录二进制数据</p></li><li><p>磁道：磁盘的盘面被划分成一个个磁道。这样的一个“圈”就是一个磁道</p></li><li><p>扇区：一个磁道又被划分成一个个扇区，每个扇区就是一个“磁盘块”各个扇区存放的数据量相同</p><p>最内侧磁道上的扇区面积最小，因此数据密度最大</p></li><li><p>盘面：磁盘有多个盘片”摞”起来，每个盘片有两个盘面。</p></li><li><p>柱面：所有盘面中相对位置相同的磁道组成柱面。</p></li></ul></li><li><p>如何在磁盘中读&#x2F;写数据</p><p>需要把“磁头”移动到想要读&#x2F;写的扇区所在的磁道。磁盘会转起来，让目标扇区从磁头下面划过，才能完成对扇区的读&#x2F;写操作。</p></li><li><p>磁盘的物理地址：磁盘地址用“柱面号•盘面号•扇区号”表示，可根据该地址读取一个“块”</p><ul><li>①根据“柱面号”移动磁臂，让磁头指向指定柱面；</li><li>②激活指定盘面对应的磁头；</li><li>③磁盘旋转的过程中，指定的扇区会从磁头下面划过，这样就完成了对指定扇区的读&#x2F;写。</li></ul></li><li><p>磁盘读写时间</p><ul><li><p>寻找时间Ts</p><p>：在读&#x2F;写数据前，将磁头移动到指定磁道所花的时间。</p><ul><li>①启动磁头臂是需要时间的。假设耗时为s；</li><li>②移动磁头也是需要时间的。假设磁头匀速移动，每跨越一个磁道耗时为m，总共需要跨越n条磁道。则：寻道时间$Ts&#x3D;s+ m*n$</li></ul></li><li><p>延迟时间TR</p><p>：通过旋转磁盘，使磁头定位到目标扇区所需要的时间。</p><ul><li>设磁盘转速为r（单位：转&#x2F;秒，或转&#x2F;分），则平均所需的延迟时间$TR&#x3D;(1&#x2F;2)*(1&#x2F;r)&#x3D; 1&#x2F;2r$</li><li>硬盘的典型转速为5400 转&#x2F;分，或7200转&#x2F;分</li></ul></li><li><p>传输时间Tt</p><p>：从磁盘读出或向磁盘写入数据所经历的时间</p><ul><li>假设磁盘转速为r，此次读&#x2F;写的字节数为b，每个磁道上的字节数为N。</li><li>则：传输时间$Tt&#x3D;(1&#x2F;r)*(b&#x2F;N)&#x3D; b&#x2F;(rN)$</li></ul></li><li><p>平均存取时间</p><ul><li>总的平均存取时间$T&#x3D;Ts + 1&#x2F;2r + b&#x2F;(rN)$</li><li>延迟时间和传输时间都与磁盘转速相关，且为线性相关而转速是硬件的固有属性，因此操作系统也无法优化延迟时间和传输时间</li></ul></li></ul></li><li><p>磁盘的分类</p><ul><li>磁头是否移动<ul><li>磁头可以移动的称为活动头磁盘。磁臂可以来回伸缩来带动磁头定位磁道</li><li>磁头不可移动的称为固定头磁盘。这种磁盘中每个磁道有一个磁头</li></ul></li><li>根据盘片是否可更换<ul><li>固定盘磁盘</li><li>可换盘磁盘</li></ul></li></ul></li></ol><h4 id="5-3-2-磁盘管理"><a href="#5-3-2-磁盘管理" class="headerlink" title="5.3.2 磁盘管理"></a>5.3.2 磁盘管理</h4><ol><li><p>磁盘初始化</p><p> 一个新的磁盘只是一个磁性记录材料的空白盘。在磁盘可以存储数据之前，必须将它分成扇区，以便磁盘控制器能够进行读写操作，这个过程称为低级格式化（或称物理格式化）。</p><p> 低级格式化为每个扇区使用特殊的数据结构，填充磁盘。每个扇区的数据结构通常由头部、数据区域（通常为512B大小）和尾部组成。头部和尾部包含了一些磁盘控制器的使用信息。</p></li><li><p>分区</p><p>在可以使用磁盘存储文件之前，操作系统还要将自己的数据结构记录到磁盘上，分为两步：</p><ul><li>第一步是，将磁盘分为由一个或多个柱面组成的分区（即我们熟悉的C盘、D盘等形式的分区），每个分区的起始扇区和大小都记录在磁盘主引导记录的分区表中</li><li>第二步是，对物理分区进行逻辑格式化（创建文件系统），操作系统将初始的文件系统数据结构存储到磁盘上，这些数据结构包括空闲空间和已分配的空间以及一个初始为空的目录。</li></ul><p>因扇区的单位太小，为了提高效率，操作系统将多个相邻的扇区组合在一起，形成一簇（在Linux中称为块）。为了更高效地管理磁盘，一簇只能存放一个文件的内容，文件所占用的空间只能是簇的整数倍；如果文件大小小于一簇（甚至是0字节），也要占用一簇的空间。</p></li><li><p>引导块</p><p> 计算机启动时需要运行一个初始化程序（自举程序），它初始化CPU、寄存器、设备控制器和内存等，接着启动操作系统。为此，自举程序找到磁盘上的操作系统内核，将它加载到内存， 并转到起始地址，从而开始操作系统的运行。</p><p> 自举程序通常存放在ROM中，为了避免改变自举代码而需要改变ROM硬件的问题，通常只在ROM中保留很小的自举装入程序，而将完整功能的引导程序保存在磁盘的启动块上，启动块位于磁盘的固定位置。具有启动分区的磁盘称为启动磁盘或系统磁盘。</p><ul><li><p>Windows允许将磁盘分为多个分区，有一个分区为引导分区，它包含操作系统和设备驱动程序。</p></li><li><p>Windows系统将引导代码存储在磁盘的第0号扇区，它称为主引导记录（MBR）。</p></li><li><p>引导首先运行ROM中的代码，这个代码指示系统从MBR中读取引导代码。</p><p>除了包含引导代码，MBR还包含：一个磁盘分区表和一个标志（以指示从哪个分区引导系统）</p></li><li><p>当系统找到引导分区时，读取分区的第一个扇区，称为引导扇区，并继续余下的引导过程，包括加载各种系统服务。</p></li></ul></li><li><p>坏块</p><p>由于磁盘有移动部件且容错能力弱，因此容易导致一个或多个扇区损坏。</p><ul><li>对于简单磁盘，如采用IDE控制器的磁盘，坏块可手动处理，如MS-DOS的Format命令执行逻辑格式化时会扫描磁盘以检查坏块。坏块在FAT表上会标明，因此程序不会使用它们。</li><li>对于复杂的磁盘，控制器维护磁盘内的坏块列表。这个列表在出厂低级格式化时就已初始化，并在磁盘的使用过程中不断更新。低级格式化将一些块保留作为备用，操作系统看不到这些块。<br>控制器可以采用备用块来逻辑地替代坏块，这种方案称为扇区备用。</li></ul><p>对坏块的处理实质上就是用某种机制使系统不去使用坏块。</p></li><li><p>减少磁盘延迟时间的方法</p><ul><li>磁盘地址结构的设计：<ul><li>为什么磁盘的物理地址是（柱面号，盘面号，扇区号）而不是（盘面号，柱面号，扇区号）？</li><li>答：读取地址连续的磁盘块时，采用这样的的地址结构可以减少磁头移动消耗的时间</li></ul></li><li>方法<ul><li>交替编号<ul><li>具体做法：让编号相邻的扇区在物理上不相邻</li><li>原理：磁头读入一个扇区数据后需要一小段时间处理，如果逻辑上相邻的扇区在物理上也相邻，则读入几个连续的逻辑扇区，可能需要很长的“延迟时间”</li></ul></li><li>错位命名<ul><li>具体做法：让相邻盘面的扇区编号”错位”</li><li>原理：与”交替编号”的原理相同。“错位命名法”可降低延迟时间</li></ul></li></ul></li></ul></li></ol><h4 id="5-3-3-磁盘调度算法"><a href="#5-3-3-磁盘调度算法" class="headerlink" title="5.3.3 磁盘调度算法"></a>5.3.3 磁盘调度算法</h4><ol><li><p><strong>先来先服务（FCFS）</strong></p><p>根据进程请求访问磁盘的先后顺序进行调度。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230922090407192.png" alt="image-20230922090407192"></p><ul><li>优点：公平；如果请求访问的磁道比较集中的话，算法性能还算过的去</li><li>缺点：如果有大量进程竞争使用磁盘，请求访问的磁道很分散，则FCFS在性能上很差，寻道时间长。</li></ul></li><li><p><strong>最短寻找时间优先（SSTF）</strong></p><p>SSTF算法会优先处理的磁道是与当前磁头最近的磁道。可以保证每次的寻道时间最短，但是并不能保证总的寻道时间最短。（其实就是贪心算法的思想，只是选择眼前最优，但是总体未必最优）</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230922090856029.png" alt="image-20230922090856029"></p><ul><li><p>优点：性能较好，平均寻道时间短</p></li><li><p>缺点：可能产生“饥饿”现象，磁头有可能在一个小区域内来回来去地移动。</p><blockquote><p>Eg：本例中，如果在处理18号磁道的访问请求时又来了一个38号磁道的访问请求，处理38号磁道的访问请求时又来了一个18号磁道的访问请求。如果有源源不断的18号、38号磁道的访问请求到来的话，150、160、184号磁道的访问请求就永远得不到满足，从而产生“饥饿”现象。</p></blockquote></li></ul></li><li><p><strong>扫描算法（SCAN）</strong></p><p>又称电梯算法，只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移动。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230922091629172.png" alt="image-20230922091629172"></p><ul><li>优点：性能较好，平均寻道时间较短，不会产生饥饿现象</li><li>缺点：<ul><li>①只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了184号磁道的访问请求之后就不需要再往右移动磁头了。</li><li>②SCAN算法对于各个位置磁道的响应频率不平均（如：假设此时磁头正在往右移动，且刚处理过90号磁道，那么下次处理90号磁道的请求就需要等磁头移动很长一段距离；而响应了184号磁道的请求之后，很快又可以再次响应184号磁道的请求了）</li></ul></li></ul></li><li><p><strong>LOOK调度算法</strong></p><p>如果在磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向。（边移动边观察，因此叫 LOOK）</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230922092519102.png" alt="image-20230922092519102"></p><ul><li>优点：比起SCAN算法来，不需要每次都移动到最外侧或最内侧才改变磁头方向，使寻道时间进一步缩短</li></ul></li><li><p><strong>循环扫描算法（C-SCAN）</strong></p><p>只有磁头朝某个特定方向移动时才处理磁道访问请求，而返回时直接快速移动至起始端而不处理任何请求。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230922092744277.png" alt="image-20230922092744277"></p><ul><li>优点：比起SCAN来，对于各个位置磁道的响应频率很平均。</li><li>缺点：只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了184号磁道的访问请求之后就不需要再往右移动磁头了；并且，磁头返回时其实只需要返回到18号磁道即可，不需要返回到最边缘的磁道。另外，比起SCAN算法来，平均寻道时间更长。</li></ul></li><li><p><strong>C-LOOK 调度算法</strong></p><p>如果磁头移动的方向上已经没有磁道访问请求了，就可以立即让磁头返回，并且磁头只需要返回到有磁道访问请求的位置即可。</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230922092846866.png" alt="image-20230922092846866"></p><ul><li>优点：比起C-SCAN算法，不需要每次都移动到最外侧或最内侧才改变磁头方向，使寻道时间进一步缩短</li></ul></li></ol><h4 id="5-3-4-固态硬盘"><a href="#5-3-4-固态硬盘" class="headerlink" title="5.3.4 固态硬盘"></a>5.3.4 固态硬盘</h4><ol><li><p>固态硬盘的特性</p><ul><li><p>原理：固态硬盘(SSD)是基于闪存技术Flash Memory，属于电可擦除ROM，即EEPROM</p></li><li><p>组成：</p><p><img src="https://raw.githubusercontent.com/ZzDarker/figure/main/img/image-20230922093902941.png" alt="image"></p><ul><li>闪存翻译层：负责翻译逻辑块号，找到对应页（Page）</li><li>存储介质：多个闪存芯片（Flash Chip）；每个芯片包含多个块（block）；每个块包含多个页（page）。</li></ul></li><li><p>读写性能特性：</p><ul><li>数据是以页为单位读写的。相当于磁盘的“扇区”</li><li>以块（bock）为单位“擦除“，擦干净的块，其中的每页都可以写一次，读无限次。</li><li>支持随机访问，系统给定一个逻辑地址，闪存翻译层可通过电路迅速定位到对应的物理地址</li><li>读快、写慢。要写的页如果有数据，则不能写入，需要将块内其他页全部复制到一个新的（擦除过的）块中，再写入新的页</li></ul></li><li><p>与机械硬盘对比</p><ul><li>SSD读写速度快，随机访问性能高，用电路控制访问位置；机诚硬盘通过移动磁臂旋转磁盘控制访问位置，有寻道时间和旋转延迟</li><li>SSD安静无噪音、耐摔抗震、能耗低、造价更贵</li><li>SSD的一个”块”被擦除次数过多（重复写同一个块）可能会坏掉，而机械硬盘的扇区不会因为写的次数太多而坏掉</li></ul></li></ul></li><li><p>磨碎均衡</p><p>思想：将“擦除”平均分布在各个块上，以提升使用寿命</p><ul><li>动态磨损均衡：写入数据时，优先选择累计擦除次数少的新闪存块。</li><li>静态磨损均衡：SSD监测并自动进行数据分配、迁移，让老旧的闪存块承担以读为主的储存任务，让较新的闪存块承担更多的写任务</li></ul><blockquote><p>例：某固态硬盘采用磨损均衡技术，大小为240B&#x3D;1TB，闪存块的擦写寿命只有210&#x3D;1K次。某男子平均每天会对该固态硬盘写237B&#x3D;128GB数据。在最理想的情况下，这个固态硬盘可以用多久？</p><p>SSD采用磨损均衡技术，最理想情况下，SSD中每个块被擦除的次数都是完全均衡的。<br>$$<br>1T&#x2F;128G&#x3D;8<br>$$<br>因此，平均8天，每个闪存块需要擦除一次。</p><p>每个闪存块可以被擦除1K次，因此经过8K天，约23年，固态使用到寿命。</p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> CS核心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈谈教师</title>
      <link href="/posts/a1116f6.html"/>
      <url>/posts/a1116f6.html</url>
      
        <content type="html"><![CDATA[<p><strong>本文由一位Microsoft工程师创作。</strong></p><p><strong>注：本文的“teacher”不含国外教师，属于特指。</strong></p><p>“成绩优等”的人，老师不会针对，但“成绩差”的人，老师疯狂针对。貌似咱们的老师喜欢“成绩好”的，不喜欢“成绩差”的，而这种不公正的待遇，竟然持续了数年。成绩“差”的学生，TA也是一个完整的人，TA理应被老师尊重，TA不应受到这种待遇。然而遗憾的是，即便是你成绩再“优异”，有时候，你也无法避免遭受老师的侮辱。然而究竟什么是“优“，貌似是没有固定客观答案的，因为每一个人都有所擅长的点，而这种所谓的“优”只不过是老师的一面之词罢了，即一位老师说一个人是“优”，那么这个人必定为“优”，这完全是……</p><blockquote><p>那些没能力学习的人都去当老师了 —— 奥斯卡·王尔德</p></blockquote><blockquote><p>如果他们给了你画好线的纸，不要按着线写。 —— [西班牙] 胡安·拉蒙·希门尼斯 1956年诺贝尔文学奖获得者</p></blockquote><blockquote><p>瞎子岂能领瞎子，两个人不是都要掉在坑里吗？ 学生不高过老师，凡学成了的会和老师一样。 —— 圣经，路加福音6:39</p></blockquote><p>责任和能力<br>所有人他妈都在告诉你：</p><p>“你可能在人生里，可能会遇到几个有责任的老师。</p><p>你要心怀感激，因为他们一定教会了你什么。</p><p>并且你要从心里上尊重他，因为他教会了你从没接触过的东西。”</p><p>是这样吗？哈哈哈！</p><p>我告诉你真相：</p><p><strong>责任和能力毫无关系</strong></p><p>我鼓励你尊重那些真的教会你东西的老师，但请你注意，责任和能力毫无关系，TA可能是一位非常有责任心的老师，但TA很有可能是无能之辈，还希望你认清这一点。</p><p><strong>大多数情况下，如果TA有能力，TA就不会在学校里当老师教你。</strong></p><p>除非TA大公无私，放弃了很多，想为中国教育做些什么，并且努力提升自我，只为改变中国教育……我不排除有这种人——TA明白自己能力不足，虚心听我批评了这些，但有些人不同，TA不承认自己能力不足，还祸害学生。</p><p>顺便说一句，我不是这种人的范畴内，所以不要把我当作老师来评价。因为第一，我不是老师，我是个退休的程序员；其次，写这本书的时候，我的角色是个作家。我不曾教你任何东西，你之所以看这本书，是因为您求知的欲望，我只是把事实写下来，想让更多人明白事实而已。</p><p>如果你是老师，看到这篇文章，请你注意，你可能是个有责任的老师，但同样，如果你的能力很弱，就不要装作什么都懂，不然你会适得其反，将你的学生推到一个无底深渊。</p><p>因此，</p><p>应该受到能力培训教育的是老师，</p><p>而不是学生。</p><p>我从我的老师那里学到了什么<br>幼儿园老师给我的评语：“一无是处的懒人、废物，你将一事无成。”</p><p>现在看来，她的孩子应该是这样。而我活出的样子和她的评语恰恰相反，这让我突然想笑，而且是得意的那种。</p><p>小学语文老师给我的评语：“愿我用双手，撑起一片天空。”</p><p>我的初中数学老师没有教会我算账，她是个喜欢用嘴打架的人，自认为口才很好，而我从她身上学到的是：</p><p>“如果你要做老师，就要学会用嘴忽悠家长。”</p><p>我的评价是，那点数学知识不如菜市场的老妈妈骗你学得快。</p><p>幸好我学会了但没用它，因我不是老师。</p><p>我的初中音乐老师没教会我怎么唱歌，但她看到我听李斯特的《爱之梦》，还批评我：</p><p>“李斯特的《爱之梦》是你该听的吗？”（言外之意就是：“你个没学过音乐的小孩也配听？也配欣赏？你能欣赏懂？”）</p><p>你觉得和你成绩有关吗？你在人生路上，总会遇到无数个过分的老师，让你又喜又悲，你是应该感谢她，还是应该憎恨她？</p><p>于是我从她身上学到的是：“我喜欢的，跟你没半毛钱关系，我热爱我的，你热爱你的，你的评价不会对我造成影响。”</p><p>我的初中英文老师没有教会我一句英文，如果非要说我从初中英文老师那里学到了什么：</p><p>“没有最好，只有更好。”</p><p>我可以大言不惭的说，我的高中英文老师也没有教我一句英文，但他教会我：</p><p>“没有舍，就没有得。”</p><p>我的高中英文老师的妻子（一位音乐老师）教会了我两个字：</p><p>“感恩”</p><p>我也没在大学老师那里学到任何有关专业的东西，印象深刻中，我从我的一个导师身上只学到了：“与其抱怨，不如改变。”</p><p>……</p><p><strong>那些想当老师的人，你们还是去提升下自己吧，免得侮辱这个职业尊称。</strong></p><p><strong>如果你人生路上，没遇到过这种坑爹的老师，那我就得祝贺你了，但并不是每个人都如此幸运，我希望你明白这一点。</strong></p><p><strong>我不知道我上这么多年学，从老师那学到了啥。很多人都说我们是高材生，是状元生，我们很会舔学校的老师，我们往往是学校老师最得意的门生，实际上我与他们不同，我背地里骂还是比较多。我考上大学，去外企工作的一切知识，都是我一个人自己学来的，和老师根本没关系。TA们教的东西，往往是和现实脱轨的，不提是否有效：既不能让我去名校，也不能让我去外企，更不能让我发财……恰恰搞笑的是，这些都和九年义务教育的内容完全无关。至今我都觉得人生的前25年在国内学校里完全是浪费时间。</strong></p><p>不论你以后是否要做老师，我总结从TA们身上学到的东西，或许这个是最准确之说法：</p><p>不要重蹈“TA们”的覆辙！</p><p>写到这，估计很多人会疯狂大笑，但自己仔细想想，确实如此。</p><p><strong>一个永远都不会错的老师</strong><br><strong>这个世界最荒谬的事情莫过于此，人们总是相信自己老师说的话。</strong></p><p>人们可以尊重老师，但人们不要过分地相信自己的老师。老师也是人，人必然会犯错。</p><p>所有人都会告诉你： “你要听老师的话！老师是对你好！老师怎么教你，你就怎么做！老师不教的，你就不要学！老师教不会的，肯定是你笨！你怎么能质疑你的老师，再怎样TA也比你强！……”</p><p>然而我告诉你：</p><p><strong>听老师的？这真的是一种很搞笑的教育，你所做的一切的努力，最终就是相信一个永远都不会错的老师？这是什么狗屁逻辑？你们管这玩意儿叫教育？</strong></p><p><strong>如果你们老师说得对，TA不应该在讲台上，TA应该做着其它的事情。</strong></p><p><strong>真正的教育从业者，绝不是寻找一个铁饭碗体制的工作。那些靠国家教育单位混饭吃的老师，TA们毫无教育观念，也不从未有过想改变过什么，也不会想着怎么能教好学生，哪怕是为其思考过一秒。</strong></p><p><strong>如果你老师说的对，那么TA不应该在教书，TA至少应该活成了你想成为的那种人，但那种人绝不是TA——教师。</strong></p><p>如果你听了TA的，那么，你会成为TA。</p><p><strong>我经常对IT类大学生说这么一句话：</strong></p><p><strong>如果你老师说的对，那你的老师不应该在大学里教你，此时应该在谷歌公司研究新科技。</strong></p><p><strong>你听他的，除非你也想当大学老师，不然就是闲着没事找事。</strong></p><p>再次引用：</p><blockquote><p>那些没能力学习的人都去当老师了 —— 奥斯卡·王尔德</p></blockquote><p>你的老师告诉你牛顿讲过一句话：“站在巨人的肩膀上。”</p><p>实际上，他连👆这句话都骗了你，你好好看看原话：</p><p><strong>我宁愿站在巨人的肩膀上而不是他们的阴影中，因为那样我可以看得更远。—— 艾萨克·牛顿</strong></p><p>我还记得我以前初中数学老师开家长会，她说，隔壁班老师的儿子，明明考了211，然后不满意，又复读考，然后考了985，不满意，然后继续考，又想考名流985。就这样晃悠过了4年，意思很明显想和家长们表达——这种精神值得学习。</p><p>我站后面，我心想，“这他妈不是傻缺、傻*？”</p><p>为什么他不一次性考上北大？难道我们家长不希望让孩子一次性考上？</p><p>这就类似于，谈一个对象睡了分，谈一个对象睡了分，睡了四个女孩都怀孕了，然后办了离婚手续，最终您的孩子没有结婚，妻离子散，财产被分光，孩子抚养权还被拿走。</p><p>我的老师是在鼓励我们家长应该教育小孩考上了也得复读？还是考上了也不满意？我严重怀疑他母亲（隔壁班主任）的智商，我更怀疑他本人的智商。</p><p>看样子他提前知道自己要失败然后准备复读了？！或者说，这小哥根本不知道自己要读什么学校，就是瞎凑热闹，要么就是为了证明自己，可这也说不过去，证明什么呢？证明自己复读能力比别人强？我可以理解为，这家伙根本不知道什么叫大学？也没有目标？也没自己想读的专业？</p><p>北大清华都不是最好的。如果您的孩子想学医学，说不定北大医学院是个不错的选择，那复旦也是个不错的选择；如果您的孩子想学金融，说不定清华是个不错的选择；如果您的孩子是想学焊接，那肯定不是我们镇上的职业院校好，而是哈尔滨工业大学…… 我可以直接理解为，这家伙根本不知道自己要干啥，他太乐意听爸妈的话了，一直在考，于是忘记了为什么要复读。您的孩子可以考不上理想的学校，但不至于没有目的性的去考，比985好的学校很多，比如哈佛还等着你呢，你去考呗！我看你复读多少年能考上。</p><p>你们不要听老师胡扯，我不鼓励你们复读，我鼓励你全力以赴一次考上自己理想的学校，我更鼓励你建立属于自己的真正目标，考不考得上其实都不重要。还记得范进中举吗？咱们的老师，在给我们家长重新讲了一遍现代版的“范进中举”。另外如果老师说的对，最终就不会在这里教书了，如果老师说的对，她或许不知道在哪上班 —— 而一定不是站在讲台上——和你们说隔壁班老师的儿子的故事，况且 —— 还如此的愚蠢、多余。</p><p>如果你们想让自己的孩子今后也站在讲台上——像我们的初中班主任这样，给你们天天讲故事，那你就尽管相信她这种人说的话吧。看看你们自己，每天为生活工作奔波，都是因为听你老师的话、听你父母的话导致的。</p><p>你们其中没有一个人是例外的，原本你们可以做自己，原本你们可以过上属于更好的生活，但你们为了服从命令而作出了妥协！</p><p>再次引用：</p><blockquote><p>瞎子岂能领瞎子，两个人不是都要掉在坑里吗？ 学生不高过老师，凡学成了的会和老师一样。 —— 圣经，路加福音6:39</p></blockquote><p>谁教了你的老师？<br>很显然，是你老师的老师。</p><p>再次疑问重要的东西，你能从老师那学到什么教训吗？</p><p><strong>答：千万不要重蹈“TA们”的覆辙！</strong></p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Data Structure and Algorithm</title>
      <link href="/posts/dfa2d520.html"/>
      <url>/posts/dfa2d520.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-初识算法"><a href="#一-初识算法" class="headerlink" title="一. 初识算法"></a>一. 初识算法</h1><h2 id="1-1-什么是算法？"><a href="#1-1-什么是算法？" class="headerlink" title="1.1 什么是算法？"></a>1.1 什么是算法？</h2><p><strong>定义</strong></p><p>在数学和计算机科学领域，算法是一系列有限的严谨指令，通常用于解决一类特定问题或执行计算</p><blockquote><p>In mathematics and computer science, an <strong>algorithm</strong> (&#x2F;ˈælɡərɪðəm&#x2F;) is a finite sequence of rigorous instructions, typically used to solve a class of specific problems or to perform a computation.[^1]</p></blockquote><p><strong>Introduction to Algorithm[^2]</strong></p><p>不正式的说，算法就是任何定义优良的计算过程：接收一些值作为输入，在有限的时间内，产生一些值作为输出。</p><blockquote><p>Informally, an algorithm is any well-defined computational procedure that takes some value, or set of values, as input and produces some value, or set of values, as output in a finite amount of time.</p></blockquote><h2 id="1-2-什么是数据结构？"><a href="#1-2-什么是数据结构？" class="headerlink" title="1.2 什么是数据结构？"></a>1.2 什么是数据结构？</h2><p><strong>定义</strong></p><p>在计算机科学领域，数据结构是一种数据组织、管理和存储格式，通常被选择用来高效访问数据</p><blockquote><p>In computer science, a <strong>data structure</strong> is a data organization, management, and storage format that is usually chosen for efficient access to data</p></blockquote><p><strong>Introduction to Algorithm[^2]</strong></p><p>数据结构是一种存储和组织数据的方式，旨在便于访问和修改</p><blockquote><p>A data structure is a way to store and organize data in order to facilitate access and modifications</p></blockquote><p>可以说，<strong>程序 &#x3D; 数据结构 + 算法</strong>，它们是每一位程序员的基本功，下来我们通过对一个非常著名的二分查找算法的讲解来认识一下算法</p><h2 id="1-3-二分查找-3"><a href="#1-3-二分查找-3" class="headerlink" title="1.3 二分查找 [^3]"></a>1.3 二分查找 [^3]</h2><p>二分查找算法也称折半查找，是一种非常高效的工作于有序数组的查找算法。后续的课程中还会学习更多的查找算法，但在此之前，不妨用它作为入门。</p><h3 id="1-基础版"><a href="#1-基础版" class="headerlink" title="1) 基础版"></a>1) 基础版</h3><p>需求：在<strong>有序</strong>数组 $A$ 内，查找值 $target$</p><ul><li>如果找到返回索引</li><li>如果找不到返回 $-1$</li></ul><p>算法描述</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>前提</td><td>给定一个内含 $n$ 个元素的有序数组 $A$，满足 $A_{0}\leq A_{1}\leq A_{2}\leq \cdots \leq A_{n-1}$，一个待查值 $target$</td></tr><tr><td>1</td><td>设置 $i&#x3D;0$，$j&#x3D;n-1$</td></tr><tr><td>2</td><td>如果 $i \gt j$，结束查找，没找到</td></tr><tr><td>3</td><td>设置 $m &#x3D; floor(\frac {i+j}{2})$ ，$m$ 为中间索引，$floor$ 是向下取整（$\leq \frac {i+j}{2}$ 的最小整数）</td></tr><tr><td>4</td><td>如果 $target &lt; A_{m}$ 设置 $j &#x3D; m - 1$，跳到第2步</td></tr><tr><td>5</td><td>如果 $A_{m} &lt; target$ 设置 $i &#x3D; m + 1$，跳到第2步</td></tr><tr><td>6</td><td>如果 $A_{m} &#x3D; target$，结束查找，找到了</td></tr></tbody></table><blockquote><p><em><strong>P.S.</strong></em></p><ul><li>对于一个算法来讲，都有较为严谨的描述，上面是一个例子</li><li>后续讲解时，以简明直白为目标，不会总以上面的方式来描述算法</li></ul></blockquote><p>java 实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = a.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; a[m]) &#123;<span class="comment">// 在左边</span></span><br><span class="line">            j = m - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[m] &lt; target) &#123;<span class="comment">// 在右边</span></span><br><span class="line">            i = m + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>$i,j$ 对应着搜索区间 $[0,a.length-1]$（注意是闭合的区间），$i&lt;&#x3D;j$ 意味着搜索区间内还有未比较的元素，$i,j$ 指向的元素也可能是比较的目标<ul><li>思考：如果不加 $i&#x3D;&#x3D;j$ 行不行？</li><li>回答：不行，因为这意味着 $i,j$ 指向的元素会漏过比较</li></ul></li><li>$m$ 对应着中间位置，中间位置左边和右边的元素可能不相等（差一个），不会影响结果</li><li>如果某次未找到，那么缩小后的区间内不包含 $m$</li></ul><h3 id="2-改变版"><a href="#2-改变版" class="headerlink" title="2) 改变版"></a>2) 改变版</h3><p>另一种写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = a.length;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; a[m]) &#123;<span class="comment">// 在左边</span></span><br><span class="line">            j = m;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[m] &lt; target) &#123;<span class="comment">// 在右边</span></span><br><span class="line">            i = m + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>$i,j$ 对应着搜索区间 $[0,a.length)$（注意是左闭右开的区间），$i&lt;j$ 意味着搜索区间内还有未比较的元素，$j$ 指向的<strong>一定不是</strong>查找目标<ul><li>思考：为啥这次不加 $i&#x3D;&#x3D;j$ 的条件了？</li><li>回答：这回 $j$ 指向的不是查找目标，如果还加 $i&#x3D;&#x3D;j$ 条件，就意味着 $j$ 指向的还会再次比较，找不到时，会死循环</li></ul></li><li>如果某次要缩小右边界，那么 $j&#x3D;m$，因为此时的 $m$ 已经<strong>不是</strong>查找目标了</li></ul><h2 id="1-4-衡量算法好坏"><a href="#1-4-衡量算法好坏" class="headerlink" title="1.4 衡量算法好坏"></a>1.4 衡量算法好坏</h2><p><strong>时间复杂度</strong></p><p>下面的查找算法也能得出与之前二分查找一样的结果，那你能说出它差在哪里吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        i &lt; a.length;</span><br><span class="line">        i++</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == k) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑最坏情况下（没找到）例如 <code>[1,2,3,4]</code> 查找 5</p><ul><li><code>int i = 0</code> 只执行一次</li><li><code>i &lt; a.length</code> 受数组元素个数 $n$ 的影响，比较 $n+1$ 次</li><li><code>i++</code> 受数组元素个数 $n$ 的影响，自增 $n$ 次</li><li><code>a[i] == k</code> 受元素个数 $n$ 的影响，比较 $n$ 次</li><li><code>return -1</code>，执行一次</li></ul><p>粗略认为每行代码执行时间是 $t$，假设 $n&#x3D;4$ 那么</p><ul><li>总执行时间是 $(1+4+1+4+4+1)*t &#x3D; 15t$</li><li>可以推导出更一般地公式为，$T &#x3D; (3*n+3)t$</li></ul><p>如果套用二分查找算法，还是 <code>[1,2,3,4]</code> 查找 5</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = a.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; a[m]) &#123;<span class="comment">// 在左边</span></span><br><span class="line">            j = m - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[m] &lt; target) &#123;<span class="comment">// 在右边</span></span><br><span class="line">            i = m + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>int i = 0, j = a.length - 1</code> 各执行 1 次</p></li><li><p><code>i &lt;= j</code> 比较 $floor(\log_{2}(n)+1)$ 再加 1 次</p></li><li><p><code>(i + j) &gt;&gt;&gt; 1</code> 计算 $floor(\log_{2}(n)+1)$ 次</p></li><li><p>接下来 <code>if() else if() else</code> 会执行 $3* floor(\log_{2}(n)+1)$ 次，分别为</p><ul><li>if 比较</li><li>else if 比较</li><li>else if 比较成立后的赋值语句</li></ul></li><li><p><code>return -1</code>，执行一次</p></li></ul><p>结果：</p><ul><li>总执行时间为 $(2 + (1+3) + 3 + 3 * 3 +1)*t &#x3D; 19t$</li><li>更一般地公式为 $(4 + 5 * floor(\log_{2}(n)+1))*t$</li></ul><blockquote><p><strong>注意：</strong></p><p>左侧未找到和右侧未找到结果不一样，这里不做分析</p></blockquote><p>两个算法比较，可以看到 $n$ 在较小的时候，二者花费的次数差不多</p><img src="https://bu.dusays.com/2024/11/16/6737f8d096d94.png" alt="image-20221108095747933.png" style="zoom:50%;" /><p>但随着 $n$ 越来越大，比如说 $n&#x3D;1000$ 时，用二分查找算法（红色）也就是 $54t$，而蓝色算法则需要 $3003t$</p><img src="https://bu.dusays.com/2024/11/16/6737f8d0985d6.png" alt="image-20221108100014451.png" style="zoom:50%;" /><blockquote><p>画图采用的是 <a href="https://www.desmos.com/calculator?lang=zh-CN">Desmos | 图形计算器</a></p></blockquote><p>计算机科学中，<strong>时间复杂度</strong>是用来衡量：一个算法的执行，随数据规模增大，而增长的时间成本</p><ul><li>不依赖于环境因素</li></ul><p>如何表示时间复杂度呢？</p><ul><li><p>假设算法要处理的数据规模是 $n$，代码总的执行行数用函数 $f(n)$ 来表示，例如：</p><ul><li>线性查找算法的函数 $f(n) &#x3D; 3*n + 3$</li><li>二分查找算法的函数 $f(n) &#x3D; (floor(log_2(n)) + 1) * 5 + 4$</li></ul></li><li><p>为了对 $f(n)$ 进行化简，应当抓住主要矛盾，找到一个变化趋势与之相近的表示法</p></li></ul><p><strong>大 $O$ 表示法[^4]</strong></p><p><img src="https://bu.dusays.com/2024/11/16/6737f8d18bb55.png" alt="image-20221108103846566.png"></p><p>其中</p><ul><li>$c, c_1, c_2$ 都为一个常数</li><li>$f(n)$ 是实际执行代码行数与 n 的函数</li><li>$g(n)$ 是经过化简，变化趋势与 $f(n)$ 一致的 n 的函数</li></ul><p><strong>渐进上界</strong></p><p>渐进上界（asymptotic upper bound）：从某个常数 $n_0$开始，$c*g(n)$ 总是位于 $f(n)$ 上方，那么记作 $O(g(n))$</p><ul><li>代表算法执行的最差情况</li></ul><p>例1</p><ul><li>$f(n) &#x3D; 3*n+3$ </li><li>$g(n) &#x3D; n$</li><li>取 $c&#x3D;4$，在$n_0&#x3D;3$ 之后，$g(n)$ 可以作为 $f(n)$ 的渐进上界，因此表示法写作 $O(n)$</li></ul><p>例2</p><ul><li>$f(n) &#x3D; 5*floor(log_2(n)) + 9$</li><li>$g(n) &#x3D; log_2(n)$</li><li>$O(log_2(n))$</li></ul><p>已知 $f(n)$ 来说，求 $g(n)$</p><ul><li>表达式中相乘的常量，可以省略，如<ul><li>$f(n) &#x3D; 100*n^2$ 中的 $100$</li></ul></li><li>多项式中数量规模更小（低次项）的表达式，如<ul><li>$f(n)&#x3D;n^2+n$ 中的 $n$</li><li>$f(n) &#x3D; n^3 + n^2$ 中的 $n^2$</li></ul></li><li>不同底数的对数，渐进上界可以用一个对数函数 $\log n$ 表示<ul><li>例如：$log_2(n)$ 可以替换为 $log_{10}(n)$，因为 $log_2(n) &#x3D; \frac{log_{10}(n)}{log_{10}(2)}$，相乘的常量 $\frac{1}{log_{10}(2)}$ 可以省略</li></ul></li><li>类似的，对数的常数次幂可省略<ul><li>如：$log(n^c) &#x3D; c * log(n)$</li></ul></li></ul><p><strong>常见大 $O$ 表示法</strong></p><p><img src="https://bu.dusays.com/2024/11/16/6737f8e9c50db.png" alt="image-20221108114915524.png"></p><p> 按时间复杂度从低到高</p><ul><li>黑色横线 $O(1)$，常量时间，意味着算法时间并不随数据规模而变化</li><li>绿色 $O(log(n))$，对数时间</li><li>蓝色 $O(n)$，线性时间，算法时间与数据规模成正比</li><li>橙色 $O(n*log(n))$，拟线性时间</li><li>红色 $O(n^2)$ 平方时间</li><li>黑色朝上 $O(2^n)$ 指数时间</li><li>没画出来的 $O(n!)$</li></ul><p><strong>渐进下界</strong></p><p>渐进下界（asymptotic lower bound）：从某个常数 $n_0$开始，$c*g(n)$ 总是位于 $f(n)$ 下方，那么记作 $\Omega(g(n))$</p><p><strong>渐进紧界</strong></p><p>渐进紧界（asymptotic tight bounds）：从某个常数 $n_0$开始，$f(n)$ 总是在 $c_1<em>g(n)$ 和 $c_2</em>g(n)$ 之间，那么记作 $\Theta(g(n))$</p><p><strong>空间复杂度</strong></p><p>与时间复杂度类似，一般也使用大 $O$ 表示法来衡量：一个算法执行随数据规模增大，而增长的<strong>额外</strong>空间成本</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearchBasic</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = a.length - <span class="number">1</span>;    <span class="comment">// 设置指针和初值</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;                <span class="comment">// i~j 范围内有东西</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; a[m]) &#123;         <span class="comment">// 目标在左边</span></span><br><span class="line">            j = m - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[m] &lt; target) &#123; <span class="comment">// 目标在右边</span></span><br><span class="line">            i = m + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                    <span class="comment">// 找到了</span></span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>二分查找性能</strong></p><p>下面分析二分查找算法的性能</p><p>时间复杂度</p><ul><li>最坏情况：$O(\log n)$</li><li>最好情况：如果待查找元素恰好在数组中央，只需要循环一次 $O(1)$</li></ul><p>空间复杂度</p><ul><li>需要常数个指针 $i,j,m$，因此额外占用的空间是 $O(1)$</li></ul><h2 id="1-5-再看二分查找"><a href="#1-5-再看二分查找" class="headerlink" title="1.5 再看二分查找"></a>1.5 再看二分查找</h2><h3 id="1-平衡版"><a href="#1-平衡版" class="headerlink" title="1) 平衡版"></a>1) 平衡版</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearchBalance</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = a.length;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span> &lt; j - i) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; a[m]) &#123;</span><br><span class="line">            j = m;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i = m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (a[i] == target) ? i : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思想：</p><ol><li>左闭右开的区间，$i$ 指向的可能是目标，而 $j$ 指向的不是目标</li><li>不奢望循环内通过 $m$ 找出目标, 缩小区间直至剩 1 个, 剩下的这个可能就是要找的（通过 $i$）<ul><li>$j - i &gt; 1$ 的含义是，在范围内待比较的元素个数 &gt; 1</li></ul></li><li>改变 $i$ 边界时，它指向的可能是目标，因此不能 $m+1$</li><li>循环内的平均比较次数减少了</li><li>时间复杂度 $\Theta(log(n))$</li></ol><h3 id="2-Java-版"><a href="#2-Java-版" class="headerlink" title="2) Java 版"></a>2) Java 版</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch0</span><span class="params">(<span class="type">long</span>[] a, <span class="type">int</span> fromIndex, <span class="type">int</span> toIndex,</span></span><br><span class="line"><span class="params">                                     <span class="type">long</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> fromIndex;</span><br><span class="line">    <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> toIndex - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (low + high) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">midVal</span> <span class="operator">=</span> a[mid];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (midVal &lt; key)</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (midVal &gt; key)</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> mid; <span class="comment">// key found</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -(low + <span class="number">1</span>);  <span class="comment">// key not found.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>例如 $[1,3,5,6]$ 要插入 $2$ 那么就是找到一个位置，这个位置左侧元素都比它小<ul><li>等循环结束，若没找到，low 左侧元素肯定都比 target 小，因此 low 即插入点</li></ul></li><li>插入点取负是为了与找到情况区分</li><li>-1 是为了把索引 0 位置的插入点与找到的情况进行区分</li></ul><h3 id="3-Leftmost-与-Rightmost"><a href="#3-Leftmost-与-Rightmost" class="headerlink" title="3) Leftmost 与 Rightmost"></a>3) Leftmost 与 Rightmost</h3><p>有时我们希望返回的是最左侧的重复元素，如果用 Basic 二分查找</p><ul><li><p>对于数组 $[1, 2, 3, 4, 4, 5, 6, 7]$，查找元素4，结果是索引3</p></li><li><p>对于数组 $[1, 2, 4, 4, 4, 5, 6, 7]$，查找元素4，结果也是索引3，并不是最左侧的元素</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearchLeftmost1</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = a.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">candidate</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; a[m]) &#123;</span><br><span class="line">            j = m - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[m] &lt; target) &#123;</span><br><span class="line">            i = m + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            candidate = m; <span class="comment">// 记录候选位置</span></span><br><span class="line">            j = m - <span class="number">1</span>;     <span class="comment">// 继续向左</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> candidate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果希望返回的是最右侧元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearchRightmost1</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = a.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">candidate</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; a[m]) &#123;</span><br><span class="line">            j = m - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[m] &lt; target) &#123;</span><br><span class="line">            i = m + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            candidate = m; <span class="comment">// 记录候选位置</span></span><br><span class="line">            i = m + <span class="number">1</span>;   <span class="comment">// 继续向右</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> candidate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>应用</strong></p><p>对于 Leftmost 与 Rightmost，可以返回一个比 -1 更有用的值</p><p>Leftmost 改为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearchLeftmost</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = a.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt;= a[m]) &#123;</span><br><span class="line">            j = m - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i = m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>leftmost 返回值的另一层含义：$\lt target$ 的元素个数</li><li>小于等于中间值，都要向左找</li></ul><p>Rightmost 改为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearchRightmost</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = a.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; a[m]) &#123;</span><br><span class="line">            j = m - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i = m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>大于等于中间值，都要向右找</li></ul><p>几个名词</p><p><img src="https://bu.dusays.com/2024/11/16/6737f8d2b4595.png" alt="image-20221125174155058.png"></p><p><strong>范围查询</strong>：</p><ul><li>查询 $x \lt 4$，$0 .. leftmost(4) - 1$</li><li>查询 $x \leq 4$，$0 .. rightmost(4)$</li><li>查询 $4 \lt x$，$rightmost(4) + 1 .. \infty $</li><li>查询 $4 \leq x$， $leftmost(4) .. \infty$</li><li>查询 $4 \leq x \leq 7$，$leftmost(4) .. rightmost(7)$</li><li>查询 $4 \lt x \lt 7$，$rightmost(4)+1 .. leftmost(7)-1$</li></ul><p><strong>求排名</strong>：$leftmost(target) + 1$</p><ul><li>$target$ 可以不存在，如：$leftmost(5)+1 &#x3D; 6$</li><li>$target$ 也可以存在，如：$leftmost(4)+1 &#x3D; 3$</li></ul><p><strong>求前任（predecessor）</strong>：$leftmost(target) - 1$</p><ul><li>$leftmost(3) - 1 &#x3D; 1$，前任 $a_1 &#x3D; 2$</li><li>$leftmost(4) - 1 &#x3D; 1$，前任 $a_1 &#x3D; 2$</li></ul><p><strong>求后任（successor）</strong>：$rightmost(target)+1$</p><ul><li>$rightmost(5) + 1 &#x3D; 5$，后任 $a_5 &#x3D; 7$</li><li>$rightmost(4) + 1 &#x3D; 5$，后任 $a_5 &#x3D; 7$</li></ul><p><strong>求最近邻居</strong>：</p><ul><li>前任和后任距离更近者</li></ul><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><h3 id="1-时间复杂度估算"><a href="#1-时间复杂度估算" class="headerlink" title="1) 时间复杂度估算"></a>1) 时间复杂度估算</h3><p>用函数 $f(n)$ 表示算法效率与数据规模的关系，假设每次解决问题需要 1 微秒（$10^{-6}$ 秒），进行估算：</p><ol><li>如果 $f(n) &#x3D; n^2$ 那么 1 秒能解决多少次问题？1 天呢？</li><li>如果 $f(n) &#x3D; log_2(n)$  那么 1 秒能解决多少次问题？1 天呢？</li><li>如果 $f(n) &#x3D; n!$ 那么 1 秒能解决多少次问题？1 天呢？</li></ol><p><strong>参考解答</strong></p><ol><li>1秒 $\sqrt{10^6} &#x3D; 1000$ 次，1 天 $\sqrt{10^6 * 3600 * 24} \approx 293938$ 次</li><li>1秒 $2^{1,000,000} $ 次，一天 $2^{86,400,000,000}$</li><li>推算如下<ul><li>$10! &#x3D; 3,628,800$ 1秒能解决 $1,000,000$ 次，因此次数为 9 次</li><li>$14!&#x3D;87,178,291,200$，一天能解决 $86,400,000,000$ 次，因此次数为 13 次</li></ul></li></ol><h3 id="2-耗时估算"><a href="#2-耗时估算" class="headerlink" title="2) 耗时估算"></a>2) 耗时估算</h3><p>一台机器对200个单词进行排序花了200秒(使用冒泡排序)，那么花费800秒，大概可以对多少个单词进行排序</p><p>a. 400</p><p>b. 600</p><p>c. 800</p><p>d. 1600</p><p><strong>答案</strong></p><ul><li>a</li></ul><p><strong>解释</strong></p><ul><li>冒泡排序时间复杂度是 $O(N^2)$</li><li>时间增长 4 倍，而因此能处理的数据量是原来的 $\sqrt{4} &#x3D; 2$ 倍</li></ul><h3 id="3-E01-二分查找-Leetcode-704"><a href="#3-E01-二分查找-Leetcode-704" class="headerlink" title="3) E01. 二分查找-Leetcode 704"></a>3) E01. 二分查找-Leetcode 704</h3><p><strong>要点</strong>：减而治之，可以用递归或非递归实现</p><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1</p><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">12</span>], target = <span class="number">9</span></span><br><span class="line">输出: <span class="number">4</span></span><br><span class="line">解释: <span class="number">9</span> 出现在 nums 中并且下标为 <span class="number">4</span></span><br><span class="line">    </span><br><span class="line">输入: nums = [-<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">12</span>], target = <span class="number">2</span></span><br><span class="line">输出: -<span class="number">1</span></span><br><span class="line">解释: <span class="number">2</span> 不存在 nums 中因此返回 -<span class="number">1</span>    </span><br></pre></td></tr></table></figure><p><strong>参考答案</strong>：略，可以用讲过的任意一种二分求解</p><h3 id="4-E02-搜索插入位置-Leetcode-35"><a href="#4-E02-搜索插入位置-Leetcode-35" class="headerlink" title="4) E02. 搜索插入位置-Leetcode 35"></a>4) E02. 搜索插入位置-Leetcode 35</h3><p><strong>要点</strong>：理解谁代表插入位置</p><p>给定一个排序数组和一个目标值</p><ul><li>在数组中找到目标值，并返回其索引</li><li>如果目标值不存在于数组中，返回它将会被按顺序插入的位置</li></ul><p>例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 5</span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">输入: nums = [1,3,5,6], target = 2</span><br><span class="line">输出: 1</span><br><span class="line"></span><br><span class="line">输入: nums = [1,3,5,6], target = 7</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p><strong>参考答案1</strong>：用二分查找基础版代码改写，基础版中，找到返回 m，没找到 i 代表插入点，因此有</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = a.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; a[m]) &#123;</span><br><span class="line">            j = m - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[m] &lt; target) &#123;</span><br><span class="line">            i = m + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i; <span class="comment">// 原始 return -1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>参考答案2</strong>：用二分查找平衡版改写，平衡版中</p><ul><li>如果 target &#x3D;&#x3D; a[i] 返回 i 表示找到</li><li>如果 target &lt; a[i]，例如 target &#x3D; 2，a[i] &#x3D; 3，这时就应该在 i 位置插入 2</li><li>如果 a[i] &lt; target，例如 a[i] &#x3D; 3，target &#x3D; 4，这时就应该在 i+1 位置插入 4</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = a.length;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span> &lt; j - i) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; a[m]) &#123;</span><br><span class="line">            j = m;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i = m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (target &lt;= a[i]) ? i : i + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 原始 (target == a[i]) ? i : -1;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>参考答案3</strong>：用 leftmost 版本解，返回值即为插入位置（并能处理元素重复的情况）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = a.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= j) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(target &lt;= a[m]) &#123;</span><br><span class="line">            j = m - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i = m + <span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-E03-搜索开始结束位置-Leetcode-34"><a href="#5-E03-搜索开始结束位置-Leetcode-34" class="headerlink" title="5) E03. 搜索开始结束位置-Leetcode 34"></a>5) E03. 搜索开始结束位置-Leetcode 34</h3><p>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 target，返回 [-1, -1]。</p><p>你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题</p><p>例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">输出：[3,4]</span><br><span class="line"></span><br><span class="line">输入：nums = [5,7,7,8,8,10], target = 6</span><br><span class="line">输出：[-1,-1]</span><br><span class="line"></span><br><span class="line">输入：nums = [], target = 0</span><br><span class="line">输出：[-1,-1]</span><br></pre></td></tr></table></figure><p><strong>参考答案</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">left</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = a.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">candidate</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; a[m]) &#123;</span><br><span class="line">            j = m - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[m] &lt; target) &#123;</span><br><span class="line">            i = m + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            candidate = m;</span><br><span class="line">            j = m - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> candidate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">right</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = a.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">candidate</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; a[m]) &#123;</span><br><span class="line">            j = m - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[m] &lt; target) &#123;</span><br><span class="line">            i = m + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            candidate = m;</span><br><span class="line">            i = m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> candidate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> left(nums, target);</span><br><span class="line">    <span class="keyword">if</span>(x == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;x, right(nums, target)&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二-基础数据结构"><a href="#二-基础数据结构" class="headerlink" title="二. 基础数据结构"></a>二. 基础数据结构</h1><h2 id="2-1-数组"><a href="#2-1-数组" class="headerlink" title="2.1 数组"></a>2.1 数组</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1) 概述"></a>1) 概述</h3><p><strong>定义</strong></p><p>在计算机科学中，数组是由一组元素（值或变量）组成的数据结构，每个元素有至少一个索引或键来标识</p><blockquote><p>In computer science, an <strong>array</strong> is a data structure consisting of a collection of <em>elements</em> (values or variables), each identified by at least one <em>array index</em> or <em>key</em></p></blockquote><p>因为数组内的元素是<strong>连续存储</strong>的，所以数组中元素的地址，可以通过其索引计算出来，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] array = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure><p>知道了数组的<strong>数据</strong>起始地址 $BaseAddress$，就可以由公式 $BaseAddress + i * size$ 计算出索引 $i$ 元素的地址</p><ul><li>$i$ 即索引，在 Java、C 等语言都是从 0 开始</li><li>$size$ 是每个元素占用字节，例如 $int$ 占 $4$，$double$ 占 $8$</li></ul><p><strong>小测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] array = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure><p>已知 array 的<strong>数据</strong>的起始地址是 0x7138f94c8，那么元素 3 的地址是什么？</p><blockquote><p>答：0x7138f94c8 + 2 * 1 &#x3D; 0x7138f94ca</p></blockquote><p><strong>空间占用</strong></p><p>Java 中数组结构为</p><ul><li>8 字节 markword</li><li>4 字节 class 指针（压缩 class 指针的情况）</li><li>4 字节 数组大小（决定了数组最大容量是 $2^{32}$）</li><li>数组元素 + 对齐字节（java 中所有对象大小都是 8 字节的整数倍[^12]，不足的要用对齐字节补足）</li></ul><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] array = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><p>的大小为 40 个字节，组成如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8 + 4 + 4 + 5*4 + 4(alignment)</span><br></pre></td></tr></table></figure><p><strong>随机访问性能</strong></p><p>即根据索引查找元素，时间复杂度是 $O(1)$</p><h3 id="2-动态数组"><a href="#2-动态数组" class="headerlink" title="2) 动态数组"></a>2) 动态数组</h3><p><strong>java 版本</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicArray</span> <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 逻辑大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> <span class="number">8</span>; <span class="comment">// 容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] array = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向最后位置 [size] 添加元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element 待添加元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> element)</span> &#123;</span><br><span class="line">        add(size, element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向 [0 .. size] 位置添加元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index   索引位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element 待添加元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> element)</span> &#123;</span><br><span class="line">        checkAndGrow();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; size) &#123;</span><br><span class="line">            <span class="comment">// 向后挪动, 空出待插入位置</span></span><br><span class="line">            System.arraycopy(array, index,</span><br><span class="line">                    array, index + <span class="number">1</span>, size - index);</span><br><span class="line">        &#125;</span><br><span class="line">        array[index] = element;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkAndGrow</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 容量检查</span></span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            array = <span class="keyword">new</span> <span class="title class_">int</span>[capacity];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (size == capacity) &#123;</span><br><span class="line">            <span class="comment">// 进行扩容, 1.5 1.618 2</span></span><br><span class="line">            capacity += capacity &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span>[] newArray = <span class="keyword">new</span> <span class="title class_">int</span>[capacity];</span><br><span class="line">            System.arraycopy(array, <span class="number">0</span>,</span><br><span class="line">                    newArray, <span class="number">0</span>, size);</span><br><span class="line">            array = newArray;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从 [0 .. size) 范围删除元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 索引位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 被删除元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123; <span class="comment">// [0..size)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">removed</span> <span class="operator">=</span> array[index];</span><br><span class="line">        <span class="keyword">if</span> (index &lt; size - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 向前挪动</span></span><br><span class="line">            System.arraycopy(array, index + <span class="number">1</span>,</span><br><span class="line">                    array, index, size - index - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> removed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 索引位置, 在 [0..size) 区间内</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 该索引位置的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> array[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历方法1</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> consumer 遍历要执行的操作, 入参: 每个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foreach</span><span class="params">(Consumer&lt;Integer&gt; consumer)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="comment">// 提供 array[i]</span></span><br><span class="line">            <span class="comment">// 返回 void</span></span><br><span class="line">            consumer.accept(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历方法2 - 迭代器遍历</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;Integer&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123; <span class="comment">// 有没有下一个元素</span></span><br><span class="line">                <span class="keyword">return</span> i &lt; size;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">next</span><span class="params">()</span> &#123; <span class="comment">// 返回当前元素,并移动到下一个元素</span></span><br><span class="line">                <span class="keyword">return</span> array[i++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历方法3 - stream 遍历</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> stream 流</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> IntStream <span class="title function_">stream</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> IntStream.of(Arrays.copyOfRange(array, <span class="number">0</span>, size));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这些方法实现，都简化了 index 的有效性判断，假设输入的 index 都是合法的</li></ul><p><strong>插入或删除性能</strong></p><p>头部位置，时间复杂度是 $O(n)$</p><p>中间位置，时间复杂度是 $O(n)$</p><p>尾部位置，时间复杂度是 $O(1)$（均摊来说）</p><h3 id="3-二维数组"><a href="#3-二维数组" class="headerlink" title="3) 二维数组"></a>3) 二维数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] array = &#123;</span><br><span class="line">    &#123;<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>&#125;,</span><br><span class="line">    &#123;<span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>&#125;,</span><br><span class="line">    &#123;<span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>内存图如下</p><p><img src="https://bu.dusays.com/2024/11/16/6737f8d0907ce.png" alt="image-20221104114132056.png"></p><ul><li><p>二维数组占 32 个字节，其中 array[0]，array[1]，array[2] 三个元素分别保存了指向三个一维数组的引用</p></li><li><p>三个一维数组各占 40 个字节</p></li><li><p>它们在内层布局上是<strong>连续</strong>的</p></li></ul><p>更一般的，对一个二维数组 $Array[m][n]$</p><ul><li>$m$ 是外层数组的长度，可以看作 row 行</li><li>$n$ 是内层数组的长度，可以看作 column 列</li><li>当访问 $Array[i][j]$，$0\leq i \lt m, 0\leq j \lt n$时，就相当于<ul><li>先找到第 $i$ 个内层数组（行）</li><li>再找到此内层数组中第 $j$ 个元素（列）</li></ul></li></ul><p><strong>小测试</strong></p><p>Java 环境下（不考虑类指针和引用压缩，此为默认情况），有下面的二维数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[][] array = &#123;</span><br><span class="line">    &#123;<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>&#125;,</span><br><span class="line">    &#123;<span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>&#125;,</span><br><span class="line">    &#123;<span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>已知 array <strong>对象</strong>起始地址是 0x1000，那么 23 这个元素的地址是什么？</p><blockquote><p>答：</p><ul><li>起始地址 0x1000</li><li>外层数组大小：16字节对象头 + 3元素 * 每个引用4字节 + 4 对齐字节 &#x3D; 32 &#x3D; 0x20</li><li>第一个内层数组大小：16字节对象头 + 5元素 * 每个byte1字节 + 3 对齐字节 &#x3D; 24 &#x3D; 0x18</li><li>第二个内层数组，16字节对象头 &#x3D; 0x10，待查找元素索引为 2</li><li>最后结果 &#x3D; 0x1000 + 0x20 + 0x18 + 0x10 + 2*1 &#x3D; 0x104a</li></ul></blockquote><h3 id="4-局部性原理"><a href="#4-局部性原理" class="headerlink" title="4) 局部性原理"></a>4) 局部性原理</h3><p>这里只讨论空间局部性</p><ul><li>cpu 读取内存（速度慢）数据后，会将其放入高速缓存（速度快）当中，如果后来的计算再用到此数据，在缓存中能读到的话，就不必读内存了</li><li>缓存的最小存储单位是缓存行（cache line），一般是 64 bytes，一次读的数据少了不划算啊，因此最少读 64 bytes 填满一个缓存行，因此读入某个数据时也会读取其<strong>临近的数据</strong>，这就是所谓<strong>空间局部性</strong></li></ul><p><strong>对效率的影响</strong></p><p>比较下面 ij 和 ji 两个方法的执行效率</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> <span class="number">1000000</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">columns</span> <span class="operator">=</span> <span class="number">14</span>;</span><br><span class="line"><span class="type">int</span>[][] a = <span class="keyword">new</span> <span class="title class_">int</span>[rows][columns];</span><br><span class="line"></span><br><span class="line"><span class="type">StopWatch</span> <span class="variable">sw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line">sw.start(<span class="string">&quot;ij&quot;</span>);</span><br><span class="line">ij(a, rows, columns);</span><br><span class="line">sw.stop();</span><br><span class="line">sw.start(<span class="string">&quot;ji&quot;</span>);</span><br><span class="line">ji(a, rows, columns);</span><br><span class="line">sw.stop();</span><br><span class="line">System.out.println(sw.prettyPrint());</span><br></pre></td></tr></table></figure><p>ij 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">ij</span><span class="params">(<span class="type">int</span>[][] a, <span class="type">int</span> rows, <span class="type">int</span> columns)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; columns; j++) &#123;</span><br><span class="line">            sum += a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ji 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">ji</span><span class="params">(<span class="type">int</span>[][] a, <span class="type">int</span> rows, <span class="type">int</span> columns)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; columns; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            sum += a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">0</span><br><span class="line">StopWatch &#x27;&#x27;: running time = 96283300 ns</span><br><span class="line">---------------------------------------------</span><br><span class="line">ns         %     Task name</span><br><span class="line">---------------------------------------------</span><br><span class="line">016196200  017%  ij</span><br><span class="line">080087100  083%  ji</span><br></pre></td></tr></table></figure><p>可以看到 ij 的效率比 ji 快很多，为什么呢？</p><ul><li>缓存是有限的，当新数据来了后，一些旧的缓存行数据就会被覆盖</li><li>如果不能充分利用缓存的数据，就会造成效率低下</li></ul><p>以 ji 执行为例，第一次内循环要读入 $[0,0]$ 这条数据，由于局部性原理，读入 $[0,0]$ 的同时也读入了 $[0,1] … [0,13]$，如图所示</p><p><img src="https://bu.dusays.com/2024/11/16/6737f8d07e51f.png" alt="image-20221104164329026.png"></p><p>但很遗憾，第二次内循环要的是 $[1,0]$ 这条数据，缓存中没有，于是再读入了下图的数据</p><p><img src="https://bu.dusays.com/2024/11/16/6737f8d07f4c0.png" alt="image-20221104164716282.png"></p><p>这显然是一种浪费，因为 $[0,1] … [0,13]$ 包括 $[1,1] … [1,13]$ 这些数据虽然读入了缓存，却没有及时用上，而缓存的大小是有限的，等执行到第九次内循环时</p><p><img src="https://bu.dusays.com/2024/11/16/6737f8d089ecf.png" alt="image-20221104164947154.png"></p><p>缓存的第一行数据已经被新的数据 $[8,0] … [8,13]$ 覆盖掉了，以后如果再想读，比如 $[0,1]$，又得到内存去读了</p><p>同理可以分析 ij 函数则能充分利用局部性原理加载到的缓存数据</p><p><strong>举一反三</strong></p><ol><li><p>I&#x2F;O 读写时同样可以体现局部性原理</p></li><li><p>数组可以充分利用局部性原理，那么链表呢？</p><blockquote><p>答：链表不行，因为链表的元素并非相邻存储</p></blockquote></li></ol><h3 id="5-越界检查"><a href="#5-越界检查" class="headerlink" title="5) 越界检查"></a>5) 越界检查</h3><p>java 中对数组元素的读写都有越界检查，类似于下面的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_within_bounds</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span>        </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> &lt;= index &amp;&amp; index &lt; <span class="built_in">length</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>代码位置：<code>openjdk\src\hotspot\share\oops\arrayOop.hpp</code></li></ul><p>只不过此检查代码，不需要由程序员自己来调用，JVM 会帮我们调用</p><h3 id="习题-1"><a href="#习题-1" class="headerlink" title="习题"></a>习题</h3><h4 id="E01-合并有序数组-对应-Leetcode-88"><a href="#E01-合并有序数组-对应-Leetcode-88" class="headerlink" title="E01. 合并有序数组 - 对应 Leetcode 88"></a>E01. 合并有序数组 - 对应 Leetcode 88</h4><p>将数组内两个区间内的有序元素合并</p><p>例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 5, 6, 2, 4, 10, 11]</span><br></pre></td></tr></table></figure><p>可以视作两个有序区间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 5, 6] 和 [2, 4, 10, 11]</span><br></pre></td></tr></table></figure><p>合并后，结果仍存储于原有空间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 4, 5, 6, 10, 11]</span><br></pre></td></tr></table></figure><p><strong>方法1</strong></p><p>递归</p><ul><li>每次递归把更小的元素复制到结果数组</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">merge(left=[<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>],right=[<span class="number">2</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">11</span>],a2=[])&#123;</span><br><span class="line">    merge(left=[<span class="number">5</span>,<span class="number">6</span>],right=[<span class="number">2</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">11</span>],a2=[<span class="number">1</span>])&#123;</span><br><span class="line">        merge(left=[<span class="number">5</span>,<span class="number">6</span>],right=[<span class="number">4</span>,<span class="number">10</span>,<span class="number">11</span>],a2=[<span class="number">1</span>,<span class="number">2</span>])&#123;</span><br><span class="line">            merge(left=[<span class="number">5</span>,<span class="number">6</span>],right=[<span class="number">10</span>,<span class="number">11</span>],a2=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>])&#123;</span><br><span class="line">                merge(left=[<span class="number">6</span>],right=[<span class="number">10</span>,<span class="number">11</span>],a2=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>])&#123;</span><br><span class="line">                    merge(left=[],right=[<span class="number">10</span>,<span class="number">11</span>],a2=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])&#123;</span><br><span class="line"><span class="comment">// 拷贝10，11</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] a1, <span class="type">int</span> i, <span class="type">int</span> iEnd, <span class="type">int</span> j, <span class="type">int</span> jEnd,</span></span><br><span class="line"><span class="params">                              <span class="type">int</span>[] a2, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; iEnd) &#123;</span><br><span class="line">        System.arraycopy(a1, j, a2, k, jEnd - j + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &gt; jEnd) &#123;</span><br><span class="line">        System.arraycopy(a1, i, a2, k, iEnd - i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a1[i] &lt; a1[j]) &#123;</span><br><span class="line">        a2[k] = a1[i];</span><br><span class="line">        merge(a1, i + <span class="number">1</span>, iEnd, j, jEnd, a2, k + <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        a2[k] = a1[j];</span><br><span class="line">        merge(a1, i, iEnd, j + <span class="number">1</span>, jEnd, a2, k + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] a1 = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">11</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] a2 = <span class="keyword">new</span> <span class="title class_">int</span>[a1.length];</span><br><span class="line">merge(a1, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, a2, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p><strong>方法2</strong></p><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] a1, <span class="type">int</span> i, <span class="type">int</span> iEnd,</span></span><br><span class="line"><span class="params">                             <span class="type">int</span> j, <span class="type">int</span> jEnd,</span></span><br><span class="line"><span class="params">                             <span class="type">int</span>[] a2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= iEnd &amp;&amp; j &lt;= jEnd) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a1[i] &lt; a1[j]) &#123;</span><br><span class="line">            a2[k] = a1[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            a2[k] = a1[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; iEnd) &#123;</span><br><span class="line">        System.arraycopy(a1, j, a2, k, jEnd - j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &gt; jEnd) &#123;</span><br><span class="line">        System.arraycopy(a1, i, a2, k, iEnd - i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] a1 = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">11</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] a2 = <span class="keyword">new</span> <span class="title class_">int</span>[a3.length];</span><br><span class="line">merge(a1, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, a2);</span><br></pre></td></tr></table></figure><h2 id="2-2-链表"><a href="#2-2-链表" class="headerlink" title="2.2 链表"></a>2.2 链表</h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1) 概述"></a>1) 概述</h3><p><strong>定义</strong></p><p>在计算机科学中，链表是数据元素的线性集合，其每个元素都指向下一个元素，元素存储上并不连续</p><blockquote><p>In computer science, a <strong>linked list</strong> is a linear collection of data elements whose order is not given by their physical placement in memory. Instead, each element points to the next. </p></blockquote><p>可以分类为[^5]</p><ul><li>单向链表，每个元素只知道其下一个元素是谁</li></ul><p><img src="https://bu.dusays.com/2024/11/16/6737f8d1a3052.png" alt="image-20221110083407176.png"></p><ul><li>双向链表，每个元素知道其上一个元素和下一个元素</li></ul><p><img src="https://bu.dusays.com/2024/11/16/6737f8d1bfaaa.png" alt="image-20221110083427372.png"></p><ul><li>循环链表，通常的链表尾节点 tail 指向的都是 null，而循环链表的 tail 指向的是头节点 head</li></ul><p><img src="https://bu.dusays.com/2024/11/16/6737f8d1e2d07.png" alt="image-20221110083538273.png"></p><p>链表内还有一种特殊的节点称为哨兵（Sentinel）节点，也叫做哑元（ Dummy）节点，它不存储数据，通常用作头尾，用来简化边界判断，如下图所示</p><p><img src="https://bu.dusays.com/2024/11/16/6737f8d21182e.png" alt="image-20221110084611550.png"></p><p><strong>随机访问性能</strong></p><p>根据 index 查找，时间复杂度 $O(n)$</p><p><strong>插入或删除性能</strong></p><ul><li>起始位置：$O(1)$</li><li>结束位置：如果已知 tail 尾节点是 $O(1)$，不知道 tail 尾节点是 $O(n)$</li><li>中间位置：根据 index 查找时间 + $O(1)$</li></ul><h3 id="2-单向链表"><a href="#2-单向链表" class="headerlink" title="2) 单向链表"></a>2) 单向链表</h3><p>根据单向链表的定义，首先定义一个存储 value 和 next 指针的类 Node，和一个描述头部节点的引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinglyLinkedList</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Node head; <span class="comment">// 头部节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123; <span class="comment">// 节点类</span></span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        Node next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> value, Node next)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Node 定义为内部类，是为了对外<strong>隐藏</strong>实现细节，没必要让类的使用者关心 Node 结构</li><li>定义为 static 内部类，是因为 Node <strong>不需要</strong>与 SinglyLinkedList 实例相关，多个 SinglyLinkedList实例能共用 Node 类定义</li></ul><p><strong>头部添加</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinglyLinkedList</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.head = <span class="keyword">new</span> <span class="title class_">Node</span>(value, <span class="built_in">this</span>.head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果 this.head &#x3D;&#x3D; null，新增节点指向 null，并作为新的 this.head</li><li>如果 this.head !&#x3D; null，新增节点指向原来的 this.head，并作为新的 this.head<ul><li>注意赋值操作执行顺序是从右到左</li></ul></li></ul><p><strong>while 遍历</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinglyLinkedList</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">curr</span> <span class="operator">=</span> <span class="built_in">this</span>.head;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 做一些事</span></span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>for 遍历</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinglyLinkedList</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">curr</span> <span class="operator">=</span> <span class="built_in">this</span>.head; curr != <span class="literal">null</span>; curr = curr.next) &#123;</span><br><span class="line">            <span class="comment">// 做一些事</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>以上两种遍历都可以把<strong>要做的事</strong>以 Consumer 函数的方式传递进来<ul><li>Consumer 的规则是<strong>一个参数</strong>，<strong>无返回值</strong>，因此像 System.out::println 方法等都是 Consumer</li><li>调用 Consumer 时，将当前节点 curr.value 作为参数传递给它</li></ul></li></ul><p><strong>迭代器遍历</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinglyLinkedList</span> <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">NodeIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;Integer&gt; &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">curr</span> <span class="operator">=</span> head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> curr != <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Integer <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> curr.value;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;Integer&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NodeIterator</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>hasNext 用来判断是否还有必要调用 next</li><li>next 做两件事<ul><li>返回当前节点的 value</li><li>指向下一个节点</li></ul></li><li>NodeIterator 要定义为<strong>非 static 内部类</strong>，是因为它与 SinglyLinkedList 实例相关，是对某个 SinglyLinkedList 实例的迭代</li></ul><p><strong>递归遍历</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinglyLinkedList</span> <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">        recursion(<span class="built_in">this</span>.head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">recursion</span><span class="params">(Node curr)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (curr == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 前面做些事</span></span><br><span class="line">        recursion(curr.next);</span><br><span class="line">        <span class="comment">// 后面做些事</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>尾部添加</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinglyLinkedList</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">findLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node curr;</span><br><span class="line">        <span class="keyword">for</span> (curr = <span class="built_in">this</span>.head; curr.next != <span class="literal">null</span>; ) &#123;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">last</span> <span class="operator">=</span> findLast();</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="literal">null</span>) &#123;</span><br><span class="line">            addFirst(value);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        last.next = <span class="keyword">new</span> <span class="title class_">Node</span>(value, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意，找最后一个节点，终止条件是 curr.next &#x3D;&#x3D; null </li><li>分成两个方法是为了代码清晰，而且 findLast() 之后还能复用</li></ul><p><strong>尾部添加多个</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinglyLinkedList</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> first, <span class="type">int</span>... rest)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">Node</span> <span class="variable">sublist</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(first, <span class="literal">null</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">curr</span> <span class="operator">=</span> sublist;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> value : rest) &#123;</span><br><span class="line">            curr.next = <span class="keyword">new</span> <span class="title class_">Node</span>(value, <span class="literal">null</span>);</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">Node</span> <span class="variable">last</span> <span class="operator">=</span> findLast();</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.head = sublist;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        last.next = sublist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>先串成一串 sublist</li><li>再作为一个整体添加</li></ul><p><strong>根据索引获取</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinglyLinkedList</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">findNode</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">curr</span> <span class="operator">=</span> <span class="built_in">this</span>.head; curr != <span class="literal">null</span>; curr = curr.next, i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index == i) &#123;</span><br><span class="line">                <span class="keyword">return</span> curr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> IllegalArgumentException <span class="title function_">illegalIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(String.format(<span class="string">&quot;index [%d] 不合法%n&quot;</span>, index));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> findNode(index);</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> node.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> illegalIndex(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>同样，分方法可以实现复用</li></ul><p><strong>插入</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinglyLinkedList</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">            addFirst(value);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> findNode(index - <span class="number">1</span>); <span class="comment">// 找到上一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="literal">null</span>) &#123; <span class="comment">// 找不到</span></span><br><span class="line">            <span class="keyword">throw</span> illegalIndex(index);</span><br><span class="line">        &#125;</span><br><span class="line">        prev.next = <span class="keyword">new</span> <span class="title class_">Node</span>(value, prev.next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>插入包括下面的删除，都必须找到上一个节点</li></ul><p><strong>删除</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinglyLinkedList</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.head != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.head = <span class="built_in">this</span>.head.next;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> illegalIndex(index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> findNode(index - <span class="number">1</span>);</span><br><span class="line">        Node curr;</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="literal">null</span> &amp;&amp; (curr = prev.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            prev.next = curr.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> illegalIndex(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第一个 if 块对应着 removeFirst 情况</li><li>最后一个 if 块对应着至少得两个节点的情况<ul><li>不仅仅判断上一个节点非空，还要保证当前节点非空</li></ul></li></ul><h3 id="3-单向链表（带哨兵）"><a href="#3-单向链表（带哨兵）" class="headerlink" title="3) 单向链表（带哨兵）"></a>3) 单向链表（带哨兵）</h3><p>观察之前单向链表的实现，发现每个方法内几乎都有判断是不是 head 这样的代码，能不能简化呢？</p><p>用一个不参与数据存储的特殊 Node 作为哨兵，它一般被称为哨兵或哑元，拥有哨兵节点的链表称为带头链表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinglyLinkedListSentinel</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Node</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Integer.MIN_VALUE, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>具体存什么值无所谓，因为不会用到它的值</li></ul><p>加入哨兵节点后，代码会变得比较简单，先看几个工具方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinglyLinkedListSentinel</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据索引获取节点</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">findNode</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">curr</span> <span class="operator">=</span> <span class="built_in">this</span>.head; curr != <span class="literal">null</span>; curr = curr.next, i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == index) &#123;</span><br><span class="line">                <span class="keyword">return</span> curr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取最后一个节点</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">findLast</span><span class="params">()</span> &#123;</span><br><span class="line">        Node curr;</span><br><span class="line">        <span class="keyword">for</span> (curr = <span class="built_in">this</span>.head; curr.next != <span class="literal">null</span>; ) &#123;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>findNode 与之前类似，只是 i 初始值设置为 -1 对应哨兵，实际传入的 index 也是 $[-1, \infty)$</li><li>findLast 绝不会返回 null 了，就算没有其它节点，也会返回哨兵作为最后一个节点</li></ul><p>这样，代码简化为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinglyLinkedListSentinel</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">last</span> <span class="operator">=</span> findLast();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        改动前</span></span><br><span class="line"><span class="comment">        if (last == null) &#123;</span></span><br><span class="line"><span class="comment">            this.head = new Node(value, null);</span></span><br><span class="line"><span class="comment">            return;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        last.next = <span class="keyword">new</span> <span class="title class_">Node</span>(value, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        改动前</span></span><br><span class="line"><span class="comment">        if (index == 0) &#123;</span></span><br><span class="line"><span class="comment">            this.head = new Node(value, this.head);</span></span><br><span class="line"><span class="comment">            return;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">// index 传入 0 时，返回的是哨兵</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> findNode(index - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="literal">null</span>) &#123;</span><br><span class="line">            prev.next = <span class="keyword">new</span> <span class="title class_">Node</span>(value, prev.next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> illegalIndex(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        改动前</span></span><br><span class="line"><span class="comment">        if (index == 0) &#123;</span></span><br><span class="line"><span class="comment">            if (this.head != null) &#123;</span></span><br><span class="line"><span class="comment">                this.head = this.head.next;</span></span><br><span class="line"><span class="comment">                return;</span></span><br><span class="line"><span class="comment">            &#125; else &#123;</span></span><br><span class="line"><span class="comment">                throw illegalIndex(index);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">// index 传入 0 时，返回的是哨兵</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> findNode(index - <span class="number">1</span>);</span><br><span class="line">        Node curr;</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="literal">null</span> &amp;&amp; (curr = prev.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            prev.next = curr.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> illegalIndex(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        改动前</span></span><br><span class="line"><span class="comment">        this.head = new Node(value, this.head);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"><span class="built_in">this</span>.head.next = <span class="keyword">new</span> <span class="title class_">Node</span>(value, <span class="built_in">this</span>.head.next);</span><br><span class="line">        <span class="comment">// 也可以视为 insert 的特例, 即 insert(0, value);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对于删除，前面说了【最后一个 if 块对应着至少得两个节点的情况】，现在有了哨兵，就凑足了两个节点</li></ul><h3 id="4-双向链表（带哨兵）"><a href="#4-双向链表（带哨兵）" class="headerlink" title="4) 双向链表（带哨兵）"></a>4) 双向链表（带哨兵）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoublyLinkedListSentinel</span> <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node head;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DoublyLinkedListSentinel</span><span class="params">()</span> &#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>, <span class="number">666</span>, <span class="literal">null</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>, <span class="number">888</span>, <span class="literal">null</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">findNode</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> head; p != tail; p = p.next, i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == index) &#123;</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        insert(<span class="number">0</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> tail.prev;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">added</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(prev, value, tail);</span><br><span class="line">        prev.next = added;</span><br><span class="line">        tail.prev = added;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">removed</span> <span class="operator">=</span> tail.prev;</span><br><span class="line">        <span class="keyword">if</span> (removed == head) &#123;</span><br><span class="line">            <span class="keyword">throw</span> illegalIndex(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> removed.prev;</span><br><span class="line">        prev.next = tail;</span><br><span class="line">        tail.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> findNode(index - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> illegalIndex(index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> prev.next;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">inserted</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(prev, value, next);</span><br><span class="line">        prev.next = inserted;</span><br><span class="line">        next.prev = inserted;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> findNode(index - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> illegalIndex(index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">removed</span> <span class="operator">=</span> prev.next;</span><br><span class="line">        <span class="keyword">if</span> (removed == tail) &#123;</span><br><span class="line">            <span class="keyword">throw</span> illegalIndex(index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> removed.next;</span><br><span class="line">        prev.next = next;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IllegalArgumentException <span class="title function_">illegalIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                String.format(<span class="string">&quot;index [%d] 不合法%n&quot;</span>, index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;Integer&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> head.next;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> p != tail;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> p.value;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        Node prev;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        Node next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Node prev, <span class="type">int</span> value, Node next)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.prev = prev;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-环形链表（带哨兵）"><a href="#5-环形链表（带哨兵）" class="headerlink" title="5) 环形链表（带哨兵）"></a>5) 环形链表（带哨兵）</h3><p>双向环形链表带哨兵，这时哨兵<strong>既作为头，也作为尾</strong></p><p><img src="https://bu.dusays.com/2024/11/16/6737f8d65ec35.png" alt="image-20221229144232651.png"></p><p><img src="https://bu.dusays.com/2024/11/16/6737f8d5ca228.png" alt="image-20221229143756065.png"></p><p><img src="https://bu.dusays.com/2024/11/16/6737f8d69c1ad.png" alt="image-20221229153338425.png"></p><p><img src="https://bu.dusays.com/2024/11/16/6737f8d705af9.png" alt="image-20221229154248800.png"></p><p>参考实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoublyLinkedListSentinel</span> <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;Integer&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;&gt;() &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> sentinel.next;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> p != sentinel;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> p.value;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        Node prev;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        Node next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Node prev, <span class="type">int</span> value, Node next)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.prev = prev;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">sentinel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>, -<span class="number">1</span>, <span class="literal">null</span>); <span class="comment">// 哨兵</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DoublyLinkedListSentinel</span><span class="params">()</span> &#123;</span><br><span class="line">        sentinel.next = sentinel;</span><br><span class="line">        sentinel.prev = sentinel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加到第一个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 待添加值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> sentinel.next;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> sentinel;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">added</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(prev, value, next);</span><br><span class="line">        prev.next = added;</span><br><span class="line">        next.prev = added;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加到最后一个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 待添加值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> sentinel.prev;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> sentinel;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">added</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(prev, value, next);</span><br><span class="line">        prev.next = added;</span><br><span class="line">        next.prev = added;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除第一个</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">removed</span> <span class="operator">=</span> sentinel.next;</span><br><span class="line">        <span class="keyword">if</span> (removed == sentinel) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;非法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">a</span> <span class="operator">=</span> sentinel;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">b</span> <span class="operator">=</span> removed.next;</span><br><span class="line">        a.next = b;</span><br><span class="line">        b.prev = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除最后一个</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">removed</span> <span class="operator">=</span> sentinel.prev;</span><br><span class="line">        <span class="keyword">if</span> (removed == sentinel) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;非法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">a</span> <span class="operator">=</span> removed.prev;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">b</span> <span class="operator">=</span> sentinel;</span><br><span class="line">        a.next = b;</span><br><span class="line">        b.prev = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据值删除节点</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;假定 value 在链表中作为 key, 有唯一性&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 待删除值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeByValue</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">removed</span> <span class="operator">=</span> findNodeByValue(value);</span><br><span class="line">        <span class="keyword">if</span> (removed != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> removed.prev;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> removed.next;</span><br><span class="line">            prev.next = next;</span><br><span class="line">            next.prev = prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">findNodeByValue</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> sentinel.next;</span><br><span class="line">        <span class="keyword">while</span> (p != sentinel) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.value == value) &#123;</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="习题-2"><a href="#习题-2" class="headerlink" title="习题"></a>习题</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础加强</title>
      <link href="/posts/83897b92.html"/>
      <url>/posts/83897b92.html</url>
      
        <content type="html"><![CDATA[<h1 id="写在前面的话："><a href="#写在前面的话：" class="headerlink" title="写在前面的话："></a>写在前面的话：</h1><blockquote><p>基础加强包含了：</p><p>反射，动态代理，类加载器，xml，注解，日志，单元测试等知识点</p><p>其中最难的是反射和动态代理，其他知识点都非常简单</p></blockquote><h1 id="1-反射"><a href="#1-反射" class="headerlink" title="1. 反射"></a>1. 反射</h1><h2 id="1-1-反射的概述："><a href="#1-1-反射的概述：" class="headerlink" title="1.1 反射的概述："></a>1.1 反射的概述：</h2><p>​<strong>专业的解释（了解一下）：</strong></p><p>​       是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；</p><p>​       对于任意一个对象，都能够调用它的任意属性和方法；</p><p>​       这种动态获取信息以及动态调用对象方法的功能称为Java语言的反射机制。</p><p>​<strong>通俗的理解：（掌握）</strong></p><ul><li><p>利用<strong>反射</strong>创建的对象<strong>可以无视修饰符</strong>调用类里面的内容</p></li><li><p>可以跟<strong>配置文件结合起来使用</strong>，把要创建的对象信息和方法写在配置文件中。</p><p>读取到什么类，就创建什么类的对象</p><p>读取到什么方法，就调用什么方法</p><p>此时当需求变更的时候不需要修改代码，只要修改配置文件即可。</p></li></ul><h2 id="1-2-学习反射到底学什么？"><a href="#1-2-学习反射到底学什么？" class="headerlink" title="1.2 学习反射到底学什么？"></a>1.2 学习反射到底学什么？</h2><p>反射都是从class字节码文件中获取的内容。</p><ul><li>如何获取class字节码文件的对象</li><li>利用反射如何获取构造方法（创建对象）</li><li>利用反射如何获取成员变量（赋值，获取值）</li><li>利用反射如何获取成员方法（运行）</li></ul><h2 id="1-3-获取字节码文件对象的三种方式"><a href="#1-3-获取字节码文件对象的三种方式" class="headerlink" title="1.3 获取字节码文件对象的三种方式"></a>1.3 获取字节码文件对象的三种方式</h2><ul><li>Class这个类里面的静态方法forName（“全类名”）<strong>（最常用）</strong></li><li>通过class属性获取  </li><li>通过对象获取字节码文件对象</li></ul><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.Class这个类里面的静态方法forName</span></span><br><span class="line"><span class="comment">//Class.forName(&quot;类的全类名&quot;)： 全类名 = 包名 + 类名</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.itheima.reflectdemo.Student&quot;</span>);</span><br><span class="line"><span class="comment">//源代码阶段获取 --- 先把Student加载到内存中，再获取字节码文件的对象</span></span><br><span class="line"><span class="comment">//clazz 就表示Student这个类的字节码文件对象。</span></span><br><span class="line"><span class="comment">//就是当Student.class这个文件加载到内存之后，产生的字节码文件对象</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.通过class属性获取</span></span><br><span class="line"><span class="comment">//类名.class</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz2</span> <span class="operator">=</span> Student.class;</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为class文件在硬盘中是唯一的，所以，当这个文件加载到内存之后产生的对象也是唯一的</span></span><br><span class="line">System.out.println(clazz1 == clazz2);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.通过Student对象获取字节码文件对象</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz3</span> <span class="operator">=</span> s.getClass();</span><br><span class="line">System.out.println(clazz1 == clazz2);<span class="comment">//true</span></span><br><span class="line">System.out.println(clazz2 == clazz3);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><h2 id="1-4-字节码文件和字节码文件对象"><a href="#1-4-字节码文件和字节码文件对象" class="headerlink" title="1.4 字节码文件和字节码文件对象"></a>1.4 字节码文件和字节码文件对象</h2><p>java文件：就是我们自己编写的java代码。</p><p>字节码文件：就是通过java文件编译之后的class文件（是在硬盘上真实存在的，用眼睛能看到的）</p><p>字节码文件对象：当class文件加载到内存之后，虚拟机自动创建出来的对象。</p><p>​这个对象里面至少包含了：构造方法，成员变量，成员方法。</p><p>而我们的反射获取的是什么？字节码文件对象，这个对象在内存中是唯一的。</p><h2 id="1-5-获取构造方法"><a href="#1-5-获取构造方法" class="headerlink" title="1.5 获取构造方法"></a>1.5 获取构造方法</h2><p>规则：</p><p>​get表示获取</p><p>​Declared表示私有</p><p>​最后的s表示所有，复数形式</p><p>​如果当前获取到的是私有的，必须要临时修改访问权限，否则无法使用</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>Constructor&lt;?&gt;[] getConstructors()</td><td>获得所有的构造（只能public修饰）</td></tr><tr><td>Constructor&lt;?&gt;[] getDeclaredConstructors()</td><td>获得所有的构造（包含private修饰）</td></tr><tr><td>Constructor<T> getConstructor(Class&lt;?&gt;… parameterTypes)</td><td>获取指定构造（只能public修饰）</td></tr><tr><td>Constructor<T> getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)</td><td>获取指定构造（包含private修饰）</td></tr></tbody></table><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException &#123;</span><br><span class="line">        <span class="comment">//1.获得整体（class字节码文件对象）</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.itheima.reflectdemo.Student&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取构造方法对象</span></span><br><span class="line">        <span class="comment">//获取所有构造方法（public）</span></span><br><span class="line">        Constructor[] constructors1 = clazz.getConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor constructor : constructors1) &#123;</span><br><span class="line">            System.out.println(constructor);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;=======================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取所有构造（带私有的）</span></span><br><span class="line">        Constructor[] constructors2 = clazz.getDeclaredConstructors();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Constructor constructor : constructors2) &#123;</span><br><span class="line">            System.out.println(constructor);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;=======================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取指定的空参构造</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">con1</span> <span class="operator">=</span> clazz.getConstructor();</span><br><span class="line">        System.out.println(con1);</span><br><span class="line"></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">con2</span> <span class="operator">=</span> clazz.getConstructor(String.class,<span class="type">int</span>.class);</span><br><span class="line">        System.out.println(con2);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;=======================&quot;</span>);</span><br><span class="line">        <span class="comment">//获取指定的构造(所有构造都可以获取到，包括public包括private)</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">con3</span> <span class="operator">=</span> clazz.getDeclaredConstructor();</span><br><span class="line">        System.out.println(con3);</span><br><span class="line">        <span class="comment">//了解 System.out.println(con3 == con1);</span></span><br><span class="line">        <span class="comment">//每一次获取构造方法对象的时候，都会新new一个。</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">con4</span> <span class="operator">=</span> clazz.getDeclaredConstructor(String.class);</span><br><span class="line">        System.out.println(con4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-6-获取构造方法并创建对象"><a href="#1-6-获取构造方法并创建对象" class="headerlink" title="1.6 获取构造方法并创建对象"></a>1.6 获取构造方法并创建对象</h2><p>涉及到的方法：newInstance</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先要有一个javabean类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> age</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> age</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;name = &quot;</span> + name + <span class="string">&quot;, age = &quot;</span> + age + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类中的代码：</span></span><br><span class="line"><span class="comment">//需求1：</span></span><br><span class="line"><span class="comment">//获取空参，并创建对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.获取整体的字节码文件对象</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.itheima.a02reflectdemo1.Student&quot;</span>);</span><br><span class="line"><span class="comment">//2.获取空参的构造方法</span></span><br><span class="line"><span class="type">Constructor</span> <span class="variable">con</span> <span class="operator">=</span> clazz.getConstructor();</span><br><span class="line"><span class="comment">//3.利用空参构造方法创建对象</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> (Student) con.newInstance();</span><br><span class="line">System.out.println(stu);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;=============================================&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类中的代码：</span></span><br><span class="line"><span class="comment">//需求2：</span></span><br><span class="line"><span class="comment">//获取带参构造，并创建对象</span></span><br><span class="line"><span class="comment">//1.获取整体的字节码文件对象</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.itheima.a02reflectdemo1.Student&quot;</span>);</span><br><span class="line"><span class="comment">//2.获取有参构造方法</span></span><br><span class="line"><span class="type">Constructor</span> <span class="variable">con</span> <span class="operator">=</span> clazz.getDeclaredConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line"><span class="comment">//3.临时修改构造方法的访问权限（暴力反射）</span></span><br><span class="line">con.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">//4.直接创建对象</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> (Student) con.newInstance(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">23</span>);</span><br><span class="line">System.out.println(stu);</span><br></pre></td></tr></table></figure><h2 id="1-7-获取成员变量"><a href="#1-7-获取成员变量" class="headerlink" title="1.7 获取成员变量"></a>1.7 获取成员变量</h2><p>规则：</p><p>​get表示获取</p><p>​Declared表示私有</p><p>​最后的s表示所有，复数形式</p><p>​如果当前获取到的是私有的，必须要临时修改访问权限，否则无法使用</p><p>方法名：</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>Field[] getFields()</td><td>返回所有成员变量对象的数组（只能拿public的）</td></tr><tr><td>Field[] getDeclaredFields()</td><td>返回所有成员变量对象的数组，存在就能拿到</td></tr><tr><td>Field getField(String name)</td><td>返回单个成员变量对象（只能拿public的）</td></tr><tr><td>Field getDeclaredField(String name)</td><td>返回单个成员变量对象，存在就能拿到</td></tr></tbody></table><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException &#123;</span><br><span class="line">        <span class="comment">//获取成员变量对象</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.获取class对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.itheima.reflectdemo.Student&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取成员变量的对象（Field对象)只能获取public修饰的</span></span><br><span class="line">        Field[] fields1 = clazz.getFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields1) &#123;</span><br><span class="line">            System.out.println(field);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;===============================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取成员变量的对象（public + private）</span></span><br><span class="line">        Field[] fields2 = clazz.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields2) &#123;</span><br><span class="line">            System.out.println(field);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;===============================&quot;</span>);</span><br><span class="line">        <span class="comment">//获得单个成员变量对象</span></span><br><span class="line">        <span class="comment">//如果获取的属性是不存在的，那么会报异常</span></span><br><span class="line">        <span class="comment">//Field field3 = clazz.getField(&quot;aaa&quot;);</span></span><br><span class="line">        <span class="comment">//System.out.println(field3);//NoSuchFieldException</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">field4</span> <span class="operator">=</span> clazz.getField(<span class="string">&quot;gender&quot;</span>);</span><br><span class="line">        System.out.println(field4);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;===============================&quot;</span>);</span><br><span class="line">        <span class="comment">//获取单个成员变量（私有）</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">field5</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(field5);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String gender;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String address;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, String address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, String gender, String address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.gender = gender;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> age</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> age</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> gender</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getGender</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> gender</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGender</span><span class="params">(String gender)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> address</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAddress</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> address</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAddress</span><span class="params">(String address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;name = &quot;</span> + name + <span class="string">&quot;, age = &quot;</span> + age + <span class="string">&quot;, gender = &quot;</span> + gender + <span class="string">&quot;, address = &quot;</span> + address + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1-8-获取成员变量并获取值和修改值"><a href="#1-8-获取成员变量并获取值和修改值" class="headerlink" title="1.8 获取成员变量并获取值和修改值"></a>1.8 获取成员变量并获取值和修改值</h2><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>void set(Object obj, Object value）</td><td>赋值</td></tr><tr><td>Object get(Object obj)</td><td>获取值</td></tr></tbody></table><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;zhangsan&quot;</span>,<span class="number">23</span>,<span class="string">&quot;广州&quot;</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;lisi&quot;</span>,<span class="number">24</span>,<span class="string">&quot;北京&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//需求：</span></span><br><span class="line">        <span class="comment">//利用反射获取成员变量并获取值和修改值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.获取class对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.itheima.reflectdemo.Student&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取name成员变量</span></span><br><span class="line">        <span class="comment">//field就表示name这个属性的对象</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">//临时修饰他的访问权限</span></span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.设置(修改)name的值</span></span><br><span class="line">        <span class="comment">//参数一：表示要修改哪个对象的name？</span></span><br><span class="line">        <span class="comment">//参数二：表示要修改为多少？</span></span><br><span class="line">        field.set(s,<span class="string">&quot;wangwu&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.获取name的值</span></span><br><span class="line">        <span class="comment">//表示我要获取这个对象的name的值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> (String)field.get(s);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.打印结果</span></span><br><span class="line">        System.out.println(result);</span><br><span class="line"></span><br><span class="line">        System.out.println(s);</span><br><span class="line">        System.out.println(ss);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String gender;</span><br><span class="line">    <span class="keyword">public</span> String address;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, String address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, String gender, String address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.gender = gender;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> age</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> age</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> gender</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getGender</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> gender</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGender</span><span class="params">(String gender)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> address</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAddress</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> address</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAddress</span><span class="params">(String address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;name = &quot;</span> + name + <span class="string">&quot;, age = &quot;</span> + age + <span class="string">&quot;, gender = &quot;</span> + gender + <span class="string">&quot;, address = &quot;</span> + address + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1-9-获取成员方法"><a href="#1-9-获取成员方法" class="headerlink" title="1.9 获取成员方法"></a>1.9 获取成员方法</h2><p>规则：</p><p>​get表示获取</p><p>​Declared表示私有</p><p>​最后的s表示所有，复数形式</p><p>​如果当前获取到的是私有的，必须要临时修改访问权限，否则无法使用</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>Method[] getMethods()</td><td>返回所有成员方法对象的数组（只能拿public的）</td></tr><tr><td>Method[] getDeclaredMethods()</td><td>返回所有成员方法对象的数组，存在就能拿到</td></tr><tr><td>Method getMethod(String name, Class&lt;?&gt;… parameterTypes)</td><td>返回单个成员方法对象（只能拿public的）</td></tr><tr><td>Method getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes)</td><td>返回单个成员方法对象，存在就能拿到</td></tr></tbody></table><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo6</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException &#123;</span><br><span class="line">        <span class="comment">//1.获取class对象</span></span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.itheima.reflectdemo.Student&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取方法</span></span><br><span class="line">        <span class="comment">//getMethods可以获取父类中public修饰的方法</span></span><br><span class="line">        Method[] methods1 = clazz.getMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods1) &#123;</span><br><span class="line">            System.out.println(method);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;===========================&quot;</span>);</span><br><span class="line">        <span class="comment">//获取所有的方法（包含私有）</span></span><br><span class="line">        <span class="comment">//但是只能获取自己类中的方法</span></span><br><span class="line">        Method[] methods2 = clazz.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods2) &#123;</span><br><span class="line">            System.out.println(method);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;===========================&quot;</span>);</span><br><span class="line">        <span class="comment">//获取指定的方法（空参）</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method3</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;sleep&quot;</span>);</span><br><span class="line">        System.out.println(method3);</span><br><span class="line"></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method4</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;eat&quot;</span>,String.class);</span><br><span class="line">        System.out.println(method4);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取指定的私有方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method5</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;playGame&quot;</span>);</span><br><span class="line">        System.out.println(method5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1-10-获取成员方法并运行"><a href="#1-10-获取成员方法并运行" class="headerlink" title="1.10 获取成员方法并运行"></a>1.10 获取成员方法并运行</h2><p>方法</p><p> Object invoke(Object obj, Object… args) ：运行方法</p><p>参数一：用obj对象调用该方法</p><p>参数二：调用方法的传递的参数（如果没有就不写）</p><p>返回值：方法的返回值（如果没有就不写）</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.a02reflectdemo1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo6</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">        <span class="comment">//1.获取字节码文件对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.itheima.a02reflectdemo1.Student&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取一个对象</span></span><br><span class="line">        <span class="comment">//需要用这个对象去调用方法</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.获取一个指定的方法</span></span><br><span class="line">        <span class="comment">//参数一：方法名</span></span><br><span class="line">        <span class="comment">//参数二：参数列表，如果没有可以不写</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">eatMethod</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;eat&quot;</span>,String.class);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//运行</span></span><br><span class="line">        <span class="comment">//参数一：表示方法的调用对象</span></span><br><span class="line">        <span class="comment">//参数二：方法在运行时需要的实际参数</span></span><br><span class="line">        <span class="comment">//注意点：如果方法有返回值，那么需要接收invoke的结果</span></span><br><span class="line">        <span class="comment">//如果方法没有返回值，则不需要接收</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> (String) eatMethod.invoke(s, <span class="string">&quot;重庆小面&quot;</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String gender;</span><br><span class="line">    <span class="keyword">public</span> String address;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> age</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> age</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;name = &quot;</span> + name + <span class="string">&quot;, age = &quot;</span> + age + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;学生在学习&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;学生在睡觉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">eat</span><span class="params">(String something)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;学生在吃&quot;</span> + something);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;学生已经吃完了，非常happy&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试题："><a href="#面试题：" class="headerlink" title="面试题："></a>面试题：</h2><p>​你觉得反射好不好？好，有两个方向</p><p>​第一个方向：无视修饰符访问类中的内容。但是这种操作在开发中一般不用，都是框架底层来用的。</p><p>​第二个方向：反射可以跟配置文件结合起来使用，动态的创建对象，动态的调用方法。</p><h2 id="1-11-练习泛型擦除（掌握概念，了解代码）"><a href="#1-11-练习泛型擦除（掌握概念，了解代码）" class="headerlink" title="1.11 练习泛型擦除（掌握概念，了解代码）"></a>1.11 练习泛型擦除（掌握概念，了解代码）</h2><p>理解：（掌握）</p><p>​集合中的泛型只在java文件中存在，当编译成class文件之后，就没有泛型了。</p><p>代码示例：（了解）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.reflectdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo8</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">        <span class="comment">//1.创建集合对象</span></span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">123</span>);</span><br><span class="line"><span class="comment">//        list.add(&quot;aaa&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.利用反射运行add方法去添加字符串</span></span><br><span class="line">        <span class="comment">//因为反射使用的是class字节码文件</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取class对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> list.getClass();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取add方法对象</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;add&quot;</span>, Object.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//运行方法</span></span><br><span class="line">        method.invoke(list,<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印集合</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1-12-练习：修改字符串的内容（掌握概念，了解代码）"><a href="#1-12-练习：修改字符串的内容（掌握概念，了解代码）" class="headerlink" title="1.12 练习：修改字符串的内容（掌握概念，了解代码）"></a>1.12 练习：修改字符串的内容（掌握概念，了解代码）</h2><p>在这个练习中，我需要你掌握的是字符串不能修改的真正原因。</p><p>字符串，在底层是一个byte类型的字节数组，名字叫做value</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span>[] value;</span><br></pre></td></tr></table></figure><p>真正不能被修改的原因：final和private</p><p>final修饰value表示value记录的地址值不能修改。</p><p>private修饰value而且没有对外提供getvalue和setvalue的方法。所以，在外界不能获取或修改value记录的地址值。</p><p>如果要强行修改可以用反射：</p><p>代码示例：（了解）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="comment">// private final byte[] value= &#123;97,98,99&#125;;</span></span><br><span class="line"><span class="comment">// 没有对外提供getvalue和setvalue的方法，不能修改value记录的地址值</span></span><br><span class="line"><span class="comment">// 如果我们利用反射获取了value的地址值。</span></span><br><span class="line"><span class="comment">// 也是可以修改的，final修饰的value</span></span><br><span class="line"><span class="comment">// 真正不可变的value数组的地址值，里面的内容利用反射还是可以修改的，比较危险</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.获取class对象</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> s.getClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.获取value成员变量（private）</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line"><span class="comment">//但是这种操作非常危险</span></span><br><span class="line"><span class="comment">//JDK高版本已经屏蔽了这种操作，低版本还是可以的</span></span><br><span class="line"><span class="comment">//临时修改权限</span></span><br><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.获取value记录的地址值</span></span><br><span class="line"><span class="type">byte</span>[] bytes = (<span class="type">byte</span>[]) field.get(s);</span><br><span class="line">bytes[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(s);<span class="comment">//dbc</span></span><br><span class="line">System.out.println(ss);<span class="comment">//dbc</span></span><br></pre></td></tr></table></figure><h2 id="1-13-练习，反射和配置文件结合动态获取的练习（重点）"><a href="#1-13-练习，反射和配置文件结合动态获取的练习（重点）" class="headerlink" title="1.13 练习，反射和配置文件结合动态获取的练习（重点）"></a>1.13 练习，反射和配置文件结合动态获取的练习（重点）</h2><p>需求: 利用反射根据文件中的不同类名和方法名，创建不同的对象并调用方法。</p><p>分析:</p><p>①通过Properties加载配置文件</p><p>②得到类名和方法名</p><p>③通过类名反射得到Class对象</p><p>④通过Class对象创建一个对象</p><p>⑤通过Class对象得到方法</p><p>⑥调用方法</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectDemo9</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        <span class="comment">//1.读取配置文件的信息</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;day14-code\\prop.properties&quot;</span>);</span><br><span class="line">        prop.load(fis);</span><br><span class="line">        fis.close();</span><br><span class="line">        System.out.println(prop);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">classname</span> <span class="operator">=</span> prop.get(<span class="string">&quot;classname&quot;</span>) + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodname</span> <span class="operator">=</span> prop.get(<span class="string">&quot;methodname&quot;</span>) + <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取字节码文件对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(classname);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.要先创建这个类的对象</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">con</span> <span class="operator">=</span> clazz.getDeclaredConstructor();</span><br><span class="line">        con.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> con.newInstance();</span><br><span class="line">        System.out.println(o);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.获取方法的对象</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getDeclaredMethod(methodname);</span><br><span class="line">        method.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.运行方法</span></span><br><span class="line">        method.invoke(o);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">配置文件中的信息：</span><br><span class="line">classname=com.itheima.a02reflectdemo1.Student</span><br><span class="line">methodname=sleep</span><br></pre></td></tr></table></figure><h2 id="1-14-利用发射保存对象中的信息（重点）"><a href="#1-14-利用发射保存对象中的信息（重点）" class="headerlink" title="1.14 利用发射保存对象中的信息（重点）"></a>1.14 利用发射保存对象中的信息（重点）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyReflectDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException, IOException &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        对于任意一个对象，都可以把对象所有的字段名和值，保存到文件中去</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">       <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小A&quot;</span>,<span class="number">23</span>,<span class="string">&#x27;女&#x27;</span>,<span class="number">167.5</span>,<span class="string">&quot;睡觉&quot;</span>);</span><br><span class="line">       <span class="type">Teacher</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>(<span class="string">&quot;播妞&quot;</span>,<span class="number">10000</span>);</span><br><span class="line">       saveObject(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把对象里面所有的成员变量名和值保存到本地文件中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">saveObject</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IllegalAccessException, IOException &#123;</span><br><span class="line">        <span class="comment">//1.获取字节码文件的对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> obj.getClass();</span><br><span class="line">        <span class="comment">//2. 创建IO流</span></span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;myreflect\\a.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//3. 获取所有的成员变量</span></span><br><span class="line">        Field[] fields = clazz.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="comment">//获取成员变量的名字</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> field.getName();</span><br><span class="line">            <span class="comment">//获取成员变量的值</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> field.get(obj);</span><br><span class="line">            <span class="comment">//写出数据</span></span><br><span class="line">            bw.write(name + <span class="string">&quot;=&quot;</span> + value);</span><br><span class="line">            bw.newLine();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bw.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span> gender;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> height;</span><br><span class="line">    <span class="keyword">private</span> String hobby;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">char</span> gender, <span class="type">double</span> height, String hobby)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.gender = gender;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">        <span class="built_in">this</span>.hobby = hobby;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> age</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> age</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> gender</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">getGender</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> gender</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGender</span><span class="params">(<span class="type">char</span> gender)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> height</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getHeight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> height</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHeight</span><span class="params">(<span class="type">double</span> height)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> hobby</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getHobby</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> hobby;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hobby</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHobby</span><span class="params">(String hobby)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.hobby = hobby;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;name = &quot;</span> + name + <span class="string">&quot;, age = &quot;</span> + age + <span class="string">&quot;, gender = &quot;</span> + gender + <span class="string">&quot;, height = &quot;</span> + height + <span class="string">&quot;, hobby = &quot;</span> + hobby + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> salary;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Teacher</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Teacher</span><span class="params">(String name, <span class="type">double</span> salary)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> salary</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getSalary</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> salary</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSalary</span><span class="params">(<span class="type">double</span> salary)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Teacher&#123;name = &quot;</span> + name + <span class="string">&quot;, salary = &quot;</span> + salary + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="2-动态代理"><a href="#2-动态代理" class="headerlink" title="2. 动态代理"></a>2. 动态代理</h1><h2 id="2-1-好处："><a href="#2-1-好处：" class="headerlink" title="2.1 好处："></a>2.1 好处：</h2><p>​无侵入式的给方法增强功能</p><h2 id="2-2-动态代理三要素："><a href="#2-2-动态代理三要素：" class="headerlink" title="2.2 动态代理三要素："></a>2.2 动态代理三要素：</h2><p>1，真正干活的对象</p><p>2，代理对象</p><p>3，利用代理调用方法</p><p>切记一点：代理可以增强或者拦截的方法都在接口中，接口需要写在newProxyInstance的第二个参数里。</p><h2 id="2-3-代码实现："><a href="#2-3-代码实现：" class="headerlink" title="2.3 代码实现："></a>2.3 代码实现：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        需求：</span></span><br><span class="line"><span class="comment">            外面的人想要大明星唱一首歌</span></span><br><span class="line"><span class="comment">             1. 获取代理的对象</span></span><br><span class="line"><span class="comment">                代理对象 = ProxyUtil.createProxy(大明星的对象);</span></span><br><span class="line"><span class="comment">             2. 再调用代理的唱歌方法</span></span><br><span class="line"><span class="comment">                代理对象.唱歌的方法(&quot;只因你太美&quot;);</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        <span class="comment">//1. 获取代理的对象</span></span><br><span class="line">        <span class="type">BigStar</span> <span class="variable">bigStar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigStar</span>(<span class="string">&quot;鸡哥&quot;</span>);</span><br><span class="line">        <span class="type">Star</span> <span class="variable">proxy</span> <span class="operator">=</span> ProxyUtil.createProxy(bigStar);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 调用唱歌的方法</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> proxy.sing(<span class="string">&quot;只因你太美&quot;</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 类的作用：</span></span><br><span class="line"><span class="comment">*       创建一个代理</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyUtil</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 方法的作用：</span></span><br><span class="line"><span class="comment">    *       给一个明星的对象，创建一个代理</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *  形参：</span></span><br><span class="line"><span class="comment">    *       被代理的明星对象</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *  返回值：</span></span><br><span class="line"><span class="comment">    *       给明星创建的代理</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 需求：</span></span><br><span class="line"><span class="comment">    *   外面的人想要大明星唱一首歌</span></span><br><span class="line"><span class="comment">    *   1. 获取代理的对象</span></span><br><span class="line"><span class="comment">    *      代理对象 = ProxyUtil.createProxy(大明星的对象);</span></span><br><span class="line"><span class="comment">    *   2. 再调用代理的唱歌方法</span></span><br><span class="line"><span class="comment">    *      代理对象.唱歌的方法(&quot;只因你太美&quot;);</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Star <span class="title function_">createProxy</span><span class="params">(BigStar bigStar)</span>&#123;</span><br><span class="line">       <span class="comment">/* java.lang.reflect.Proxy类：提供了为对象产生代理对象的方法：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span></span><br><span class="line"><span class="comment">        参数一：用于指定用哪个类加载器，去加载生成的代理类</span></span><br><span class="line"><span class="comment">        参数二：指定接口，这些接口用于指定生成的代理长什么，也就是有哪些方法</span></span><br><span class="line"><span class="comment">        参数三：用来指定生成的代理对象要干什么事情*/</span></span><br><span class="line">        <span class="type">Star</span> <span class="variable">star</span> <span class="operator">=</span> (Star) Proxy.newProxyInstance(</span><br><span class="line">                ProxyUtil.class.getClassLoader(),<span class="comment">//参数一：用于指定用哪个类加载器，去加载生成的代理类</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Star.class&#125;,<span class="comment">//参数二：指定接口，这些接口用于指定生成的代理长什么，也就是有哪些方法</span></span><br><span class="line">                <span class="comment">//参数三：用来指定生成的代理对象要干什么事情</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                        * 参数一：代理的对象</span></span><br><span class="line"><span class="comment">                        * 参数二：要运行的方法 sing</span></span><br><span class="line"><span class="comment">                        * 参数三：调用sing方法时，传递的实参</span></span><br><span class="line"><span class="comment">                        * */</span></span><br><span class="line">                        <span class="keyword">if</span>(<span class="string">&quot;sing&quot;</span>.equals(method.getName()))&#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;准备话筒，收钱&quot;</span>);</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;dance&quot;</span>.equals(method.getName()))&#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;准备场地，收钱&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//去找大明星开始唱歌或者跳舞</span></span><br><span class="line">                        <span class="comment">//代码的表现形式：调用大明星里面唱歌或者跳舞的方法</span></span><br><span class="line">                        <span class="keyword">return</span> method.invoke(bigStar,args);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> star;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Star</span> &#123;</span><br><span class="line">    <span class="comment">//我们可以把所有想要被代理的方法定义在接口当中</span></span><br><span class="line">    <span class="comment">//唱歌</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">sing</span><span class="params">(String name)</span>;</span><br><span class="line">    <span class="comment">//跳舞</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">dance</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BigStar</span> <span class="keyword">implements</span> <span class="title class_">Star</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BigStar</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BigStar</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//唱歌</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sing</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.name + <span class="string">&quot;正在唱&quot;</span> + name);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;谢谢&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//跳舞</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dance</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.name + <span class="string">&quot;正在跳舞&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;BigStar&#123;name = &quot;</span> + name + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-4-额外扩展"><a href="#2-4-额外扩展" class="headerlink" title="2.4 额外扩展"></a>2.4 额外扩展</h2><p>动态代理，还可以拦截方法</p><p>比如：</p><p>​在这个故事中，经济人作为代理，如果别人让邀请大明星去唱歌，打篮球，经纪人就增强功能。</p><p>​但是如果别人让大明星去扫厕所，经纪人就要拦截，不会去调用大明星的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 类的作用：</span></span><br><span class="line"><span class="comment">*       创建一个代理</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyUtil</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Star <span class="title function_">createProxy</span><span class="params">(BigStar bigStar)</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span></span><br><span class="line">        <span class="type">Star</span> <span class="variable">star</span> <span class="operator">=</span> (Star) Proxy.newProxyInstance(</span><br><span class="line">                ProxyUtil.class.getClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Star.class&#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                        <span class="keyword">if</span>(<span class="string">&quot;cleanWC&quot;</span>.equals(method.getName()))&#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;拦截，不调用大明星的方法&quot;</span>);</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//如果是其他方法，正常执行</span></span><br><span class="line">                        <span class="keyword">return</span> method.invoke(bigStar,args);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> star;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-5-动态代理的练习"><a href="#2-5-动态代理的练习" class="headerlink" title="2.5 动态代理的练习"></a>2.5 动态代理的练习</h2><p>​ 对add方法进行增强，对remove方法进行拦截，对其他方法不拦截也不增强</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyProxyDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//动态代码可以增强也可以拦截</span></span><br><span class="line">        <span class="comment">//1.创建真正干活的人</span></span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.创建代理对象</span></span><br><span class="line">        <span class="comment">//参数一：类加载器。当前类名.class.getClassLoader()</span></span><br><span class="line">        <span class="comment">//                 找到是谁，把当前的类，加载到内存中了，我再麻烦他帮我干一件事情，把后面的代理类，也加载到内存</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//参数二：是一个数组，在数组里面写接口的字节码文件对象。</span></span><br><span class="line">        <span class="comment">//                  如果写了List，那么表示代理，可以代理List接口里面所有的方法，对这些方法可以增强或者拦截</span></span><br><span class="line">        <span class="comment">//                  但是，一定要写ArrayList真实实现的接口</span></span><br><span class="line">        <span class="comment">//                  假设在第二个参数中，写了MyInter接口，那么是错误的。</span></span><br><span class="line">        <span class="comment">//                  因为ArrayList并没有实现这个接口，那么就无法对这个接口里面的方法，进行增强或拦截</span></span><br><span class="line">        <span class="comment">//参数三：用来创建代理对象的匿名内部类</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">proxyList</span> <span class="operator">=</span> (List) Proxy.newProxyInstance(</span><br><span class="line">                <span class="comment">//参数一：类加载器</span></span><br><span class="line">                MyProxyDemo1.class.getClassLoader(),</span><br><span class="line">                <span class="comment">//参数二：是一个数组，表示代理对象能代理的方法范围</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;List.class&#125;,</span><br><span class="line">                <span class="comment">//参数三：本质就是代理对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="comment">//invoke方法参数的意义</span></span><br><span class="line">                    <span class="comment">//参数一：表示代理对象，一般不用（了解）</span></span><br><span class="line">                    <span class="comment">//参数二：就是方法名，我们可以对方法名进行判断，是增强还是拦截</span></span><br><span class="line">                    <span class="comment">//参数三：就是下面第三步调用方法时，传递的参数。</span></span><br><span class="line">                    <span class="comment">//举例1：</span></span><br><span class="line">                    <span class="comment">//list.add(&quot;XX好帅&quot;);</span></span><br><span class="line">                    <span class="comment">//此时参数二就是add这个方法名</span></span><br><span class="line">                    <span class="comment">//此时参数三 args[0] 就是 XX好帅</span></span><br><span class="line">                    <span class="comment">//举例2：</span></span><br><span class="line">                    <span class="comment">//list.set(1, &quot;aaa&quot;);</span></span><br><span class="line">                    <span class="comment">//此时参数二就是set这个方法名</span></span><br><span class="line">                    <span class="comment">//此时参数三  args[0] 就是 1  args[1]&quot;aaa&quot;</span></span><br><span class="line">                    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                        <span class="comment">//对add方法做一个增强，统计耗时时间</span></span><br><span class="line">                        <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;add&quot;</span>)) &#123;</span><br><span class="line">                            <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">                            <span class="comment">//调用集合的方法，真正的添加数据</span></span><br><span class="line">                            method.invoke(list, args);</span><br><span class="line">                            <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">                            System.out.println(<span class="string">&quot;耗时时间：&quot;</span> + (end - start));</span><br><span class="line">                            <span class="comment">//需要进行返回，返回值要跟真正增强或者拦截的方法保持一致</span></span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(method.getName().equals(<span class="string">&quot;remove&quot;</span>) &amp;&amp; args[<span class="number">0</span>] <span class="keyword">instanceof</span> Integer)&#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;拦截了按照索引删除的方法&quot;</span>);</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(method.getName().equals(<span class="string">&quot;remove&quot;</span>))&#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;拦截了按照对象删除的方法&quot;</span>);</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            <span class="comment">//如果当前调用的是其他方法,我们既不增强，也不拦截</span></span><br><span class="line">                            method.invoke(list,args);</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.调用方法</span></span><br><span class="line">        <span class="comment">//如果调用者是list，就好比绕过了第二步的代码，直接添加元素</span></span><br><span class="line">        <span class="comment">//如果调用者是代理对象，此时代理才能帮我们增强或者拦截</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//每次调用方法的时候，都不会直接操作集合</span></span><br><span class="line">        <span class="comment">//而是先调用代理里面的invoke，在invoke方法中进行判断，可以增强或者拦截</span></span><br><span class="line">        proxyList.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        proxyList.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        proxyList.add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">        proxyList.add(<span class="string">&quot;ddd&quot;</span>);</span><br><span class="line"></span><br><span class="line">        proxyList.remove(<span class="number">0</span>);</span><br><span class="line">        proxyList.remove(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印集合</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-日志"><a href="#3-日志" class="headerlink" title="3.日志"></a>3.日志</h1><h2 id="3-1-作用："><a href="#3-1-作用：" class="headerlink" title="3.1 作用："></a>3.1 作用：</h2><p>​跟输出语句一样，可以把程序在运行过程中的详细信息都打印在控制台上。</p><p>​利用log日志还可以把这些详细信息保存到文件和数据库中。</p><h2 id="3-2-使用步骤："><a href="#3-2-使用步骤：" class="headerlink" title="3.2 使用步骤："></a>3.2 使用步骤：</h2><p>​不是java的，也不是自己写的，是第三方提供的代码，所以我们要导入jar包。</p><ul><li><p>把第三方的代码导入到当前的项目当中</p><p>新建lib文件夹，把jar粘贴到lib文件夹当中，全选后右键点击选择add as a ….</p><p>检测导入成功：导入成功后jar包可以展开。在项目重构界面可以看到导入的内容</p></li><li><p>把配置文件粘贴到src文件夹下</p></li><li><p>在代码中获取日志对象</p></li><li><p>调用方法打印日志</p></li></ul><h2 id="3-3-日志级别"><a href="#3-3-日志级别" class="headerlink" title="3.3 日志级别"></a>3.3 日志级别</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TRACE, DEBUG, INFO, WARN, ERROR</span><br></pre></td></tr></table></figure><p>还有两个特殊的：</p><p>​ALL：输出所有日志</p><p>​OFF：关闭所有日志</p><p>日志级别从小到大的关系：</p><p>​TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR</p><h2 id="3-4-配置文件"><a href="#3-4-配置文件" class="headerlink" title="3.4 配置文件"></a>3.4 配置文件</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        CONSOLE ：表示当前的日志信息是可以输出到控制台的。</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;CONSOLE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--输出流对象 默认 System.out 改为 System.err--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">target</span>&gt;</span>System.out<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度</span></span><br><span class="line"><span class="comment">                %msg：日志消息，%n是换行符--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%-5level]  %c [%thread] : %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- File是输出的方向通向文件的 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;FILE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--日志输出路径--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>C:/code/itheima-data.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指定日志文件拆分和压缩规则--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span></span></span><br><span class="line"><span class="tag">                       <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--通过指定压缩文件名称，来确定分割文件方式--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>C:/code/itheima-data2-%d&#123;yyyy-MMdd&#125;.log%i.gz<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--文件拆分大小--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>1MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF</span></span><br><span class="line"><span class="comment">   ， 默认debug</span></span><br><span class="line"><span class="comment">    &lt;root&gt;可以包含零个或多个&lt;appender-ref&gt;元素，标识这个输出位置将会被本日志级别控制。</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;CONSOLE&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;FILE&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote></blockquote><h1 id="4-类加载器"><a href="#4-类加载器" class="headerlink" title="4.类加载器"></a>4.类加载器</h1><h2 id="4-1类加载器"><a href="#4-1类加载器" class="headerlink" title="4.1类加载器"></a>4.1类加载器</h2><ul><li><p>作用</p><p>负责将.class文件（存储的物理文件）加载在到内存中</p><p><img src="https://bu.dusays.com/2024/10/01/66fc0f8d23b2c.png" alt="01_类加载器.png"></p></li></ul><h2 id="4-2类加载的完整过程"><a href="#4-2类加载的完整过程" class="headerlink" title="4.2类加载的完整过程"></a>4.2类加载的完整过程</h2><ul><li><p>类加载时机</p><p>简单理解：字节码文件什么时候会被加载到内存中？</p><p>有以下的几种情况：</p><ul><li>创建类的实例（对象）</li><li>调用类的类方法</li><li>访问类或者接口的类变量，或者为该类变量赋值</li><li>使用反射方式来强制创建某个类或接口对应的java.lang.Class对象</li><li>初始化某个类的子类</li><li>直接使用java.exe命令来运行某个主类</li></ul><p>总结而言：用到了就加载，不用不加载</p></li><li><p>类加载过程</p><ol><li><p>加载</p><ul><li>通过包名 + 类名，获取这个类，准备用流进行传输</li><li>在这个类加载到内存中</li><li>加载完毕创建一个class对象</li></ul><p><img src="https://bu.dusays.com/2024/10/01/66fc0f8d175d4.png" alt="02_类加载过程加载.png"></p></li><li><p>链接</p><ul><li><p>验证</p><p>确保Class文件字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身安全</p><p>(文件中的信息是否符合虚拟机规范有没有安全隐患)</p></li></ul><p><img src="https://bu.dusays.com/2024/10/01/66fc0f8d27eae.png" alt="03_类加载过程验证.png"></p><ul><li><p>准备</p><p>负责为类的类变量（被static修饰的变量）分配内存，并设置默认初始化值</p><p>(初始化静态变量)</p></li></ul><p><img src="https://bu.dusays.com/2024/10/01/66fc0f8d173fa.png" alt="04_类加载过程准备.png"></p><ul><li><p>解析</p><p>将类的二进制数据流中的符号引用替换为直接引用</p><p>(本类中如果用到了其他类，此时就需要找到对应的类)</p></li></ul><p><img src="https://bu.dusays.com/2024/10/01/66fc0f8d2107d.png" alt="05_类加载过程解析.png"></p></li><li><p>初始化</p><p>根据程序员通过程序制定的主观计划去初始化类变量和其他资源</p><p>(静态变量赋值以及初始化其他资源)</p><p><img src="https://bu.dusays.com/2024/10/01/66fc0f8d2a6be.png" alt="06_类加载过程初始化.png"></p></li></ol></li><li><p>小结</p><ul><li>当一个类被使用的时候，才会加载到内存</li><li>类加载的过程: 加载、验证、准备、解析、初始化</li></ul></li></ul><h2 id="4-3类加载的分类【理解】"><a href="#4-3类加载的分类【理解】" class="headerlink" title="4.3类加载的分类【理解】"></a>4.3类加载的分类【理解】</h2><ul><li><p>分类</p><ul><li>Bootstrap class loader：虚拟机的内置类加载器，通常表示为null ，并且没有父null</li><li>Platform class loader：平台类加载器,负责加载JDK中一些特殊的模块</li><li>System class loader：系统类加载器,负责加载用户类路径上所指定的类库</li></ul></li><li><p>类加载器的继承关系</p><ul><li>System的父加载器为Platform</li><li>Platform的父加载器为Bootstrap</li></ul></li><li><p>代码演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取系统类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">systemClassLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取系统类加载器的父加载器 --- 平台类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader1</span> <span class="operator">=</span> systemClassLoader.getParent();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取平台类加载器的父加载器 --- 启动类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader2</span> <span class="operator">=</span> classLoader1.getParent();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;系统类加载器&quot;</span> + systemClassLoader);</span><br><span class="line">        System.out.println(<span class="string">&quot;平台类加载器&quot;</span> + classLoader1);</span><br><span class="line">        System.out.println(<span class="string">&quot;启动类加载器&quot;</span> + classLoader2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-4双亲委派模型【理解】"><a href="#4-4双亲委派模型【理解】" class="headerlink" title="4.4双亲委派模型【理解】"></a>4.4双亲委派模型【理解】</h2><ul><li><p>介绍</p><p>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式</p><p><img src="https://bu.dusays.com/2024/10/01/66fc0f8e2c498.png" alt="07_双亲委派模型.png"></p></li></ul><h2 id="4-5ClassLoader-中的两个方法【应用】"><a href="#4-5ClassLoader-中的两个方法【应用】" class="headerlink" title="4.5ClassLoader 中的两个方法【应用】"></a>4.5ClassLoader 中的两个方法【应用】</h2><ul><li><p>方法介绍</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public static ClassLoader getSystemClassLoader()</td><td>获取系统类加载器</td></tr><tr><td>public InputStream getResourceAsStream(String name)</td><td>加载某一个资源文件</td></tr></tbody></table></li><li><p>示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//static ClassLoader getSystemClassLoader() 获取系统类加载器</span></span><br><span class="line">        <span class="comment">//InputStream getResourceAsStream(String name)  加载某一个资源文件</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取系统类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">systemClassLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//利用加载器去加载一个指定的文件</span></span><br><span class="line">        <span class="comment">//参数：文件的路径（放在src的根目录下，默认去那里加载）</span></span><br><span class="line">        <span class="comment">//返回值：字节流。</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> systemClassLoader.getResourceAsStream(<span class="string">&quot;prop.properties&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        prop.load(is);</span><br><span class="line"></span><br><span class="line">        System.out.println(prop);</span><br><span class="line"></span><br><span class="line">        is.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="5-xml"><a href="#5-xml" class="headerlink" title="5.xml"></a>5.xml</h1><h2 id="5-1概述【理解】"><a href="#5-1概述【理解】" class="headerlink" title="5.1概述【理解】"></a>5.1概述【理解】</h2><ul><li><p>万维网联盟(W3C)</p><p>万维网联盟(W3C)创建于1994年，又称W3C理事会。1994年10月在麻省理工学院计算机科学实验室成立。<br>建立者： Tim Berners-Lee (蒂姆·伯纳斯·李)。<br>是Web技术领域最具权威和影响力的国际中立性技术标准机构。<br>到目前为止，W3C已发布了200多项影响深远的Web技术标准及实施指南，</p><ul><li><p>如广为业界采用的超文本标记语言HTML（标准通用标记语言下的一个应用）、</p></li><li><p>可扩展标记语言XML（标准通用标记语言下的一个子集）</p></li><li><p>以及帮助残障人士有效获得Web信息的无障碍指南（WCAG）等</p><p><img src="https://bu.dusays.com/2024/10/01/66fc0fc4cdcff.png" alt="01_w3c概述.png"></p></li></ul></li><li><p>xml概述</p><p>XML的全称为(EXtensible Markup Language)，是一种可扩展的标记语言<br>标记语言: 通过标签来描述数据的一门语言(标签有时我们也将其称之为元素)<br>可扩展：标签的名字是可以自定义的,XML文件是由很多标签组成的,而标签名是可以自定义的</p></li><li><p>作用</p><ul><li>用于进行存储数据和传输数据</li><li>作为软件的配置文件</li></ul></li><li><p>作为配置文件的优势</p><ul><li>可读性好</li><li>可维护性高</li></ul></li></ul><h2 id="5-2标签的规则【应用】"><a href="#5-2标签的规则【应用】" class="headerlink" title="5.2标签的规则【应用】"></a>5.2标签的规则【应用】</h2><ul><li><p>标签由一对尖括号和合法标识符组成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;student&gt;</span><br></pre></td></tr></table></figure></li><li><p>标签必须成对出现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;student&gt; &lt;/student&gt;</span><br><span class="line">前边的是开始标签，后边的是结束标签</span><br></pre></td></tr></table></figure></li><li><p>特殊的标签可以不成对,但是必须有结束标记</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;address/&gt;</span><br></pre></td></tr></table></figure></li><li><p>标签中可以定义属性,属性和标签名空格隔开,属性值必须用引号引起来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;student id=<span class="string">&quot;1&quot;</span>&gt; &lt;/student&gt;</span><br></pre></td></tr></table></figure></li><li><p>标签需要正确的嵌套</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这是正确的: &lt;student id=<span class="string">&quot;1&quot;</span>&gt; &lt;name&gt;张三&lt;/name&gt; &lt;/student&gt;</span><br><span class="line">这是错误的: &lt;student id=<span class="string">&quot;1&quot;</span>&gt;&lt;name&gt;张三&lt;/student&gt;&lt;/name&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-3语法规则【应用】"><a href="#5-3语法规则【应用】" class="headerlink" title="5.3语法规则【应用】"></a>5.3语法规则【应用】</h2><ul><li><p>语法规则</p><ul><li><p>XML文件的后缀名为：xml</p></li><li><p>文档声明必须是第一行第一列</p><?xml version="1.0" encoding="UTF-8" standalone="yes”?><p>version：该属性是必须存在的<br>encoding：该属性不是必须的</p><p>​打开当前xml文件的时候应该是使用什么字符编码表(一般取值都是UTF-8)</p><p>standalone: 该属性不是必须的，描述XML文件是否依赖其他的xml文件，取值为yes&#x2F;no</p></li><li><p>必须存在一个根标签，有且只能有一个</p></li><li><p>XML文件中可以定义注释信息</p></li><li><p>XML文件中可以存在以下特殊字符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&amp;lt; &lt; 小于</span><br><span class="line">&amp;gt; &gt; 大于</span><br><span class="line">&amp;amp; &amp; 和号</span><br><span class="line">&amp;apos; <span class="string">&#x27; 单引号</span></span><br><span class="line"><span class="string">&amp;quot; &quot; 引号</span></span><br></pre></td></tr></table></figure></li><li><p>XML文件中可以存在CDATA区</p><![CDATA[ …内容… ]]></li></ul></li><li><p>示例代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--注释的内容--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--本xml文件用来描述多个学生信息--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">students</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--第一个学生信息--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">student</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>23<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">info</span>&gt;</span>学生<span class="symbol">&amp;lt;</span> <span class="symbol">&amp;gt;</span><span class="symbol">&amp;gt;</span><span class="symbol">&amp;gt;</span><span class="symbol">&amp;gt;</span><span class="symbol">&amp;gt;</span><span class="symbol">&amp;gt;</span><span class="symbol">&amp;gt;</span><span class="symbol">&amp;gt;</span><span class="symbol">&amp;gt;</span><span class="symbol">&amp;gt;</span><span class="symbol">&amp;gt;</span>的信息<span class="tag">&lt;/<span class="name">info</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">message</span>&gt;</span> &lt;![CDATA[内容 &lt;&lt;&lt;&lt;&lt;&lt; &gt;&gt;&gt;&gt;&gt;&gt; ]]]&gt;<span class="tag">&lt;/<span class="name">message</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--第二个学生信息--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">student</span> <span class="attr">id</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>李四<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>24<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">students</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="5-4xml解析【应用】"><a href="#5-4xml解析【应用】" class="headerlink" title="5.4xml解析【应用】"></a>5.4xml解析【应用】</h2><ul><li><p>概述</p><p>xml解析就是从xml中获取到数据</p></li><li><p>常见的解析思想</p><p>DOM(Document Object Model)文档对象模型:就是把文档的各个组成部分看做成对应的对象。<br>会把xml文件全部加载到内存,在内存中形成一个树形结构,再获取对应的值</p><p><img src="https://bu.dusays.com/2024/10/01/66fc0fc4d1ee0.png" alt="02_dom解析概述.png"></p></li><li><p>常见的解析工具</p><ul><li>JAXP: SUN公司提供的一套XML的解析的API</li><li>JDOM: 开源组织提供了一套XML的解析的API-jdom</li><li>DOM4J: 开源组织提供了一套XML的解析的API-dom4j,全称：Dom For Java</li><li>pull: 主要应用在Android手机端解析XML</li></ul></li><li><p>解析的准备工作</p><ol><li><p>我们可以通过网站：<a href="https://dom4j.github.io/">https://dom4j.github.io/</a> 去下载dom4j</p><p>今天的资料中已经提供,我们不用再单独下载了,直接使用即可</p></li><li><p>将提供好的dom4j-1.6.1.zip解压,找到里面的dom4j-1.6.1.jar</p></li><li><p>在idea中当前模块下新建一个libs文件夹,将jar包复制到文件夹中</p></li><li><p>选中jar包 -&gt; 右键 -&gt; 选择add as library即可</p></li></ol></li><li><p>需求</p><ul><li>解析提供好的xml文件</li><li>将解析到的数据封装到学生对象中</li><li>并将学生对象存储到ArrayList集合中</li><li>遍历集合</li></ul></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="line">&lt;!--注释的内容--&gt;</span><br><span class="line">&lt;!--本xml文件用来描述多个学生信息--&gt;</span><br><span class="line">&lt;students&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--第一个学生信息--&gt;</span><br><span class="line">    &lt;student id=<span class="string">&quot;1&quot;</span>&gt;</span><br><span class="line">        &lt;name&gt;张三&lt;/name&gt;</span><br><span class="line">        &lt;age&gt;<span class="number">23</span>&lt;/age&gt;</span><br><span class="line">    &lt;/student&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--第二个学生信息--&gt;</span><br><span class="line">    &lt;student id=<span class="string">&quot;2&quot;</span>&gt;</span><br><span class="line">        &lt;name&gt;李四&lt;/name&gt;</span><br><span class="line">        &lt;age&gt;<span class="number">24</span>&lt;/age&gt;</span><br><span class="line">    &lt;/student&gt;</span><br><span class="line"></span><br><span class="line">&lt;/students&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上边是已经准备好的student.xml文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String id, String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&#x27;&quot;</span> + id + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 利用dom4j解析xml文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XmlParse</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> DocumentException &#123;</span><br><span class="line">        <span class="comment">//1.获取一个解析器对象</span></span><br><span class="line">        <span class="type">SAXReader</span> <span class="variable">saxReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line">        <span class="comment">//2.利用解析器把xml文件加载到内存中,并返回一个文档对象</span></span><br><span class="line">        <span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> saxReader.read(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;myxml\\xml\\student.xml&quot;</span>));</span><br><span class="line">        <span class="comment">//3.获取到根标签</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">rootElement</span> <span class="operator">=</span> document.getRootElement();</span><br><span class="line">        <span class="comment">//4.通过根标签来获取student标签</span></span><br><span class="line">        <span class="comment">//elements():可以获取调用者所有的子标签.会把这些子标签放到一个集合中返回.</span></span><br><span class="line">        <span class="comment">//elements(&quot;标签名&quot;):可以获取调用者所有的指定的子标签,会把这些子标签放到一个集合中并返回</span></span><br><span class="line">        <span class="comment">//List list = rootElement.elements();</span></span><br><span class="line">        List&lt;Element&gt; studentElements = rootElement.elements(<span class="string">&quot;student&quot;</span>);</span><br><span class="line">        <span class="comment">//System.out.println(list.size());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//用来装学生对象</span></span><br><span class="line">        ArrayList&lt;Student&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.遍历集合,得到每一个student标签</span></span><br><span class="line">        <span class="keyword">for</span> (Element element : studentElements) &#123;</span><br><span class="line">            <span class="comment">//element依次表示每一个student标签</span></span><br><span class="line">  </span><br><span class="line">            <span class="comment">//获取id这个属性</span></span><br><span class="line">            <span class="type">Attribute</span> <span class="variable">attribute</span> <span class="operator">=</span> element.attribute(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">            <span class="comment">//获取id的属性值</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> attribute.getValue();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取name标签</span></span><br><span class="line">            <span class="comment">//element(&quot;标签名&quot;):获取调用者指定的子标签</span></span><br><span class="line">            <span class="type">Element</span> <span class="variable">nameElement</span> <span class="operator">=</span> element.element(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">            <span class="comment">//获取这个标签的标签体内容</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> nameElement.getText();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取age标签</span></span><br><span class="line">            <span class="type">Element</span> <span class="variable">ageElement</span> <span class="operator">=</span> element.element(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">            <span class="comment">//获取age标签的标签体内容</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">age</span> <span class="operator">=</span> ageElement.getText();</span><br><span class="line"></span><br><span class="line"><span class="comment">//            System.out.println(id);</span></span><br><span class="line"><span class="comment">//            System.out.println(name);</span></span><br><span class="line"><span class="comment">//            System.out.println(age);</span></span><br><span class="line"></span><br><span class="line">            <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(id,name,Integer.parseInt(age));</span><br><span class="line">            list.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历操作</span></span><br><span class="line">        <span class="keyword">for</span> (Student student : list) &#123;</span><br><span class="line">            System.out.println(student);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-5DTD约束【理解】"><a href="#5-5DTD约束【理解】" class="headerlink" title="5.5DTD约束【理解】"></a>5.5DTD约束【理解】</h2><ul><li><p>什么是约束</p><p>用来限定xml文件中可使用的标签以及属性</p></li><li><p>约束的分类</p><ul><li>DTD</li><li>schema</li></ul></li><li><p>编写DTD约束</p><ul><li><p>步骤</p><ol><li><p>创建一个文件，这个文件的后缀名为.dtd</p></li><li><p>看xml文件中使用了哪些元素</p><!ELEMENT><p> 可以定义元素</p></li><li><p>判断元素是简单元素还是复杂元素</p><p>简单元素：没有子元素。<br>复杂元素：有子元素的元素；</p></li></ol></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ELEMENT <span class="title function_">persons</span> <span class="params">(person)</span>&gt;</span><br><span class="line">&lt;!ELEMENT <span class="title function_">person</span> <span class="params">(name,age)</span>&gt;</span><br><span class="line">&lt;!ELEMENT <span class="title function_">name</span> <span class="params">(#PCDATA)</span>&gt;</span><br><span class="line">&lt;!ELEMENT <span class="title function_">age</span> <span class="params">(#PCDATA)</span>&gt;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure></li><li><p>引入DTD约束</p><ul><li><p>引入DTD约束的三种方法</p><ul><li><p>引入本地dtd</p><!DOCTYPE 根元素名称 SYSTEM ‘DTD文件的路径'></li><li><p>在xml文件内部引入</p><!DOCTYPE 根元素名称 [ dtd文件内容 ]></li><li><p>引入网络dtd</p><!DOCTYPE 根元素的名称 PUBLIC "DTD文件名称" "DTD文档的URL"></li></ul></li><li><p>代码实现</p><ul><li><p>引入本地DTD约束</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 这是persondtd.dtd文件中的内容,已经提前写好</span><br><span class="line"><span class="meta">&lt;!ELEMENT <span class="keyword">persons</span> (<span class="keyword">person</span>)&gt;</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT <span class="keyword">person</span> (<span class="keyword">name</span>,<span class="keyword">age</span>)&gt;</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT <span class="keyword">name</span> (<span class="keyword">#PCDATA</span>)&gt;</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT <span class="keyword">age</span> (<span class="keyword">#PCDATA</span>)&gt;</span></span><br><span class="line"></span><br><span class="line">// 在person1.xml文件中引入persondtd.dtd约束</span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">persons</span> <span class="keyword">SYSTEM</span> <span class="string">&#x27;persondtd.dtd&#x27;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">persons</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">person</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>23<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">person</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">persons</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在xml文件内部引入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">persons</span> [</span></span><br><span class="line"><span class="meta">        <span class="meta">&lt;!ELEMENT <span class="keyword">persons</span> (<span class="keyword">person</span>)&gt;</span></span></span><br><span class="line"><span class="meta">        <span class="meta">&lt;!ELEMENT <span class="keyword">person</span> (<span class="keyword">name</span>,<span class="keyword">age</span>)&gt;</span></span></span><br><span class="line"><span class="meta">        <span class="meta">&lt;!ELEMENT <span class="keyword">name</span> (<span class="keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">        <span class="meta">&lt;!ELEMENT <span class="keyword">age</span> (<span class="keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">        ]&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">persons</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">person</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>23<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">person</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">persons</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>引入网络dtd</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">persons</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;dtd文件的名称&quot;</span> <span class="string">&quot;dtd文档的URL&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">persons</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">person</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>23<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">person</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">persons</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>DTD语法</p><ul><li><p>定义元素</p><p>定义一个元素的格式为：<!ELEMENT 元素名 元素类型><br>简单元素：</p><p>​EMPTY: 表示标签体为空</p><p>​ANY: 表示标签体可以为空也可以不为空</p><p>​PCDATA: 表示该元素的内容部分为字符串</p><p>复杂元素：<br>​直接写子元素名称. 多个子元素可以使用”,”或者”|”隔开；<br>​“,”表示定义子元素的顺序 ; “|”: 表示子元素只能出现任意一个<br>​“?”零次或一次, “+”一次或多次, “*”零次或多次;如果不写则表示出现一次</p><p><img src="https://bu.dusays.com/2024/10/01/66fc0fc4d7029.png" alt="03_DTD语法定义元素.png"></p></li><li><p>定义属性</p><p>格式</p><p>定义一个属性的格式为：<!ATTLIST 元素名称 属性名称 属性的类型 属性的约束><br>属性的类型：<br>​CDATA类型：普通的字符串</p><p>属性的约束:</p><p>​&#x2F;&#x2F; #REQUIRED： 必须的<br>​&#x2F;&#x2F; #IMPLIED： 属性不是必需的<br>​&#x2F;&#x2F; #FIXED value：属性值是固定的</p></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ELEMENT <span class="title function_">persons</span> <span class="params">(person+)</span>&gt;</span><br><span class="line">&lt;!ELEMENT <span class="title function_">person</span> <span class="params">(name,age)</span>&gt;</span><br><span class="line">&lt;!ELEMENT <span class="title function_">name</span> <span class="params">(#PCDATA)</span>&gt;</span><br><span class="line">&lt;!ELEMENT <span class="title function_">age</span> <span class="params">(#PCDATA)</span>&gt;</span><br><span class="line">&lt;!ATTLIST person id CDATA #REQUIRED&gt;</span><br><span class="line"></span><br><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="line">&lt;!DOCTYPE persons SYSTEM <span class="string">&#x27;persondtd.dtd&#x27;</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;persons&gt;</span><br><span class="line">    &lt;person id=<span class="string">&quot;001&quot;</span>&gt;</span><br><span class="line">        &lt;name&gt;张三&lt;/name&gt;</span><br><span class="line">        &lt;age&gt;<span class="number">23</span>&lt;/age&gt;</span><br><span class="line">    &lt;/person&gt;</span><br><span class="line"></span><br><span class="line">    &lt;<span class="type">person</span> <span class="variable">id</span> <span class="operator">=</span> <span class="string">&quot;002&quot;</span>&gt;</span><br><span class="line">        &lt;name&gt;张三&lt;/name&gt;</span><br><span class="line">        &lt;age&gt;<span class="number">23</span>&lt;/age&gt;</span><br><span class="line">    &lt;/person&gt;</span><br><span class="line"></span><br><span class="line">&lt;/persons&gt;</span><br><span class="line">​```</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="5-6schema约束【理解】"><a href="#5-6schema约束【理解】" class="headerlink" title="5.6schema约束【理解】"></a>5.6schema约束【理解】</h2><ul><li><p>schema和dtd的区别</p><ol><li>schema约束文件也是一个xml文件，符合xml的语法，这个文件的后缀名.xsd</li><li>一个xml中可以引用多个schema约束文件，多个schema使用名称空间区分（名称空间类似于java包名）</li><li>dtd里面元素类型的取值比较单一常见的是PCDATA类型，但是在schema里面可以支持很多个数据类型</li><li>schema 语法更加的复杂</li></ol><p><img src="https://bu.dusays.com/2024/10/01/66fc0fc4c0af0.png" alt="04_schema约束介绍.png"></p></li><li><p>编写schema约束</p><ul><li><p>步骤</p><p>1，创建一个文件，这个文件的后缀名为.xsd。<br>2，定义文档声明<br>3，schema文件的根标签为： <schema><br>4，在<schema>中定义属性：<br>​xmlns&#x3D;<a href="http://www.w3.org/2001/XMLSchema">http://www.w3.org/2001/XMLSchema</a><br>5，在<schema>中定义属性 ：<br>​targetNamespace &#x3D;唯一的url地址，指定当前这个schema文件的名称空间。<br>6，在<schema>中定义属性 ：<br>​elementFormDefault&#x3D;”qualified“，表示当前schema文件是一个质量良好的文件。<br>7，通过element定义元素<br>8，判断当前元素是简单元素还是复杂元素</p><p><img src="https://bu.dusays.com/2024/10/01/66fc0fc4d751a.png" alt="05_schema约束编写.png"></p></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="line">&lt;schema</span><br><span class="line">    xmlns=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span></span><br><span class="line">    targetNamespace=<span class="string">&quot;http://www.itheima.cn/javase&quot;</span></span><br><span class="line">    elementFormDefault=<span class="string">&quot;qualified&quot;</span></span><br><span class="line">&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--定义persons复杂元素--&gt;</span><br><span class="line">    &lt;element name=<span class="string">&quot;persons&quot;</span>&gt;</span><br><span class="line">        &lt;complexType&gt;</span><br><span class="line">            &lt;sequence&gt;</span><br><span class="line">                &lt;!--定义person复杂元素--&gt;</span><br><span class="line">                &lt;<span class="type">element</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;person&quot;</span>&gt;</span><br><span class="line">                    &lt;complexType&gt;</span><br><span class="line">                        &lt;sequence&gt;</span><br><span class="line">                            &lt;!--定义name和age简单元素--&gt;</span><br><span class="line">                            &lt;<span class="type">element</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;name&quot;</span> type = <span class="string">&quot;string&quot;</span>&gt;&lt;/element&gt;</span><br><span class="line">                            &lt;<span class="type">element</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;age&quot;</span> type = <span class="string">&quot;string&quot;</span>&gt;&lt;/element&gt;</span><br><span class="line">                        &lt;/sequence&gt;</span><br><span class="line">                        </span><br><span class="line">                    &lt;/complexType&gt;</span><br><span class="line">                &lt;/element&gt;</span><br><span class="line">            &lt;/sequence&gt;</span><br><span class="line">        &lt;/complexType&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/element&gt;</span><br><span class="line"></span><br><span class="line">&lt;/schema&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li><li><p>引入schema约束</p><ul><li><p>步骤</p><p>1，在根标签上定义属性xmlns&#x3D;”<a href="http://www.w3.org/2001/XMLSchema-instance">http://www.w3.org/2001/XMLSchema-instance</a>“<br>2，通过xmlns引入约束文件的名称空间<br>3，给某一个xmlns属性添加一个标识，用于区分不同的名称空间<br>​格式为: xmlns:标识&#x3D;“名称空间地址” ,标识可以是任意的，但是一般取值都是xsi<br>4，通过xsi:schemaLocation指定名称空间所对应的约束文件路径<br>​格式为：xsi:schemaLocation &#x3D; “名称空间url 文件路径“</p></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="line"></span><br><span class="line">&lt;persons</span><br><span class="line">    xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">    xmlns=<span class="string">&quot;http://www.itheima.cn/javase&quot;</span></span><br><span class="line">    xsi:schemaLocation=<span class="string">&quot;http://www.itheima.cn/javase person.xsd&quot;</span></span><br><span class="line">&gt;</span><br><span class="line">    &lt;person&gt;</span><br><span class="line">        &lt;name&gt;张三&lt;/name&gt;</span><br><span class="line">        &lt;age&gt;<span class="number">23</span>&lt;/age&gt;</span><br><span class="line">    &lt;/person&gt;</span><br><span class="line"></span><br><span class="line">&lt;/persons&gt;</span><br><span class="line">​```</span><br></pre></td></tr></table></figure></li></ul></li><li><p>schema约束定义属性</p><ul><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="line">&lt;schema</span><br><span class="line">    xmlns=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span></span><br><span class="line">    targetNamespace=<span class="string">&quot;http://www.itheima.cn/javase&quot;</span></span><br><span class="line">    elementFormDefault=<span class="string">&quot;qualified&quot;</span></span><br><span class="line">&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--定义persons复杂元素--&gt;</span><br><span class="line">    &lt;element name=<span class="string">&quot;persons&quot;</span>&gt;</span><br><span class="line">        &lt;complexType&gt;</span><br><span class="line">            &lt;sequence&gt;</span><br><span class="line">                &lt;!--定义person复杂元素--&gt;</span><br><span class="line">                &lt;<span class="type">element</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;person&quot;</span>&gt;</span><br><span class="line">                    &lt;complexType&gt;</span><br><span class="line">                        &lt;sequence&gt;</span><br><span class="line">                            &lt;!--定义name和age简单元素--&gt;</span><br><span class="line">                            &lt;<span class="type">element</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;name&quot;</span> type = <span class="string">&quot;string&quot;</span>&gt;&lt;/element&gt;</span><br><span class="line">                            &lt;<span class="type">element</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;age&quot;</span> type = <span class="string">&quot;string&quot;</span>&gt;&lt;/element&gt;</span><br><span class="line">                        &lt;/sequence&gt;</span><br><span class="line">                        </span><br><span class="line">                        &lt;!--定义属性，required( 必须的)/optional( 可选的)--&gt;</span><br><span class="line">                        &lt;attribute name=<span class="string">&quot;id&quot;</span> type=<span class="string">&quot;string&quot;</span> use=<span class="string">&quot;required&quot;</span>&gt;&lt;/attribute&gt;</span><br><span class="line">                    &lt;/complexType&gt;</span><br><span class="line">                    </span><br><span class="line">                &lt;/element&gt;</span><br><span class="line">            &lt;/sequence&gt;</span><br><span class="line">        &lt;/complexType&gt;</span><br><span class="line">    &lt;/element&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/schema&gt;</span><br><span class="line"></span><br><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="line">&lt;persons</span><br><span class="line">    xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">    xmlns=<span class="string">&quot;http://www.itheima.cn/javase&quot;</span></span><br><span class="line">    xsi:schemaLocation=<span class="string">&quot;http://www.itheima.cn/javase person.xsd&quot;</span></span><br><span class="line">&gt;</span><br><span class="line">    &lt;person id=<span class="string">&quot;001&quot;</span>&gt;</span><br><span class="line">        &lt;name&gt;张三&lt;/name&gt;</span><br><span class="line">        &lt;age&gt;<span class="number">23</span>&lt;/age&gt;</span><br><span class="line">    &lt;/person&gt;</span><br><span class="line"></span><br><span class="line">&lt;/persons&gt;</span><br><span class="line">​```</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="6-单元测试Junit"><a href="#6-单元测试Junit" class="headerlink" title="6. 单元测试Junit"></a>6. 单元测试Junit</h1><h2 id="6-1-什么是单元测试？（掌握）"><a href="#6-1-什么是单元测试？（掌握）" class="headerlink" title="6.1 什么是单元测试？（掌握）"></a>6.1 什么是单元测试？（掌握）</h2><p>对部分代码进行测试。</p><h2 id="6-2-Junit的特点？（掌握）"><a href="#6-2-Junit的特点？（掌握）" class="headerlink" title="6.2 Junit的特点？（掌握）"></a>6.2 Junit的特点？（掌握）</h2><ul><li><p>是一个第三方的工具。（把别人写的代码导入项目中）（专业叫法：导jar包）</p></li><li><p>如果运行结果显示绿色，表示运行结果是正确的。</p><p>如果运行结果显示红色，表示运行结果是错误的。</p></li></ul><h2 id="6-3-基本用法：（掌握）"><a href="#6-3-基本用法：（掌握）" class="headerlink" title="6.3 基本用法：（掌握）"></a>6.3 基本用法：（掌握）</h2><p>1，一定要先写一个方法。</p><p>2，在这个方法的上面写@Test</p><p>3，鼠标点一下@Test  按alt + 回车，点击Junit4</p><p>​此时就可以自动导包。</p><p>​如果自动导包失败（连接外网，或者自己手动导包）</p><p>​如果导包成功在左下角就会出现Junit4的相关jar包</p><h3 id="手动导包（掌握）"><a href="#手动导包（掌握）" class="headerlink" title="手动导包（掌握）"></a>手动导包（掌握）</h3><p>1，在当前模块下，右键新建一个文件夹（lib）</p><p>2，把今天资料里面的两个jar包，拷贝到lib文件夹里面</p><p>3，选中两个jar右键点击add as a lib….</p><p>4，到代码中，找到@Test，按alt + 回车，再来导入。</p><h3 id="运行测试代码（掌握）"><a href="#运行测试代码（掌握）" class="headerlink" title="运行测试代码（掌握）"></a>运行测试代码（掌握）</h3><ul><li>只能直接运行无参无返回值的非静态方法</li><li>想要运行谁，就右键点击哪个方法。如果想要运行一个类里面所有的测试方法，选择类名，有点点击即可。</li></ul><h3 id="Junit正确的打开方式（正确的使用方式）（掌握）"><a href="#Junit正确的打开方式（正确的使用方式）（掌握）" class="headerlink" title="Junit正确的打开方式（正确的使用方式）（掌握）"></a>Junit正确的打开方式（正确的使用方式）（掌握）</h3><p>注意点：并不是直接在要测试的方法上面直接加@Test</p><p>原因：因为要测试的方法有可能是有参数的，有返回值，或者是静态的。</p><h3 id="正确的使用方式：（掌握）"><a href="#正确的使用方式：（掌握）" class="headerlink" title="正确的使用方式：（掌握）"></a>正确的使用方式：（掌握）</h3><p>1，新建测试类</p><p>2，新建测试方法（要测试的方法名 + Test） methodTest</p><p>3，在这个方法中直接调用要测试的方法</p><p>4，在测试方法的上面写@Test</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//真正用来测试的类</span></span><br><span class="line"><span class="comment">//测试用例（测试类）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JunitTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在这个类里面再写无参无返回值的非静态方法</span></span><br><span class="line">    <span class="comment">//在方法中调用想要测试的方法</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2Test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//调用要测试的方法</span></span><br><span class="line">        <span class="type">JunitDemo1</span> <span class="variable">jd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JunitDemo1</span>();</span><br><span class="line">        jd.method2(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实际开发中单元测试的使用方式（掌握）"><a href="#实际开发中单元测试的使用方式（掌握）" class="headerlink" title="实际开发中单元测试的使用方式（掌握）"></a>实际开发中单元测试的使用方式（掌握）</h3><p>需求：测试File中的delete方法，写的是否正确（掌握）</p><p>开发中的测试原则：</p><p>不污染原数据。</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JunitDemo3</span> &#123;</span><br><span class="line">    <span class="comment">//在实际开发中，真正完整的单元测试该怎么写？</span></span><br><span class="line">    <span class="comment">//前提：</span></span><br><span class="line">    <span class="comment">//以后在工作的时候，测试代码不能污染原数据。（修改，篡改）</span></span><br><span class="line">    <span class="comment">//1.利用Before去对数据做一个初始化的动作</span></span><br><span class="line">    <span class="comment">//2.利用Test真正的去测试方法</span></span><br><span class="line">    <span class="comment">//3.利用After去还原数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//需求：测试File类中的delete方法是否书写正确？？？</span></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforemethod</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//先备份</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">src</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Users\\moon\\Desktop\\a.txt&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">dest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Users\\moon\\Desktop\\copy.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(src);</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(dest);</span><br><span class="line">        <span class="type">int</span> b;</span><br><span class="line">        <span class="keyword">while</span>((b = fis.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(b);</span><br><span class="line">        &#125;</span><br><span class="line">        fos.close();</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//作为一个标准的测试人员，运行完单元测试之后，不能污染原数据</span></span><br><span class="line">    <span class="comment">//需要达到下面两个要求：</span></span><br><span class="line">    <span class="comment">//1.得到结果</span></span><br><span class="line">    <span class="comment">//2.a.txt还在而且其他的备份文件消失</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Users\\moon\\Desktop\\a.txt&quot;</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">delete</span> <span class="operator">=</span> file.delete();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//检查a.txt是否存在</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">exists</span> <span class="operator">=</span> file.exists();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//只有同时满足了下面所有的断言，才表示delete方法编写正确</span></span><br><span class="line">        Assert.assertEquals(<span class="string">&quot;delete方法出错了&quot;</span>,delete,<span class="literal">true</span>);</span><br><span class="line">        Assert.assertEquals(<span class="string">&quot;delete方法出错了&quot;</span>,exists,<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">aftermethod</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//还要对a.txt做一个还原</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">src</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Users\\moon\\Desktop\\copy.txt&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">dest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Users\\moon\\Desktop\\a.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(src);</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(dest);</span><br><span class="line">        <span class="type">int</span> b;</span><br><span class="line">        <span class="keyword">while</span>((b = fis.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(b);</span><br><span class="line">        &#125;</span><br><span class="line">        fos.close();</span><br><span class="line">        fis.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//备份数据要删除</span></span><br><span class="line">        src.delete();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作业：</p><p>​测试Properties类中的store方法是否书写正确？</p><p>开发心得：</p><p>1.Before  准备数据</p><p>2.Test  测试方法</p><p>3.After 还原</p><p>Before</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">准备数据</span><br><span class="line"><span class="number">1.</span>创建Properties的对象</span><br><span class="line"><span class="number">2.</span>put数据到集合当中</span><br><span class="line"><span class="comment">//只不过在下面的方法中，我们也需要用到Properties的对象，所以写完之后要挪到成员位置</span></span><br></pre></td></tr></table></figure><p>Test</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">调用store方法，保存数据到本地文件</span><br><span class="line"></span><br><span class="line">断言<span class="number">1</span>：</span><br><span class="line">判断当前文件是否存在</span><br><span class="line">断言<span class="number">2</span>：</span><br><span class="line">文件的大小一定是大于<span class="number">0</span></span><br><span class="line">断言<span class="number">3</span>：</span><br><span class="line">再次读取文件中的数据，判断是否跟集合中一致</span><br><span class="line"></span><br><span class="line">结论：</span><br><span class="line">如果所有的断言都通过了，表示store方法是正确的</span><br></pre></td></tr></table></figure><p>After</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">把本地文件给删除</span><br></pre></td></tr></table></figure><h3 id="扩展点："><a href="#扩展点：" class="headerlink" title="扩展点："></a>扩展点：</h3><p>在单元测试中，相对路径是相对当前模块而言的。</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;aweihaoshuai.txt&quot;</span>);</span><br><span class="line">file.createNewFile();</span><br><span class="line"><span class="comment">//此时是把aweihaoshuai.txt这个文件新建到模块中了。</span></span><br></pre></td></tr></table></figure><h1 id="7-注解"><a href="#7-注解" class="headerlink" title="7. 注解"></a>7. 注解</h1><h2 id="7-1-注释和注解的区别？（掌握）"><a href="#7-1-注释和注解的区别？（掌握）" class="headerlink" title="7.1 注释和注解的区别？（掌握）"></a>7.1 注释和注解的区别？（掌握）</h2><p>共同点：都可以对程序进行解释说明。</p><p>不同点：注释，是给程序员看的。只在Java中有效。在class文件中不存在注释的。</p><p>​当编译之后，会进行注释擦除。</p><p>​注解，是给虚拟机看的。当虚拟机看到注解之后，就知道要做什么事情了。</p><h2 id="7-2-如何使用注解（掌握）"><a href="#7-2-如何使用注解（掌握）" class="headerlink" title="7.2 如何使用注解（掌握）"></a>7.2 如何使用注解（掌握）</h2><p>在以前看过注解@Override。</p><p>当子类重写父类方法的时候，在重写的方法上面写@Override。</p><p>当虚拟机看到@Override的时候，就知道下面的方法是重写的父类的。检查语法，如果语法正确编译正常，如果语法错误，就会报错。</p><h2 id="7-3-Java中已经存在的注解（掌握）"><a href="#7-3-Java中已经存在的注解（掌握）" class="headerlink" title="7.3 Java中已经存在的注解（掌握）"></a>7.3 Java中已经存在的注解（掌握）</h2><p>@Override：表示方法的重写</p><p>@Deprecated：表示修饰的方法已过时</p><p>@SuppressWarnings(“all”)：压制警告</p><p>除此之外，还需要掌握第三方框架中提供的注解：</p><p>比如：Junit</p><p>@Test 表示运行测试方法</p><p>@Before 表示在Test之前运行，进行数据的初始化</p><p>@After 表示在Test之后运行，进行数据的还原</p><h2 id="7-4-自定义注解（了解）"><a href="#7-4-自定义注解（了解）" class="headerlink" title="7.4 自定义注解（了解）"></a>7.4 自定义注解（了解）</h2><p>自定义注解单独存在是没有什么意义的，一般会跟反射结合起来使用，会用发射去解析注解。</p><p>针对于注解，只要掌握会使用别人已经写好的注解即可。</p><p>关于注解的解析，一般是在框架的底层已经写好了。</p><h2 id="7-5-特殊属性（掌握）"><a href="#7-5-特殊属性（掌握）" class="headerlink" title="7.5 特殊属性（掌握）"></a>7.5 特殊属性（掌握）</h2><p>value：</p><p>​当注解中只有”一个属性”,并且属性名是”value”,使用注解时,可以省略value属性名</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注解的定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Anno2 &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">age</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">23</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注解的使用</span></span><br><span class="line"><span class="meta">@Anno2(&quot;123&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnoDemo2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Anno2(&quot;123&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-6-元注解（了解）"><a href="#7-6-元注解（了解）" class="headerlink" title="7.6 元注解（了解）"></a>7.6 元注解（了解）</h2><p>可以写在注解上面的注解</p><p>@Target ：指定注解能在哪里使用</p><p>@Retention ：可以理解为保留时间(生命周期) </p><h4 id="Target"><a href="#Target" class="headerlink" title="Target:"></a>Target:</h4><p>​    作用：用来标识注解使用的位置，如果没有使用该注解标识，则自定义的注解可以使用在任意位置。</p><p>​    可使用的值定义在ElementType枚举类中，常用值如下</p><ul><li>TYPE，类，接口</li><li>FIELD, 成员变量</li><li>METHOD, 成员方法</li><li>PARAMETER, 方法参数</li><li>CONSTRUCTOR, 构造方法</li><li>LOCAL_VARIABLE, 局部变量</li></ul><h4 id="Retention："><a href="#Retention：" class="headerlink" title="Retention："></a>Retention：</h4><p>​    作用：用来标识注解的生命周期(有效范围)</p><p>​    可使用的值定义在RetentionPolicy枚举类中，常用值如下</p><ul><li>SOURCE：注解只作用在源码阶段，生成的字节码文件中不存在</li><li>CLASS：注解作用在源码阶段，字节码文件阶段，运行阶段不存在，默认值</li><li>RUNTIME：注解作用在源码阶段，字节码文件阶段，运行阶段</li></ul><p>注解的解析：</p><h2 id="7-7-模拟JUnit自带的-Test注解（了解）"><a href="#7-7-模拟JUnit自带的-Test注解（了解）" class="headerlink" title="7.7 模拟JUnit自带的@Test注解（了解）"></a>7.7 模拟JUnit自带的@Test注解（了解）</h2><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyTest &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTestMethod</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyTest</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;method1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;method2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyTest</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;method3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTestDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException, InvocationTargetException &#123;</span><br><span class="line">        <span class="comment">//1,获取class对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.itheima.test2.MyTestMethod&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取所有方法</span></span><br><span class="line">        Method[] methods = clazz.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            <span class="comment">//method依次表示类里面的每一个方法</span></span><br><span class="line">            method.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="comment">//判断当前方法有没有MyTest注解</span></span><br><span class="line">            <span class="keyword">if</span>(method.isAnnotationPresent(MyTest.class))&#123;</span><br><span class="line">                method.invoke(o);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-8-注解小结："><a href="#7-8-注解小结：" class="headerlink" title="7.8 注解小结："></a>7.8 注解小结：</h2><p>掌握如何使用已经存在的注解即可。</p><p>@Override：表示方法的重写</p><p>@Deprecated：表示修饰的方法已过时</p><p>@SuppressWarnings(“all”)：压制警告</p><p>@Test：表示要运行的方法</p><p>在以后的实际开发中，注解是使用框架已经提供好的注解。</p><p>自定义注解+解析注解（很难的，<strong>了解</strong>），一般会出现在框架的底层。当以后我们要自己写一个框架的时候，才会用到自定义注解+解析注解。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反射 </tag>
            
            <tag> 动态代理 </tag>
            
            <tag> 注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码之外的生存指南</title>
      <link href="/posts/fc933cea.html"/>
      <url>/posts/fc933cea.html</url>
      
        <content type="html"><![CDATA[<h1 id="书籍介绍"><a href="#书籍介绍" class="headerlink" title="书籍介绍"></a>书籍介绍</h1><p>这是一本专注于软件开发人员职业发展和个人成长的著作。本书通过丰富的内容和生动的案例，向读者展示了如何成为一个成功的软件开发人员，并如何在职业生涯和个人生活中取得成功。</p><p>首先，本书强调了设定职业目标的重要性。成功软件开发人员的共同点在于他们不仅精通技术技能，更懂得如何发展软技能，如良好的沟通、以身作则的能力、从失败中快速恢复的能力，甚至提升个人健康水平的能力。</p><p>其次，本书深入讨论了如何拓展并维护良好的人际交往能力。在生活和工作中，我们需要有效地与他人互动和交往，决定了我们如何与他人协作，以及是否能建立起有效的人际关系。</p><p>此外，本书还提供了一系列实用的策略和方法，帮助读者应对注意力分散的挑战，提高工作效率与生产力。例如，书中介绍了番茄工作法，这是一种时间管理方法，通过定时的工作和休息，帮助我们减少对干扰物的注意，提高专注力。</p><p>在理财方面，本书也提供了许多实用的建议。理财实践方法主要是关于如何有效地管理财务和利用金钱，以达到个人财务的富足和稳定发展。同时，本书也强调了理财对职业生涯的影响，指出你的财务状态将很大程度上决定你在职业生涯中的关键决策。</p><p>在个人形象塑造方面，本书也给出了具体的建议。通过健身和健康的饮食方式，我们可以改善身体形态、增强身体素质以及提升自信心。</p><p>最后，本书还探讨了心态的力量和重要性。心态对我们的行为和生活影响巨大，一个积极、坚韧的心态可以帮助我们更好地实现自我，创造更好的未来。</p><details class="folding-tag" ><summary> 成功软件开发人员的共同点 </summary>              <div class='content'>              <p>成功软件开发人员的共同点主要体现在他们不仅精通技术技能，更懂得如何发展软技能。如良好的沟通、以身作则的能力、从失败中快速恢复的能力，甚至提升个人健康水平的能力都是他们成功必不可少的因素。</p><p>以作者John Z. Sonmez的经验为例，他在17年的软件开发生涯中，早期曾因技术技能不被赏识而遭受挫折。后来，他通过培养领导技能，沟通技能，以及自我营销的能力等软技能，成功转型成为了一名在线培训名师，年收入达到了令人艳羡的六位数。</p><p>在软件开发领域，变化迅速，新的框架和技术每天都在诞生。因此，一名优秀的软件开发人员，除了要掌握扎实的计算机科学基础知识，还需要善于学习新技能，掌握新技术。此外，他们还需要培养自己在面对道德挑战时做出正确选择的能力。</p><p>对于如何成为一名成功的软件开发人员，作者John Z. Sonmez的建议是先从自我营销开始，先明确自己产品的定位，然后才能更有效地吸引到目标客户。</p>              </div>            </details><details class="folding-tag" ><summary> 设定职业目标的重要性 </summary>              <div class='content'>              <p>设定职业目标的重要性体现在为你的生活提供明确的方向。如同在一片茫茫大海中航行，如果你的船没有方向，那么无论你如何努力划桨，都只是徒劳无功。这就是为什么大多数软件开发人员会发现自己陷入了一个循环圈，没有取得实质性的进展。没有设定职业目标可能会导致生活和工作缺乏方向，可能会让你在面临选择时感到迷茫，甚至可能会让你在面临困境时感到无法应对。</p><p>为了走出这个循环圈，你需要设定职业目标。你可以考虑你的长期和短期目标，无论是成为一家公司的高管，还是开创自己的业务，或者只是成为一个出色的软件开发人员。当你明确自己的目标时，你就可以制定具体的计划，比如你需要掌握哪些技能，你需要获得哪些经验，你计划何时达成你的目标。这些具体的计划可以帮助你避免在生活中随波逐流，让你更有信心，更有动力去面对生活中的挑战。</p><p>同时，设定职业目标并不只是设定具体的职业路径。为了实现你的职业目标，你还需要发展自我营销，提高你的学习效率，管理好你的财务状况，维持健康的身体，保持积极的心态。这些都是帮助你实现职业目标的重要技能。</p>              </div>            </details><details class="folding-tag" ><summary> 拓展并维护良好的人际交往能力 </summary>              <div class='content'>              <p>拓展并维护良好的人际交往能力是人们在生活和工作中的必要技能。它涉及到我们与他人的互动和交往方式，决定了我们如何与他人协作，以及是否能建立起有效的人际关系。</p><p>人际交往能力的重要性在于能提升我们的社会适应性以及生活质量。例如，在团队中进行有效合作，或者与同事建立和谐的关系等。同时，良好的人际交往能力也能帮助我们解决问题，达成目标。</p><p>获取人际交往能力的方法有很多。例如，参与本地用户组，通过社交媒体，甚至加入重叠的社交圈等。在这些场合中，你需要以正确的方式展示自己的能力，并尽可能以真诚的态度与他人互动，这样才能有效地与他人建立联系。</p><p>在与人交往时，你需要记住“每个人都希望感到自己很重要”。当你与他人交流时，请牢记这一准则，时刻洞察自己将会对人类的这一基本需求有何影响。</p>              </div>            </details><details class="folding-tag" ><summary> 如何处理“毒瘤” </summary>              <div class='content'>              <p>如何处理“毒瘤”是指当我们在生活和工作中遇到一些很难相处的人，比如他们常常带来负面情绪或者破坏团队精神，我们可以采取一些策略来限制他们的影响并保护自己。这些人可能会被我们称为”苛性碱”，因为他们总是把自己扮演成”受害者”，总是卷入一些不幸的事件。在人际交往中，我们需要注意他们的言行，避免过多地与他们交往。</p><p>例如，如果你发现某个人总是制造麻烦，总是带来负面情绪，甚至损害到团队的氛围，那么你可能需要尽量减少与他&#x2F;她接触。你可以尽量减少与他们的工作互动，也可以避免与他们在非工作场合的接触。这样做的原因是因为这些人的行为可能会对我们产生负面影响，影响我们的情绪和态度。</p><p>此外，如果你发现这些人是你工作上的上司或者同事，你需要更加谨慎处理。你需要考虑是否需要调整工作团队，或者甚至是寻找新的工作机会。这是因为他们可能会对你的职业生涯产生负面影响。</p>              </div>            </details><details class="folding-tag" ><summary> 自我营销的重要性 </summary>              <div class='content'>              <p>自我营销的重要性主要体现在帮助个体提升在职场和社交场合的影响力，从而获得更多的机会和资源，实现职业和个人目标的达成。以软件开发领域为例，无论你的技术有多么精湛，如果你没有通过有效的自我营销策略让人们知道你的能力，那么你也就只能局限在某个小范围内工作，无法充分利用你的潜能。</p><p>自我营销不是一蹴而就的技能，它需要时间和持续的努力。然而，一旦你学会了自我营销，它就像是个“乘数效应”，让你的才能得以放大。就像在酒吧驻场的乐队，尽管他们的技术水平可能不输原唱艺术家，但因为缺乏有效的营销策略，他们只能在小范围内演出，无法像流行乐队一样在全世界巡回演出，创造着白金唱片。</p><p>对于软件开发人员来说，自我营销的方式多种多样，包括创建博客、写书、演讲、YouTube以及与其他人建立联系等。通过这些方式，你可以打造自己的个人品牌，将自己的独特观点和技能展示给更广泛的受众。一旦形成了自己的品牌风格和信息，你需要找到一种适合的方式来传达这些信息，例如通过博客文章、YouTube视频或者社交媒体平台。</p><p>成功的自我营销并不容易，它需要运气、时机和持续的努力。然而，只要你坚持不懈地投入到自我营销中，你一定能够获得成功。就像齐格勒·齐格所说：“如果你能帮助足够多的人们得到他们想要的东西，你就会得到自己想要的东西。”</p>              </div>            </details><details class="folding-tag" ><summary> 创建个人品牌的步骤 </summary>              <div class='content'>              <p>创建个人品牌的步骤主要涉及到明确品牌信息、选择细分市场、创建品牌口号、创建电梯内销售概要、创建视觉符号五个主要方面。</p><p>在明确要传达的品牌信息这个步骤中，需要了解自我价值和目标受众的核心需求，形成一套独特的价值主张。这就好像你通过写文章来表达自己的观点，你需要清晰、准确地表达自己的观点，让人理解你的立场和价值观。</p><p>在挑选细分市场这个步骤中，则是要确定自己的目标受众，并针对这部分群体进行更深入的沟通和了解。比如你是一个英语老师，你的细分市场就是那些需要学习英语的人，他们可能是在校的大学生，可能是需要提高自己英语水平的上班族，也有可能是想要出国留学的人。</p><p>在创建品牌口号这个步骤中，你需要将自己的独特价值主张凝练成一句简单易懂的口号，这句话必须反映出你的核心理念，并让人们在听到或看到它的时候，立刻就能联想到你或者你的个人品牌。比如著名的苹果公司，它的口号就是“不同凡想”，简洁而有力的展现了其创新、前卫的品牌形象。</p><p>在创建电梯内销售概要这个步骤中，就是要将自己的品牌信息进行进一步的浓缩和整理，用一种简洁、明了的方式展示给听众。比如，假设你是一个销售人员，你可以在搭乘电梯的时间里，用一段简短的语言向潜在客户介绍你的产品或服务，这就是“电梯内销售概要”。</p><p>最后的创建视觉符号，也就是设计自己的商标、网站和宣传资料等，让人们在看到这些视觉元素时就能立刻辨认出你的品牌。这就像一个人的穿着、发型和说话方式，都是传达其性格特点和个人风格的视觉符号。</p>              </div>            </details><details class="folding-tag" ><summary> 品牌的定义与重要性 </summary>              <div class='content'>              <p>品牌的定义与重要性主要包含品牌的四要素：信息传递、视觉符号、品牌一致性和品牌曝光率。</p><p>一个品牌，比如个人品牌，其本质就是传递一种信息。就像你创立的个人品牌“简单程序员”，其核心信息就是“化繁为简”，把各种复杂的概念分解后，转化为人人可以理解的简单概念。这种信息就是你想传达的，以及品牌所承载的情感诉求。也就是说，品牌要明确自己的定位，知道自己的受众是谁，他们的需求是什么，他们期望从你这里获得的体验如何等等。</p><p>品牌的视觉符号也很重要。视觉符号，比如Logo、色彩搭配等，能够让人更快地识别到你的品牌。但是，品牌的关键并不在于视觉元素，而是品牌带给你的感受，是你与品牌互动时的预期。也就是说，即使你的品牌没有视觉符号，只要它能够提供你期望的体验，那就可以说它是一个成功的品牌。</p><p>品牌一致性是构建品牌认知度的关键。一旦失去了一致性，就无法构建品牌认知度。假设其他三个要素你做得都很好，但有的人只见过一次你的品牌，对你也没有太多意义。因此，你需要确保你在各种平台上，比如社交媒体、网站、活动等，所展示和传播的品牌信息与你的品牌口号、视觉符号等相一致。</p>              </div>            </details><details class="folding-tag" ><summary> 应对注意力分散的策略 </summary>              <div class='content'>              <p>应对注意力分散的策略主要在于如何提升个人的专注力和效率。例如，在生活或学习过程中，我们常常会面临各种各样的诱惑，像是不停滑动的手机屏幕，或者沉浸在轻松有趣的视频节目中。在这种情况下，我们需要学会制定有效的策略和方法，来应对注意力分散的挑战。</p><p>有一种方法叫番茄工作法，这是一种时间管理方法。这个方法的核心理念是将工作任务分割成一系列的“番茄时间”，每个番茄时间大约是25分钟。在一个番茄时间里，你需要全神贯注地进行工作，期间不允许任何干扰。一旦番茄钟响，你就要停下来休息5分钟。每完成四个番茄时间，你可以休息15到30分钟。这样的时间管理方式能够帮助我们保持专注，提高工作效率。</p><p>另一种方法就是环境管理。研究发现，我们的注意力很容易受到环境的影响。因此，营造一个有利于专注的环境，也有助于我们提升工作效率。比如，保持工作台整洁，避免干扰性的物品；关掉不相关的网页和应用等。</p><p>另外，还有一种策略叫做定期休息。过度的劳累和压力会消耗我们的精力，使我们更容易受到外界干扰。所以，我们需要在工作过程中安排适当的休息时间，帮助自己恢复精力。比如，每工作一小时就站起来活动一下，或者做一些深呼吸练习。这样不仅可以增强我们的注意力，还能提高我们的工作效率。</p>              </div>            </details><details class="folding-tag" ><summary> 提高工作效率与生产力的方法 </summary>              <div class='content'>              <p>提高工作效率与生产力的方法多种多样，例如GTD、”番茄工作法”和塞恩菲尔德的”不要打破链条”方法等。对我来说，”番茄工作法”是我试过的方法中影响最大且最为有效的。这并非因为我总是认为它是最有效的，相反，我初次使用时并不以为然，甚至怀疑它的实际效果。但是，当我尝试使用了一周后，我真正体会到了它的过人之处。</p><p>番茄工作法的核心理念是将工作时间分割为一段段短周期，每个周期为一段时间，通常为25分钟，称为一个”番茄钟” 。在这25分钟里，你需要全神贯注地进行工作，无论你是正在写代码、学习，还是处理其他事务。每完成一个周期，你就可以休息5分钟。这样的一个周期被称为一个“番茄”。完成4个”番茄”后，你可以休息一个稍长一些的时间，例如15至30分钟。这整个流程就是”番茄工作法”。</p><p>番茄工作法的原理很简单，就是通过定时的工作和休息，帮助你减少对干扰物的注意，提高你的专注力。而专注力的提高，自然也就意味着工作生产力的提高。同时，定时休息也有助于提高你的效率，避免疲劳累积。</p><p>在我的日常工作中，我也经常使用番茄工作法。比如说，我会在一天的开始安排2到3个番茄钟来写作，然后，根据我的工作进度，可能会安排一些处理邮件的番茄钟。这样，我既可以保证工作的效率，也可以保证在一天的工作结束后能够有充分的休息。</p>              </div>            </details><details class="folding-tag" ><summary> 专注的定义与重要性 </summary>              <div class='content'>              <p>专注的定义与重要性主要涵盖了专注是什么，以及为什么专注对于完成任务是至关重要的。根据上述的内容，专注是注意力分散的对立面，是我们专注于完成某一项任务的专注状态。这就好比是，如果我要你全神贯注地写这段文字，那么你就需要暂时忘记其他一切分散你注意力的事情，如手机的消息提示、突然响起的门铃等。</p><p>专注的魔力就在于，如果我们能保持专注，就可以提升我们的工作效率。例如，如果你要写一篇很长的文章，你可能需要一整天的时间。然而，假如你能专注地工作，你可能会发现，其实你只需要几个小时就可以完成。这就是专注的力量。</p><p>要想实现专注，我们首先需要理解，专注并不是一个“即插即用”的开关。要进入专注的状态，往往需要我们先投入一点时间来准备。例如，我刚刚提到的写文章的例子，我首先需要戴上耳机，忽略一切电子邮件，然后全神贯注地对着屏幕打字，直到我找到那个专注于“写这一章”的状态。</p><p>在应对干扰方面，我们需要做好一系列措施来保持专注。例如，我们可以将手机调为静音状态，关掉分散注意力的浏览器窗口，或者在门上挂一个“正在忙，勿打扰”的牌子等。此外，我们还可以借助一些应用程序，如Offtime、BreakFee、Freedom或StayFocused等，来帮助我们更好地应对智能手机的诱惑，保持专注。</p>              </div>            </details><details class="folding-tag" ><summary> 理财实践方法 </summary>              <div class='content'>              <p>理财实践方法主要是关于如何有效地管理财务和利用金钱，以达到个人财务的富足和稳定发展。金钱，如果使用得当，可以成为提升生活品质的工具，相反，如果管理不当，也会带来无穷烦恼，甚至导致生活败落。以软件开发者为例，懂得理财对于其在职业生涯的发展和财务自由度的提升有深远影响。</p><p>首先，理财的第一步是理解理财的基本概念。你需要了解金钱是如何运转的，以及你该如何利用它。这包括了解投资、贷款、储蓄、保险等各种金融工具，以便在适当时使用。</p><p>其次，理财实践方法涉及很多具体的操作，例如如何开始投资不动产、如何谈判你的薪酬、如何开始制订退休计划等等。这些都需要你有足够的专业知识和对市场的理解。例如，如果你决定投资房产，你需要了解房产市场的趋势、选择合适的区域和房型，以及管理房产所需的成本等。同样，如果你希望调整你的薪酬，你需要准备好你的业绩报告，了解市场的行情，同时具备一定的谈判技巧。</p><p>再者，理财实践方法也强调了职业生涯对于财务的重要影响。你在职业生涯中做出的许多关键决策，如跳槽、创业、进修等，都与你对财务的规划密切相关。因此，良好的理财思维可以让你在职业生涯中做出更明智的决策。</p>              </div>            </details><details class="folding-tag" ><summary> 理财对职业生涯的影响 </summary>              <div class='content'>              <p>理财对职业生涯的影响主要表现为：你的财务状态将很大程度上决定你在职业生涯中的关键决策。</p><p>就像一名软件开发人员，你所做的决策不仅涉及到你的工作，还包括你的职业发展路径、跳槽、退休等重要的职业生涯规划。你如何对待财务，比如如何储蓄、投资，直接影响着你的职业规划和生活质量。</p><p>理财不仅是一个财务问题，更是一个心态问题。例如，如果你有明确的职业规划，知道自己的职业目标，就能更好地利用你的财务资源，进行有效的职业投资。此外，积极的心态也能帮助你更好地处理财务问题，比如面对投资失败，如何调整心态，如何持续学习和成长，这些都是你职业生涯中不可或缺的能力。</p><p>因此，理财不仅仅是关于金钱，更多的是关于如何有效使用和管理自己的财务资源，以便更好地支持你的职业生涯，实现你的职业目标。同时，这个过程也需要你有一个积极的心态，让你能够坦然面对财务上的起伏，坚持你的职业目标，实现你的职业梦想。</p>              </div>            </details><details class="folding-tag" ><summary> 健身与个人形象塑造 </summary>              <div class='content'>              <p>健身与个人形象塑造是指通过健身和健康的饮食方式，达到改善身体形态、增强身体素质以及提升自信心的一种过程。对于软件开发人员来说，这尤为重要，因为他们常常长时间坐在电脑前，容易产生久坐导致的多种健康问题，并且，一个健康和健美的形象，也会使他们在工作中更容易成功。</p><p>作者本人从16岁起就开始学习健身和节食，并且参加了18岁时的健美大赛。他不仅在健身上有丰富的经验，还指导和帮助过很多人塑形、减肥、增肌以及达成其他健身目标，显示出他的专业知识。</p><p>对于软件开发人员来说，改变他们的健身观念尤为重要。虽然传统的软件开发人员的形象往往是消瘦、戴眼镜的，但现在很多人认为，软件开发人员都是胖胖的男士，留着络腮胡子，穿着一件脏兮兮的白色T恤。这种刻板印象需要得到改变，而健身则是一个很好的方法。</p><p>对于想要健身的人，作者给出了一些具体的建议。首先，他认为健身并不等同于不能拥有健康和保持好身材，他倡导健康的饮食和科学的运动习惯。其次，他强调在开始任何新的饮食或锻炼计划之前，你可能应该咨询你的医生，以确保你的计划是安全有效的。</p>              </div>            </details><details class="folding-tag" ><summary> 软件开发人员的健身实践与观念 </summary>              <div class='content'>              <p>软件开发人员的健身实践与观念，指的是软件开发人员如何对待和处理自身的健身问题。这个观念不仅关乎个人健康，还影响到工作效率和创造力。从某种意义上说，软件开发人员对健身的理解和实践，是他们生活方式的折射。</p><p>大部分软件开发人员都会长时间坐在电脑前编程，他们面临的健康挑战，包括肥胖、颈椎病、腰椎病等问题。因此，他们更需要通过健身来保持健康。例如，他们可以进行一些有针对性的锻炼，如瑜伽、游泳、跑步等，以此来增强肌肉力量，改善身体柔韧性，改善心血管功能。</p><p>对于软件开发人员来说，健康不只是关乎寿命，更是关乎生活的质量。通过健身，他们可以拥有更强的身体素质和心理素质，这对于他们应对工作中的压力和挑战至关重要。他们可能会发现，健身能帮助他们拥有更清晰的思维，和更高的工作效率。</p><p>但是，由于工作繁忙等原因，很多软件开发人员缺乏健身时间。对于这部分人来说，他们可能会采用一些比较灵活的健身方式，例如使用一些健身APP或设备，利用碎片化时间进行锻炼。他们也会尝试在健身和工作之间找到平衡，例如在办公室附近设置健身房，或者选择在下班后或周末进行锻炼。</p>              </div>            </details><details class="folding-tag" ><summary> 心态的力量和重要性 </summary>              <div class='content'>              <p>心态的力量和重要性体现在很多方面，其中一个关键方面体现在你的职业生涯中。拥有一个商业心态能够帮助你以一种全新的方式看待你的工作，使你能像一位真正的企业家那样，对你的职业生涯进行战略规划和管理。</p><p>对于开发者来说，这种思维方式尤其重要，因为你实际上是在经营一个自己的业务 —— 你的编程技能和服务。你需要学会将雇主视为你的唯一客户，并思考如何为他们提供最好的服务，就像你在经营自己的小店铺一样。</p><p>同样重要的是，你需要像经营一家公司一样来思考你的职业生涯。这意味着你需要不断寻找改进和发展的方法，就像任何企业都在寻求提高产品质量和效率一样。你需要学会推销你的技能，让更多的人了解你的服务，从而提高你的收入。</p><p>心态的力量还体现在处理生活中的困难时。例如，很多人在遇到困难时，倾向于责怪外部环境，认为自己是一个”生活的受害者”。然而，实际上，心态对我们的行为和生活影响巨大。一个人的心态可以让他消极沮丧，也可以使他积极向上。就像卡拉斯科所做的那样，他成功地通过改变自己的心态，从一个消极的软件开发人员变成了一个充满活力、激情四溢的健身教练。</p><p>此外，心态的力量还可以帮助你塑造自我形象，使你相信你可以成为任何你想成为的人。例如，卡罗尔·德韦克在《终身成长：重新定义成功的思维模式》一书中详细阐述了固定心态与成长心态的区别，指出前者会导致人害怕失败，不愿意挑战自己；而后者则鼓励人们拥抱挑战，积极寻求成长和进步。</p>              </div>            </details><details class="folding-tag" ><summary> 斯多葛哲学的定义和核心理念 </summary>              <div class='content'>              <p>斯多葛哲学的定义和核心理念，简单来说，斯多葛哲学是一种强调人应该以超然物外的姿态面对生活挑战，并追求自身价值最大化的思想。斯多葛学派认为，人的能力、财富，乃至生命中的一切都属于“借来的”，因此，我们需要爱我们身边的人，但同时也需要意识到，我们无法永久保留任何事物。</p><p>斯多葛哲学的核心理念之一是超脱，即超然于这个世界，不执着于我们不能控制的事情。就像射箭手在射出箭后对结果就不再能控制一样，我们也需要明白，在我们的生活里，有许多事情是我们无法控制的。所以，斯多葛主义鼓励我们关注并专注于我们能够控制的事情，即我们自己的思想和行为。</p><p>那么，如何实践斯多葛主义呢？简单来说，斯多葛主义倡导我们做最好的自己，关注并专注于我们能够控制的东西，全权负责我们的生活。这意味着我们需要时刻保持良好的心态，积极应对生活的挑战，并从中找寻生命的意义。</p><p>此外，斯多葛主义拒绝命运的摆布。在塞涅卡看来，我们所拥有的一切都不是我们自己的财产，而是借来的。因此，我们需要有借有还，爱我们所拥有的一切，但又需要清楚，我们无法永久保留任何事物。</p>              </div>            </details>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>springbootweb请求响应</title>
      <link href="/posts/9f024484.html"/>
      <url>/posts/9f024484.html</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBootWeb请求响应"><a href="#SpringBootWeb请求响应" class="headerlink" title="SpringBootWeb请求响应"></a>SpringBootWeb请求响应</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在上一次的课程中，我们开发了springbootweb的入门程序。 基于SpringBoot的方式开发一个web应用，浏览器发起请求 &#x2F;hello 后 ，给浏览器返回字符串 “Hello World ~”。</p><p><img src="https://bu.dusays.com/2024/07/24/66a0616d73dec.png" alt="image-20220826161735076.png"></p><p>其实呢，是我们在浏览器发起请求，请求了我们的后端web服务器(也就是内置的Tomcat)。而我们在开发web程序时呢，定义了一个控制器类Controller，请求会被部署在Tomcat中的Controller接收，然后Controller再给浏览器一个响应，响应一个字符串 “Hello World”。 而在请求响应的过程中是遵循HTTP协议的。</p><p>但是呢，这里要告诉大家的时，其实在Tomcat这类Web服务器中，是不识别我们自己定义的Controller的。但是我们前面讲到过Tomcat是一个Servlet容器，是支持Serlvet规范的，所以呢，在tomcat中是可以识别 Servlet程序的。 那我们所编写的XxxController 是如何处理请求的，又与Servlet之间有什么联系呢？</p><p>其实呢，在SpringBoot进行web程序开发时，它内置了一个核心的Servlet程序 DispatcherServlet，称之为 核心控制器。 DispatcherServlet 负责接收页面发送的请求，然后根据执行的规则，将请求再转发给后面的请求处理器Controller，请求处理器处理完请求之后，最终再由DispatcherServlet给浏览器响应数据。</p><p><img src="https://bu.dusays.com/2024/07/24/66a0616d87bcc.png" alt="image-20220826165340157.png"></p><p>那将来浏览器发送请求，会携带请求数据，包括：请求行、请求头；请求到达tomcat之后，tomcat会负责解析这些请求数据，然后呢将解析后的请求数据会传递给Servlet程序的HttpServletRequest对象，那也就意味着 HttpServletRequest 对象就可以获取到请求数据。 而Tomcat，还给Servlet程序传递了一个参数 HttpServletResponse，通过这个对象，我们就可以给浏览器设置响应数据 。</p><p><img src="https://bu.dusays.com/2024/07/24/66a0616d8ee3f.png" alt="image-20220826171407354.png"> </p><p>那上述所描述的这种浏览器&#x2F;服务器的架构模式呢，我们称之为：BS架构。</p><p><img src="https://bu.dusays.com/2024/07/24/66a0616d87c18.png" alt="image-20220826171454775.png"> </p><p>• BS架构：Browser&#x2F;Server，浏览器&#x2F;服务器架构模式。客户端只需要浏览器，应用程序的逻辑和数据都存储在服务端。</p><p>那今天呢，我们的课程内容主要就围绕着：请求、响应进行。 今天课程内容，主要包含三个部分：</p><blockquote><ul><li>请求</li><li>响应</li><li>分层解耦</li></ul></blockquote><h2 id="1-请求"><a href="#1-请求" class="headerlink" title="1. 请求"></a>1. 请求</h2><p>在本章节呢，我们主要讲解，如何接收页面传递过来的请求数据。</p><h3 id="1-1-Postman"><a href="#1-1-Postman" class="headerlink" title="1.1 Postman"></a>1.1 Postman</h3><p>之前我们课程中有提到当前最为主流的开发模式：前后端分离</p><p><img src="https://bu.dusays.com/2024/07/24/66a061700c60f.png" alt="image-20221203095553048.png"></p><p>在这种模式下，前端技术人员基于”接口文档”，开发前端程序；后端技术人员也基于”接口文档”，开发后端程序。</p><p>由于前后端分离，对我们后端技术人员来讲，在开发过程中，是没有前端页面的，那我们怎么测试自己所开发的程序呢？</p><p>方式1：像之前SpringBoot入门案例中一样，直接使用浏览器。在浏览器中输入地址，测试后端程序。</p><ul><li>弊端：在浏览器地址栏中输入地址这种方式都是GET请求，如何我们要用到POST请求怎么办呢？<ul><li>要解决POST请求，需要程序员自己编写前端代码（比较麻烦）</li></ul></li></ul><p>方式2：使用专业的接口测试工具（课程中我们使用Postman工具）</p><h4 id="1-1-1-介绍"><a href="#1-1-1-介绍" class="headerlink" title="1.1.1 介绍"></a>1.1.1 介绍</h4><p><img src="https://bu.dusays.com/2024/07/24/66a0616d5cef8.png" alt="image-20220826173003949.png"> </p><ul><li><p>Postman是一款功能强大的网页调试与发送网页HTTP请求的Chrome插件。</p><blockquote><p>Postman原是Chrome浏览器的插件，可以模拟浏览器向后端服务器发起任何形式(如:get、post)的HTTP请求</p><p>使用Postman还可以在发起请求时，携带一些请求参数、请求头等信息</p></blockquote></li><li><p>作用：常用于进行接口测试</p></li><li><p>特征</p><ul><li>简单</li><li>实用</li><li>美观</li><li>大方</li></ul></li></ul><h4 id="1-1-2-安装"><a href="#1-1-2-安装" class="headerlink" title="1.1.2 安装"></a>1.1.2 安装</h4><p><img src="https://bu.dusays.com/2024/07/24/66a0616d5cf26.png" alt="image-20220826173919556.png"> </p><p>双击资料中提供的<code>Postman-win64-8.3.1-Setup.exe</code>即可自动安装。</p><p><img src="https://bu.dusays.com/2024/07/24/66a0616e74983.png" alt="image-20220826174601266.png"> </p><p>安装完成之后，进入页面中会提示有新版本可以升级（无需升级）</p><p><img src="https://bu.dusays.com/2024/07/24/66a0616ec716e.png" alt="image-20220826174900779.png"></p><p><img src="https://bu.dusays.com/2024/07/24/66a0617056093.png" alt="image-20221203112117979.png"></p><p>界面介绍:</p><p><img src="https://bu.dusays.com/2024/07/24/66a0616ed4504.png" alt="image-20220826175306141.png"> </p><p><strong>如果我们需要将测试的请求信息保存下来，就需要创建一个postman的账号，然后登录之后才可以。</strong></p><p><img src="https://bu.dusays.com/2024/07/24/66a061702fdc7.png" alt="image-20221203103623435.png"></p><p><img src="https://bu.dusays.com/2024/07/24/66a061707a679.png" alt="image-20221203112252985.png"> </p><p><img src="https://bu.dusays.com/2024/07/24/66a0617087cbe.png" alt="image-20221203112320687.png"> </p><p>登录完成之后，可以创建工作空间：</p><p><img src="https://bu.dusays.com/2024/07/24/66a06170f12dc.png" alt="image-20221203113552785.png"></p><p><img src="https://bu.dusays.com/2024/07/24/66a06171ca4a4.png" alt="image-20221203113925733.png"></p><p><img src="https://bu.dusays.com/2024/07/24/66a061717b2aa.png" alt="image-20221203113847126.png"></p><p>创建请求：</p><p><img src="https://bu.dusays.com/2024/07/24/66a0617282c06.png" alt="image-20221203114031824.png"></p><p>点击”Save”，保存当前请求</p><p><img src="https://bu.dusays.com/2024/07/24/66a06172b757a.png" alt="image-20221203114231572.png"></p><p><img src="https://bu.dusays.com/2024/07/24/66a06172c3787.png" alt="image-20221203114806665.png"></p><p><img src="https://bu.dusays.com/2024/07/24/66a06172d8f86.png" alt="image-20221203114852752.png"></p><p><img src="https://bu.dusays.com/2024/07/24/66a06172cff1e.png" alt="image-20221203115001098.png"></p><p><img src="https://bu.dusays.com/2024/07/24/66a06172e8dc9.png" alt="image-20221203115041949.png"></p><p><img src="https://bu.dusays.com/2024/07/24/66a06173a6db8.png" alt="image-20221203115110440.png"></p><h3 id="1-2-简单参数"><a href="#1-2-简单参数" class="headerlink" title="1.2 简单参数"></a>1.2 简单参数</h3><p>简单参数：在向服务器发起请求时，向服务器传递的是一些普通的请求数据。</p><p><img src="https://bu.dusays.com/2024/07/24/66a0616ee8cd8.png" alt="image-20220826180550583.png"></p><p>那么在后端程序中，如何接收传递过来的普通参数数据呢？</p><p>我们在这里讲解两种方式：</p><ol><li>原始方式   </li><li>SpringBoot方式</li></ol><h4 id="1-2-1-原始方式"><a href="#1-2-1-原始方式" class="headerlink" title="1.2.1 原始方式"></a>1.2.1 原始方式</h4><p>在原始的Web程序当中，需要通过Servlet中提供的API：HttpServletRequest（请求对象），获取请求的相关信息。比如获取请求参数：</p><blockquote><p>Tomcat接收到http请求时：把请求的相关信息封装到HttpServletRequest对象中</p></blockquote><p>在Controller中，我们要想获取Request对象，可以直接在方法的形参中声明 HttpServletRequest 对象。然后就可以通过该对象来获取请求信息：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据指定的参数名获取请求参数的数据值</span></span><br><span class="line">String  request.getParameter(<span class="string">&quot;参数名&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestController</span> &#123;</span><br><span class="line">    <span class="comment">//原始方式</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/simpleParam&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">simpleParam</span><span class="params">(HttpServletRequest request)</span>&#123;</span><br><span class="line">        <span class="comment">// http://localhost:8080/simpleParam?name=Tom&amp;age=10</span></span><br><span class="line">        <span class="comment">// 请求参数： name=Tom&amp;age=10   （有2个请求参数）</span></span><br><span class="line">        <span class="comment">// 第1个请求参数： name=Tom   参数名:name，参数值:Tom</span></span><br><span class="line">        <span class="comment">// 第2个请求参数： age=10     参数名:age , 参数值:10</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;name&quot;</span>);<span class="comment">//name就是请求参数名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">ageStr</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;age&quot;</span>);<span class="comment">//age就是请求参数名</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> Integer.parseInt(ageStr);<span class="comment">//需要手动进行类型转换</span></span><br><span class="line">        System.out.println(name+<span class="string">&quot;  :  &quot;</span>+age);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以上这种方式，我们仅做了解。（在以后的开发中不会使用到）</p></blockquote><h4 id="1-2-2-SpringBoot方式"><a href="#1-2-2-SpringBoot方式" class="headerlink" title="1.2.2 SpringBoot方式"></a>1.2.2 SpringBoot方式</h4><p>在Springboot的环境中，对原始的API进行了封装，接收参数的形式更加简单。 如果是简单参数，参数名与形参变量名相同，定义同名的形参即可接收参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestController</span> &#123;</span><br><span class="line">    <span class="comment">// http://localhost:8080/simpleParam?name=Tom&amp;age=10</span></span><br><span class="line">    <span class="comment">// 第1个请求参数： name=Tom   参数名:name，参数值:Tom</span></span><br><span class="line">    <span class="comment">// 第2个请求参数： age=10     参数名:age , 参数值:10</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//springboot方式</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/simpleParam&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">simpleParam</span><span class="params">(String name , Integer age )</span>&#123;<span class="comment">//形参名和请求参数名保持一致</span></span><br><span class="line">        System.out.println(name+<span class="string">&quot;  :  &quot;</span>+age);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>postman测试( GET 请求)：</strong></p><p><img src="https://bu.dusays.com/2024/07/24/66a061743dbd4.png" alt="image-20221203122405075.png"> </p><p><strong>postman测试( POST请求 )：</strong></p><p><img src="https://bu.dusays.com/2024/07/24/66a0616f1b5a4.png" alt="image-20220826181117898.png"></p><blockquote><p><strong>结论：不论是GET请求还是POST请求，对于简单参数来讲，只要保证&#x3D;&#x3D;请求参数名和Controller方法中的形参名保持一致&#x3D;&#x3D;，就可以获取到请求参数中的数据值。</strong></p></blockquote><h4 id="1-2-3-参数名不一致"><a href="#1-2-3-参数名不一致" class="headerlink" title="1.2.3 参数名不一致"></a>1.2.3 参数名不一致</h4><p>如果方法形参名称与请求参数名称不一致，controller方法中的形参还能接收到请求参数值吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestController</span> &#123;</span><br><span class="line">    <span class="comment">// http://localhost:8080/simpleParam?name=Tom&amp;age=20</span></span><br><span class="line">    <span class="comment">// 请求参数名：name</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//springboot方式</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/simpleParam&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">simpleParam</span><span class="params">(String username , Integer age )</span>&#123;<span class="comment">//请求参数名和形参名不相同</span></span><br><span class="line">        System.out.println(username+<span class="string">&quot;  :  &quot;</span>+age);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案：运行没有报错。 controller方法中的username值为：null，age值为20</p><ul><li>结论：对于简单参数来讲，请求参数名和controller方法中的形参名不一致时，无法接收到请求数据</li></ul><p>那么如果我们开发中，遇到了这种请求参数名和controller方法中的形参名不相同，怎么办？</p><p>解决方案：可以使用Spring提供的@RequestParam注解完成映射</p><p>在方法形参前面加上 @RequestParam 然后通过value属性执行请求参数名，从而完成映射。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestController</span> &#123;</span><br><span class="line">    <span class="comment">// http://localhost:8080/simpleParam?name=Tom&amp;age=20</span></span><br><span class="line">    <span class="comment">// 请求参数名：name</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//springboot方式</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/simpleParam&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">simpleParam</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span> String username , Integer age )</span>&#123;</span><br><span class="line">        System.out.println(username+<span class="string">&quot;  :  &quot;</span>+age);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意事项：</strong></p><p>@RequestParam中的required属性默认为true（默认值也是true），代表该请求参数必须传递，如果不传递将报错</p><p><img src="https://bu.dusays.com/2024/07/24/66a061746dae8.png" alt="image-20221203130726310.png"></p><p>如果该参数是可选的，可以将required属性设置为false</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/simpleParam&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">simpleParam</span><span class="params">(<span class="meta">@RequestParam(name = &quot;name&quot;, required = false)</span> String username, Integer age)</span>&#123;</span><br><span class="line">System.out.println(username+ <span class="string">&quot;:&quot;</span> + age);</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="1-3-实体参数"><a href="#1-3-实体参数" class="headerlink" title="1.3 实体参数"></a>1.3 实体参数</h3><p>在使用简单参数做为数据传递方式时，前端传递了多少个请求参数，后端controller方法中的形参就要书写多少个。如果请求参数比较多，通过上述的方式一个参数一个参数的接收，会比较繁琐。 </p><p>此时，我们可以考虑将请求参数封装到一个实体类对象中。 要想完成数据封装，需要遵守如下规则：<strong>请求参数名与实体类的属性名相同</strong></p><p><img src="https://bu.dusays.com/2024/07/24/66a06175952a4.png" alt="image-20221203131954932.png"></p><h4 id="1-3-1-简单实体对象"><a href="#1-3-1-简单实体对象" class="headerlink" title="1.3.1 简单实体对象"></a>1.3.1 简单实体对象</h4><p>定义POJO实体类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Controller方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestController</span> &#123;</span><br><span class="line">    <span class="comment">//实体参数：简单实体对象</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/simplePojo&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">simplePojo</span><span class="params">(User user)</span>&#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Postman测试：</p><ul><li>参数名和实体类属性名一致时</li></ul><p><img src="https://bu.dusays.com/2024/07/24/66a061751b6c3.png" alt="image-20221203161246168.png"> </p><ul><li>参数名和实体类属性名不一致时</li></ul><p><img src="https://bu.dusays.com/2024/07/24/66a061751b6c3.png" alt="image-20221203161004349.png"></p><h4 id="1-3-2-复杂实体对象"><a href="#1-3-2-复杂实体对象" class="headerlink" title="1.3.2 复杂实体对象"></a>1.3.2 复杂实体对象</h4><p>上面我们讲的呢是简单的实体对象，下面我们在来学习下复杂的实体对象。</p><p>复杂实体对象指的是，在实体类中有一个或多个属性，也是实体对象类型的。如下：</p><ul><li>User类中有一个Address类型的属性（Address是一个实体类）</li></ul><p><img src="https://bu.dusays.com/2024/07/24/66a06175d90a4.png" alt="image-20221203160447953.png"></p><p>复杂实体对象的封装，需要遵守如下规则：</p><ul><li><strong>请求参数名与形参对象属性名相同，按照对象层次结构关系即可接收嵌套实体类属性参数。</strong></li></ul><p>定义POJO实体类：</p><ul><li>Address实体类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Address</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String province;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getProvince</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> province;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setProvince</span><span class="params">(String province)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.province = province;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> city;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCity</span><span class="params">(String city)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.city = city;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Address&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;province=&#x27;&quot;</span> + province + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, city=&#x27;&quot;</span> + city + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>User实体类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Address address; <span class="comment">//地址对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Address <span class="title function_">getAddress</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAddress</span><span class="params">(Address address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, address=&quot;</span> + address +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Controller方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestController</span> &#123;</span><br><span class="line">    <span class="comment">//实体参数：复杂实体对象</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/complexPojo&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">complexPojo</span><span class="params">(User user)</span>&#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Postman测试：</p><p><img src="https://bu.dusays.com/2024/07/24/66a061756ad1b.png" alt="image-20221203162706175.png"> </p><h3 id="1-4-数组集合参数"><a href="#1-4-数组集合参数" class="headerlink" title="1.4 数组集合参数"></a>1.4 数组集合参数</h3><p>数组集合参数的使用场景：在HTML的表单中，有一个表单项是支持多选的(复选框)，可以提交选择的多个值。</p><p><img src="https://bu.dusays.com/2024/07/24/66a061764e667.png" alt="image-20221203164114083.png"> </p><p>多个值是怎么提交的呢？其实多个值也是一个一个的提交。</p><p><img src="https://bu.dusays.com/2024/07/24/66a06176d0d2b.png" alt="image-20221203164944144.png"> </p><p>后端程序接收上述多个值的方式有两种：</p><ol><li>数组</li><li>集合</li></ol><h4 id="1-4-1-数组"><a href="#1-4-1-数组" class="headerlink" title="1.4.1 数组"></a>1.4.1 数组</h4><p>数组参数：<strong>请求参数名与形参数组名称相同且请求参数为多个，定义数组类型形参即可接收参数</strong></p><p><img src="https://bu.dusays.com/2024/07/24/66a06176f07b0.png" alt="image-20221203190218468.png"></p><p>Controller方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestController</span> &#123;</span><br><span class="line">    <span class="comment">//数组集合参数</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/arrayParam&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">arrayParam</span><span class="params">(String[] hobby)</span>&#123;</span><br><span class="line">        System.out.println(Arrays.toString(hobby));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Postman测试：</p><p>在前端请求时，有两种传递形式：</p><p>方式一： xxxxxxxxxx?hobby&#x3D;game&amp;hobby&#x3D;java</p><p><img src="https://bu.dusays.com/2024/07/24/66a061771a24b.png" alt="image-20221203191732601.png"> </p><p>方式二：xxxxxxxxxxxxx?hobby&#x3D;game,java</p><p><img src="https://bu.dusays.com/2024/07/24/66a061771cf9e.png" alt="image-20221203191822996.png"></p><h4 id="1-4-2-集合"><a href="#1-4-2-集合" class="headerlink" title="1.4.2 集合"></a>1.4.2 集合</h4><p>集合参数：<strong>请求参数名与形参集合对象名相同且请求参数为多个，@RequestParam 绑定参数关系</strong></p><blockquote><p>默认情况下，请求中参数名相同的多个值，是封装到数组。如果要封装到集合，要使用@RequestParam绑定参数关系</p></blockquote><p><img src="https://bu.dusays.com/2024/07/24/66a06177608f0.png" alt="image-20221203211640646.png"></p><p>Controller方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestController</span> &#123;</span><br><span class="line">    <span class="comment">//数组集合参数</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/listParam&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">listParam</span><span class="params">(<span class="meta">@RequestParam</span> List&lt;String&gt; hobby)</span>&#123;</span><br><span class="line">        System.out.println(hobby);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Postman测试：</p><p>方式一： xxxxxxxxxx?hobby&#x3D;game&amp;hobby&#x3D;java</p><p><img src="https://bu.dusays.com/2024/07/24/66a061784665d.png" alt="image-20221203212221939.png"> </p><p>方式二：xxxxxxxxxxxxx?hobby&#x3D;game,java</p><p><img src="https://bu.dusays.com/2024/07/24/66a061783e691.png" alt="image-20221203212024679.png"></p><h3 id="1-5-日期参数"><a href="#1-5-日期参数" class="headerlink" title="1.5 日期参数"></a>1.5 日期参数</h3><p>上述演示的都是一些普通的参数，在一些特殊的需求中，可能会涉及到日期类型数据的封装。比如，如下需求：</p><p><img src="https://bu.dusays.com/2024/07/24/66a0616f26716.png" alt="image-20220826194159343.png"> </p><p>因为日期的格式多种多样（如：2022-12-12 10:05:45 、2022&#x2F;12&#x2F;12 10:05:45），那么对于日期类型的参数在进行封装的时候，需要通过@DateTimeFormat注解，以及其pattern属性来设置日期的格式。</p><p><img src="https://bu.dusays.com/2024/07/24/66a061785e75f.png" alt="image-20221203213120692.png"></p><ul><li>@DateTimeFormat注解的pattern属性中指定了哪种日期格式，前端的日期参数就必须按照指定的格式传递。</li><li>后端controller方法中，需要使用Date类型或LocalDateTime类型，来封装传递的参数。</li></ul><p>Controller方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestController</span> &#123;</span><br><span class="line">    <span class="comment">//日期时间参数</span></span><br><span class="line">   <span class="meta">@RequestMapping(&quot;/dateParam&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">dateParam</span><span class="params">(<span class="meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)</span> LocalDateTime updateTime)</span>&#123;</span><br><span class="line">        System.out.println(updateTime);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Postman测试：</p><p><img src="https://bu.dusays.com/2024/07/24/66a06178695da.png" alt="image-20221203214600716.png"></p><h3 id="1-6-JSON参数"><a href="#1-6-JSON参数" class="headerlink" title="1.6 JSON参数"></a>1.6 JSON参数</h3><p>在学习前端技术时，我们有讲到过JSON，而在前后端进行交互时，如果是比较复杂的参数，前后端通过会使用JSON格式的数据进行传输。 （JSON是开发中最常用的前后端数据交互方式）</p><p>我们学习JSON格式参数，主要从以下两个方面着手：</p><ol><li>Postman在发送请求时，如何传递json格式的请求参数</li><li>在服务端的controller方法中，如何接收json格式的请求参数</li></ol><p>Postman发送JSON格式数据：</p><p><img src="https://bu.dusays.com/2024/07/24/66a061787eb99.png" alt="image-20221203225623337.png"></p><p>服务端Controller方法接收JSON格式数据：</p><ul><li>传递json格式的参数，在Controller中会使用实体类进行封装。 </li><li>封装规则：<strong>JSON数据键名与形参对象属性名相同，定义POJO类型形参即可接收参数。需要使用 @RequestBody标识。</strong></li></ul><p><img src="https://bu.dusays.com/2024/07/24/66a061798bb6c.png" alt="image-20221203230457901.png"></p><ul><li>@RequestBody注解：将JSON数据映射到形参的实体类对象中（JSON中的key和实体类中的属性名保持一致）</li></ul><p>实体类：Address</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Address</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String province;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//省略GET , SET 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实体类：User</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//省略GET , SET 方法</span></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>Controller方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestController</span> &#123;</span><br><span class="line">    <span class="comment">//JSON参数</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/jsonParam&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">jsonParam</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span>&#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Postman测试：</p><p><img src="https://bu.dusays.com/2024/07/24/66a0617990494.png" alt="image-20221203231803000.png"> </p><h3 id="1-7-路径参数"><a href="#1-7-路径参数" class="headerlink" title="1.7 路径参数"></a>1.7 路径参数</h3><p>传统的开发中请求参数是放在请求体(POST请求)传递或跟在URL后面通过?key&#x3D;value的形式传递(GET请求)。</p><p><img src="https://bu.dusays.com/2024/07/24/66a06179cf845.png" alt="image-20221203235715804.png"></p><p>在现在的开发中，经常还会直接在请求的URL中传递参数。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/user/1</span><br><span class="line">http://localhost:880/user/1/0</span><br></pre></td></tr></table></figure><p>上述的这种传递请求参数的形式呢，我们称之为：路径参数。</p><p>学习路径参数呢，主要掌握在后端的controller方法中，如何接收路径参数。</p><p>路径参数：</p><ul><li>前端：通过请求URL直接传递参数</li><li>后端：使用{…}来标识该路径参数，需要使用@PathVariable获取路径参数</li></ul><p><img src="https://bu.dusays.com/2024/07/24/66a0617a03dac.png" alt="image-20221204001520756.png"></p><p>Controller方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestController</span> &#123;</span><br><span class="line">    <span class="comment">//路径参数</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/path/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">pathParam</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span>&#123;</span><br><span class="line">        System.out.println(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Postman测试：</p><p><img src="https://bu.dusays.com/2024/07/24/66a06179d80e8.png" alt="image-20221204002040184.png"></p><p><strong>传递多个路径参数：</strong></p><p>Postman：</p><p><img src="https://bu.dusays.com/2024/07/24/66a0617a8ea4c.png" alt="image-20221204002306288.png"></p><p>Controller方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestController</span> &#123;</span><br><span class="line">    <span class="comment">//路径参数</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/path/&#123;id&#125;/&#123;name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">pathParam2</span><span class="params">(<span class="meta">@PathVariable</span> Integer id, <span class="meta">@PathVariable</span> String name)</span>&#123;</span><br><span class="line">        System.out.println(id+ <span class="string">&quot; : &quot;</span> +name);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-响应"><a href="#2-响应" class="headerlink" title="2. 响应"></a>2. 响应</h2><p>前面我们学习过HTTL协议的交互方式：请求响应模式（有请求就有响应）</p><p>那么Controller程序呢，除了接收请求外，还可以进行响应。</p><h3 id="2-1-ResponseBody"><a href="#2-1-ResponseBody" class="headerlink" title="2.1 @ResponseBody"></a>2.1 @ResponseBody</h3><p>在我们前面所编写的controller方法中，都已经设置了响应数据。</p><p><img src="https://bu.dusays.com/2024/07/24/66a0617abb071.png" alt="image-20221204100656376.png"></p><p>controller方法中的return的结果，怎么就可以响应给浏览器呢？</p><p>答案：使用@ResponseBody注解</p><p><strong>@ResponseBody注解：</strong></p><ul><li>类型：方法注解、类注解</li><li>位置：书写在Controller方法上或类上</li><li>作用：将方法返回值直接响应给浏览器<ul><li>如果返回值类型是实体对象&#x2F;集合，将会转换为JSON格式后在响应给浏览器</li></ul></li></ul><p>但是在我们所书写的Controller中，只在类上添加了@RestController注解、方法添加了@RequestMapping注解，并没有使用@ResponseBody注解，怎么给浏览器响应呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World ~&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello World ~&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因：在类上添加的@RestController注解，是一个组合注解。</p><ul><li>@RestController &#x3D; @Controller + @ResponseBody</li></ul><p>@RestController源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span>   <span class="comment">//元注解（修饰注解的注解）</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span>  <span class="comment">//元注解</span></span><br><span class="line"><span class="meta">@Documented</span>    <span class="comment">//元注解</span></span><br><span class="line"><span class="meta">@Controller</span>   </span><br><span class="line"><span class="meta">@ResponseBody</span> </span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RestController &#123;</span><br><span class="line">    <span class="meta">@AliasFor(</span></span><br><span class="line"><span class="meta">        annotation = Controller.class</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结论：在类上添加@RestController就相当于添加了@ResponseBody注解。</p><ul><li>类上有@RestController注解或@ResponseBody注解时：表示当前类下所有的方法返回值做为响应数据<ul><li>方法的返回值，如果是一个POJO对象或集合时，会先转换为JSON格式，在响应给浏览器</li></ul></li></ul><p>下面我们来测试下响应数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResponseController</span> &#123;</span><br><span class="line">    <span class="comment">//响应字符串</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World ~&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello World ~&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//响应实体对象</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/getAddr&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Address <span class="title function_">getAddr</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Address</span> <span class="variable">addr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Address</span>();<span class="comment">//创建实体类对象</span></span><br><span class="line">        addr.setProvince(<span class="string">&quot;广东&quot;</span>);</span><br><span class="line">        addr.setCity(<span class="string">&quot;深圳&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> addr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//响应集合数据</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/listAddr&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Address&gt; <span class="title function_">listAddr</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;Address&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//集合对象</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">Address</span> <span class="variable">addr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Address</span>();</span><br><span class="line">        addr.setProvince(<span class="string">&quot;广东&quot;</span>);</span><br><span class="line">        addr.setCity(<span class="string">&quot;深圳&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Address</span> <span class="variable">addr2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Address</span>();</span><br><span class="line">        addr2.setProvince(<span class="string">&quot;陕西&quot;</span>);</span><br><span class="line">        addr2.setCity(<span class="string">&quot;西安&quot;</span>);</span><br><span class="line"></span><br><span class="line">        list.add(addr);</span><br><span class="line">        list.add(addr2);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在服务端响应了一个对象或者集合，那私前端获取到的数据是什么样子的呢？我们使用postman发送请求来测试下。测试效果如下：</p><p><img src="https://bu.dusays.com/2024/07/24/66a0617b64d95.png" alt="image-20221204172339375.png"></p><p><img src="https://bu.dusays.com/2024/07/24/66a0617b7bfc5.png" alt="image-20221204172705426.png"></p><h3 id="2-2-统一响应结果"><a href="#2-2-统一响应结果" class="headerlink" title="2.2 统一响应结果"></a>2.2 统一响应结果</h3><p>大家有没有发现一个问题，我们在前面所编写的这些Controller方法中，返回值各种各样，没有任何的规范。</p><p><img src="https://bu.dusays.com/2024/07/24/66a0617bdca5b.png" alt="image-20221204174052622.png"></p><p>如果我们开发一个大型项目，项目中controller方法将成千上万，使用上述方式将造成整个项目难以维护。那在真实的项目开发中是什么样子的呢？</p><p>在真实的项目开发中，无论是哪种方法，我们都会定义一个统一的返回结果。方案如下：</p><p><img src="https://bu.dusays.com/2024/07/24/66a0617c27fd1.png" alt="problem.png"></p><blockquote><p>前端：只需要按照统一格式的返回结果进行解析(仅一种解析方案)，就可以拿到数据。</p></blockquote><p>统一的返回结果使用类来描述，在这个结果中包含：</p><ul><li><p>响应状态码：当前请求是成功，还是失败</p></li><li><p>状态码信息：给页面的提示信息</p></li><li><p>返回的数据：给前端响应的数据（字符串、对象、集合）</p></li></ul><p>定义在一个实体类Result来包含以上信息。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer code;<span class="comment">//响应码，1 代表成功; 0 代表失败</span></span><br><span class="line">    <span class="keyword">private</span> String msg;  <span class="comment">//响应码 描述字符串</span></span><br><span class="line">    <span class="keyword">private</span> Object data; <span class="comment">//返回的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Result</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Result</span><span class="params">(Integer code, String msg, Object data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCode</span><span class="params">(Integer code)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMsg</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(Object data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//增删改 成功响应(不需要给前端返回数据)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">success</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="number">1</span>,<span class="string">&quot;success&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查询 成功响应(把查询结果做为返回数据响应给前端)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">success</span><span class="params">(Object data)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="number">1</span>,<span class="string">&quot;success&quot;</span>,data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//失败响应</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">error</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="number">0</span>,msg,<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改造Controller：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResponseController</span> &#123; </span><br><span class="line">    <span class="comment">//响应统一格式的结果</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World ~&quot;</span>);</span><br><span class="line">        <span class="comment">//return new Result(1,&quot;success&quot;,&quot;Hello World ~&quot;);</span></span><br><span class="line">        <span class="keyword">return</span> Result.success(<span class="string">&quot;Hello World ~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//响应统一格式的结果</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/getAddr&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">getAddr</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Address</span> <span class="variable">addr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Address</span>();</span><br><span class="line">        addr.setProvince(<span class="string">&quot;广东&quot;</span>);</span><br><span class="line">        addr.setCity(<span class="string">&quot;深圳&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Result.success(addr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//响应统一格式的结果</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/listAddr&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">listAddr</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;Address&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">Address</span> <span class="variable">addr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Address</span>();</span><br><span class="line">        addr.setProvince(<span class="string">&quot;广东&quot;</span>);</span><br><span class="line">        addr.setCity(<span class="string">&quot;深圳&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Address</span> <span class="variable">addr2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Address</span>();</span><br><span class="line">        addr2.setProvince(<span class="string">&quot;陕西&quot;</span>);</span><br><span class="line">        addr2.setCity(<span class="string">&quot;西安&quot;</span>);</span><br><span class="line"></span><br><span class="line">        list.add(addr);</span><br><span class="line">        list.add(addr2);</span><br><span class="line">        <span class="keyword">return</span> Result.success(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Postman测试：</p><p><img src="https://bu.dusays.com/2024/07/24/66a0617c64fd3.png" alt="image-20221204180946963.png"></p><p><img src="https://bu.dusays.com/2024/07/24/66a0617c27fd1.png" alt="image-20221204180744084.png"></p><h3 id="2-3-案例"><a href="#2-3-案例" class="headerlink" title="2.3 案例"></a>2.3 案例</h3><p>下面我们通过一个案例，来加强对请求响应的学习。</p><h4 id="2-3-1-需求说明"><a href="#2-3-1-需求说明" class="headerlink" title="2.3.1 需求说明"></a>2.3.1 需求说明</h4><p>需求：加载并解析xml文件中的数据，完成数据处理，并在页面展示</p><p><img src="https://bu.dusays.com/2024/07/24/66a0617ddb914.png" alt="image-20221204185928260.png">  </p><ul><li>获取员工数据，返回统一响应结果，在页面渲染展示</li></ul><h4 id="2-3-2-准备工作"><a href="#2-3-2-准备工作" class="headerlink" title="2.3.2 准备工作"></a>2.3.2 准备工作</h4><p>案例准备：</p><ol><li><p>XML文件</p><ul><li>已经准备好(emp.xml)，直接导入进来，放在 src&#x2F;main&#x2F;resources目录下</li></ul></li><li><p>工具类</p><ul><li>已经准备好解析XML文件的工具类，无需自己实现</li><li>直接在创建一个包 com.itheima.utils ，然后将工具类拷贝进来</li></ul></li><li><p>前端页面资源</p><ul><li>已经准备好，直接拷贝进来，放在src&#x2F;main&#x2F;resources下的static目录下</li></ul></li></ol><p>Springboot项目的静态资源(html，css，js等前端资源)默认存放目录为：classpath:&#x2F;static 、 classpath:&#x2F;public、 classpath:&#x2F;resources</p><blockquote><p>在SpringBoot项目中，静态资源默认可以存放的目录：</p><ul><li>classpath:&#x2F;static&#x2F;</li><li>classpath:&#x2F;public&#x2F;</li><li>classpath:&#x2F;resources&#x2F;</li><li>classpath:&#x2F;META-INF&#x2F;resources&#x2F;</li></ul><p>classpath：</p><ul><li>代表的是类路径，在maven的项目中，其实指的就是 src&#x2F;main&#x2F;resources 或者 src&#x2F;main&#x2F;java，但是java目录是存放java代码的，所以相关的配置文件及静态资源文档，就放在 src&#x2F;main&#x2F;resources下。</li></ul></blockquote><h4 id="2-3-3-实现步骤"><a href="#2-3-3-实现步骤" class="headerlink" title="2.3.3 实现步骤"></a>2.3.3 实现步骤</h4><ol><li><p>在pom.xml文件中引入dom4j的依赖，用于解析XML文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.dom4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dom4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>引入资料中提供的：解析XML的工具类XMLParserUtils、实体类Emp、XML文件emp.xml</p><p><img src="https://bu.dusays.com/2024/07/24/66a0617c6b5e6.png" alt="image-20221204182828547.png"> </p></li><li><p>引入资料中提供的静态页面文件，放在resources下的static目录下</p><p><img src="https://bu.dusays.com/2024/07/24/66a0617d0aca9.png" alt="image-20221204183044848.png"> </p></li><li><p>创建EmpController类，编写Controller程序，处理请求，响应数据</p><p><img src="https://bu.dusays.com/2024/07/24/66a0617d3fbf2.png" alt="image-20221204184313822.png"></p></li></ol><h4 id="2-3-4-代码实现"><a href="#2-3-4-代码实现" class="headerlink" title="2.3.4 代码实现"></a>2.3.4 代码实现</h4><p>Contriller代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmpController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/listEmp&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">list</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1. 加载并解析emp.xml</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">file</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getClassLoader().getResource(<span class="string">&quot;emp.xml&quot;</span>).getFile();</span><br><span class="line">        <span class="comment">//System.out.println(file);</span></span><br><span class="line">        List&lt;Emp&gt; empList = XmlParserUtils.parse(file, Emp.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 对数据进行转换处理 - gender, job</span></span><br><span class="line">        empList.stream().forEach(emp -&gt; &#123;</span><br><span class="line">            <span class="comment">//处理 gender 1: 男, 2: 女</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">gender</span> <span class="operator">=</span> emp.getGender();</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;1&quot;</span>.equals(gender))&#123;</span><br><span class="line">                emp.setGender(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;2&quot;</span>.equals(gender))&#123;</span><br><span class="line">                emp.setGender(<span class="string">&quot;女&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//处理job - 1: 讲师, 2: 班主任 , 3: 就业指导</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">job</span> <span class="operator">=</span> emp.getJob();</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;1&quot;</span>.equals(job))&#123;</span><br><span class="line">                emp.setJob(<span class="string">&quot;讲师&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;2&quot;</span>.equals(job))&#123;</span><br><span class="line">                emp.setJob(<span class="string">&quot;班主任&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;3&quot;</span>.equals(job))&#123;</span><br><span class="line">                emp.setJob(<span class="string">&quot;就业指导&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//3. 响应数据</span></span><br><span class="line">        <span class="keyword">return</span> Result.success(empList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>统一返回结果实体类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer code ;<span class="comment">//1 成功 , 0 失败</span></span><br><span class="line">    <span class="keyword">private</span> String msg; <span class="comment">//提示信息</span></span><br><span class="line">    <span class="keyword">private</span> Object data; <span class="comment">//数据 date</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Result</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Result</span><span class="params">(Integer code, String msg, Object data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCode</span><span class="params">(Integer code)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMsg</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(Object data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">success</span><span class="params">(Object data)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="number">1</span>, <span class="string">&quot;success&quot;</span>, data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">success</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="number">1</span>, <span class="string">&quot;success&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">error</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="number">0</span>, msg, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-5-测试"><a href="#2-3-5-测试" class="headerlink" title="2.3.5 测试"></a>2.3.5 测试</h4><p>代码编写完毕之后，我们就可以运行引导类，启动服务进行测试了。 </p><p>使用Postman测试：</p><p><img src="https://bu.dusays.com/2024/07/24/66a0617dc6906.png" alt="image-20221204190341389.png"></p><p>打开浏览器，在浏览器地址栏输入： <a href="http://localhost:8080/emp.html">http://localhost:8080/emp.html</a></p><p><img src="https://bu.dusays.com/2024/07/24/66a0617d790b5.png" alt="image-20221204185455556.png"> </p><h4 id="2-3-6-问题分析"><a href="#2-3-6-问题分析" class="headerlink" title="2.3.6 问题分析"></a>2.3.6 问题分析</h4><p>上述案例的功能，我们虽然已经实现，但是呢，我们会发现案例中：解析XML数据，获取数据的代码，处理数据的逻辑的代码，给页面响应的代码全部都堆积在一起了，全部都写在controller方法中了。</p><p><img src="https://bu.dusays.com/2024/07/24/66a0617e5d226.png" alt="image-20221204190712411.png"></p><p>当前程序的这个业务逻辑还是比较简单的，如果业务逻辑再稍微复杂一点，我们会看到Controller方法的代码量就很大了。</p><ul><li><p>当我们要修改操作数据部分的代码，需要改动Controller</p></li><li><p>当我们要完善逻辑处理部分的代码，需要改动Controller</p></li><li><p>当我们需要修改数据响应的代码，还是需要改动Controller</p></li></ul><p>这样呢，就会造成我们整个工程代码的复用性比较差，而且代码难以维护。 那如何解决这个问题呢？其实在现在的开发中，有非常成熟的解决思路，那就是分层开发。</p><h2 id="3-分层解耦"><a href="#3-分层解耦" class="headerlink" title="3. 分层解耦"></a>3. 分层解耦</h2><h3 id="3-1-三层架构"><a href="#3-1-三层架构" class="headerlink" title="3.1 三层架构"></a>3.1 三层架构</h3><h4 id="3-1-1-介绍"><a href="#3-1-1-介绍" class="headerlink" title="3.1.1 介绍"></a>3.1.1 介绍</h4><p>在我们进行程序设计以及程序开发时，尽可能让每一个接口、类、方法的职责更单一些（单一职责原则）。</p><blockquote><p>单一职责原则：一个类或一个方法，就只做一件事情，只管一块功能。</p><p>这样就可以让类、接口、方法的复杂度更低，可读性更强，扩展性更好，也更利用后期的维护。</p></blockquote><p>我们之前开发的程序呢，并不满足单一职责原则。下面我们来分析下之前的程序：</p><p><img src="https://bu.dusays.com/2024/07/24/66a0617e758c7.png" alt="image-20221204191650390.png"> </p><p>那其实我们上述案例的处理逻辑呢，从组成上看可以分为三个部分：</p><ul><li>数据访问：负责业务数据的维护操作，包括增、删、改、查等操作。</li><li>逻辑处理：负责业务逻辑处理的代码。</li><li>请求处理、响应数据：负责，接收页面的请求，给页面响应数据。</li></ul><p>按照上述的三个组成部分，在我们项目开发中呢，可以将代码分为三层：</p><p><img src="https://bu.dusays.com/2024/07/24/66a0617ea6b24.png" alt="image-20221204193837678.png"></p><ul><li>Controller：控制层。接收前端发送的请求，对请求进行处理，并响应数据。</li><li>Service：业务逻辑层。处理具体的业务逻辑。</li><li>Dao：数据访问层(Data Access Object)，也称为持久层。负责数据访问操作，包括数据的增、删、改、查。</li></ul><p>基于三层架构的程序执行流程：</p><p><img src="https://bu.dusays.com/2024/07/24/66a0617f05a04.png" alt="image-20221204194207812.png"></p><ul><li>前端发起的请求，由Controller层接收（Controller响应数据给前端）</li><li>Controller层调用Service层来进行逻辑处理（Service层处理完后，把处理结果返回给Controller层）</li><li>Serivce层调用Dao层（逻辑处理过程中需要用到的一些数据要从Dao层获取）</li><li>Dao层操作文件中的数据（Dao拿到的数据会返回给Service层）</li></ul><blockquote><p>思考：按照三层架构的思想，如何要对业务逻辑(Service层)进行变更，会影响到Controller层和Dao层吗？ </p><p>答案：不会影响。 （程序的扩展性、维护性变得更好了）</p></blockquote><h4 id="3-1-2-代码拆分"><a href="#3-1-2-代码拆分" class="headerlink" title="3.1.2 代码拆分"></a>3.1.2 代码拆分</h4><p>我们使用三层架构思想，来改造下之前的程序：</p><ul><li>控制层包名：xxxx.controller</li><li>业务逻辑层包名：xxxx.service</li><li>数据访问层包名：xxxx.dao</li></ul><p><img src="https://bu.dusays.com/2024/07/24/66a0617f23209.png" alt="image-20221204195812200.png"></p><p><strong>控制层：</strong>接收前端发送的请求，对请求进行处理，并响应数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmpController</span> &#123;</span><br><span class="line">    <span class="comment">//业务层对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">EmpService</span> <span class="variable">empService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmpServiceA</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/listEmp&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">list</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1. 调用service层, 获取数据</span></span><br><span class="line">        List&lt;Emp&gt; empList = empService.listEmp();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 响应数据</span></span><br><span class="line">        <span class="keyword">return</span> Result.success(empList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>业务逻辑层：</strong>处理具体的业务逻辑</p><ul><li>业务接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//业务逻辑接口（制定业务标准）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EmpService</span> &#123;</span><br><span class="line">    <span class="comment">//获取员工列表</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Emp&gt; <span class="title function_">listEmp</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>业务实现类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//业务逻辑实现类（按照业务标准实现）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmpServiceA</span> <span class="keyword">implements</span> <span class="title class_">EmpService</span> &#123;</span><br><span class="line">    <span class="comment">//dao层对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">EmpDao</span> <span class="variable">empDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmpDaoA</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Emp&gt; <span class="title function_">listEmp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1. 调用dao, 获取数据</span></span><br><span class="line">        List&lt;Emp&gt; empList = empDao.listEmp();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 对数据进行转换处理 - gender, job</span></span><br><span class="line">        empList.stream().forEach(emp -&gt; &#123;</span><br><span class="line">            <span class="comment">//处理 gender 1: 男, 2: 女</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">gender</span> <span class="operator">=</span> emp.getGender();</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;1&quot;</span>.equals(gender))&#123;</span><br><span class="line">                emp.setGender(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;2&quot;</span>.equals(gender))&#123;</span><br><span class="line">                emp.setGender(<span class="string">&quot;女&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//处理job - 1: 讲师, 2: 班主任 , 3: 就业指导</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">job</span> <span class="operator">=</span> emp.getJob();</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;1&quot;</span>.equals(job))&#123;</span><br><span class="line">                emp.setJob(<span class="string">&quot;讲师&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;2&quot;</span>.equals(job))&#123;</span><br><span class="line">                emp.setJob(<span class="string">&quot;班主任&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;3&quot;</span>.equals(job))&#123;</span><br><span class="line">                emp.setJob(<span class="string">&quot;就业指导&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> empList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>数据访问层：</strong>负责数据的访问操作，包含数据的增、删、改、查</p><ul><li>数据访问接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据访问层接口（制定标准）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EmpDao</span> &#123;</span><br><span class="line">    <span class="comment">//获取员工列表数据</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Emp&gt; <span class="title function_">listEmp</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>数据访问实现类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据访问实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmpDaoA</span> <span class="keyword">implements</span> <span class="title class_">EmpDao</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Emp&gt; <span class="title function_">listEmp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1. 加载并解析emp.xml</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">file</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getClassLoader().getResource(<span class="string">&quot;emp.xml&quot;</span>).getFile();</span><br><span class="line">        System.out.println(file);</span><br><span class="line">        List&lt;Emp&gt; empList = XmlParserUtils.parse(file, Emp.class);</span><br><span class="line">        <span class="keyword">return</span> empList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/07/24/66a0617fe4adc.png" alt="image-20221204201342490.png"></p><p>三层架构的好处：</p><ol><li>复用性强</li><li>便于维护</li><li>利用扩展</li></ol><h3 id="3-2-分层解耦"><a href="#3-2-分层解耦" class="headerlink" title="3.2 分层解耦"></a>3.2 分层解耦</h3><p>刚才我们学习过程序分层思想了，接下来呢，我们来学习下程序的解耦思想。</p><p>解耦：解除耦合。</p><h4 id="3-2-1-耦合问题"><a href="#3-2-1-耦合问题" class="headerlink" title="3.2.1 耦合问题"></a>3.2.1 耦合问题</h4><p>首先需要了解软件开发涉及到的两个概念：内聚和耦合。</p><ul><li><p>内聚：软件中各个功能模块内部的功能联系。</p></li><li><p>耦合：衡量软件中各个层&#x2F;模块之间的依赖、关联的程度。</p></li></ul><p><strong>软件设计原则：高内聚低耦合。</strong></p><blockquote><p>高内聚指的是：一个模块中各个元素之间的联系的紧密程度，如果各个元素(语句、程序段)之间的联系程度越高，则内聚性越高，即 “高内聚”。</p><p>低耦合指的是：软件中各个层、模块之间的依赖关联程序越低越好。</p></blockquote><p>程序中高内聚的体现：</p><ul><li>EmpServiceA类中只编写了和员工相关的逻辑处理代码</li></ul><p><img src="https://bu.dusays.com/2024/07/24/66a0617fca291.png" alt="image-20221204202531571.png"> </p><p>程序中耦合代码的体现：</p><ul><li>把业务类变为EmpServiceB时，需要修改controller层中的代码</li></ul><p><img src="https://bu.dusays.com/2024/07/24/66a0618034526.png" alt="image-20221204203904900.png"></p><p>高内聚、低耦合的目的是使程序模块的可重用性、移植性大大增强。</p><p><img src="https://bu.dusays.com/2024/07/24/66a0616f89744.png" alt="image-20220828215549593.png"></p><h4 id="3-2-2-解耦思路"><a href="#3-2-2-解耦思路" class="headerlink" title="3.2.2  解耦思路"></a>3.2.2  解耦思路</h4><p>之前我们在编写代码时，需要什么对象，就直接new一个就可以了。 这种做法呢，层与层之间代码就耦合了，当service层的实现变了之后， 我们还需要修改controller层的代码。</p><p><img src="https://bu.dusays.com/2024/07/24/66a061806c630.png" alt="image-20221204204916033.png"></p><p> 那应该怎么解耦呢？</p><ul><li>首先不能在EmpController中使用new对象。代码如下：</li></ul><p><img src="https://bu.dusays.com/2024/07/24/66a0618061e9d.png" alt="image-20221204205328069.png"></p><ul><li>此时，就存在另一个问题了，不能new，就意味着没有业务层对象（程序运行就报错），怎么办呢？<ul><li>我们的解决思路是：<ul><li>提供一个容器，容器中存储一些对象(例：EmpService对象)</li><li>controller程序从容器中获取EmpService类型的对象</li></ul></li></ul></li></ul><p>我们想要实现上述解耦操作，就涉及到Spring中的两个核心概念：</p><ul><li><p><strong>控制反转：</strong> Inversion Of Control，简称IOC。对象的创建控制权由程序自身转移到外部（容器），这种思想称为控制反转。</p><blockquote><p>对象的创建权由程序员主动创建转移到容器(由容器创建、管理对象)。这个容器称为：IOC容器或Spring容器</p></blockquote></li><li><p><strong>依赖注入：</strong> Dependency Injection，简称DI。容器为应用程序提供运行时，所依赖的资源，称之为依赖注入。</p><blockquote><p>程序运行时需要某个资源，此时容器就为其提供这个资源。</p><p>例：EmpController程序运行时需要EmpService对象，Spring容器就为其提供并注入EmpService对象</p></blockquote></li></ul><p>IOC容器中创建、管理的对象，称之为：bean对象</p><h3 id="3-3-IOC-DI"><a href="#3-3-IOC-DI" class="headerlink" title="3.3 IOC&amp;DI"></a>3.3 IOC&amp;DI</h3><p>上面我们引出了Spring中IOC和DI的基本概念，下面我们就来具体学习下IOC和DI的代码实现。</p><h4 id="3-3-1-IOC-DI入门"><a href="#3-3-1-IOC-DI入门" class="headerlink" title="3.3.1 IOC&amp;DI入门"></a>3.3.1 IOC&amp;DI入门</h4><p>任务：完成Controller层、Service层、Dao层的代码解耦</p><ul><li>思路：<ol><li>删除Controller层、Service层中new对象的代码</li><li>Service层及Dao层的实现类，交给IOC容器管理</li><li>为Controller及Service注入运行时依赖的对象<ul><li>Controller程序中注入依赖的Service层对象</li><li>Service程序中注入依赖的Dao层对象</li></ul></li></ol></li></ul><p>第1步：删除Controller层、Service层中new对象的代码</p><p><img src="https://bu.dusays.com/2024/07/24/66a06180e01ed.png" alt="image-20221204212807207.png"></p><p>第2步：Service层及Dao层的实现类，交给IOC容器管理</p><ul><li>使用Spring提供的注解：@Component ，就可以实现类交给IOC容器管理</li></ul><p><img src="https://bu.dusays.com/2024/07/24/66a061811f114.png" alt="image-20221204213328034.png"></p><p>第3步：为Controller及Service注入运行时依赖的对象</p><ul><li>使用Spring提供的注解：@Autowired ，就可以实现程序运行时IOC容器自动注入需要的依赖对象</li></ul><p><img src="https://bu.dusays.com/2024/07/24/66a0618170a03.png" alt="image-20221204213859112.png"></p><p>完整的三层代码：</p><ul><li><strong>Controller层：</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmpController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">//运行时,从IOC容器中获取该类型对象,赋值给该变量</span></span><br><span class="line">    <span class="keyword">private</span> EmpService empService ;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/listEmp&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">list</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1. 调用service, 获取数据</span></span><br><span class="line">        List&lt;Emp&gt; empList = empService.listEmp();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 响应数据</span></span><br><span class="line">        <span class="keyword">return</span> Result.success(empList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>Service层：</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">//将当前对象交给IOC容器管理,成为IOC容器的bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmpServiceA</span> <span class="keyword">implements</span> <span class="title class_">EmpService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">//运行时,从IOC容器中获取该类型对象,赋值给该变量</span></span><br><span class="line">    <span class="keyword">private</span> EmpDao empDao ;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Emp&gt; <span class="title function_">listEmp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1. 调用dao, 获取数据</span></span><br><span class="line">        List&lt;Emp&gt; empList = empDao.listEmp();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 对数据进行转换处理 - gender, job</span></span><br><span class="line">        empList.stream().forEach(emp -&gt; &#123;</span><br><span class="line">            <span class="comment">//处理 gender 1: 男, 2: 女</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">gender</span> <span class="operator">=</span> emp.getGender();</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;1&quot;</span>.equals(gender))&#123;</span><br><span class="line">                emp.setGender(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;2&quot;</span>.equals(gender))&#123;</span><br><span class="line">                emp.setGender(<span class="string">&quot;女&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//处理job - 1: 讲师, 2: 班主任 , 3: 就业指导</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">job</span> <span class="operator">=</span> emp.getJob();</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;1&quot;</span>.equals(job))&#123;</span><br><span class="line">                emp.setJob(<span class="string">&quot;讲师&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;2&quot;</span>.equals(job))&#123;</span><br><span class="line">                emp.setJob(<span class="string">&quot;班主任&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;3&quot;</span>.equals(job))&#123;</span><br><span class="line">                emp.setJob(<span class="string">&quot;就业指导&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> empList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Dao层：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">//将当前对象交给IOC容器管理,成为IOC容器的bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmpDaoA</span> <span class="keyword">implements</span> <span class="title class_">EmpDao</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Emp&gt; <span class="title function_">listEmp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1. 加载并解析emp.xml</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">file</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getClassLoader().getResource(<span class="string">&quot;emp.xml&quot;</span>).getFile();</span><br><span class="line">        System.out.println(file);</span><br><span class="line">        List&lt;Emp&gt; empList = XmlParserUtils.parse(file, Emp.class);</span><br><span class="line">        <span class="keyword">return</span> empList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行测试：</p><ul><li>启动SpringBoot引导类，打开浏览器，输入：<a href="http://localhost:8080/emp.html">http://localhost:8080/emp.html</a></li></ul><p><img src="https://bu.dusays.com/2024/07/24/66a0617d790b5.png" alt="image-20221204185455556.png"></p><h4 id="3-3-2-IOC详解"><a href="#3-3-2-IOC详解" class="headerlink" title="3.3.2 IOC详解"></a>3.3.2 IOC详解</h4><p>通过IOC和DI的入门程序呢，我们已经基本了解了IOC和DI的基础操作。接下来呢，我们学习下IOC控制反转和DI依赖注入的细节。</p><h5 id="3-3-2-1-bean的声明"><a href="#3-3-2-1-bean的声明" class="headerlink" title="3.3.2.1 bean的声明"></a>3.3.2.1 bean的声明</h5><p>前面我们提到IOC控制反转，就是将对象的控制权交给Spring的IOC容器，由IOC容器创建及管理对象。IOC容器创建的对象称为bean对象。</p><p>在之前的入门案例中，要把某个对象交给IOC容器管理，需要在类上添加一个注解：@Component </p><p>而Spring框架为了更好的标识web应用程序开发当中，bean对象到底归属于哪一层，又提供了@Component的衍生注解：</p><ul><li>@Controller    （标注在控制层类上）</li><li>@Service          （标注在业务层类上）</li><li>@Repository    （标注在数据访问层类上）</li></ul><p>修改入门案例代码：</p><ul><li><strong>Controller层：</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span>  <span class="comment">//@RestController = @Controller + @ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmpController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">//运行时,从IOC容器中获取该类型对象,赋值给该变量</span></span><br><span class="line">    <span class="keyword">private</span> EmpService empService ;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/listEmp&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">list</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1. 调用service, 获取数据</span></span><br><span class="line">        List&lt;Emp&gt; empList = empService.listEmp();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 响应数据</span></span><br><span class="line">        <span class="keyword">return</span> Result.success(empList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>Service层：</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmpServiceA</span> <span class="keyword">implements</span> <span class="title class_">EmpService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">//运行时,从IOC容器中获取该类型对象,赋值给该变量</span></span><br><span class="line">    <span class="keyword">private</span> EmpDao empDao ;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Emp&gt; <span class="title function_">listEmp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1. 调用dao, 获取数据</span></span><br><span class="line">        List&lt;Emp&gt; empList = empDao.listEmp();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 对数据进行转换处理 - gender, job</span></span><br><span class="line">        empList.stream().forEach(emp -&gt; &#123;</span><br><span class="line">            <span class="comment">//处理 gender 1: 男, 2: 女</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">gender</span> <span class="operator">=</span> emp.getGender();</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;1&quot;</span>.equals(gender))&#123;</span><br><span class="line">                emp.setGender(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;2&quot;</span>.equals(gender))&#123;</span><br><span class="line">                emp.setGender(<span class="string">&quot;女&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//处理job - 1: 讲师, 2: 班主任 , 3: 就业指导</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">job</span> <span class="operator">=</span> emp.getJob();</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;1&quot;</span>.equals(job))&#123;</span><br><span class="line">                emp.setJob(<span class="string">&quot;讲师&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;2&quot;</span>.equals(job))&#123;</span><br><span class="line">                emp.setJob(<span class="string">&quot;班主任&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;3&quot;</span>.equals(job))&#123;</span><br><span class="line">                emp.setJob(<span class="string">&quot;就业指导&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> empList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Dao层：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmpDaoA</span> <span class="keyword">implements</span> <span class="title class_">EmpDao</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Emp&gt; <span class="title function_">listEmp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1. 加载并解析emp.xml</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">file</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getClassLoader().getResource(<span class="string">&quot;emp.xml&quot;</span>).getFile();</span><br><span class="line">        System.out.println(file);</span><br><span class="line">        List&lt;Emp&gt; empList = XmlParserUtils.parse(file, Emp.class);</span><br><span class="line">        <span class="keyword">return</span> empList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要把某个对象交给IOC容器管理，需要在对应的类上加上如下注解之一：</p><table><thead><tr><th align="left">注解</th><th>说明</th><th>位置</th></tr></thead><tbody><tr><td align="left">@Controller</td><td>@Component的衍生注解</td><td>标注在控制器类上</td></tr><tr><td align="left">@Service</td><td>@Component的衍生注解</td><td>标注在业务类上</td></tr><tr><td align="left">@Repository</td><td>@Component的衍生注解</td><td>标注在数据访问类上（由于与mybatis整合，用的少）</td></tr><tr><td align="left">@Component</td><td>声明bean的基础注解</td><td>不属于以上三类时，用此注解</td></tr></tbody></table><blockquote><p>查看源码：<img src="https://bu.dusays.com/2024/07/24/66a06181d3ef1.png" alt="image-20221204221320230.png"></p></blockquote><p>在IOC容器中，每一个Bean都有一个属于自己的名字，可以通过注解的value属性指定bean的名字。如果没有指定，默认为类名首字母小写。</p><p><img src="https://bu.dusays.com/2024/07/24/66a0618236805.png" alt="image-20221204222650873.png"></p><blockquote><p>注意事项: </p><ul><li>声明bean的时候，可以通过value属性指定bean的名字，如果没有指定，默认为类名首字母小写。</li><li>使用以上四个注解都可以声明bean，但是在springboot集成web开发中，声明控制器bean只能用@Controller。</li></ul></blockquote><h5 id="3-3-2-2-组件扫描"><a href="#3-3-2-2-组件扫描" class="headerlink" title="3.3.2.2 组件扫描"></a>3.3.2.2 组件扫描</h5><p>问题：使用前面学习的四个注解声明的bean，一定会生效吗？</p><p>答案：不一定。（原因：bean想要生效，还需要被组件扫描）</p><p> 下面我们通过修改项目工程的目录结构，来测试bean对象是否生效：</p><p><img src="https://bu.dusays.com/2024/07/24/66a06182616c7.png" alt="image-20221204223602694.png"></p><p>运行程序后，报错：</p><p><img src="https://bu.dusays.com/2024/07/24/66a06182948a5.png" alt="image-20221204223815554.png"></p><p>为什么没有找到bean对象呢？</p><ul><li>使用四大注解声明的bean，要想生效，还需要被组件扫描注解@ComponentScan扫描</li></ul><blockquote><p>@ComponentScan注解虽然没有显式配置，但是实际上已经包含在了引导类声明注解 @SpringBootApplication 中，&#x3D;&#x3D;<strong>默认扫描的范围是SpringBoot启动类所在包及其子包</strong>&#x3D;&#x3D;。</p><p><img src="https://bu.dusays.com/2024/07/24/66a06182b0c92.png" alt="image-20221204224643683.png"> </p></blockquote><ul><li>解决方案：手动添加@ComponentScan注解，指定要扫描的包   （&#x3D;&#x3D;仅做了解，不推荐&#x3D;&#x3D;）</li></ul><p><img src="https://bu.dusays.com/2024/07/24/66a0618311b89.png" alt="image-20221204225437297.png"></p><p>推荐做法（如下图）：</p><ul><li>将我们定义的controller，service，dao这些包呢，都放在引导类所在包com.itheima的子包下，这样我们定义的bean就会被自动的扫描到</li></ul><p><img src="https://bu.dusays.com/2024/07/24/66a061837b2b3.png" alt="image-20221204225815624.png"></p><h4 id="3-3-3-DI详解"><a href="#3-3-3-DI详解" class="headerlink" title="3.3.3 DI详解"></a>3.3.3 DI详解</h4><p>上一小节我们讲解了控制反转IOC的细节，接下来呢，我们学习依赖注解DI的细节。</p><p>依赖注入，是指IOC容器要为应用程序去提供运行时所依赖的资源，而资源指的就是对象。</p><p>在入门程序案例中，我们使用了@Autowired这个注解，完成了依赖注入的操作，而这个Autowired翻译过来叫：自动装配。</p><p>@Autowired注解，默认是按照<strong>类型</strong>进行自动装配的（去IOC容器中找某个类型的对象，然后完成注入操作）</p><blockquote><p>入门程序举例：在EmpController运行的时候，就要到IOC容器当中去查找EmpService这个类型的对象，而我们的IOC容器中刚好有一个EmpService这个类型的对象，所以就找到了这个类型的对象完成注入操作。</p></blockquote><p>那如果在IOC容器中，存在多个相同类型的bean对象，会出现什么情况呢？</p><p><img src="https://bu.dusays.com/2024/07/24/66a06183cb5ae.png" alt="image-20221204232154445.png"></p><ul><li>程序运行会报错</li></ul><p><img src="https://bu.dusays.com/2024/07/24/66a061839fca0.png" alt="image-20221204231616724.png"></p><p>如何解决上述问题呢？Spring提供了以下几种解决方案：</p><ul><li><p>@Primary</p></li><li><p>@Qualifier</p></li><li><p>@Resource</p></li></ul><p>使用@Primary注解：当存在多个相同类型的Bean注入时，加上@Primary注解，来确定默认的实现。</p><p><img src="https://bu.dusays.com/2024/07/24/66a06183dbba6.png" alt="image-20221204232501679.png"> </p><p>使用@Qualifier注解：指定当前要注入的bean对象。 在@Qualifier的value属性中，指定注入的bean的名称。</p><ul><li>@Qualifier注解不能单独使用，必须配合@Autowired使用</li></ul><p><img src="https://bu.dusays.com/2024/07/24/66a061843a520.png" alt="image-20221204233333606.png"></p><p>使用@Resource注解：是按照bean的名称进行注入。通过name属性指定要注入的bean的名称。</p><p><img src="https://bu.dusays.com/2024/07/24/66a061849e2e0.png" alt="image-20221204233637735.png"></p><blockquote><p>面试题 ： @Autowird 与 @Resource的区别</p><ul><li>@Autowired 是spring框架提供的注解，而@Resource是JDK提供的注解</li><li>@Autowired 默认是按照类型注入，而@Resource是按照名称注入</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis基础</title>
      <link href="/posts/54d9f3d9.html"/>
      <url>/posts/54d9f3d9.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-Mybatis基础操作"><a href="#1-Mybatis基础操作" class="headerlink" title="1. Mybatis基础操作"></a>1. Mybatis基础操作</h1><p>学习完mybatis入门后，我们继续学习mybatis基础操作。</p><h2 id="1-1-需求"><a href="#1-1-需求" class="headerlink" title="1.1 需求"></a>1.1 需求</h2><p>需求说明：</p><ul><li>根据资料中提供的《tlias智能学习辅助系统》页面原型及需求，完成员工管理的需求开发。</li></ul><p><img src="https://bu.dusays.com/2024/07/23/669fadbaae85d.png" alt="image-20221210180155700.png"> </p><p><img src="https://bu.dusays.com/2024/07/23/669fadb966327.png" alt="image-20221210180343288.png"></p><p><img src="https://bu.dusays.com/2024/07/23/669fadbc5142f.png" alt="image-20221210180515206.png"></p><p>通过分析以上的页面原型和需求，我们确定了功能列表：</p><ol><li><p>查询</p><ul><li>根据主键ID查询</li><li>条件查询</li></ul></li><li><p>新增</p></li><li><p>更新</p></li><li><p>删除</p><ul><li>根据主键ID删除</li><li>根据主键ID批量删除</li></ul></li></ol><h2 id="1-2-准备"><a href="#1-2-准备" class="headerlink" title="1.2 准备"></a>1.2 准备</h2><p>实施前的准备工作：</p><ol><li>准备数据库表</li><li>创建一个新的springboot工程，选择引入对应的起步依赖（mybatis、mysql驱动、lombok）</li><li>application.properties中引入数据库连接信息</li><li>创建对应的实体类 Emp（实体类属性采用驼峰命名）</li><li>准备Mapper接口 EmpMapper</li></ol><p><strong>准备数据库表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">-- 部门管理</span><br><span class="line">create table dept</span><br><span class="line">(</span><br><span class="line">    id          int unsigned primary key auto_increment comment &#x27;主键ID&#x27;,</span><br><span class="line">    name        varchar(10) not null unique comment &#x27;部门名称&#x27;,</span><br><span class="line">    create_time datetime    not null comment &#x27;创建时间&#x27;,</span><br><span class="line">    update_time datetime    not null comment &#x27;修改时间&#x27;</span><br><span class="line">) comment &#x27;部门表&#x27;;</span><br><span class="line">-- 部门表测试数据</span><br><span class="line">insert into dept (id, name, create_time, update_time)</span><br><span class="line">values (1, &#x27;学工部&#x27;, now(), now()),</span><br><span class="line">       (2, &#x27;教研部&#x27;, now(), now()),</span><br><span class="line">       (3, &#x27;咨询部&#x27;, now(), now()),</span><br><span class="line">       (4, &#x27;就业部&#x27;, now(), now()),</span><br><span class="line">       (5, &#x27;人事部&#x27;, now(), now());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 员工管理</span><br><span class="line">create table emp</span><br><span class="line">(</span><br><span class="line">    id          int unsigned primary key auto_increment comment &#x27;ID&#x27;,</span><br><span class="line">    username    varchar(20)      not null unique comment &#x27;用户名&#x27;,</span><br><span class="line">    password    varchar(32) default &#x27;123456&#x27; comment &#x27;密码&#x27;,</span><br><span class="line">    name        varchar(10)      not null comment &#x27;姓名&#x27;,</span><br><span class="line">    gender      tinyint unsigned not null comment &#x27;性别, 说明: 1 男, 2 女&#x27;,</span><br><span class="line">    image       varchar(300) comment &#x27;图像&#x27;,</span><br><span class="line">    job         tinyint unsigned comment &#x27;职位, 说明: 1 班主任,2 讲师, 3 学工主管, 4 教研主管, 5 咨询师&#x27;,</span><br><span class="line">    entrydate   date comment &#x27;入职时间&#x27;,</span><br><span class="line">    dept_id     int unsigned comment &#x27;部门ID&#x27;,</span><br><span class="line">    create_time datetime         not null comment &#x27;创建时间&#x27;,</span><br><span class="line">    update_time datetime         not null comment &#x27;修改时间&#x27;</span><br><span class="line">) comment &#x27;员工表&#x27;;</span><br><span class="line">-- 员工表测试数据</span><br><span class="line">INSERT INTO emp (id, username, password, name, gender, image, job, entrydate, dept_id, create_time, update_time)</span><br><span class="line">VALUES </span><br><span class="line">(1, &#x27;jinyong&#x27;, &#x27;123456&#x27;, &#x27;金庸&#x27;, 1, &#x27;1.jpg&#x27;, 4, &#x27;2000-01-01&#x27;, 2, now(), now()),</span><br><span class="line">(2, &#x27;zhangwuji&#x27;, &#x27;123456&#x27;, &#x27;张无忌&#x27;, 1, &#x27;2.jpg&#x27;, 2, &#x27;2015-01-01&#x27;, 2, now(), now()),</span><br><span class="line">(3, &#x27;yangxiao&#x27;, &#x27;123456&#x27;, &#x27;杨逍&#x27;, 1, &#x27;3.jpg&#x27;, 2, &#x27;2008-05-01&#x27;, 2, now(), now()),</span><br><span class="line">(4, &#x27;weiyixiao&#x27;, &#x27;123456&#x27;, &#x27;韦一笑&#x27;, 1, &#x27;4.jpg&#x27;, 2, &#x27;2007-01-01&#x27;, 2, now(), now()),</span><br><span class="line">(5, &#x27;changyuchun&#x27;, &#x27;123456&#x27;, &#x27;常遇春&#x27;, 1, &#x27;5.jpg&#x27;, 2, &#x27;2012-12-05&#x27;, 2, now(), now()),</span><br><span class="line">(6, &#x27;xiaozhao&#x27;, &#x27;123456&#x27;, &#x27;小昭&#x27;, 2, &#x27;6.jpg&#x27;, 3, &#x27;2013-09-05&#x27;, 1, now(), now()),</span><br><span class="line">(7, &#x27;jixiaofu&#x27;, &#x27;123456&#x27;, &#x27;纪晓芙&#x27;, 2, &#x27;7.jpg&#x27;, 1, &#x27;2005-08-01&#x27;, 1, now(), now()),</span><br><span class="line">(8, &#x27;zhouzhiruo&#x27;, &#x27;123456&#x27;, &#x27;周芷若&#x27;, 2, &#x27;8.jpg&#x27;, 1, &#x27;2014-11-09&#x27;, 1, now(), now()),</span><br><span class="line">(9, &#x27;dingminjun&#x27;, &#x27;123456&#x27;, &#x27;丁敏君&#x27;, 2, &#x27;9.jpg&#x27;, 1, &#x27;2011-03-11&#x27;, 1, now(), now()),</span><br><span class="line">(10, &#x27;zhaomin&#x27;, &#x27;123456&#x27;, &#x27;赵敏&#x27;, 2, &#x27;10.jpg&#x27;, 1, &#x27;2013-09-05&#x27;, 1, now(), now()),</span><br><span class="line">(11, &#x27;luzhangke&#x27;, &#x27;123456&#x27;, &#x27;鹿杖客&#x27;, 1, &#x27;11.jpg&#x27;, 5, &#x27;2007-02-01&#x27;, 3, now(), now()),</span><br><span class="line">(12, &#x27;hebiweng&#x27;, &#x27;123456&#x27;, &#x27;鹤笔翁&#x27;, 1, &#x27;12.jpg&#x27;, 5, &#x27;2008-08-18&#x27;, 3, now(), now()),</span><br><span class="line">(13, &#x27;fangdongbai&#x27;, &#x27;123456&#x27;, &#x27;方东白&#x27;, 1, &#x27;13.jpg&#x27;, 5, &#x27;2012-11-01&#x27;, 3, now(), now()),</span><br><span class="line">(14, &#x27;zhangsanfeng&#x27;, &#x27;123456&#x27;, &#x27;张三丰&#x27;, 1, &#x27;14.jpg&#x27;, 2, &#x27;2002-08-01&#x27;, 2, now(), now()),</span><br><span class="line">(15, &#x27;yulianzhou&#x27;, &#x27;123456&#x27;, &#x27;俞莲舟&#x27;, 1, &#x27;15.jpg&#x27;, 2, &#x27;2011-05-01&#x27;, 2, now(), now()),</span><br><span class="line">(16, &#x27;songyuanqiao&#x27;, &#x27;123456&#x27;, &#x27;宋远桥&#x27;, 1, &#x27;16.jpg&#x27;, 2, &#x27;2010-01-01&#x27;, 2, now(), now()),</span><br><span class="line">(17, &#x27;chenyouliang&#x27;, &#x27;123456&#x27;, &#x27;陈友谅&#x27;, 1, &#x27;17.jpg&#x27;, NULL, &#x27;2015-03-21&#x27;, NULL, now(), now());</span><br></pre></td></tr></table></figure><p><strong>创建一个新的springboot工程，选择引入对应的起步依赖（mybatis、mysql驱动、lombok）</strong></p><p><img src="https://bu.dusays.com/2024/07/23/669fadbb35b55.png" alt="image-20221210182008131.png"></p><p><strong>application.properties中引入数据库连接信息</strong></p><blockquote><p>提示：可以把之前项目中已有的配置信息复制过来即可</p></blockquote><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#驱动类名称</span></span><br><span class="line"><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="comment">#数据库连接的url</span></span><br><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/mybatis</span></span><br><span class="line"><span class="comment">#连接数据库的用户名</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="comment">#连接数据库的密码</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">1234</span></span><br></pre></td></tr></table></figure><p><strong>创建对应的实体类Emp（实体类属性采用驼峰命名）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Emp</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Short gender;</span><br><span class="line">    <span class="keyword">private</span> String image;</span><br><span class="line">    <span class="keyword">private</span> Short job;</span><br><span class="line">    <span class="keyword">private</span> LocalDate entrydate;     <span class="comment">//LocalDate类型对应数据表中的date类型</span></span><br><span class="line">    <span class="keyword">private</span> Integer deptId;</span><br><span class="line">    <span class="keyword">private</span> LocalDateTime createTime;<span class="comment">//LocalDateTime类型对应数据表中的datetime类型</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime updateTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>准备Mapper接口：EmpMapper</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*@Mapper注解：表示当前接口为mybatis中的Mapper接口</span></span><br><span class="line"><span class="comment">  程序运行时会自动创建接口的实现类对象(代理对象)，并交给Spring的IOC容器管理</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EmpMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成以上操作后，项目工程结构目录如下：</p><p><img src="https://bu.dusays.com/2024/07/23/669fadbb33a0c.png" alt="image-20221210182500817.png"></p><h2 id="1-3-删除"><a href="#1-3-删除" class="headerlink" title="1.3 删除"></a>1.3 删除</h2><h3 id="1-3-1-功能实现"><a href="#1-3-1-功能实现" class="headerlink" title="1.3.1 功能实现"></a>1.3.1 功能实现</h3><p>页面原型：</p><p><img src="https://bu.dusays.com/2024/07/23/669fadbf2c1c2.png" alt="image-20221210183336095.png"></p><blockquote><p>当我们点击后面的”删除”按钮时，前端页面会给服务端传递一个参数，也就是该行数据的ID。 我们接收到ID后，根据ID删除数据即可。</p></blockquote><p><strong>功能：根据主键删除数据</strong></p><ul><li>SQL语句</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 删除id=17的数据</span><br><span class="line">delete from emp where id = 17;</span><br></pre></td></tr></table></figure><blockquote><p>Mybatis框架让程序员更关注于SQL语句</p></blockquote><ul><li>接口方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EmpMapper</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//@Delete(&quot;delete from emp where id = 17&quot;)</span></span><br><span class="line">    <span class="comment">//public void delete();</span></span><br><span class="line">    <span class="comment">//以上delete操作的SQL语句中的id值写成固定的17，就表示只能删除id=17的用户数据</span></span><br><span class="line">    <span class="comment">//SQL语句中的id值不能写成固定数值，需要变为动态的数值</span></span><br><span class="line">    <span class="comment">//解决方案：在delete方法中添加一个参数(用户id)，将方法中的参数，传给SQL语句</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据id删除数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id    用户id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Delete(&quot;delete from emp where id = #&#123;id&#125;&quot;)</span><span class="comment">//使用#&#123;key&#125;方式获取方法中的参数值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Integer id)</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>@Delete注解：用于编写delete操作的SQL语句</p></blockquote><blockquote><p>如果mapper接口方法形参只有一个普通类型的参数，#{…} 里面的属性名可以随便写，如：#{id}、#{value}。但是建议保持名字一致。</p></blockquote><ul><li>测试<ul><li>在单元测试类中通过@Autowired注解注入EmpMapper类型对象</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpringbootMybatisCrudApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">//从Spring的IOC容器中，获取类型是EmpMapper的对象并注入</span></span><br><span class="line">    <span class="keyword">private</span> EmpMapper empMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDel</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//调用删除方法</span></span><br><span class="line">        empMapper.delete(<span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-2-日志输入"><a href="#1-3-2-日志输入" class="headerlink" title="1.3.2 日志输入"></a>1.3.2 日志输入</h3><p>在Mybatis当中我们可以借助日志，查看到sql语句的执行、执行传递的参数以及执行结果。具体操作如下：</p><ol><li><p>打开application.properties文件</p></li><li><p>开启mybatis的日志，并指定输出到控制台</p></li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#指定mybatis输出日志的位置, 输出控制台</span></span><br><span class="line"><span class="attr">mybatis.configuration.log-impl</span>=<span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure><p>开启日志之后，我们再次运行单元测试，可以看到在控制台中，输出了以下的SQL语句信息：</p><p><img src="https://bu.dusays.com/2024/07/23/669fadb9baea4.png" alt="image-20220901164225644.png"> </p><blockquote><p>但是我们发现输出的SQL语句：delete from emp where id &#x3D; ?，我们输入的参数16并没有在后面拼接，id的值是使用?进行占位。那这种SQL语句我们称为预编译SQL。</p></blockquote><h3 id="1-3-3-预编译SQL"><a href="#1-3-3-预编译SQL" class="headerlink" title="1.3.3 预编译SQL"></a>1.3.3 预编译SQL</h3><h4 id="1-3-3-1-介绍"><a href="#1-3-3-1-介绍" class="headerlink" title="1.3.3.1 介绍"></a>1.3.3.1 介绍</h4><p>预编译SQL有两个优势：</p><ol><li>性能更高</li><li>更安全(防止SQL注入)</li></ol><p><img src="https://bu.dusays.com/2024/07/23/669fadbc97981.png" alt="image-20221210202222206.png"></p><blockquote><p>性能更高：预编译SQL，编译一次之后会将编译后的SQL语句缓存起来，后面再次执行这条语句时，不会再次编译。（只是输入的参数不同）</p><p>更安全(防止SQL注入)：将敏感字进行转义，保障SQL的安全性。</p></blockquote><h4 id="1-3-3-2-SQL注入"><a href="#1-3-3-2-SQL注入" class="headerlink" title="1.3.3.2 SQL注入"></a>1.3.3.2 SQL注入</h4><p>SQL注入：是通过操作输入的数据来修改事先定义好的SQL语句，以达到执行代码对服务器进行攻击的方法。</p><blockquote><p>由于没有对用户输入进行充分检查，而SQL又是拼接而成，在用户输入参数时，在参数中添加一些SQL关键字，达到改变SQL运行结果的目的，也可以完成恶意攻击。</p></blockquote><p><strong>测试1：使用资料中提供的程序，来验证SQL注入问题</strong></p><p><img src="https://bu.dusays.com/2024/07/23/669fadbce79fd.png" alt="image-20221210205419634.png"></p><p>第1步：进入到DOS</p><p><img src="https://bu.dusays.com/2024/07/23/669fadbee468c.png" alt="image-20221211124744203.png"></p><p><img src="https://bu.dusays.com/2024/07/23/669fadbde802d.png" alt="image-20221211124840720.png"></p><p>第2步：执行以下命令，启动程序</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#启动存在SQL注入的程序</span></span><br><span class="line">java <span class="literal">-jar</span> sql_Injection_demo<span class="literal">-0</span>.<span class="number">0.1</span><span class="literal">-SNAPSHOT</span>.jar </span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/07/23/669fadbcd655d.png" alt="image-20221210211605231.png"></p><p>第3步：打开浏览器输入<code>http://localhost:9090/login.html</code></p><p><img src="https://bu.dusays.com/2024/07/23/669fadbc9fe89.png" alt="image-20221210212406527.png"></p><p>发现竟然能够登录成功：</p><p><img src="https://bu.dusays.com/2024/07/23/669fadc8ae0a4.png" alt="image-20221210212511915.png"></p><p>以上操作为什么能够登录成功呢？</p><ul><li>由于没有对用户输入内容进行充分检查，而SQL又是字符串拼接方式而成，在用户输入参数时，在参数中添加一些SQL关键字，达到改变SQL运行结果的目的，从而完成恶意攻击。</li></ul><p><img src="https://bu.dusays.com/2024/07/23/669fadbe40374.png" alt="image-20221210213311518.png"></p><blockquote><p><img src="https://bu.dusays.com/2024/07/23/669fadbce5ba9.png" alt="image-20221210214431228.png"></p><p>用户在页面提交数据的时候人为的添加一些特殊字符，使得sql语句的结构发生了变化，最终可以在没有用户名或者密码的情况下进行登录。</p></blockquote><p><strong>测试2：使用资料中提供的程序，来验证SQL注入问题</strong></p><p>第1步：进入到DOS</p><p>第2步：执行以下命令，启动程序：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#启动解决了SQL注入的程序</span></span><br><span class="line">java <span class="literal">-jar</span> sql_prepared_demo<span class="literal">-0</span>.<span class="number">0.1</span><span class="literal">-SNAPSHOT</span>.jar</span><br></pre></td></tr></table></figure><p>第3步：打开浏览器输入<code>http://localhost:9090/login.html</code></p><p><img src="https://bu.dusays.com/2024/07/23/669fadbc9fe89.png" alt="image-20221210212406527.png"></p><p>发现无法登录：</p><p><img src="https://bu.dusays.com/2024/07/23/669fadbf8e6c5.png" alt="image-20221211125751981.png"></p><p>以上操作SQL语句的执行：</p><p><img src="https://bu.dusays.com/2024/07/23/669fadc01f889.png" alt="image-20221211130011973.png"></p><blockquote><p>把整个<code>&#39; or &#39;1&#39;=&#39;1</code>作为一个完整的参数，赋值给第2个问号（<code>&#39; or &#39;1&#39;=&#39;1</code>进行了转义，只当做字符串使用）</p></blockquote><h4 id="1-3-3-3-参数占位符"><a href="#1-3-3-3-参数占位符" class="headerlink" title="1.3.3.3 参数占位符"></a>1.3.3.3 参数占位符</h4><p>在Mybatis中提供的参数占位符有两种：${…} 、#{…}</p><ul><li><p>#{…}</p><ul><li>执行SQL时，会将#{…}替换为?，生成预编译SQL，会自动设置参数值</li><li>使用时机：参数传递，都使用#{…}</li></ul></li><li><p>${…}</p><ul><li>拼接SQL。直接将参数拼接在SQL语句中，存在SQL注入问题</li><li>使用时机：如果对表名、列表进行动态设置时使用</li></ul></li></ul><blockquote><p>注意事项：在项目开发中，建议使用#{…}，生成预编译SQL，防止SQL注入安全。</p></blockquote><h2 id="1-4-新增"><a href="#1-4-新增" class="headerlink" title="1.4 新增"></a>1.4 新增</h2><p>功能：新增员工信息</p><p><img src="https://bu.dusays.com/2024/07/23/669fadbeaea78.png" alt="image-20221211134239610.png"></p><h3 id="1-4-1-基本新增"><a href="#1-4-1-基本新增" class="headerlink" title="1.4.1 基本新增"></a>1.4.1 基本新增</h3><p>员工表结构：</p><p><img src="https://bu.dusays.com/2024/07/23/669fadbf0633f.png" alt="image-20221211134746319.png"></p><p>SQL语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp(username, name, gender, image, job, entrydate, dept_id, create_time, update_time) <span class="keyword">values</span> (<span class="string">&#x27;songyuanqiao&#x27;</span>,<span class="string">&#x27;宋远桥&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;1.jpg&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;2012-10-09&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;2022-10-01 10:00:00&#x27;</span>,<span class="string">&#x27;2022-10-01 10:00:00&#x27;</span>);</span><br></pre></td></tr></table></figure><p>接口方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EmpMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert(&quot;insert into emp(username, name, gender, image, job, entrydate, dept_id, create_time, update_time) values (#&#123;username&#125;, #&#123;name&#125;, #&#123;gender&#125;, #&#123;image&#125;, #&#123;job&#125;, #&#123;entrydate&#125;, #&#123;deptId&#125;, #&#123;createTime&#125;, #&#123;updateTime&#125;)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Emp emp)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>说明：#{…} 里面写的名称是对象的属性名</p></blockquote><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.itheima.mapper.EmpMapper;</span><br><span class="line"><span class="keyword">import</span> com.itheima.pojo.Emp;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpringbootMybatisCrudApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EmpMapper empMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInsert</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//创建员工对象</span></span><br><span class="line">        <span class="type">Emp</span> <span class="variable">emp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Emp</span>();</span><br><span class="line">        emp.setUsername(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        emp.setName(<span class="string">&quot;汤姆&quot;</span>);</span><br><span class="line">        emp.setImage(<span class="string">&quot;1.jpg&quot;</span>);</span><br><span class="line">        emp.setGender((<span class="type">short</span>)<span class="number">1</span>);</span><br><span class="line">        emp.setJob((<span class="type">short</span>)<span class="number">1</span>);</span><br><span class="line">        emp.setEntrydate(LocalDate.of(<span class="number">2000</span>,<span class="number">1</span>,<span class="number">1</span>));</span><br><span class="line">        emp.setCreateTime(LocalDateTime.now());</span><br><span class="line">        emp.setUpdateTime(LocalDateTime.now());</span><br><span class="line">        emp.setDeptId(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//调用添加方法</span></span><br><span class="line">        empMapper.insert(emp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>日志输出：</p><p><img src="https://bu.dusays.com/2024/07/23/669fadc01ba5a.png" alt="image-20221211140222240.png"></p></blockquote><h3 id="1-4-2-主键返回"><a href="#1-4-2-主键返回" class="headerlink" title="1.4.2 主键返回"></a>1.4.2 主键返回</h3><p>概念：在数据添加成功后，需要获取插入数据库数据的主键。</p><blockquote><p>如：添加套餐数据时，还需要维护套餐菜品关系表数据。</p><p><img src="https://bu.dusays.com/2024/07/23/669fadbf647fb.png" alt="image-20221211150353385.png"></p><p>业务场景：在前面讲解到的苍穹外卖菜品与套餐模块的表结构，菜品与套餐是多对多的关系，一个套餐对应多个菜品。既然是多对多的关系，是不是有一张套餐菜品中间表来维护它们之间的关系。</p><p><img src="https://bu.dusays.com/2024/07/23/669fadbfc9ffe.png" alt="image-20221212093655389.png"></p><p>在添加套餐的时候，我们需要在界面当中来录入套餐的基本信息，还需要来录入套餐与菜品的关联信息。这些信息录入完毕之后，我们一点保存，就需要将套餐的信息以及套餐与菜品的关联信息都需要保存到数据库当中。其实具体的过程包括两步，首先第一步先需要将套餐的基本信息保存了，接下来第二步再来保存套餐与菜品的关联信息。套餐与菜品的关联信息就是往中间表当中来插入数据，来维护它们之间的关系。而中间表当中有两个外键字段，一个是菜品的ID，就是当前菜品的ID，还有一个就是套餐的ID，而这个套餐的 ID 指的就是此次我所添加的套餐的ID，所以我们在第一步保存完套餐的基本信息之后，就需要将套餐的主键值返回来供第二步进行使用。这个时候就需要用到主键返回功能。</p></blockquote><p>那要如何实现在插入数据之后返回所插入行的主键值呢？</p><ul><li>默认情况下，执行插入操作时，是不会主键值返回的。如果我们想要拿到主键值，需要在Mapper接口中的方法上添加一个Options注解，并在注解中指定属性useGeneratedKeys&#x3D;true和keyProperty&#x3D;”实体类属性名”</li></ul><p>主键返回代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EmpMapper</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//会自动将生成的主键值，赋值给emp对象的id属性</span></span><br><span class="line">    <span class="meta">@Options(useGeneratedKeys = true,keyProperty = &quot;id&quot;)</span></span><br><span class="line">    <span class="meta">@Insert(&quot;insert into emp(username, name, gender, image, job, entrydate, dept_id, create_time, update_time) values (#&#123;username&#125;, #&#123;name&#125;, #&#123;gender&#125;, #&#123;image&#125;, #&#123;job&#125;, #&#123;entrydate&#125;, #&#123;deptId&#125;, #&#123;createTime&#125;, #&#123;updateTime&#125;)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Emp emp)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpringbootMybatisCrudApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EmpMapper empMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInsert</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//创建员工对象</span></span><br><span class="line">        <span class="type">Emp</span> <span class="variable">emp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Emp</span>();</span><br><span class="line">        emp.setUsername(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        emp.setName(<span class="string">&quot;杰克&quot;</span>);</span><br><span class="line">        emp.setImage(<span class="string">&quot;1.jpg&quot;</span>);</span><br><span class="line">        emp.setGender((<span class="type">short</span>)<span class="number">1</span>);</span><br><span class="line">        emp.setJob((<span class="type">short</span>)<span class="number">1</span>);</span><br><span class="line">        emp.setEntrydate(LocalDate.of(<span class="number">2000</span>,<span class="number">1</span>,<span class="number">1</span>));</span><br><span class="line">        emp.setCreateTime(LocalDateTime.now());</span><br><span class="line">        emp.setUpdateTime(LocalDateTime.now());</span><br><span class="line">        emp.setDeptId(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//调用添加方法</span></span><br><span class="line">        empMapper.insert(emp);</span><br><span class="line"></span><br><span class="line">        System.out.println(emp.getDeptId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-5-更新"><a href="#1-5-更新" class="headerlink" title="1.5 更新"></a>1.5 更新</h2><p>功能：修改员工信息</p><p><img src="https://bu.dusays.com/2024/07/23/669fadc0b649b.png" alt="image-20221212095605863.png"></p><blockquote><p>点击”编辑”按钮后，会查询所在行记录的员工信息，并把员工信息回显在修改员工的窗体上(下个知识点学习)</p><p>在修改员工的窗体上，可以修改的员工数据：用户名、员工姓名、性别、图像、职位、入职日期、归属部门</p><p>思考：在修改员工数据时，要以什么做为条件呢？</p><p>答案：员工id</p></blockquote><p>SQL语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> emp <span class="keyword">set</span> username <span class="operator">=</span> <span class="string">&#x27;linghushaoxia&#x27;</span>, name <span class="operator">=</span> <span class="string">&#x27;令狐少侠&#x27;</span>, gender <span class="operator">=</span> <span class="number">1</span> , image <span class="operator">=</span> <span class="string">&#x27;1.jpg&#x27;</span> , job <span class="operator">=</span> <span class="number">2</span>, entrydate <span class="operator">=</span> <span class="string">&#x27;2012-01-01&#x27;</span>, dept_id <span class="operator">=</span> <span class="number">2</span>, update_time <span class="operator">=</span> <span class="string">&#x27;2022-10-01 12:12:12&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">18</span>;</span><br></pre></td></tr></table></figure><p>接口方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EmpMapper</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据id修改员工信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> emp</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Update(&quot;update emp set username=#&#123;username&#125;, name=#&#123;name&#125;, gender=#&#123;gender&#125;, image=#&#123;image&#125;, job=#&#123;job&#125;, entrydate=#&#123;entrydate&#125;, dept_id=#&#123;deptId&#125;, update_time=#&#123;updateTime&#125; where id=#&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Emp emp)</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpringbootMybatisCrudApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EmpMapper empMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUpdate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//要修改的员工信息</span></span><br><span class="line">        <span class="type">Emp</span> <span class="variable">emp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Emp</span>();</span><br><span class="line">        emp.setId(<span class="number">23</span>);</span><br><span class="line">        emp.setUsername(<span class="string">&quot;songdaxia&quot;</span>);</span><br><span class="line">        emp.setPassword(<span class="literal">null</span>);</span><br><span class="line">        emp.setName(<span class="string">&quot;老宋&quot;</span>);</span><br><span class="line">        emp.setImage(<span class="string">&quot;2.jpg&quot;</span>);</span><br><span class="line">        emp.setGender((<span class="type">short</span>)<span class="number">1</span>);</span><br><span class="line">        emp.setJob((<span class="type">short</span>)<span class="number">2</span>);</span><br><span class="line">        emp.setEntrydate(LocalDate.of(<span class="number">2012</span>,<span class="number">1</span>,<span class="number">1</span>));</span><br><span class="line">        emp.setCreateTime(<span class="literal">null</span>);</span><br><span class="line">        emp.setUpdateTime(LocalDateTime.now());</span><br><span class="line">        emp.setDeptId(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//调用方法，修改员工数据</span></span><br><span class="line">        empMapper.update(emp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-6-查询"><a href="#1-6-查询" class="headerlink" title="1.6 查询"></a>1.6 查询</h2><h3 id="1-6-1-根据ID查询"><a href="#1-6-1-根据ID查询" class="headerlink" title="1.6.1 根据ID查询"></a>1.6.1 根据ID查询</h3><p>在员工管理的页面中，当我们进行更新数据时，会点击 “编辑” 按钮，然后此时会发送一个请求到服务端，会根据Id查询该员工信息，并将员工数据回显在页面上。</p><p><img src="https://bu.dusays.com/2024/07/23/669fadc0bb82e.png" alt="image-20221212101331292.png"> </p><p>SQL语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id, username, password, name, gender, image, job, entrydate, dept_id, create_time, update_time from emp;</span><br></pre></td></tr></table></figure><p>接口方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EmpMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;select id, username, password, name, gender, image, job, entrydate, dept_id, create_time, update_time from emp where id=#&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Emp <span class="title function_">getById</span><span class="params">(Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpringbootMybatisCrudApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EmpMapper empMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetById</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Emp</span> <span class="variable">emp</span> <span class="operator">=</span> empMapper.getById(<span class="number">1</span>);</span><br><span class="line">        System.out.println(emp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行结果：</p><p><img src="https://bu.dusays.com/2024/07/23/669fadc0d699d.png" alt="image-20221212103004961.png"></p><p>而在测试的过程中，我们会发现有几个字段(deptId、createTime、updateTime)是没有数据值的</p></blockquote><h3 id="1-6-2-数据封装"><a href="#1-6-2-数据封装" class="headerlink" title="1.6.2 数据封装"></a>1.6.2 数据封装</h3><p>我们看到查询返回的结果中大部分字段是有值的，但是deptId，createTime，updateTime这几个字段是没有值的，而数据库中是有对应的字段值的，这是为什么呢？</p><p><img src="https://bu.dusays.com/2024/07/23/669fadc7e4f78.png" alt="image-20221212103124490.png"></p><p>原因如下： </p><ul><li>实体类属性名和数据库表查询返回的字段名一致，mybatis会自动封装。</li><li>如果实体类属性名和数据库表查询返回的字段名不一致，不能自动封装。</li></ul><p> 解决方案：</p><ol><li>起别名</li><li>结果映射</li><li>开启驼峰命名</li></ol><p><strong>起别名</strong>：在SQL语句中，对不一样的列名起别名，别名和实体类属性名一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select id, username, password, name, gender, image, job, entrydate, &quot; +</span></span><br><span class="line"><span class="meta">        &quot;dept_id AS deptId, create_time AS createTime, update_time AS updateTime &quot; +</span></span><br><span class="line"><span class="meta">        &quot;from emp &quot; +</span></span><br><span class="line"><span class="meta">        &quot;where id=#&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Emp <span class="title function_">getById</span><span class="params">(Integer id)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>再次执行测试类：</p><p><img src="https://bu.dusays.com/2024/07/23/669fadc1623b0.png" alt="image-20221212111027396.png"></p></blockquote><p><strong>手动结果映射</strong>：通过 @Results及@Result 进行手动结果映射</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Results(&#123;@Result(column = &quot;dept_id&quot;, property = &quot;deptId&quot;),</span></span><br><span class="line"><span class="meta">          @Result(column = &quot;create_time&quot;, property = &quot;createTime&quot;),</span></span><br><span class="line"><span class="meta">          @Result(column = &quot;update_time&quot;, property = &quot;updateTime&quot;)&#125;)</span></span><br><span class="line"><span class="meta">@Select(&quot;select id, username, password, name, gender, image, job, entrydate, dept_id, create_time, update_time from emp where id=#&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Emp <span class="title function_">getById</span><span class="params">(Integer id)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>@Results源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Results &#123;</span><br><span class="line">String <span class="title function_">id</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">Result[] value() <span class="keyword">default</span> &#123;&#125;;  <span class="comment">//Result类型的数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Result源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Repeatable(Results.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Result &#123;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">id</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;<span class="comment">//表示当前列是否为主键（true:是主键）</span></span><br><span class="line"></span><br><span class="line">String <span class="title function_">column</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;<span class="comment">//指定表中字段名</span></span><br><span class="line"></span><br><span class="line">String <span class="title function_">property</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;<span class="comment">//指定类中属性名</span></span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; javaType() <span class="keyword">default</span> <span class="keyword">void</span>.class;</span><br><span class="line"></span><br><span class="line">JdbcType <span class="title function_">jdbcType</span><span class="params">()</span> <span class="keyword">default</span> JdbcType.UNDEFINED;</span><br><span class="line"></span><br><span class="line">Class&lt;? <span class="keyword">extends</span> <span class="title class_">TypeHandler</span>&gt; typeHandler() <span class="keyword">default</span> UnknownTypeHandler.class;</span><br><span class="line"></span><br><span class="line">One <span class="title function_">one</span><span class="params">()</span> <span class="keyword">default</span> <span class="meta">@One</span>;</span><br><span class="line"></span><br><span class="line">Many <span class="title function_">many</span><span class="params">()</span> <span class="keyword">default</span> <span class="meta">@Many</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>**开启驼峰命名(推荐)**：如果字段名与属性名符合驼峰命名规则，mybatis会自动通过驼峰命名规则映射</p><blockquote><p>驼峰命名规则：   abc_xyz    &#x3D;&gt;   abcXyz</p><ul><li>表中字段名：abc_xyz</li><li>类中属性名：abcXyz</li></ul></blockquote><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在application.properties中添加：</span></span><br><span class="line"><span class="attr">mybatis.configuration.map-underscore-to-camel-case</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><blockquote><p>要使用驼峰命名前提是 实体类的属性 与 数据库表中的字段名严格遵守驼峰命名。</p></blockquote><h3 id="1-6-3-条件查询"><a href="#1-6-3-条件查询" class="headerlink" title="1.6.3 条件查询"></a>1.6.3 条件查询</h3><p>在员工管理的列表页面中，我们需要根据条件查询员工信息，查询条件包括：姓名、性别、入职时间。 </p><p><img src="https://bu.dusays.com/2024/07/23/669fadc12dd60.png" alt="image-20221212113422924.png"></p><p>通过页面原型以及需求描述我们要实现的查询：</p><ul><li>姓名：要求支持模糊匹配</li><li>性别：要求精确匹配</li><li>入职时间：要求进行范围查询</li><li>根据最后修改时间进行降序排序</li></ul><p>SQL语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id, username, password, name, gender, image, job, entrydate, dept_id, create_time, update_time </span><br><span class="line"><span class="keyword">from</span> emp </span><br><span class="line"><span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;%张%&#x27;</span> </span><br><span class="line">      <span class="keyword">and</span> gender <span class="operator">=</span> <span class="number">1</span> </span><br><span class="line">      <span class="keyword">and</span> entrydate <span class="keyword">between</span> <span class="string">&#x27;2010-01-01&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;2020-01-01 &#x27;</span> </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> update_time <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><p>接口方法：</p><ul><li>方式一</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EmpMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;select * from emp &quot; +</span></span><br><span class="line"><span class="meta">            &quot;where name like &#x27;%$&#123;name&#125;%&#x27; &quot; +</span></span><br><span class="line"><span class="meta">            &quot;and gender = #&#123;gender&#125; &quot; +</span></span><br><span class="line"><span class="meta">            &quot;and entrydate between #&#123;begin&#125; and #&#123;end&#125; &quot; +</span></span><br><span class="line"><span class="meta">            &quot;order by update_time desc&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Emp&gt; <span class="title function_">list</span><span class="params">(String name, Short gender, LocalDate begin, LocalDate end)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><img src="https://bu.dusays.com/2024/07/23/669fadc1f36f9.png" alt="image-20221212115149151.png"></p><p>以上方式注意事项：</p><ol><li><p>方法中的形参名和SQL语句中的参数占位符名保持一致</p></li><li><p>模糊查询使用${…}进行字符串拼接，这种方式呢，由于是字符串拼接，并不是预编译的形式，所以效率不高、且存在sql注入风险。</p></li></ol></blockquote><ul><li>方式二（解决SQL注入风险）<ul><li>使用MySQL提供的字符串拼接函数：concat(‘%’ , ‘关键字’ , ‘%’)</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EmpMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;select * from emp &quot; +</span></span><br><span class="line"><span class="meta">            &quot;where name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;) &quot; +</span></span><br><span class="line"><span class="meta">            &quot;and gender = #&#123;gender&#125; &quot; +</span></span><br><span class="line"><span class="meta">            &quot;and entrydate between #&#123;begin&#125; and #&#123;end&#125; &quot; +</span></span><br><span class="line"><span class="meta">            &quot;order by update_time desc&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Emp&gt; <span class="title function_">list</span><span class="params">(String name, Short gender, LocalDate begin, LocalDate end)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>执行结果：生成的SQL都是预编译的SQL语句（性能高、安全）</p><p><img src="https://bu.dusays.com/2024/07/23/669fadc21a17f.png" alt="image-20221212120006242.png"></p></blockquote><h3 id="1-6-4-参数名说明"><a href="#1-6-4-参数名说明" class="headerlink" title="1.6.4 参数名说明"></a>1.6.4 参数名说明</h3><p>在上面我们所编写的条件查询功能中，我们需要保证接口中方法的形参名和SQL语句中的参数占位符名相同。</p><blockquote><p>当方法中的形参名和SQL语句中的占位符参数名不相同时，就会出现以下问题：</p><p><img src="https://bu.dusays.com/2024/07/23/669fadc4ca550.png" alt="image-20221212150611796.png"></p></blockquote><p>参数名在不同的SpringBoot版本中，处理方案还不同：</p><ul><li>在springBoot的2.x版本（保证参数名一致）</li></ul><p><img src="https://bu.dusays.com/2024/07/23/669fadc42c660.png" alt="image-20221212151156273.png"></p><blockquote><p>springBoot的父工程对compiler编译插件进行了默认的参数parameters配置，使得在编译时，会在生成的字节码文件中保留原方法形参的名称，所以#{…}里面可以直接通过形参名获取对应的值</p><p><img src="https://bu.dusays.com/2024/07/23/669fadc26fe02.png" alt="image-20221212151411154.png"></p></blockquote><ul><li>在springBoot的1.x版本&#x2F;单独使用mybatis（使用@Param注解来指定SQL语句中的参数名）</li></ul><p><img src="https://bu.dusays.com/2024/07/23/669fadc309928.png" alt="image-20221212151628715.png"></p><blockquote><p>在编译时，生成的字节码文件当中，不会保留Mapper接口中方法的形参名称，而是使用var1、var2、…这样的形参名字，此时要获取参数值时，就要通过@Param注解来指定SQL语句中的参数名</p><p><img src="https://bu.dusays.com/2024/07/23/669fadc331f18.png" alt="image-20221212151736274.png"></p></blockquote><h1 id="2-Mybatis的XML配置文件"><a href="#2-Mybatis的XML配置文件" class="headerlink" title="2. Mybatis的XML配置文件"></a>2. Mybatis的XML配置文件</h1><p>Mybatis的开发有两种方式：</p><ol><li>注解</li><li>XML</li></ol><h2 id="2-1-XML配置文件规范"><a href="#2-1-XML配置文件规范" class="headerlink" title="2.1 XML配置文件规范"></a>2.1 XML配置文件规范</h2><p>使用Mybatis的注解方式，主要是来完成一些简单的增删改查功能。如果需要实现复杂的SQL功能，建议使用XML来配置映射语句，也就是将SQL语句写在XML配置文件中。</p><p>在Mybatis中使用XML映射文件方式开发，需要符合一定的规范：</p><ol><li><p>XML映射文件的名称与Mapper接口名称一致，并且将XML映射文件和Mapper接口放置在相同包下（同包同名）</p></li><li><p>XML映射文件的namespace属性为Mapper接口全限定名一致</p></li><li><p>XML映射文件中sql语句的id与Mapper接口中的方法名一致，并保持返回类型一致。</p></li></ol><p><img src="https://bu.dusays.com/2024/07/23/669fae425b323.png" alt="image-20221212153529732.png"></p><blockquote><p>&lt;select&gt;标签：就是用于编写select查询语句的。</p><ul><li>resultType属性，指的是查询返回的单条记录所封装的类型。</li></ul></blockquote><h2 id="2-2-XML配置文件实现"><a href="#2-2-XML配置文件实现" class="headerlink" title="2.2 XML配置文件实现"></a>2.2 XML配置文件实现</h2><p>第1步：创建XML映射文件</p><p><img src="https://bu.dusays.com/2024/07/23/669fadc3bb890.png" alt="image-20221212154908306.png"></p><p><img src="https://bu.dusays.com/2024/07/23/669fadc5b752a.png" alt="image-20221212155304635.png"></p><p><img src="https://bu.dusays.com/2024/07/23/669fadc56cb4f.png" alt="image-20221212155544404.png"></p><p>第2步：编写XML映射文件</p><blockquote><p>xml映射文件中的dtd约束，直接从mybatis官网复制即可</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">  <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">  <span class="string">&quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置：XML映射文件的namespace属性为Mapper接口全限定名</p><p><img src="https://bu.dusays.com/2024/07/23/669fadc452c47.png" alt="image-20221212160316644.png"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.itheima.mapper.EmpMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置：XML映射文件中sql语句的id与Mapper接口中的方法名一致，并保持返回类型一致</p><p><img src="https://bu.dusays.com/2024/07/23/669fadc9ed750.png" alt="image-20221212163528787.png"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.itheima.mapper.EmpMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--查询操作--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.itheima.pojo.Emp&quot;</span>&gt;</span></span><br><span class="line">        select * from emp</span><br><span class="line">        where name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;)</span><br><span class="line">              and gender = #&#123;gender&#125;</span><br><span class="line">              and entrydate between #&#123;begin&#125; and #&#123;end&#125;</span><br><span class="line">        order by update_time desc</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>运行测试类，执行结果：</p><p><img src="https://bu.dusays.com/2024/07/23/669fadc5c3754.png" alt="image-20221212163719534.png"></p></blockquote><h2 id="2-3-MybatisX的使用"><a href="#2-3-MybatisX的使用" class="headerlink" title="2.3 MybatisX的使用"></a>2.3 MybatisX的使用</h2><p>MybatisX是一款基于IDEA的快速开发Mybatis的插件，为效率而生。</p><p>MybatisX的安装：</p><p><img src="https://bu.dusays.com/2024/07/23/669fadc5b34a7.png" alt="image-20221213120923252.png"></p><p>可以通过MybatisX快速定位：</p><p><img src="https://bu.dusays.com/2024/07/23/669fadd5ec3c7.png" alt="image-20221213121521406.png"></p><blockquote><p>MybatisX的使用在后续学习中会继续分享</p></blockquote><p>学习了Mybatis中XML配置文件的开发方式了，大家可能会存在一个疑问：到底是使用注解方式开发还是使用XML方式开发？</p><blockquote><p>官方说明：<a href="https://mybatis.net.cn/getting-started.html">https://mybatis.net.cn/getting-started.html</a></p><p><img src="https://bu.dusays.com/2024/07/23/669fadb9e402b.png" alt="image-20220901173948645.png"> </p></blockquote><p><strong>结论：</strong>使用Mybatis的注解，主要是来完成一些简单的增删改查功能。如果需要实现复杂的SQL功能，建议使用XML来配置映射语句。</p><h1 id="3-Mybatis动态SQL"><a href="#3-Mybatis动态SQL" class="headerlink" title="3. Mybatis动态SQL"></a>3. Mybatis动态SQL</h1><h2 id="3-1-什么是动态SQL"><a href="#3-1-什么是动态SQL" class="headerlink" title="3.1 什么是动态SQL"></a>3.1 什么是动态SQL</h2><p>在页面原型中，列表上方的条件是动态的，是可以不传递的，也可以只传递其中的1个或者2个或者全部。</p><p><img src="https://bu.dusays.com/2024/07/23/669fadbd37153.png" alt="image-20220901172933012.png"></p><p><img src="https://bu.dusays.com/2024/07/23/669fadba36121.png" alt="image-20220901173203491.png"></p><p>而在我们刚才编写的SQL语句中，我们会看到，我们将三个条件直接写死了。 如果页面只传递了参数姓名name 字段，其他两个字段 性别 和 入职时间没有传递，那么这两个参数的值就是null。</p><p>此时，执行的SQL语句为：</p><p><img src="https://bu.dusays.com/2024/07/23/669fadba178a9.png" alt="image-20220901173431554.png"> </p><p>这个查询结果是不正确的。正确的做法应该是：传递了参数，再组装这个查询条件；如果没有传递参数，就不应该组装这个查询条件。</p><p>比如：如果姓名输入了”张”, 对应的SQL为:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span>  <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;%张%&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> update_time <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><p>如果姓名输入了”张”,，性别选择了”男”，则对应的SQL为:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span>  <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;%张%&#x27;</span> <span class="keyword">and</span> gender <span class="operator">=</span> <span class="number">1</span> <span class="keyword">order</span> <span class="keyword">by</span> update_time <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><p>SQL语句会随着用户的输入或外部条件的变化而变化，我们称为：<strong>动态SQL</strong>。</p><p><img src="https://bu.dusays.com/2024/07/23/669fadc6dd57a.png" alt="image-20221213122623278.png"></p><p>在Mybatis中提供了很多实现动态SQL的标签，我们学习Mybatis中的动态SQL就是掌握这些动态SQL标签。</p><h2 id="3-2-动态SQL-if"><a href="#3-2-动态SQL-if" class="headerlink" title="3.2 动态SQL-if"></a>3.2 动态SQL-if</h2><p><code>&lt;if&gt;</code>：用于判断条件是否成立。使用test属性进行条件判断，如果条件为true，则拼接SQL。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;条件表达式&quot;</span>&gt;</span></span><br><span class="line">   要拼接的sql语句</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来，我们就通过<code>&lt;if&gt;</code>标签来改造之前条件查询的案例。</p><h3 id="3-2-1-条件查询"><a href="#3-2-1-条件查询" class="headerlink" title="3.2.1 条件查询"></a>3.2.1 条件查询</h3><p>示例：把SQL语句改造为动态SQL方式</p><ul><li>原有的SQL语句</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.itheima.pojo.Emp&quot;</span>&gt;</span></span><br><span class="line">        select * from emp</span><br><span class="line">        where name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;)</span><br><span class="line">              and gender = #&#123;gender&#125;</span><br><span class="line">              and entrydate between #&#123;begin&#125; and #&#123;end&#125;</span><br><span class="line">        order by update_time desc</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>动态SQL语句</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.itheima.pojo.Emp&quot;</span>&gt;</span></span><br><span class="line">        select * from emp</span><br><span class="line">        where</span><br><span class="line">    </span><br><span class="line">             <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null&quot;</span>&gt;</span></span><br><span class="line">                 name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;)</span><br><span class="line">             <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;gender != null&quot;</span>&gt;</span></span><br><span class="line">                 and gender = #&#123;gender&#125;</span><br><span class="line">             <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;begin != null and end != null&quot;</span>&gt;</span></span><br><span class="line">                 and entrydate between #&#123;begin&#125; and #&#123;end&#125;</span><br><span class="line">             <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">        order by update_time desc</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testList</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//性别数据为null、开始时间和结束时间也为null</span></span><br><span class="line">    List&lt;Emp&gt; list = empMapper.list(<span class="string">&quot;张&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">for</span>(Emp emp : list)&#123;</span><br><span class="line">        System.out.println(emp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行的SQL语句： </p><p><img src="https://bu.dusays.com/2024/07/23/669fadc6f272d.png" alt="image-20221213140353285.png"></p></blockquote><p>下面呢，我们修改测试方法中的代码，再次进行测试，观察执行情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testList</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//姓名为null</span></span><br><span class="line">    List&lt;Emp&gt; list = empMapper.list(<span class="literal">null</span>, (<span class="type">short</span>)<span class="number">1</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">for</span>(Emp emp : list)&#123;</span><br><span class="line">        System.out.println(emp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://bu.dusays.com/2024/07/23/669fadc7159e7.png" alt="image-20221213141139015.png"> </p><p><img src="https://bu.dusays.com/2024/07/23/669fadc711083.png" alt="image-20221213141253355.png"> </p><p>再次修改测试方法中的代码，再次进行测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testList</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//传递的数据全部为null</span></span><br><span class="line">    List&lt;Emp&gt; list = empMapper.list(<span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">for</span>(Emp emp : list)&#123;</span><br><span class="line">        System.out.println(emp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行的SQL语句：</p><p><img src="https://bu.dusays.com/2024/07/23/669fadc9c68f5.png" alt="image-20221213143854434.png"></p><p>以上问题的解决方案：使用<code>&lt;where&gt;</code>标签代替SQL语句中的where关键字</p><ul><li><code>&lt;where&gt;</code>只会在子元素有内容的情况下才插入where子句，而且会自动去除子句的开头的AND或OR</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.itheima.pojo.Emp&quot;</span>&gt;</span></span><br><span class="line">        select * from emp</span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">             <span class="comment">&lt;!-- if做为where标签的子元素 --&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null&quot;</span>&gt;</span></span><br><span class="line">                 and name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;)</span><br><span class="line">             <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;gender != null&quot;</span>&gt;</span></span><br><span class="line">                 and gender = #&#123;gender&#125;</span><br><span class="line">             <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;begin != null and end != null&quot;</span>&gt;</span></span><br><span class="line">                 and entrydate between #&#123;begin&#125; and #&#123;end&#125;</span><br><span class="line">             <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">        order by update_time desc</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testList</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//只有性别</span></span><br><span class="line">    List&lt;Emp&gt; list = empMapper.list(<span class="literal">null</span>, (<span class="type">short</span>)<span class="number">1</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">for</span>(Emp emp : list)&#123;</span><br><span class="line">        System.out.println(emp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行的SQL语句：</p><p><img src="https://bu.dusays.com/2024/07/23/669fadc7bb086.png" alt="image-20221213141909455.png"></p></blockquote><h3 id="3-2-2-更新员工"><a href="#3-2-2-更新员工" class="headerlink" title="3.2.2 更新员工"></a>3.2.2 更新员工</h3><p>案例：完善更新员工功能，修改为动态更新员工数据信息</p><ul><li>动态更新员工信息，如果更新时传递有值，则更新；如果更新时没有传递值，则不更新</li><li>解决方案：动态SQL</li></ul><p>修改Mapper接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EmpMapper</span> &#123;</span><br><span class="line">    <span class="comment">//删除@Update注解编写的SQL语句</span></span><br><span class="line">    <span class="comment">//update操作的SQL语句编写在Mapper映射文件中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Emp emp)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改Mapper映射文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.itheima.mapper.EmpMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--更新操作--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span>&gt;</span></span><br><span class="line">        update emp</span><br><span class="line">        set</span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null&quot;</span>&gt;</span></span><br><span class="line">                username=#&#123;username&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null&quot;</span>&gt;</span></span><br><span class="line">                name=#&#123;name&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;gender != null&quot;</span>&gt;</span></span><br><span class="line">                gender=#&#123;gender&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;image != null&quot;</span>&gt;</span></span><br><span class="line">                image=#&#123;image&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;job != null&quot;</span>&gt;</span></span><br><span class="line">                job=#&#123;job&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;entrydate != null&quot;</span>&gt;</span></span><br><span class="line">                entrydate=#&#123;entrydate&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;deptId != null&quot;</span>&gt;</span></span><br><span class="line">                dept_id=#&#123;deptId&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;updateTime != null&quot;</span>&gt;</span></span><br><span class="line">                update_time=#&#123;updateTime&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        where id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUpdate2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//要修改的员工信息</span></span><br><span class="line">        <span class="type">Emp</span> <span class="variable">emp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Emp</span>();</span><br><span class="line">        emp.setId(<span class="number">20</span>);</span><br><span class="line">        emp.setUsername(<span class="string">&quot;Tom111&quot;</span>);</span><br><span class="line">        emp.setName(<span class="string">&quot;汤姆111&quot;</span>);</span><br><span class="line"></span><br><span class="line">        emp.setUpdateTime(LocalDateTime.now());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用方法，修改员工数据</span></span><br><span class="line">        empMapper.update(emp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行的SQL语句：</p><p><img src="https://bu.dusays.com/2024/07/23/669fadc8bc7bd.png" alt="image-20221213152533851.png"></p></blockquote><p>再次修改测试方法，观察SQL语句执行情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUpdate2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//要修改的员工信息</span></span><br><span class="line">        <span class="type">Emp</span> <span class="variable">emp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Emp</span>();</span><br><span class="line">        emp.setId(<span class="number">20</span>);</span><br><span class="line">        emp.setUsername(<span class="string">&quot;Tom222&quot;</span>);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//调用方法，修改员工数据</span></span><br><span class="line">        empMapper.update(emp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行的SQL语句：</p><p><img src="https://bu.dusays.com/2024/07/23/669fadc9a6b69.png" alt="image-20221213152850322.png"></p></blockquote><p>以上问题的解决方案：使用<code>&lt;set&gt;</code>标签代替SQL语句中的set关键字</p><ul><li><code>&lt;set&gt;</code>：动态的在SQL语句中插入set关键字，并会删掉额外的逗号。（用于update语句中）</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.itheima.mapper.EmpMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--更新操作--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span>&gt;</span></span><br><span class="line">        update emp</span><br><span class="line">        <span class="comment">&lt;!-- 使用set标签，代替update语句中的set关键字 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null&quot;</span>&gt;</span></span><br><span class="line">                username=#&#123;username&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null&quot;</span>&gt;</span></span><br><span class="line">                name=#&#123;name&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;gender != null&quot;</span>&gt;</span></span><br><span class="line">                gender=#&#123;gender&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;image != null&quot;</span>&gt;</span></span><br><span class="line">                image=#&#123;image&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;job != null&quot;</span>&gt;</span></span><br><span class="line">                job=#&#123;job&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;entrydate != null&quot;</span>&gt;</span></span><br><span class="line">                entrydate=#&#123;entrydate&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;deptId != null&quot;</span>&gt;</span></span><br><span class="line">                dept_id=#&#123;deptId&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;updateTime != null&quot;</span>&gt;</span></span><br><span class="line">                update_time=#&#123;updateTime&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        where id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>再次执行测试方法，执行的SQL语句：</p><p><img src="https://bu.dusays.com/2024/07/23/669fadca0a6fd.png" alt="image-20221213153329553.png"></p></blockquote><p><strong>小结</strong></p><ul><li><p><code>&lt;if&gt;</code></p><ul><li><p>用于判断条件是否成立，如果条件为true，则拼接SQL</p></li><li><p>形式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null&quot;</span>&gt;</span> … <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>&lt;where&gt;</code></p><ul><li>where元素只会在子元素有内容的情况下才插入where子句，而且会自动去除子句的开头的AND或OR</li></ul></li><li><p><code>&lt;set&gt;</code></p><ul><li>动态地在行首插入 SET 关键字，并会删掉额外的逗号。（用在update语句中）</li></ul></li></ul><h2 id="3-3-动态SQL-foreach"><a href="#3-3-动态SQL-foreach" class="headerlink" title="3.3 动态SQL-foreach"></a>3.3 动态SQL-foreach</h2><p>案例：员工删除功能（既支持删除单条记录，又支持批量删除）</p><p><img src="https://bu.dusays.com/2024/07/23/669fadb9e271b.png" alt="image-20220901181751004.png"> </p><p>SQL语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete from emp where id in (1,2,3);</span><br></pre></td></tr></table></figure><p>Mapper接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EmpMapper</span> &#123;</span><br><span class="line">    <span class="comment">//批量删除</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteByIds</span><span class="params">(List&lt;Integer&gt; ids)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>XML映射文件：</p><ul><li>使用<code>&lt;foreach&gt;</code>遍历deleteByIds方法中传递的参数ids集合</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;集合名称&quot;</span> <span class="attr">item</span>=<span class="string">&quot;集合遍历出来的元素/项&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;每一次遍历使用的分隔符&quot;</span> </span></span><br><span class="line"><span class="tag">         <span class="attr">open</span>=<span class="string">&quot;遍历开始前拼接的片段&quot;</span> <span class="attr">close</span>=<span class="string">&quot;遍历结束后拼接的片段&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.itheima.mapper.EmpMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--删除操作--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteByIds&quot;</span>&gt;</span></span><br><span class="line">        delete from emp where id in</span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;ids&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">            #&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span> </span><br></pre></td></tr></table></figure><blockquote><p><img src="https://bu.dusays.com/2024/07/23/669fadc976f9c.png" alt="image-20221213165710141.png"></p></blockquote><blockquote><p>执行的SQL语句：</p><p><img src="https://bu.dusays.com/2024/07/23/669fadc90f682.png" alt="image-20221213164957636.png"></p></blockquote><h2 id="3-4-动态SQL-sql-include"><a href="#3-4-动态SQL-sql-include" class="headerlink" title="3.4 动态SQL-sql&amp;include"></a>3.4 动态SQL-sql&amp;include</h2><p>问题分析：</p><ul><li>在xml映射文件中配置的SQL，有时可能会存在很多重复的片段，此时就会存在很多冗余的代码</li></ul><p><img src="https://bu.dusays.com/2024/07/23/669fadb9dad3e.png" alt="image-20220901182204358.png"></p><p><img src="https://bu.dusays.com/2024/07/23/669fadb9e7a0f.png" alt="image-20220901182249421.png"></p><p>我们可以对重复的代码片段进行抽取，将其通过<code>&lt;sql&gt;</code>标签封装到一个SQL片段，然后再通过<code>&lt;include&gt;</code>标签进行引用。</p><ul><li><p><code>&lt;sql&gt;</code>：定义可重用的SQL片段</p></li><li><p><code>&lt;include&gt;</code>：通过属性refid，指定包含的SQL片段</p></li></ul><p><img src="https://bu.dusays.com/2024/07/23/669fadcb29eea.png" alt="image-20221213171244796.png"></p><p>SQL片段： 抽取重复的代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;commonSelect&quot;</span>&gt;</span></span><br><span class="line"> select id, username, password, name, gender, image, job, entrydate, dept_id, create_time, update_time from emp</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后通过<code>&lt;include&gt;</code> 标签在原来抽取的地方进行引用。操作如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.itheima.pojo.Emp&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;commonSelect&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null&quot;</span>&gt;</span></span><br><span class="line">            name like concat(&#x27;%&#x27;,#&#123;name&#125;,&#x27;%&#x27;)</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;gender != null&quot;</span>&gt;</span></span><br><span class="line">            and gender = #&#123;gender&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;begin != null and end != null&quot;</span>&gt;</span></span><br><span class="line">            and entrydate between #&#123;begin&#125; and #&#123;end&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    order by update_time desc</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis入门</title>
      <link href="/posts/c0c42fb6.html"/>
      <url>/posts/c0c42fb6.html</url>
      
        <content type="html"><![CDATA[<h1 id="Mybatis入门"><a href="#Mybatis入门" class="headerlink" title="Mybatis入门"></a>Mybatis入门</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在前面我们学习MySQL数据库时，都是利用图形化客户端工具(如：idea、datagrip)，来操作数据库的。</p><blockquote><p>在客户端工具中，编写增删改查的SQL语句，发给MySQL数据库管理系统，由数据库管理系统执行SQL语句并返回执行结果。</p><p>增删改操作：返回受影响行数</p><p>查询操作：返回结果集(查询的结果)</p></blockquote><p>我们做为后端程序开发人员，通常会使用Java程序来完成对数据库的操作。Java程序操作数据库，现在主流的方式是：Mybatis。</p><p>什么是MyBatis?</p><ul><li><p>MyBatis是一款优秀的 <strong>持久层</strong> <strong>框架</strong>，用于简化JDBC的开发。</p></li><li><p>MyBatis本是 Apache的一个开源项目iBatis，2010年这个项目由apache迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github。</p></li><li><p>官网：<a href="https://mybatis.org/mybatis-3/zh/index.html">https://mybatis.org/mybatis-3/zh/index.html</a></p></li></ul><p>在上面我们提到了两个词：一个是持久层，另一个是框架。</p><ul><li>持久层：指的是就是数据访问层(dao)，是用来操作数据库的。</li></ul><p><img src="https://bu.dusays.com/2024/07/23/669faa4f79ac9.png" alt="image-20220901114951631.png"> </p><ul><li>框架：是一个半成品软件，是一套可重用的、通用的、软件基础代码模型。在框架的基础上进行软件开发更加高效、规范、通用、可拓展。</li></ul><p>Mybatis课程安排：</p><ul><li><p>Mybatis入门</p></li><li><p>Mybatis基础增删改查</p></li><li><p>Mybatis动态SQL</p></li></ul><p>接下来，我们就通过一个入门程序，让大家快速感受一下通过Mybatis如何来操作数据库。</p><h2 id="1-快速入门"><a href="#1-快速入门" class="headerlink" title="1. 快速入门"></a>1. 快速入门</h2><p>需求：使用Mybatis查询所有用户数据。</p><h3 id="1-1-入门程序分析"><a href="#1-1-入门程序分析" class="headerlink" title="1.1 入门程序分析"></a>1.1 入门程序分析</h3><p>以前我们是在图形化客户端工具中编写SQL查询代码，发送给数据库执行，数据库执行后返回操作结果。</p><p><img src="https://bu.dusays.com/2024/07/23/669faa4f9d792.png" alt="image-20221209155704203.png"> </p><p>图形化工具会把数据库执行的查询结果，使用表格的形式展现出来</p><p><img src="https://bu.dusays.com/2024/07/23/669faa4f80d42.png" alt="image-20220901121116813.png"> </p><p>现在使用Mybatis操作数据库，就是在Mybatis中编写SQL查询代码，发送给数据库执行，数据库执行后返回结果。</p><p><img src="https://bu.dusays.com/2024/07/23/669faa4fd063b.png" alt="image-20221209155904370.png"></p><p> Mybatis会把数据库执行的查询结果，使用实体类封装起来（一行记录对应一个实体类对象）</p><p><img src="https://bu.dusays.com/2024/07/23/669faa52665ed.png" alt="image-20221209161623051.png"></p><p>Mybatis操作数据库的步骤：</p><ol><li><p>准备工作(创建springboot工程、数据库表user、实体类User)</p></li><li><p>引入Mybatis的相关依赖，配置Mybatis(数据库连接信息)</p></li><li><p>编写SQL语句(注解&#x2F;XML)</p></li></ol><h3 id="1-2-入门程序实现"><a href="#1-2-入门程序实现" class="headerlink" title="1.2 入门程序实现"></a>1.2 入门程序实现</h3><h4 id="1-2-1-准备工作"><a href="#1-2-1-准备工作" class="headerlink" title="1.2.1 准备工作"></a>1.2.1 准备工作</h4><h5 id="1-2-1-1-创建springboot工程"><a href="#1-2-1-1-创建springboot工程" class="headerlink" title="1.2.1.1 创建springboot工程"></a>1.2.1.1 创建springboot工程</h5><p>创建springboot工程，并导入 mybatis的起步依赖、mysql的驱动包。</p><p><img src="https://bu.dusays.com/2024/07/23/669faa4f85e4f.png" alt="image-20221209162827242.png"></p><p><img src="https://bu.dusays.com/2024/07/23/669faa4fb33c5.png" alt="image-20221209163123443.png"></p><blockquote><p>项目工程创建完成后，自动在pom.xml文件中，导入Mybatis依赖和MySQL驱动依赖</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 仅供参考：只粘贴了pom.xml中部分内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- mybatis起步依赖 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- mysql驱动包依赖 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- spring单元测试 (集成了junit) --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="1-2-1-2-数据准备"><a href="#1-2-1-2-数据准备" class="headerlink" title="1.2.1.2 数据准备"></a>1.2.1.2 数据准备</h5><p>创建用户表user，并创建对应的实体类User。</p><ul><li>用户表：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 用户表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span>(</span><br><span class="line">    id <span class="type">int</span> unsigned <span class="keyword">primary</span> key auto_increment comment <span class="string">&#x27;ID&#x27;</span>,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">100</span>) comment <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">    age tinyint unsigned comment <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">    gender tinyint unsigned comment <span class="string">&#x27;性别, 1:男, 2:女&#x27;</span>,</span><br><span class="line">    phone <span class="type">varchar</span>(<span class="number">11</span>) comment <span class="string">&#x27;手机号&#x27;</span></span><br><span class="line">) comment <span class="string">&#x27;用户表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 测试数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(id, name, age, gender, phone) <span class="keyword">VALUES</span> (<span class="keyword">null</span>,<span class="string">&#x27;白眉鹰王&#x27;</span>,<span class="number">55</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;18800000000&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(id, name, age, gender, phone) <span class="keyword">VALUES</span> (<span class="keyword">null</span>,<span class="string">&#x27;金毛狮王&#x27;</span>,<span class="number">45</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;18800000001&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(id, name, age, gender, phone) <span class="keyword">VALUES</span> (<span class="keyword">null</span>,<span class="string">&#x27;青翼蝠王&#x27;</span>,<span class="number">38</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;18800000002&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(id, name, age, gender, phone) <span class="keyword">VALUES</span> (<span class="keyword">null</span>,<span class="string">&#x27;紫衫龙王&#x27;</span>,<span class="number">42</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;18800000003&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(id, name, age, gender, phone) <span class="keyword">VALUES</span> (<span class="keyword">null</span>,<span class="string">&#x27;光明左使&#x27;</span>,<span class="number">37</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;18800000004&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(id, name, age, gender, phone) <span class="keyword">VALUES</span> (<span class="keyword">null</span>,<span class="string">&#x27;光明右使&#x27;</span>,<span class="number">48</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;18800000005&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/07/23/669faa4f80d42.png" alt="image-20220901121116813.png"> </p><ul><li><p>实体类</p><ul><li>实体类的属性名与表中的字段名一一对应。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;   <span class="comment">//id（主键）</span></span><br><span class="line">    <span class="keyword">private</span> String name;  <span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">private</span> Short age;    <span class="comment">//年龄</span></span><br><span class="line">    <span class="keyword">private</span> Short gender; <span class="comment">//性别</span></span><br><span class="line">    <span class="keyword">private</span> String phone; <span class="comment">//手机号</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//省略GET, SET方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/07/23/669faa502d228.png" alt="image-20221209170354143.png"></p><h4 id="1-2-2-配置Mybatis"><a href="#1-2-2-配置Mybatis" class="headerlink" title="1.2.2 配置Mybatis"></a>1.2.2 配置Mybatis</h4><blockquote><p>在之前使用图形化客户端工具，连接MySQL数据库时，需要配置：</p><p><img src="https://bu.dusays.com/2024/07/23/669faa50451c0.png" alt="image-20221209172527630.png"></p><p>连接数据库的四大参数：</p><ul><li>MySQL驱动类 </li><li>登录名</li><li>密码</li><li>数据库连接字符串</li></ul></blockquote><p>基于上述分析，在Mybatis中要连接数据库，同样也需要以上4个参数配置。</p><p>在springboot项目中，可以编写application.properties文件，配置数据库连接信息。我们要连接数据库，就需要配置数据库连接的基本信息，包括：driver-class-name、url 、username，password。</p><blockquote><p>在入门程序中，大家可以直接这么配置，后面会介绍什么是驱动。</p></blockquote><p>application.properties:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#驱动类名称</span></span><br><span class="line"><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="comment">#数据库连接的url</span></span><br><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/mybatis</span></span><br><span class="line"><span class="comment">#连接数据库的用户名</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="comment">#连接数据库的密码</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">1234</span></span><br></pre></td></tr></table></figure><blockquote><p>上述的配置，可以直接复制过去，不要敲错了。 全部都是 spring.datasource.xxxx 开头。</p></blockquote><h4 id="1-2-3-编写SQL语句"><a href="#1-2-3-编写SQL语句" class="headerlink" title="1.2.3 编写SQL语句"></a>1.2.3 编写SQL语句</h4><p>在创建出来的springboot工程中，在引导类所在包下，在创建一个包 mapper。在mapper包下创建一个接口 UserMapper ，这是一个持久层接口（Mybatis的持久层接口规范一般都叫 XxxMapper）。</p><p><img src="https://bu.dusays.com/2024/07/23/669faa514eb2b.png" alt="image-20221209175843651.png"></p><p>UserMapper：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.itheima.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Select;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//查询所有用户数据</span></span><br><span class="line">    <span class="meta">@Select(&quot;select id, name, age, gender, phone from user&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">list</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>@Mapper注解：表示是mybatis中的Mapper接口</p><ul><li>程序运行时：框架会自动生成接口的实现类对象(代理对象)，并给交Spring的IOC容器管理</li></ul><p> @Select注解：代表的就是select查询，用于书写select查询语句</p></blockquote><h4 id="1-2-4-单元测试"><a href="#1-2-4-单元测试" class="headerlink" title="1.2.4 单元测试"></a>1.2.4 单元测试</h4><p>在创建出来的SpringBoot工程中，在src下的test目录下，已经自动帮我们创建好了测试类 ，并且在测试类上已经添加了注解 @SpringBootTest，代表该测试类已经与SpringBoot整合。 </p><p>该测试类在运行时，会自动通过引导类加载Spring的环境（IOC容器）。我们要测试那个bean对象，就可以直接通过@Autowired注解直接将其注入进行，然后就可以测试了。 </p><p>测试类代码如下： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisQuickstartApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testList</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;User&gt; userList = userMapper.list();</span><br><span class="line">        <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">User&#123;id=1, name=&#x27;白眉鹰王&#x27;, age=55, gender=1, phone=&#x27;18800000000&#x27;&#125;</span><br><span class="line">User&#123;id=2, name=&#x27;金毛狮王&#x27;, age=45, gender=1, phone=&#x27;18800000001&#x27;&#125;</span><br><span class="line">User&#123;id=3, name=&#x27;青翼蝠王&#x27;, age=38, gender=1, phone=&#x27;18800000002&#x27;&#125;</span><br><span class="line">User&#123;id=4, name=&#x27;紫衫龙王&#x27;, age=42, gender=2, phone=&#x27;18800000003&#x27;&#125;</span><br><span class="line">User&#123;id=5, name=&#x27;光明左使&#x27;, age=37, gender=1, phone=&#x27;18800000004&#x27;&#125;</span><br><span class="line">User&#123;id=6, name=&#x27;光明右使&#x27;, age=48, gender=1, phone=&#x27;18800000005&#x27;&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="1-3-解决SQL警告与提示"><a href="#1-3-解决SQL警告与提示" class="headerlink" title="1.3 解决SQL警告与提示"></a>1.3 解决SQL警告与提示</h3><p>默认我们在UserMapper接口上加的@Select注解中编写SQL语句是没有提示的。 如果想让idea给我们提示对应的SQL语句，我们需要在IDEA中配置与MySQL数据库的链接。 </p><p>默认我们在UserMapper接口上的@Select注解中编写SQL语句是没有提示的。如果想让idea给出提示，可以做如下配置：</p><p><img src="https://bu.dusays.com/2024/07/23/669faa5474559.png" alt="image-20221210143348119.png"></p><p>配置完成之后，发现SQL语句中的关键字有提示了，但还存在不识别表名(列名)的情况：</p><p><img src="https://bu.dusays.com/2024/07/23/669faa51407cc.png" alt="image-20221210143934318.png"></p><blockquote><p>产生原因：Idea和数据库没有建立连接，不识别表信息</p><p>解决方案：在Idea中配置MySQL数据库连接</p></blockquote><p><img src="https://bu.dusays.com/2024/07/23/669faa5154c3c.png" alt="image-20221210144139792.png"> </p><blockquote><p>在配置的时候指定连接那个数据库，如上图所示连接的就是mybatis数据库。</p></blockquote><h2 id="2-JDBC介绍-了解"><a href="#2-JDBC介绍-了解" class="headerlink" title="2. JDBC介绍(了解)"></a>2. JDBC介绍(了解)</h2><h3 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h3><p>通过Mybatis的快速入门，我们明白了，通过Mybatis可以很方便的进行数据库的访问操作。但是大家要明白，其实java语言操作数据库呢，只能通过一种方式：使用sun公司提供的 JDBC 规范。</p><blockquote><p>Mybatis框架，就是对原始的JDBC程序的封装。 </p></blockquote><p>那到底什么是JDBC呢，接下来，我们就来介绍一下。</p><p>JDBC： ( Java DataBase Connectivity )，就是使用Java语言操作关系型数据库的一套API。</p><p><img src="https://bu.dusays.com/2024/07/23/669faa53809da.png" alt="image-20221210144811961.png"> </p><blockquote><p>本质：</p><ul><li><p>sun公司官方定义的一套操作所有关系型数据库的规范，即接口。</p></li><li><p>各个数据库厂商去实现这套接口，提供数据库驱动jar包。</p></li><li><p>我们可以使用这套接口(JDBC)编程，真正执行的代码是驱动jar包中的实现类。</p></li></ul></blockquote><h3 id="2-2-代码"><a href="#2-2-代码" class="headerlink" title="2.2 代码"></a>2.2 代码</h3><p>下面我们看看原始的JDBC程序是如何操作数据库的。操作步骤如下：</p><ol><li>注册驱动</li><li>获取连接对象</li><li>执行SQL语句，返回执行结果</li><li>处理执行结果</li><li>释放资源</li></ol><blockquote><p>在pom.xml文件中已引入MySQL驱动依赖，我们直接编写JDBC代码即可</p></blockquote><p>JDBC具体代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.itheima.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJdbc</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1. 注册驱动</span></span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 获取数据库连接</span></span><br><span class="line">        String url=<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/mybatis&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;1234&quot;</span>;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url, username, password);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 执行SQL</span></span><br><span class="line">        <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatement(); <span class="comment">//操作SQL的对象</span></span><br><span class="line">        String sql=<span class="string">&quot;select id,name,age,gender,phone from user&quot;</span>;</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> statement.executeQuery(sql);<span class="comment">//SQL查询结果会封装在ResultSet对象中</span></span><br><span class="line"></span><br><span class="line">        List&lt;User&gt; userList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//集合对象（用于存储User对象）</span></span><br><span class="line">        <span class="comment">//4. 处理SQL执行结果</span></span><br><span class="line">        <span class="keyword">while</span> (rs.next())&#123;</span><br><span class="line">            <span class="comment">//取出一行记录中id、name、age、gender、phone下的数据</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">            <span class="type">short</span> <span class="variable">age</span> <span class="operator">=</span> rs.getShort(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">            <span class="type">short</span> <span class="variable">gender</span> <span class="operator">=</span> rs.getShort(<span class="string">&quot;gender&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;phone&quot;</span>);</span><br><span class="line">            <span class="comment">//把一行记录中的数据，封装到User对象中</span></span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(id,name,age,gender,phone);</span><br><span class="line">            userList.add(user);<span class="comment">//User对象添加到集合</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5. 释放资源</span></span><br><span class="line">        statement.close();</span><br><span class="line">        connection.close();</span><br><span class="line">        rs.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历集合</span></span><br><span class="line">        <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>DriverManager(类)：数据库驱动管理类。</p><ul><li><p>作用：</p><ol><li><p>注册驱动</p></li><li><p>创建java代码和数据库之间的连接，即获取Connection对象</p></li></ol></li></ul><p>Connection(接口)：建立数据库连接的对象</p><ul><li>作用：用于建立java程序和数据库之间的连接</li></ul><p>Statement(接口)： 数据库操作对象(执行SQL语句的对象)。</p><ul><li>作用：用于向数据库发送sql语句</li></ul><p>ResultSet(接口)：结果集对象（一张虚拟表）</p><ul><li>作用：sql查询语句的执行结果会封装在ResultSet中</li></ul></blockquote><p>通过上述代码，我们看到直接基于JDBC程序来操作数据库，代码实现非常繁琐，所以在项目开发中，我们很少使用。  在项目开发中，通常会使用Mybatis这类的高级技术来操作数据库，从而简化数据库操作、提高开发效率。</p><h3 id="2-3-问题分析"><a href="#2-3-问题分析" class="headerlink" title="2.3 问题分析"></a>2.3 问题分析</h3><p>原始的JDBC程序，存在以下几点问题：</p><ol><li>数据库链接的四要素(驱动、链接、用户名、密码)全部硬编码在java代码中</li><li>查询结果的解析及封装非常繁琐</li><li>每一次查询数据库都需要获取连接,操作完毕后释放连接, 资源浪费, 性能降低</li></ol><p><img src="https://bu.dusays.com/2024/07/23/669faa534ce85.png" alt="image-20221210153407998.png"></p><h3 id="2-4-技术对比"><a href="#2-4-技术对比" class="headerlink" title="2.4 技术对比"></a>2.4 技术对比</h3><p>分析了JDBC的缺点之后，我们再来看一下在mybatis中，是如何解决这些问题的：</p><ol><li><p>数据库连接四要素(驱动、链接、用户名、密码)，都配置在springboot默认的配置文件 application.properties中</p></li><li><p>查询结果的解析及封装，由mybatis自动完成映射封装，我们无需关注</p></li><li><p>在mybatis中使用了数据库连接池技术，从而避免了频繁的创建连接、销毁连接而带来的资源浪费。</p></li></ol><p><img src="https://bu.dusays.com/2024/07/23/669faa51c358e.png" alt="image-20221210154324151.png"></p><blockquote><p>使用SpringBoot+Mybatis的方式操作数据库，能够提升开发效率、降低资源浪费</p></blockquote><p>而对于Mybatis来说，我们在开发持久层程序操作数据库时，需要重点关注以下两个方面：</p><ol><li><p>application.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#驱动类名称</span></span><br><span class="line"><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="comment">#数据库连接的url</span></span><br><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/mybatis</span></span><br><span class="line"><span class="comment">#连接数据库的用户名</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="comment">#连接数据库的密码</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">1234</span></span><br></pre></td></tr></table></figure></li><li><p>Mapper接口（编写SQL语句）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;select id, name, age, gender, phone from user&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">list</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="3-数据库连接池"><a href="#3-数据库连接池" class="headerlink" title="3. 数据库连接池"></a>3. 数据库连接池</h2><p>在前面我们所讲解的mybatis中，使用了数据库连接池技术，避免频繁的创建连接、销毁连接而带来的资源浪费。</p><p>下面我们就具体的了解下数据库连接池。</p><h3 id="3-1-介绍"><a href="#3-1-介绍" class="headerlink" title="3.1 介绍"></a>3.1 介绍</h3><p><img src="https://bu.dusays.com/2024/07/23/669faa51c5e7c.png" alt="image-20221210160341852.png"></p><blockquote><p>没有使用数据库连接池：</p><ul><li>客户端执行SQL语句：要先创建一个新的连接对象，然后执行SQL语句，SQL语句执行后又需要关闭连接对象从而释放资源，每次执行SQL时都需要创建连接、销毁链接，这种频繁的重复创建销毁的过程是比较耗费计算机的性能。</li></ul></blockquote><p><img src="https://bu.dusays.com/2024/07/23/669faa524923a.png" alt="image-20221210161016314.png"></p><p>数据库连接池是个容器，负责分配、管理数据库连接(Connection)</p><ul><li>程序在启动时，会在数据库连接池(容器)中，创建一定数量的Connection对象</li></ul><p>允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个</p><ul><li>客户端在执行SQL时，先从连接池中获取一个Connection对象，然后在执行SQL语句，SQL语句执行完之后，释放Connection时就会把Connection对象归还给连接池（Connection对象可以复用）</li></ul><p>释放空闲时间超过最大空闲时间的连接，来避免因为没有释放连接而引起的数据库连接遗漏</p><ul><li>客户端获取到Connection对象了，但是Connection对象并没有去访问数据库(处于空闲)，数据库连接池发现Connection对象的空闲时间 &gt; 连接池中预设的最大空闲时间，此时数据库连接池就会自动释放掉这个连接对象</li></ul><p>数据库连接池的好处：</p><ol><li>资源重用</li><li>提升系统响应速度</li><li>避免数据库连接遗漏</li></ol><h3 id="3-2-产品"><a href="#3-2-产品" class="headerlink" title="3.2 产品"></a>3.2 产品</h3><p>要怎么样实现数据库连接池呢？</p><ul><li><p>官方(sun)提供了数据库连接池标准（javax.sql.DataSource接口）</p><ul><li><p>功能：获取连接 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException;</span><br></pre></td></tr></table></figure></li><li><p>第三方组织必须按照DataSource接口实现</p></li></ul></li></ul><p>常见的数据库连接池：</p><ul><li>C3P0</li><li>DBCP</li><li>Druid</li><li>Hikari (springboot默认)</li></ul><p>现在使用更多的是：Hikari、Druid  （性能更优越）</p><ul><li>Hikari（追光者） [默认的连接池]</li></ul><p><img src="https://bu.dusays.com/2024/07/23/669faa4f74a6e.png" alt="image-20220901144923251.png"> </p><ul><li><p>Druid（德鲁伊）</p><ul><li><p>Druid连接池是阿里巴巴开源的数据库连接池项目 </p></li><li><p>功能强大，性能优秀，是Java语言最好的数据库连接池之一</p></li></ul></li></ul><p>​</p><p>如果我们想把默认的数据库连接池切换为Druid数据库连接池，只需要完成以下两步操作即可：</p><blockquote><p>参考官方地址：<a href="https://github.com/alibaba/druid/tree/master/druid-spring-boot-starter">https://github.com/alibaba/druid/tree/master/druid-spring-boot-starter</a></p></blockquote><ol><li>在pom.xml文件中引入依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Druid连接池依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>在application.properties中引入数据库连接配置</li></ol><p>方式1：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.datasource.druid.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">spring.datasource.druid.url</span>=<span class="string">jdbc:mysql://localhost:3306/mybatis</span></span><br><span class="line"><span class="attr">spring.datasource.druid.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">spring.datasource.druid.password</span>=<span class="string">1234</span></span><br></pre></td></tr></table></figure><p>方式2：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/mybatis</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">1234</span></span><br></pre></td></tr></table></figure><h2 id="4-lombok"><a href="#4-lombok" class="headerlink" title="4. lombok"></a>4. lombok</h2><h3 id="4-1-介绍"><a href="#4-1-介绍" class="headerlink" title="4.1 介绍"></a>4.1 介绍</h3><p>Lombok是一个实用的Java类库，可以通过简单的注解来简化和消除一些必须有但显得很臃肿的Java代码。</p><p><img src="https://bu.dusays.com/2024/07/23/669faa551f5f9.png" alt="image-20221210164641266.png"></p><blockquote><p>通过注解的形式自动生成构造器、getter&#x2F;setter、equals、hashcode、toString等方法，并可以自动化生成日志变量，简化java开发、提高效率。</p></blockquote><table><thead><tr><th><strong>注解</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>@Getter&#x2F;@Setter</td><td>为所有的属性提供get&#x2F;set方法</td></tr><tr><td>@ToString</td><td>会给类自动生成易阅读的  toString 方法</td></tr><tr><td>@EqualsAndHashCode</td><td>根据类所拥有的非静态字段自动重写 equals 方法和  hashCode 方法</td></tr><tr><td>@Data</td><td>提供了更综合的生成代码功能（@Getter  + @Setter + @ToString + @EqualsAndHashCode）</td></tr><tr><td>@NoArgsConstructor</td><td>为实体类生成无参的构造器方法</td></tr><tr><td>@AllArgsConstructor</td><td>为实体类生成除了static修饰的字段之外带有各参数的构造器方法。</td></tr></tbody></table><h3 id="4-2-使用"><a href="#4-2-使用" class="headerlink" title="4.2 使用"></a>4.2 使用</h3><p>第1步：在pom.xml文件中引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在springboot的父工程中，已经集成了lombok并指定了版本号，故当前引入依赖时不需要指定version --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第2步：在实体类上添加注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Short age;</span><br><span class="line">    <span class="keyword">private</span> Short gender;</span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在实体类上添加了@Data注解，那么这个类在编译时期，就会生成getter&#x2F;setter、equals、hashcode、toString等方法。</p><p><img src="https://bu.dusays.com/2024/07/23/669faa52c1010.png" alt="image-20221210170733921.png"></p></blockquote><p>说明：@Data注解中不包含全参构造方法，通常在实体类上，还会添加上：全参构造、无参构造</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span> <span class="comment">//getter方法、setter方法、toString方法、hashCode方法、equals方法</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span> <span class="comment">//无参构造</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span><span class="comment">//全参构造</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Short age;</span><br><span class="line">    <span class="keyword">private</span> Short gender;</span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Lombok的注意事项：</p><ul><li>Lombok会在编译时，会自动生成对应的java代码</li><li>在使用lombok时，还需要安装一个lombok的插件（新版本的IDEA中自带）</li></ul><p><img src="https://bu.dusays.com/2024/07/23/669faa534c5eb.png" alt="image-20221210165506359.png"></p>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot入门</title>
      <link href="/posts/6f2612a2.html"/>
      <url>/posts/6f2612a2.html</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot基础"><a href="#SpringBoot基础" class="headerlink" title="SpringBoot基础"></a>SpringBoot基础</h1><h2 id="内容大纲"><a href="#内容大纲" class="headerlink" title="内容大纲"></a>内容大纲</h2><blockquote><ol><li><p>SpringBootWeb入门</p></li><li><p>HTTP协议</p></li><li><p>Web服务器-Tomcat</p></li></ol></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="https://bu.dusays.com/2024/05/06/6638ec39d4ad5.png" alt="image-20221130095316032.png"></p><p>下面我们将进入SpringBoot基础阶段的学习。</p><p>在没有正式的学习SpringBoot之前，我们要先来了解下什么是Spring。</p><p>我们可以打开Spring的官网(<a href="https://spring.io)，去看一下Spring的简介：Spring">https://spring.io)，去看一下Spring的简介：Spring</a> makes Java simple。</p><p><img src="https://bu.dusays.com/2024/05/06/6638ec358ff33.png" alt="image-20220617222738668.png"></p><p>Spring的官方提供很多开源的项目，我们可以点击上面的projects，看到spring家族旗下的项目，按照流行程度排序为：</p><p><img src="https://bu.dusays.com/2024/05/06/6638ec35cf327.png" alt="image-20220617222925923.png"></p><p>Spring发展到今天已经形成了一种开发生态圈，Spring提供了若干个子项目，每个项目用于完成特定的功能。而我们在项目开发时，一般会偏向于选择这一套spring家族的技术，来解决对应领域的问题，那我们称这一套技术为<strong>spring全家桶</strong>。</p><p><img src="https://bu.dusays.com/2024/05/06/6638ec35e2d25.png" alt="image-20220617222609699.png"></p><p>而Spring家族旗下这么多的技术，最基础、最核心的是 SpringFramework。其他的spring家族的技术，都是基于SpringFramework的，SpringFramework中提供很多实用功能，如：依赖注入、事务管理、web开发支持、数据访问、消息服务等等。</p><p><img src="https://bu.dusays.com/2024/05/06/6638ec35e3471.png" alt="image-20220617224427947.png"></p><p>而如果我们在项目中，直接基于SpringFramework进行开发，存在两个问题：配置繁琐、入门难度大。 </p><p><img src="https://bu.dusays.com/2024/05/06/6638ec35e60f0.png" alt="image-20220823185227296.png"></p><p>所以基于此呢，spring官方推荐我们从另外一个项目开始学习，那就是目前最火爆的SpringBoot。 </p><p>通过springboot就可以快速的帮我们构建应用程序，所以springboot呢，最大的特点有两个 ：</p><ul><li>简化配置</li><li>快速开发</li></ul><p><strong>Spring Boot 可以帮助我们非常快速的构建应用程序、简化开发、提高效率 。</strong></p><p>接下来，我们就直接通过一个SpringBoot的web入门程序，让大家快速感受一下，基于SpringBoot进行Web开发的便捷性。</p><h2 id="1-SpringBootWeb快速入门"><a href="#1-SpringBootWeb快速入门" class="headerlink" title="1. SpringBootWeb快速入门"></a>1. SpringBootWeb快速入门</h2><h3 id="1-1-需求"><a href="#1-1-需求" class="headerlink" title="1.1 需求"></a>1.1 需求</h3><p>需求：基于SpringBoot的方式开发一个web应用，浏览器发起请求&#x2F;hello后，给浏览器返回字符串 “Hello World ~”。</p><p><img src="https://bu.dusays.com/2024/05/06/6638ec35a612f.png" alt="image-20220823191003444.png"></p><h3 id="1-2-开发步骤"><a href="#1-2-开发步骤" class="headerlink" title="1.2 开发步骤"></a>1.2 开发步骤</h3><p>第1步：创建SpringBoot工程项目</p><p>第2步：定义HelloController类，添加方法hello，并添加注解</p><p>第3步：测试运行</p><h4 id="1-2-1-创建SpringBoot工程（需要联网）"><a href="#1-2-1-创建SpringBoot工程（需要联网）" class="headerlink" title="1.2.1 创建SpringBoot工程（需要联网）"></a>1.2.1 创建SpringBoot工程（需要联网）</h4><p>基于Spring官方骨架，创建SpringBoot工程。</p><p><img src="https://bu.dusays.com/2024/05/06/6638ec3a10625.png" alt="image-20221201184702136.png"></p><p>基本信息描述完毕之后，勾选web开发相关依赖。</p><p><img src="https://bu.dusays.com/2024/05/06/6638ec3a319d2.png" alt="image-20221201184850248.png"></p><p>点击Finish之后，就会联网创建这个SpringBoot工程，创建好之后，结构如下：</p><ul><li>&#x3D;&#x3D;注意：在联网创建过程中，会下载相关资源(请耐心等待)&#x3D;&#x3D;</li></ul><p><img src="https://bu.dusays.com/2024/05/06/6638ec3a5796d.png" alt="image-20221201185910596.png"> </p><h4 id="1-2-2-定义请求处理类"><a href="#1-2-2-定义请求处理类" class="headerlink" title="1.2.2 定义请求处理类"></a>1.2.2 定义请求处理类</h4><p>在com.itheima这个包下创建一个子包controller</p><p><img src="https://bu.dusays.com/2024/05/06/6638ec3a5db43.png" alt="image-20221201190541295.png"></p><p>然后在controller包下新建一个类：HelloController</p><p><img src="https://bu.dusays.com/2024/05/06/6638ec3a98418.png" alt="image-20221201190825439.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World ~&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello World ~&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><h4 id="1-2-3-运行测试"><a href="#1-2-3-运行测试" class="headerlink" title="1.2.3 运行测试"></a>1.2.3 运行测试</h4><p>运行SpringBoot自动生成的引导类</p><p><img src="https://bu.dusays.com/2024/05/06/6638ec3af3b7e.png" alt="image-20221201191028124.png"> </p><p><img src="https://bu.dusays.com/2024/05/06/6638ec3b27b5e.png" alt="image-20221201191348924.png"> </p><p>打开浏览器，输入 <code>http://localhost:8080/hello</code></p><p><img src="https://bu.dusays.com/2024/05/06/6638ec35acefd.png" alt="image-20220823195048415.png"></p><h3 id="1-3-Web分析"><a href="#1-3-Web分析" class="headerlink" title="1.3 Web分析"></a>1.3 Web分析</h3><p><img src="https://bu.dusays.com/2024/05/06/6638ec3b47442.png" alt="image-20221201224603497.png"></p><p>浏览器：</p><ul><li><p>输入网址：<code>http://192.168.100.11:8080/hello</code></p><ul><li><p>通过IP地址192.168.100.11定位到网络上的一台计算机</p><blockquote><p>我们之前在浏览器中输入的localhost，就是127.0.0.1（本机）</p></blockquote></li><li><p>通过端口号8080找到计算机上运行的程序</p><blockquote><p><code>localhost:8080</code>  , 意思是在本地计算机中找到正在运行的8080端口的程序</p></blockquote></li><li><p>&#x2F;hello是请求资源位置</p><ul><li>资源：对计算机而言资源就是数据<ul><li>web资源：通过网络可以访问到的资源（通常是指存放在服务器上的数据）</li></ul></li></ul><blockquote><p><code>localhost:8080/hello</code> ，意思是向本地计算机中的8080端口程序，获取资源位置是&#x2F;hello的数据</p><ul><li>8080端口程序，在服务器找&#x2F;hello位置的资源数据，发给浏览器</li></ul></blockquote></li></ul></li></ul><p>服务器：（可以理解为ServerSocket）</p><ul><li>接收到浏览器发送的信息（如：&#x2F;hello）</li><li>在服务器上找到&#x2F;hello的资源</li><li>把资源发送给浏览器</li></ul><blockquote><p>我们在JavaSE阶段学习网络编程时，有讲过网络三要素：</p><ul><li>IP  ：网络中计算机的唯一标识</li><li>端口 ：计算机中运行程序的唯一标识</li><li>协议 ：网络中计算机之间交互的规则</li></ul><p><strong>问题：浏览器和服务器两端进行数据交互，使用什么协议？</strong></p><p><strong>答案：http协议</strong></p></blockquote><h2 id="2-HTTP协议"><a href="#2-HTTP协议" class="headerlink" title="2. HTTP协议"></a>2. HTTP协议</h2><h3 id="2-1-HTTP-概述"><a href="#2-1-HTTP-概述" class="headerlink" title="2.1 HTTP-概述"></a>2.1 HTTP-概述</h3><h4 id="2-1-1-介绍"><a href="#2-1-1-介绍" class="headerlink" title="2.1.1 介绍"></a>2.1.1 介绍</h4><p><img src="https://bu.dusays.com/2024/05/06/6638ec35ba8af.png" alt="image-20220823200024507.png"></p><p>HTTP：Hyper Text Transfer Protocol(超文本传输协议)，规定了浏览器与服务器之间数据传输的规则。</p><ul><li>http是互联网上应用最为广泛的一种网络协议 </li><li>http协议要求：浏览器在向服务器发送请求数据时，或是服务器在向浏览器发送响应数据时，都必须按照固定的格式进行数据传输</li></ul><p>如果想知道http协议的数据传输格式有哪些，可以打开浏览器，点击<code>F12</code>打开开发者工具，点击<code>Network</code>来查看</p><p><img src="https://bu.dusays.com/2024/05/06/6638ec3b81938.png" alt="image-20221202105735230.png"></p><p>浏览器向服务器进行请求时：</p><ul><li>服务器按照固定的格式进行解析</li></ul><p><img src="https://bu.dusays.com/2024/05/06/6638ec3b9ce51.png" alt="image-20221202111044434.png"></p><p>服务器向浏览器进行响应时：</p><ul><li>浏览器按照固定的格式进行解析</li></ul><p><img src="https://bu.dusays.com/2024/05/06/6638ec3be6710.png" alt="image-20221202111307819.png"></p><p><strong>所以，我们学习HTTP主要就是学习请求和响应数据的具体格式内容。</strong></p><h4 id="2-2-2-特点"><a href="#2-2-2-特点" class="headerlink" title="2.2.2 特点"></a>2.2.2 特点</h4><p>我们刚才初步认识了HTTP协议，那么我们在看看HTTP协议有哪些特点：</p><ul><li><p>**基于TCP协议: **   面向连接，安全</p><blockquote><p>TCP是一种面向连接的(建立连接之前是需要经过三次握手)、可靠的、基于字节流的传输层通信协议，在数据传输方面更安全</p></blockquote></li><li><p><strong>基于请求-响应模型:</strong>   一次请求对应一次响应（先请求后响应）</p><blockquote><p>请求和响应是一一对应关系，没有请求，就没有响应</p></blockquote></li><li><p><strong>HTTP协议是无状态协议:</strong>  对于数据没有记忆能力。每次请求-响应都是独立的</p><blockquote><p>无状态指的是客户端发送HTTP请求给服务端之后，服务端根据请求响应数据，响应完后，不会记录任何信息。</p><ul><li>缺点:  多次请求间不能共享数据</li><li>优点:  速度快</li></ul><p>请求之间无法共享数据会引发的问题：</p><ul><li>如：京东购物。加入购物车和去购物车结算是两次请求</li><li>由于HTTP协议的无状态特性，加入购物车请求响应结束后，并未记录加入购物车是何商品</li><li>发起去购物车结算的请求后，因为无法获取哪些商品加入了购物车，会导致此次请求无法正确展示数据</li></ul><p>具体使用的时候，我们发现京东是可以正常展示数据的，原因是Java早已考虑到这个问题，并提出了使用会话技术(Cookie、Session)来解决这个问题。具体如何来做，我们后面课程中会讲到。</p></blockquote><p>刚才提到HTTP协议是规定了请求和响应数据的格式，那具体的格式是什么呢?</p></li></ul><h3 id="2-2-HTTP-请求协议"><a href="#2-2-HTTP-请求协议" class="headerlink" title="2.2 HTTP-请求协议"></a>2.2 HTTP-请求协议</h3><p>浏览器和服务器是按照HTTP协议进行数据通信的。</p><p>HTTP协议又分为：请求协议和响应协议</p><ul><li>请求协议：浏览器将数据以请求格式发送到服务器<ul><li>包括：<strong>请求行</strong>、<strong>请求头</strong> 、<strong>请求体</strong></li></ul></li><li>响应协议：服务器将数据以响应格式返回给浏览器<ul><li>包括：<strong>响应行</strong> 、<strong>响应头</strong> 、<strong>响应体</strong></li></ul></li></ul><p>在HTTP1.1版本中，浏览器访问服务器的几种方式： </p><table><thead><tr><th align="center">请求方式</th><th align="left">请求说明</th></tr></thead><tbody><tr><td align="center"><strong>GET</strong></td><td align="left">获取资源。<br/>向特定的资源发出请求。例：<a href="http://www.baidu.com/s?wd=itheima">http://www.baidu.com/s?wd=itheima</a></td></tr><tr><td align="center"><strong>POST</strong></td><td align="left">传输实体主体。<br/>向指定资源提交数据进行处理请求（例：上传文件），数据被包含在请求体中。</td></tr><tr><td align="center">OPTIONS</td><td align="left">返回服务器针对特定资源所支持的HTTP请求方式。<br/>因为并不是所有的服务器都支持规定的方法，为了安全有些服务器可能会禁止掉一些方法，例如：DELETE、PUT等。那么OPTIONS就是用来询问服务器支持的方法。</td></tr><tr><td align="center">HEAD</td><td align="left">获得报文首部。<br/>HEAD方法类似GET方法，但是不同的是HEAD方法不要求返回数据。通常用于确认URI的有效性及资源更新时间等。</td></tr><tr><td align="center">PUT</td><td align="left">传输文件。<br/>PUT方法用来传输文件。类似FTP协议，文件内容包含在请求报文的实体中，然后请求保存到URL指定的服务器位置。</td></tr><tr><td align="center">DELETE</td><td align="left">删除文件。<br/>请求服务器删除Request-URI所标识的资源</td></tr><tr><td align="center">TRACE</td><td align="left">追踪路径。<br/>回显服务器收到的请求，主要用于测试或诊断</td></tr><tr><td align="center">CONNECT</td><td align="left">要求用隧道协议连接代理。<br/>HTTP&#x2F;1.1协议中预留给能够将连接改为管道方式的代理服务器</td></tr></tbody></table><p>在我们实际应用中常用的也就是 ：<strong>GET、POST</strong></p><p><strong>GET方式的请求协议：</strong></p><p><img src="https://bu.dusays.com/2024/05/06/6638ec35d58f1.png" alt="image-20220823200708026.png"> </p><ul><li><p>请求行 ：HTTP请求中的第一行数据。由：<code>请求方式</code>、<code>资源路径</code>、<code>协议/版本</code>组成（之间使用空格分隔）</p><ul><li>请求方式：GET  </li><li>资源路径：&#x2F;brand&#x2F;findAll?name&#x3D;OPPO&amp;status&#x3D;1<ul><li>请求路径：&#x2F;brand&#x2F;findAll</li><li>请求参数：name&#x3D;OPPO&amp;status&#x3D;1<ul><li>请求参数是以key&#x3D;value形式出现</li><li>多个请求参数之间使用<code>&amp;</code>连接</li></ul></li><li>请求路径和请求参数之间使用<code>?</code>连接</li></ul><p>  </p></li><li>协议&#x2F;版本：HTTP&#x2F;1.1</li></ul></li><li><p>请求头 ：第二行开始，上图黄色部分内容就是请求头。格式为key: value形式 </p><ul><li>http是个无状态的协议，所以在请求头设置浏览器的一些自身信息和想要响应的形式。这样服务器在收到信息后，就可以知道是谁，想干什么了</li></ul><p>常见的HTTP请求头有:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Host: 表示请求的主机名</span><br><span class="line"></span><br><span class="line">User-Agent: 浏览器版本。 例如：Chrome浏览器的标识类似Mozilla/5.0 ...Chrome/79 ，IE浏览器的标识类似Mozilla/5.0 (Windows NT ...)like Gecko</span><br><span class="line"></span><br><span class="line">Accept：表示浏览器能接收的资源类型，如text/*，image/*或者*/*表示所有；</span><br><span class="line"></span><br><span class="line">Accept-Language：表示浏览器偏好的语言，服务器可以据此返回不同语言的网页；</span><br><span class="line"></span><br><span class="line">Accept-Encoding：表示浏览器可以支持的压缩类型，例如gzip, deflate等。</span><br><span class="line"></span><br><span class="line">Content-Type：请求主体的数据类型</span><br><span class="line"></span><br><span class="line">Content-Length：数据主体的大小（单位：字节）</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>举例说明：服务端可以根据请求头中的内容来获取客户端的相关信息，有了这些信息服务端就可以处理不同的业务需求。</p><p>比如:</p><ul><li>不同浏览器解析HTML和CSS标签的结果会有不一致，所以就会导致相同的代码在不同的浏览器会出现不同的效果</li><li>服务端根据客户端请求头中的数据获取到客户端的浏览器类型，就可以根据不同的浏览器设置不同的代码来达到一致的效果（这就是我们常说的浏览器兼容问题）</li></ul></blockquote><ul><li>请求体 ：存储请求参数<ul><li>GET请求的请求参数在请求行中，故不需要设置请求体</li></ul></li></ul><p><strong>POST方式的请求协议：</strong></p><p><img src="https://bu.dusays.com/2024/05/06/6638ec3763bc3.png" alt="image-20220823201303601.png"></p><ul><li>请求行(以上图中红色部分)：包含请求方式、资源路径、协议&#x2F;版本<ul><li>请求方式：POST</li><li>资源路径：&#x2F;brand</li><li>协议&#x2F;版本：HTTP&#x2F;1.1</li></ul></li><li>请求头(以上图中黄色部分)   </li><li>请求体(以上图中绿色部分) ：存储请求参数 <ul><li>请求体和请求头之间是有一个空行隔开（作用：用于标记请求头结束）</li></ul></li></ul><p>GET请求和POST请求的区别：</p><table><thead><tr><th>区别方式</th><th>GET请求</th><th>POST请求</th></tr></thead><tbody><tr><td>请求参数</td><td>请求参数在请求行中。<br/>例：&#x2F;brand&#x2F;findAll?name&#x3D;OPPO&amp;status&#x3D;1</td><td>请求参数在请求体中</td></tr><tr><td>请求参数长度</td><td>请求参数长度有限制(浏览器不同限制也不同)</td><td>请求参数长度没有限制</td></tr><tr><td>安全性</td><td>安全性低。原因：请求参数暴露在浏览器地址栏中。</td><td>安全性相对高</td></tr></tbody></table><h3 id="2-3-HTTP-响应协议"><a href="#2-3-HTTP-响应协议" class="headerlink" title="2.3 HTTP-响应协议"></a>2.3 HTTP-响应协议</h3><h4 id="2-3-1-格式介绍"><a href="#2-3-1-格式介绍" class="headerlink" title="2.3.1 格式介绍"></a>2.3.1 格式介绍</h4><p>与HTTP的请求一样，HTTP响应的数据也分为3部分：<strong>响应行</strong>、<strong>响应头</strong> 、<strong>响应体</strong> </p><p><img src="https://bu.dusays.com/2024/05/06/6638ec37690c4.png" alt="image-20220823202344149.png"> </p><ul><li><p>响应行(以上图中红色部分)：响应数据的第一行。响应行由<code>协议及版本</code>、<code>响应状态码</code>、<code>状态码描述</code>组成</p><ul><li>协议&#x2F;版本：HTTP&#x2F;1.1</li><li>响应状态码：200</li><li>状态码描述：OK</li></ul></li><li><p>响应头(以上图中黄色部分)：响应数据的第二行开始。格式为key：value形式</p><ul><li>http是个无状态的协议，所以可以在请求头和响应头中设置一些信息和想要执行的动作，这样，对方在收到信息后，就可以知道你是谁，你想干什么</li></ul><p>常见的HTTP响应头有:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Content-Type：表示该响应内容的类型，例如text/html，image/jpeg ；</span><br><span class="line"></span><br><span class="line">Content-Length：表示该响应内容的长度（字节数）；</span><br><span class="line"></span><br><span class="line">Content-Encoding：表示该响应压缩算法，例如gzip ；</span><br><span class="line"></span><br><span class="line">Cache-Control：指示客户端应如何缓存，例如max-age=300表示可以最多缓存300秒 ;</span><br><span class="line"></span><br><span class="line">Set-Cookie: 告诉浏览器为当前页面所在的域设置cookie ;</span><br></pre></td></tr></table></figure></li></ul><ul><li>响应体(以上图中绿色部分)： 响应数据的最后一部分。存储响应的数据<ul><li>响应体和响应头之间有一个空行隔开（作用：用于标记响应头结束）</li></ul></li></ul><h4 id="2-3-2-响应状态码"><a href="#2-3-2-响应状态码" class="headerlink" title="2.3.2 响应状态码"></a>2.3.2 响应状态码</h4><table><thead><tr><th>状态码分类</th><th>说明</th></tr></thead><tbody><tr><td>1xx</td><td><strong>响应中</strong> — 临时状态码。表示请求已经接受，告诉客户端应该继续请求或者如果已经完成则忽略</td></tr><tr><td>2xx</td><td><strong>成功</strong> — 表示请求已经被成功接收，处理已完成</td></tr><tr><td>3xx</td><td><strong>重定向</strong> — 重定向到其它地方，让客户端再发起一个请求以完成整个处理</td></tr><tr><td>4xx</td><td><strong>客户端错误</strong> — 处理发生错误，责任在客户端，如：客户端的请求一个不存在的资源，客户端未被授权，禁止访问等</td></tr><tr><td>5xx</td><td><strong>服务器端错误</strong> — 处理发生错误，责任在服务端，如：服务端抛出异常，路由出错，HTTP版本不支持等</td></tr></tbody></table><p>参考: 资料&#x2F;SpringbootWeb&#x2F;响应状态码.md</p><p>关于响应状态码，我们先主要认识三个状态码，其余的等后期用到了再去掌握：</p><ul><li>200    ok   客户端请求成功</li><li>404  Not Found  请求资源不存在</li><li>500  Internal Server Error  服务端发生不可预期的错误</li></ul><h3 id="2-4-HTTP-协议解析"><a href="#2-4-HTTP-协议解析" class="headerlink" title="2.4 HTTP-协议解析"></a>2.4 HTTP-协议解析</h3><p>将资料中准备好的Demo工程，导入到我们的IDEA中，有一个Server.java类，这里面就是自定义的一个服务器代码，主要使用到的是<code>ServerSocket</code>和<code>Socket</code></p><blockquote><p>&#x3D;&#x3D;说明：以下代码大家不需要自己写，我们主要是通过代码，让大家了解到服务器针对HTTP协议的解析机制&#x3D;&#x3D;</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 自定义web服务器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8080</span>); <span class="comment">// 监听指定端口</span></span><br><span class="line">        System.out.println(<span class="string">&quot;server is running...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">sock</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">            System.out.println(<span class="string">&quot;connected from &quot;</span> + sock.getRemoteSocketAddress());</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Handler</span>(sock);</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Handler</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    Socket sock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(Socket sock)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sock = sock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="built_in">this</span>.sock.getInputStream();</span><br><span class="line">             <span class="type">OutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="built_in">this</span>.sock.getOutputStream()) &#123;</span><br><span class="line">                handle(input, output);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.sock.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;client disconnected.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(InputStream input, OutputStream output)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(input, StandardCharsets.UTF_8));</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(output, StandardCharsets.UTF_8));</span><br><span class="line">        <span class="comment">// 读取HTTP请求:</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">requestOk</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> reader.readLine();</span><br><span class="line">        <span class="keyword">if</span> (first.startsWith(<span class="string">&quot;GET / HTTP/1.&quot;</span>)) &#123;</span><br><span class="line">            requestOk = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">header</span> <span class="operator">=</span> reader.readLine();</span><br><span class="line">            <span class="keyword">if</span> (header.isEmpty()) &#123; <span class="comment">// 读取到空行时, HTTP Header读取完毕</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(header);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(requestOk ? <span class="string">&quot;Response OK&quot;</span> : <span class="string">&quot;Response Error&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!requestOk) &#123;<span class="comment">// 发送错误响应:</span></span><br><span class="line">            writer.write(<span class="string">&quot;HTTP/1.0 404 Not Found\r\n&quot;</span>);</span><br><span class="line">            writer.write(<span class="string">&quot;Content-Length: 0\r\n&quot;</span>);</span><br><span class="line">            writer.write(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">            writer.flush();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">// 发送成功响应:</span></span><br><span class="line">            <span class="comment">//读取html文件，转换为字符串</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Server.class.getClassLoader().getResourceAsStream(<span class="string">&quot;html/a.html&quot;</span>);</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is));</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">                data.append(line);</span><br><span class="line">            &#125;</span><br><span class="line">            br.close();</span><br><span class="line">            <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> data.toString().getBytes(StandardCharsets.UTF_8).length;</span><br><span class="line"></span><br><span class="line">            writer.write(<span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span>);</span><br><span class="line">            writer.write(<span class="string">&quot;Connection: keep-alive\r\n&quot;</span>);</span><br><span class="line">            writer.write(<span class="string">&quot;Content-Type: text/html\r\n&quot;</span>);</span><br><span class="line">            writer.write(<span class="string">&quot;Content-Length: &quot;</span> + length + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">            writer.write(<span class="string">&quot;\r\n&quot;</span>); <span class="comment">// 空行标识Header和Body的分隔</span></span><br><span class="line">            writer.write(data.toString());</span><br><span class="line">            writer.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>启动ServerSocket程序：</p><p><img src="https://bu.dusays.com/2024/05/06/6638ec3c4eeef.png" alt="image-20221202170430928.png"></p><p>浏览器输入：<code>http://localhost:8080</code>  就会访问到ServerSocket程序 </p><ul><li>ServerSocket程序，会读取服务器上<code>html/a.html</code>文件，并把文件数据发送给浏览器</li><li>浏览器接收到a.html文件中的数据后进行解析，显示以下内容</li></ul><p><img src="https://bu.dusays.com/2024/05/06/6638ec3c4d9b1.png" alt="image-20221202171204705.png"> </p><p>现在大家知道了服务器是可以使用java完成编写，是可以接受页面发送的请求和响应数据给前端浏览器的，而在开发中真正用到的Web服务器，我们不会自己写的，都是使用目前比较流行的web服务器。如：<strong>Tomcat</strong></p><p><img src="https://bu.dusays.com/2024/05/06/6638ec37887d0.png" alt="image-20220824233452167.png"> </p><h2 id="3-WEB服务器-Tomcat"><a href="#3-WEB服务器-Tomcat" class="headerlink" title="3. WEB服务器-Tomcat"></a>3. WEB服务器-Tomcat</h2><h3 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1 简介"></a>3.1 简介</h3><h4 id="3-1-1-服务器概述"><a href="#3-1-1-服务器概述" class="headerlink" title="3.1.1 服务器概述"></a>3.1.1 服务器概述</h4><p><strong>服务器硬件</strong></p><ul><li>指的也是计算机，只不过服务器要比我们日常使用的计算机大很多。</li></ul><p><img src="https://bu.dusays.com/2024/05/06/6638ec3ccfb8b.png" alt="image-20221202173148317.png"> </p><p>服务器，也称伺服器。是提供计算服务的设备。由于服务器需要响应服务请求，并进行处理，因此一般来说服务器应具备承担服务并且保障服务的能力。</p><p>服务器的构成包括处理器、硬盘、内存、系统总线等，和通用的计算机架构类似，但是由于需要提供高可靠的服务，因此在处理能力、稳定性、可靠性、安全性、可扩展性、可管理性等方面要求较高。</p><p>在网络环境下，根据服务器提供的服务类型不同，可分为：文件服务器，数据库服务器，应用程序服务器，WEB服务器等。</p><p>服务器只是一台设备，必须安装服务器软件才能提供相应的服务。</p><p><strong>服务器软件</strong></p><p>服务器软件：基于ServerSocket编写的程序</p><ul><li>服务器软件本质是一个运行在服务器设备上的应用程序</li><li>能够接收客户端请求，并根据请求给客户端响应数据</li></ul><p><img src="https://bu.dusays.com/2024/05/06/6638ec3581d68.png" alt="1530625192392.png"></p><h4 id="3-1-2-Web服务器"><a href="#3-1-2-Web服务器" class="headerlink" title="3.1.2 Web服务器"></a>3.1.2 Web服务器</h4><p>Web服务器是一个应用程序(软件)，对HTTP协议的操作进行封装，使得程序员不必直接对协议进行操作(不用程序员自己写代码去解析http协议规则)，让Web开发更加便捷。主要功能是”提供网上信息浏览服务”。</p><p><img src="https://bu.dusays.com/2024/05/06/6638ec379bba9.png" alt="image-20220824233614686.png"></p><p>Web服务器是安装在服务器端的一款软件，将来我们把自己写的Web项目部署到Tomcat服务器软件中，当Web服务器软件启动后，部署在Web服务器软件中的页面就可以直接通过浏览器来访问了。</p><p><strong>Web服务器软件使用步骤</strong></p><ul><li>准备静态资源</li><li>下载安装Web服务器软件</li><li>将静态资源部署到Web服务器上</li><li>启动Web服务器使用浏览器访问对应的资源</li></ul><p>第1步：准备静态资源</p><ul><li>在提供的资料中找到静态资源文件</li></ul><p><img src="https://bu.dusays.com/2024/05/06/6638ec3cb9cc1.png" alt="image-20221202180119859.png"> </p><p>第2步：下载安装Web服务器软件</p><p><img src="https://bu.dusays.com/2024/05/06/6638ec3d24800.png" alt="image-20221202181110555.png"></p><p>第3步：将静态资源部署到Web服务器上</p><p><img src="https://bu.dusays.com/2024/05/06/6638ec3d0785d.png" alt="image-20221202180805686.png"></p><p>第4步：启动Web服务器使用浏览器访问对应的资源</p><p><img src="https://bu.dusays.com/2024/05/06/6638ec3d56baf.png" alt="image-20221202181346327.png"></p><p>浏览器输入：<code>http://localhost:8080/demo/index.html</code></p><p><img src="https://bu.dusays.com/2024/05/06/6638ec3d952b5.png" alt="image-20221202181651469.png"></p><p>上述内容在演示的时候，使用的是Apache下的Tomcat软件，至于Tomcat软件如何使用，后面会详细的讲到。而对于Web服务器来说，实现的方案有很多，Tomcat只是其中的一种，而除了Tomcat以外，还有很多优秀的Web服务器，比如:</p><p><img src="https://bu.dusays.com/2024/05/06/6638ec382db0f.png" alt="image-20220824233728524.png"> </p><p>Tomcat就是一款软件，我们主要是以学习如何去使用为主。具体我们会从以下这些方向去学习:</p><ol><li><p>简介：初步认识下Tomcat</p></li><li><p>基本使用: 安装、卸载、启动、关闭、配置和项目部署，这些都是对Tomcat的基本操作</p></li><li><p>IDEA中如何创建Maven Web项目</p></li><li><p>IDEA中如何使用Tomcat,后面这两个都是我们以后开发经常会用到的方式</p></li></ol><p>首选我们来认识下Tomcat。</p><h4 id="3-1-3-Tomcat"><a href="#3-1-3-Tomcat" class="headerlink" title="3.1.3 Tomcat"></a>3.1.3 Tomcat</h4><p>Tomcat服务器软件是一个免费的开源的web应用服务器。是Apache软件基金会的一个核心项目。由Apache，Sun和其他一些公司及个人共同开发而成。</p><p>由于Tomcat只支持Servlet&#x2F;JSP少量JavaEE规范，所以是一个开源免费的轻量级Web服务器。</p><blockquote><p>JavaEE规范：   JavaEE &#x3D;&gt; Java Enterprise Edition(Java企业版)</p><p>avaEE规范就是指Java企业级开发的技术规范总和。包含13项技术规范：JDBC、JNDI、EJB、RMI、JSP、Servlet、XML、JMS、Java IDL、JTS、JTA、JavaMail、JAF</p></blockquote><p>因为Tomcat支持Servlet&#x2F;JSP规范，所以Tomcat也被称为Web容器、Servlet容器。JavaWeb程序需要依赖Tomcat才能运行。</p><p>Tomcat的官网: <a href="https://tomcat.apache.org/">https://tomcat.apache.org/</a> </p><p><img src="https://bu.dusays.com/2024/05/06/6638ec3825775.png" alt="image-20220824233903517.png"> </p><h3 id="3-2-基本使用"><a href="#3-2-基本使用" class="headerlink" title="3.2 基本使用"></a>3.2 基本使用</h3><h4 id="3-2-1-下载"><a href="#3-2-1-下载" class="headerlink" title="3.2.1 下载"></a>3.2.1 下载</h4><p>直接从官方网站下载：<a href="https://tomcat.apache.org/download-90.cgi">https://tomcat.apache.org/download-90.cgi</a></p><p><img src="https://bu.dusays.com/2024/05/06/6638ec382ec31.png" alt="image-20220824234407828.png"></p><blockquote><p>Tomcat软件类型说明：</p><ul><li>tar.gz文件，是linux和mac操作系统下的压缩版本</li><li>zip文件，是window操作系统下压缩版本（我们选择zip文件）</li></ul></blockquote><p>大家可以自行下载，也可以直接使用资料中已经下载好的资源，</p><p>Tomcat的软件程序  ：&#x2F;资料&#x2F;SpringbootWeb&#x2F;apache-tomcat-9.0.27-windows-x64.zip</p><p><img src="https://bu.dusays.com/2024/05/06/6638ec38189f4.png" alt="image-20220824234527743.png"> </p><h4 id="3-2-2-安装与卸载"><a href="#3-2-2-安装与卸载" class="headerlink" title="3.2.2 安装与卸载"></a>3.2.2 安装与卸载</h4><p><strong>安装:</strong> Tomcat是绿色版，直接解压即安装</p><blockquote><p>在E盘的develop目录下，将<code>apache-tomcat-9.0.27-windows-x64.zip</code>进行解压缩，会得到一个<code>apache-tomcat-9.0.27</code>的目录，Tomcat就已经安装成功。</p></blockquote><p><img src="https://bu.dusays.com/2024/05/06/6638ec3e584d4.png" alt="image-20221202184545321.png"></p><p>&#x3D;&#x3D;注意，Tomcat在解压缩的时候，解压所在的目录可以任意，但最好解压到一个不包含中文和空格的目录，因为后期在部署项目的时候，如果路径有中文或者空格可能会导致程序部署失败。&#x3D;&#x3D;</p><p>打开<code>apache-tomcat-9.0.27</code>目录就能看到如下目录结构，每个目录中包含的内容需要认识下</p><p><img src="https://bu.dusays.com/2024/05/06/6638ec383fd51.png" alt="image-20220824234652173.png">  </p><p>bin：目录下有两类文件，一种是以<code>.bat</code>结尾的，是Windows系统的可执行文件，一种是以<code>.sh</code>结尾的，是Linux系统的可执行文件。</p><p>webapps：就是以后项目部署的目录</p><p><strong>卸载：</strong>卸载比较简单，可以直接删除目录即可</p><h4 id="3-2-3-启动与关闭"><a href="#3-2-3-启动与关闭" class="headerlink" title="3.2.3 启动与关闭"></a>3.2.3 启动与关闭</h4><p><strong>启动Tomcat</strong> </p><ul><li>双击tomcat解压目录&#x2F;bin&#x2F;<strong>startup.bat</strong>文件即可启动tomcat</li></ul><p><img src="https://bu.dusays.com/2024/05/06/6638ec3d995e1.png" alt="image-20221202183201663.png"></p><p>&#x3D;&#x3D;注意: tomcat服务器启动后,黑窗口不会关闭,只要黑窗口不关闭,就证明tomcat服务器正在运行&#x3D;&#x3D;</p><p><img src="https://bu.dusays.com/2024/05/06/6638ec3e0531b.png" alt="image-20221202183409304.png"></p><p>Tomcat的默认端口为8080，所以在浏览器的地址栏输入：<code>http://127.0.0.1:8080</code> 即可访问tomcat服务器</p><blockquote><p>127.0.0.1 也可以使用localhost代替。如：<code>http://localhost:8080</code></p></blockquote><p><img src="https://bu.dusays.com/2024/05/06/6638ec3e61442.png" alt="image-20221202183550682.png"></p><ul><li>能看到以上图片中Apache Tomcat的内容就说明Tomcat已经启动成功</li></ul><p>&#x3D;&#x3D;注意事项&#x3D;&#x3D; ：Tomcat启动的过程中，遇到控制台有中文乱码时，可以通常修改conf&#x2F;logging.prooperties文件解决</p><p><img src="https://bu.dusays.com/2024/05/06/6638ec384e3b7.png" alt="image-20220825083848086.png"> </p><p><strong>关闭:</strong>  关闭有三种方式 </p><p>1、强制关闭：直接x掉Tomcat窗口（不建议）</p><p><img src="https://bu.dusays.com/2024/05/06/6638ec3ea2fb6.png" alt="image-20221202184753808.png"></p><p>2、正常关闭：bin\shutdown.bat</p><p><img src="https://bu.dusays.com/2024/05/06/6638ec3eb6509.png" alt="image-20221202185103941.png"></p><p>3、正常关闭：在Tomcat启动窗口中按下 Ctrl+C</p><ul><li>说明：如果按下Ctrl+C没有反映，可以多按几次</li></ul><h4 id="3-2-4-常见问题"><a href="#3-2-4-常见问题" class="headerlink" title="3.2.4 常见问题"></a>3.2.4 常见问题</h4><p><strong>问题1：Tomcat启动时，窗口一闪而过</strong></p><ul><li>检查JAVA_HOME环境变量是否正确配置</li></ul><p><img src="https://bu.dusays.com/2024/05/06/6638ec3f04cc2.png" alt="image-20221202190033167.png"></p><p><strong>问题2：端口号冲突</strong></p><p><img src="https://bu.dusays.com/2024/05/06/6638ec393de45.png" alt="image-20220825084104447.png"></p><ul><li><p>发生问题的原因：Tomcat使用的端口被占用了。</p></li><li><p>解决方案：换Tomcat端口号</p><ul><li>要想修改Tomcat启动的端口号，需要修改 conf&#x2F;server.xml文件</li></ul></li></ul><p><img src="https://bu.dusays.com/2024/05/06/6638ec391f943.png" alt="image-20220825084017185.png"> </p><blockquote><p>注: HTTP协议默认端口号为80，如果将Tomcat端口号改为80，则将来访问Tomcat时，将不用输入端口号。</p></blockquote><h3 id="3-3-入门程序解析"><a href="#3-3-入门程序解析" class="headerlink" title="3.3 入门程序解析"></a>3.3 入门程序解析</h3><p>关于web开发的基础知识，我们可以告一段落了。下面呢，我们在基于今天的核心技术点SpringBoot快速入门案例进行分析。</p><h4 id="3-3-1-Spring官方骨架"><a href="#3-3-1-Spring官方骨架" class="headerlink" title="3.3.1 Spring官方骨架"></a>3.3.1 Spring官方骨架</h4><p>之前我们创建的SpringBoot入门案例，是基于Spring官方提供的骨架实现的。</p><p>Spring官方骨架，可以理解为Spring官方为程序员提供一个搭建项目的模板。</p><p><img src="https://bu.dusays.com/2024/05/06/6638ec3f0c866.png" alt="image-20221202195646621.png"></p><p>我们可以通过访问：<a href="https://start.spring.io/">https://start.spring.io/</a> ，进入到官方骨架页面</p><p><img src="https://bu.dusays.com/2024/05/06/6638ec4066af2.png" alt="image-20221202201623424.png"></p><p><img src="https://bu.dusays.com/2024/05/06/6638ec3f4cd6b.png" alt="image-20221202200356398.png"></p><p><img src="https://bu.dusays.com/2024/05/06/6638ec3f6d7eb.png" alt="image-20221202200547676.png"></p><p><img src="https://bu.dusays.com/2024/05/06/6638ec3f927e8.png" alt="image-20221202200708988.png"></p><p>Spring官方生成的SpringBoot项目，怎么使用呢？</p><ul><li>解压缩后，就会得到一个SpringBoot项目工程</li></ul><p><img src="https://bu.dusays.com/2024/05/06/6638ec3fc44f7.png" alt="image-20221202201042109.png"></p><p><img src="https://bu.dusays.com/2024/05/06/6638ec402db48.png" alt="image-20221202201221136.png"></p><p>打开pom.xml文件，我们可以看到springboot项目中引入了web依赖和test依赖</p><p><img src="https://bu.dusays.com/2024/05/06/6638ec408082c.png" alt="image-20221202201826364.png"></p><blockquote><p><strong>结论：不论使用IDEA创建SpringBoot项目，还是直接在官方网站利用骨架生成SpringBoot项目，项目的结构和pom.xml文件中内容是相似的。</strong></p></blockquote><h4 id="3-3-2-起步依赖"><a href="#3-3-2-起步依赖" class="headerlink" title="3.3.2 起步依赖"></a>3.3.2 起步依赖</h4><p>在我们之前讲解的SpringBoot快速入门案例中，同样也引用了：web依赖和test依赖</p><p><img src="https://bu.dusays.com/2024/05/06/6638ec40b05c1.png" alt="image-20221202202305118.png"></p><p>spring-boot-starter-web和spring-boot-starter-test，在SpringBoot中又称为：起步依赖</p><p>而在SpringBoot的项目中，有很多的起步依赖，他们有一个共同的特征：就是以<code>spring-boot-starter-</code>作为开头。在以后大家遇到spring-boot-starter-xxx这类的依赖，都为起步依赖。</p><p>起步依赖有什么特殊之处呢，这里我们以入门案例中引入的起步依赖做为讲解：</p><ul><li>spring-boot-starter-web：包含了web应用开发所需要的常见依赖</li><li>spring-boot-starter-test：包含了单元测试所需要的常见依赖</li></ul><blockquote><p><strong>spring-boot-starter-web</strong>内部把关于Web开发所有的依赖都已经导入并且指定了版本，只需引入 <code>spring-boot-starter-web</code> 依赖就可以实现Web开发的需要的功能</p><p><img src="https://bu.dusays.com/2024/05/06/6638ec40f27d5.png" alt="image-20221202204013113.png"></p></blockquote><p>Spring的官方提供了很多现成的starter(起步依赖)，我们在开发相关应用时，只需要引入对应的starter即可。</p><p>官方地址：<a href="https://docs.spring.io/spring-boot/docs/2.7.2/reference/htmlsingle/#using.build-systems.starters">https://docs.spring.io/spring-boot/docs/2.7.2/reference/htmlsingle/#using.build-systems.starters</a></p><p><img src="https://bu.dusays.com/2024/05/06/6638ec41181d5.png" alt="image-20221202204536647.png"></p><p>每一个起步依赖，都用于开发一个特定的功能。</p><blockquote><p>举例：当我们开发中需要使用redis数据库时，只需要在SpringBoot项目中，引入：spring-boot-starter-redis ，即可导入redis开发所需要的依赖。</p></blockquote><h4 id="3-3-2-SpringBoot父工程"><a href="#3-3-2-SpringBoot父工程" class="headerlink" title="3.3.2 SpringBoot父工程"></a>3.3.2 SpringBoot父工程</h4><p>在我们之前开发的SpringBoot入门案例中，我们通过maven引入的依赖，是没有指定具体的依赖版本号的。</p><p><img src="https://bu.dusays.com/2024/05/06/6638ec4156e29.png" alt="image-20221202205103486.png"></p><p>为什么没有指定<version>版本号，可以正常使用呢？</p><ul><li>因为每一个SpringBoot工程，都有一个父工程。依赖的版本号，在父工程中统一管理。</li></ul><p><img src="https://bu.dusays.com/2024/05/06/6638ec4187bd8.png" alt="image-20221202205318778.png"></p><h4 id="3-3-3-内嵌Tomcat"><a href="#3-3-3-内嵌Tomcat" class="headerlink" title="3.3.3 内嵌Tomcat"></a>3.3.3 内嵌Tomcat</h4><p>问题：为什么我们之前书写的SpringBoot入门程序中，并没有把程序部署到Tomcat的webapps目录下，也可以运行呢？</p><p>原因呢，是因为在我们的SpringBoot中，引入了web运行环境(也就是引入spring-boot-starter-web起步依赖)，其内部已经集成了内置的Tomcat服务器。</p><p>我们可以通过IDEA开发工具右侧的maven面板中，就可以看到当前工程引入的依赖。其中已经将Tomcat的相关依赖传递下来了，也就是说在SpringBoot中可以直接使用Tomcat服务器。</p><p><img src="https://bu.dusays.com/2024/05/06/6638ec397cb98.png" alt="image-20220825194553137.png"> </p><p>当我们运行SpringBoot的引导类时(运行main方法)，就会看到命令行输出的日志，其中占用8080端口的就是Tomcat。</p><p><img src="https://bu.dusays.com/2024/05/06/6638ec39aed0d.png" alt="image-20220825195359993.png"></p>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven入门</title>
      <link href="/posts/c6e613d8.html"/>
      <url>/posts/c6e613d8.html</url>
      
        <content type="html"><![CDATA[<h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><blockquote><ol><li>初识Maven</li><li>Maven概述<ul><li>Maven模型介绍</li><li>Maven仓库介绍</li><li>Maven安装与配置</li></ul></li><li>IDEA集成Maven</li><li>依赖管理</li></ol></blockquote><h2 id="01-Maven课程介绍"><a href="#01-Maven课程介绍" class="headerlink" title="01. Maven课程介绍"></a>01. Maven课程介绍</h2><h3 id="1-1-课程安排"><a href="#1-1-课程安排" class="headerlink" title="1.1 课程安排"></a>1.1 课程安排</h3><p>学习完前端Web开发技术后，我们即将开始学习后端Web开发技术。做为一名Java开发工程师，<strong>后端Web开发技术是我们学习的重点</strong>。</p><p><img src="https://bu.dusays.com/2024/05/05/6637a999c4207.png" alt="image-20221130095316032.png"></p><p>后端Web开发技术的学习，我们会先学习Java项目的构建工具：Maven</p><h3 id="1-2-初识Maven"><a href="#1-2-初识Maven" class="headerlink" title="1.2 初识Maven"></a>1.2 初识Maven</h3><h4 id="1-2-1-什么是Maven"><a href="#1-2-1-什么是Maven" class="headerlink" title="1.2.1 什么是Maven"></a>1.2.1 什么是Maven</h4><p>Maven是Apache旗下的一个开源项目，是一款用于管理和构建java项目的工具。</p><p>官网：<a href="https://maven.apache.org/">https://maven.apache.org/</a></p><blockquote><p>Apache 软件基金会，成立于1999年7月，是目前世界上最大的最受欢迎的开源软件基金会，也是一个专门为支持开源项目而生的非盈利性组织。</p><p>开源项目：<a href="https://www.apache.org/index.html#projects-list">https://www.apache.org/index.html#projects-list</a></p></blockquote><h4 id="1-2-2-Maven的作用"><a href="#1-2-2-Maven的作用" class="headerlink" title="1.2.2 Maven的作用"></a>1.2.2 Maven的作用</h4><p>使用Maven能够做什么呢？</p><ol><li>依赖管理</li><li>统一项目结构</li><li>项目构建</li></ol><p><strong>依赖管理</strong>：</p><ul><li>方便快捷的管理项目依赖的资源(jar包)，避免版本冲突问题</li></ul><p><img src="https://bu.dusays.com/2024/05/05/6637a99c01226.png" alt="image-20221130104014162.png"></p><p>当使用maven进行项目依赖(jar包)管理，则很方便的可以解决这个问题。 我们只需要在maven项目的pom.xml文件中，添加一段如下图所示的配置即可实现。</p><p><img src="https://bu.dusays.com/2024/05/05/6637a995e87dc.png" alt="image-20220616001159531.png">  </p><p>**统一项目结构 : **</p><ul><li>提供标准、统一的项目结构</li></ul><p>在项目开发中，当你使用不同的开发工具 (如：Eclipse、Idea)，创建项目工程时：</p><p><img src="https://bu.dusays.com/2024/05/05/6637a99b6930e.png" alt="image-20221130212841973.png"> </p><p>若我们创建的是一个maven工程，是可以帮我们自动生成统一、标准的项目目录结构：</p><p><img src="https://bu.dusays.com/2024/05/05/6637a99c5eaab.png" alt="image-20221130220539444.png"></p><p>具体的统一结构如下：</p><p><img src="https://bu.dusays.com/2024/05/05/6637a99b13ee0.png" alt="image-20221130140132209.png"></p><blockquote><p>目录说明： </p><ul><li>src&#x2F;main&#x2F;java: java源代码目录</li><li>src&#x2F;main&#x2F;resources:  配置文件信息</li><li>src&#x2F;test&#x2F;java: 测试代码</li><li>src&#x2F;test&#x2F;resources: 测试配置文件信息</li></ul></blockquote><p><strong>项目构建 :</strong> </p><ul><li>maven提供了标准的、跨平台(Linux、Windows、MacOS) 的自动化项目构建方式</li></ul><p><img src="https://bu.dusays.com/2024/05/05/6637a99b29859.png" alt="image-20221130140247524.png"></p><p>如上图所示我们开发了一套系统，代码需要进行编译、测试、打包、发布，这些操作如果需要反复进行就显得特别麻烦，而Maven提供了一套简单的命令来完成项目构建。</p><p><img src="https://bu.dusays.com/2024/05/05/6637a99cdc7b4.png" alt="image-20221130222907628.png"></p><p>综上所述，可以得到一个结论：<strong>Maven是一款管理和构建java项目的工具</strong></p><h2 id="02-Maven概述"><a href="#02-Maven概述" class="headerlink" title="02. Maven概述"></a>02. Maven概述</h2><h3 id="2-1-Maven介绍"><a href="#2-1-Maven介绍" class="headerlink" title="2.1 Maven介绍"></a>2.1 Maven介绍</h3><p>Apache Maven是一个项目管理和构建工具，它基于项目对象模型(Project Object Model , 简称: POM)的概念，通过一小段描述信息来管理项目的构建、报告和文档。</p><p>官网：<a href="https://maven.apache.org/">https://maven.apache.org/</a></p><p>Maven的作用： </p><ol><li>方便的依赖管理</li><li>统一的项目结构</li><li>标准的项目构建流程</li></ol><h3 id="2-2-Maven模型"><a href="#2-2-Maven模型" class="headerlink" title="2.2 Maven模型"></a>2.2 Maven模型</h3><ul><li>项目对象模型 (Project Object Model)</li><li>依赖管理模型(Dependency)</li><li>构建生命周期&#x2F;阶段(Build lifecycle &amp; phases)</li></ul><p>1). 构建生命周期&#x2F;阶段(Build lifecycle &amp; phases)</p><p><img src="https://bu.dusays.com/2024/05/05/6637a99c636d5.png" alt="image-20221130142100703.png"></p><p>以上图中紫色框起来的部分，就是用来完成标准化构建流程 。当我们需要编译，Maven提供了一个编译插件供我们使用；当我们需要打包，Maven就提供了一个打包插件供我们使用等。 </p><p>2). 项目对象模型 (Project Object Model)</p><p><img src="https://bu.dusays.com/2024/05/06/6637b79933fb9.png" alt="image-20221130142643255.png"></p><p>以上图中紫色框起来的部分属于项目对象模型，就是将我们自己的项目抽象成一个对象模型，有自己专属的坐标，如下图所示是一个Maven项目：</p><p><img src="https://bu.dusays.com/2024/05/05/6637a99613ec9.png" alt="image-20220616094113852.png"></p><blockquote><p>坐标，就是资源(jar包)的唯一标识，通过坐标可以定位到所需资源(jar包)位置</p><p><img src="https://bu.dusays.com/2024/05/05/6637a99d04c87.png" alt="image-20221130230134757.png"></p></blockquote><p>3). 依赖管理模型(Dependency)</p><p><img src="https://bu.dusays.com/2024/05/05/6637a99ada029.png" alt="image-20221130143139644.png"></p><p>以上图中紫色框起来的部分属于依赖管理模型，是使用坐标来描述当前项目依赖哪些第三方jar包</p><p><img src="https://bu.dusays.com/2024/05/05/6637a99bc18cd.png" alt="image-20221130174805973.png"></p><p>之前我们项目中需要jar包时，直接就把jar包复制到项目下的lib目录，而现在书写在pom.xml文件中的坐标又是怎么能找到所要的jar包文件的呢？</p><blockquote><p>答案：Maven仓库</p></blockquote><h3 id="2-3-Maven仓库"><a href="#2-3-Maven仓库" class="headerlink" title="2.3 Maven仓库"></a>2.3 Maven仓库</h3><p>仓库：用于存储资源，管理各种jar包</p><blockquote><p>仓库的本质就是一个目录(文件夹)，这个目录被用来存储开发中所有依赖(就是jar包)和插件</p></blockquote><p>Maven仓库分为：</p><ul><li>本地仓库：自己计算机上的一个目录(用来存储jar包)</li><li>中央仓库：由Maven团队维护的全球唯一的。仓库地址：<a href="https://repo1.maven.org/maven2/">https://repo1.maven.org/maven2/</a></li><li>远程仓库(私服)：一般由公司团队搭建的私有仓库</li></ul><p><img src="https://bu.dusays.com/2024/05/05/6637a9961f73b.png" alt="image-20220616095633552.png"></p><p>当项目中使用坐标引入对应依赖jar包后，首先会查找本地仓库中是否有对应的jar包</p><ul><li><p>如果有，则在项目直接引用</p></li><li><p>如果没有，则去中央仓库中下载对应的jar包到本地仓库</p></li></ul><p>如果还可以搭建远程仓库(私服)，将来jar包的查找顺序则变为： 本地仓库 –&gt; 远程仓库–&gt; 中央仓库</p><h3 id="2-4-Maven安装"><a href="#2-4-Maven安装" class="headerlink" title="2.4 Maven安装"></a>2.4 Maven安装</h3><p>认识了Maven后，我们就要开始使用Maven了，那么首先我们要进行Maven的下载与安装。</p><h4 id="2-4-1-下载"><a href="#2-4-1-下载" class="headerlink" title="2.4.1 下载"></a>2.4.1 下载</h4><p>下载地址：<a href="https://maven.apache.org/download.cgi">https://maven.apache.org/download.cgi</a></p><p>在提供的资料中，已经提供了下载好的安装包。如下： </p><p><img src="https://bu.dusays.com/2024/05/05/6637a99616400.png" alt="image-20220616100211209.png"> </p><h4 id="2-4-2-安装步骤"><a href="#2-4-2-安装步骤" class="headerlink" title="2.4.2 安装步骤"></a>2.4.2 安装步骤</h4><p>Maven安装配置步骤：</p><ol><li>解压安装</li><li>配置仓库</li><li>配置Maven环境变量</li></ol><p><strong>1、解压 apache-maven-3.6.1-bin.zip（解压即安装）</strong></p><blockquote><p>建议解压到没有中文、特殊字符的路径下。如课程中解压到 <code>E:\develop</code> 下。</p></blockquote><p><img src="https://bu.dusays.com/2024/05/05/6637a994a9012.gif" alt="1-1669821012006.gif"> </p><p>解压缩后的目录结构如下：</p><p><img src="https://bu.dusays.com/2024/05/05/6637a99658066.png" alt="image-20220616100529868-1669794069698.png"> </p><ul><li>bin目录 ： 存放的是可执行命令。（mvn 命令重点关注）</li><li>conf目录 ：存放Maven的配置文件。（settings.xml配置文件后期需要修改）</li><li>lib目录 ：存放Maven依赖的jar包。（Maven也是使用java开发的，所以它也依赖其他的jar包）</li></ul><p><strong>2、配置本地仓库</strong></p><p>2.1、在自己计算机上新一个目录（本地仓库，用来存储jar包）</p><p><img src="https://bu.dusays.com/2024/05/05/6637a99cd4daf.png" alt="image-20221130231857537.png"> </p><p>2.2、进入到conf目录下修改settings.xml配置文件 </p><p>1). 使用超级记事本软件，打开settings.xml文件，定位到53行</p><p>2). 复制<localRepository>标签，粘贴到注释的外面（55行）</p><p>3). 复制之前新建的用来存储jar包的路径，替换掉<localRepository>标签体内容</p><p><img src="https://bu.dusays.com/2024/05/05/6637a9950bee0.gif" alt="2.gif"></p><p><strong>3、配置阿里云私服</strong></p><p>由于中央仓库在国外，所以下载jar包速度可能比较慢，而阿里公司提供了一个远程仓库，里面基本也都有开源项目的jar包。</p><p>进入到conf目录下修改settings.xml配置文件：</p><p>1). 使用超级记事本软件，打开settings.xml文件，定位到160行左右</p><p>2). 在<mirrors>标签下为其添加子标签<mirror>，内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span>          </span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/05/6637a995aa736.gif" alt="3.gif"></p><p>注意配置的位置，在<mirrors> … </mirrors> 中间添加配置。如下图所示：</p><p><img src="https://bu.dusays.com/2024/05/05/6637a99ae2f1b.png" alt="image-20221130161346565.png"></p><p>&#x3D;&#x3D;注:  只可配置一个<mirror>(另一个要注释!) ，不然两个可能发生冲突，导致jar包无法下载!!!!!!!&#x3D;&#x3D;</p><p><strong>4、配置环境变量</strong></p><blockquote><p>Maven环境变量的配置类似于JDK环境变量配置一样</p></blockquote><p>1). 在系统变量处新建一个变量MAVEN_HOME</p><ul><li>MAVEN_HOME环境变量的值，设置为maven的解压安装目录</li></ul><p><img src="https://bu.dusays.com/2024/05/05/6637a99669ec2.png" alt="image-20220616102344350.png"></p><p>2). 在Path中进行配置</p><ul><li>PATH环境变量的值，设置为：%MAVEN_HOME%\bin</li></ul><p><img src="https://bu.dusays.com/2024/05/05/6637a9970b24a.png" alt="image-20220616102435856.png"> </p><p>3). 打开DOS命令提示符进行验证，出现如图所示表示安装成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn -v</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/05/05/6637a99746d57.png" alt="image-20220616102554143.png"> </p><h2 id="03-IDEA集成Maven"><a href="#03-IDEA集成Maven" class="headerlink" title="03. IDEA集成Maven"></a>03. IDEA集成Maven</h2><p>我们要想在IDEA中使用Maven进行项目构建，就需要在IDEA中集成Maven</p><h3 id="3-1-配置Maven环境"><a href="#3-1-配置Maven环境" class="headerlink" title="3.1 配置Maven环境"></a>3.1 配置Maven环境</h3><h4 id="3-1-1-当前工程设置"><a href="#3-1-1-当前工程设置" class="headerlink" title="3.1.1 当前工程设置"></a>3.1.1 当前工程设置</h4><p>1、选择 IDEA中 File  &#x3D;&gt;  Settings  &#x3D;&gt;  Build,Execution,Deployment  &#x3D;&gt;  Build Tools  &#x3D;&gt;  Maven</p><p><img src="https://bu.dusays.com/2024/05/05/6637a997aca0d.png" alt="image-20220616103219646.png"> </p><p><img src="https://bu.dusays.com/2024/05/05/6637a99d3ce52.png" alt="image-20221130234731629.png"></p><p>2、设置IDEA使用本地安装的Maven，并修改配置文件及本地仓库路径</p><p><img src="https://bu.dusays.com/2024/05/05/6637a997b0c9e.png" alt="image-20220616103302386.png"></p><blockquote><p>Maven home path ：指定当前Maven的安装目录</p><p>User settings file ：指定当前Maven的settings.xml配置文件的存放路径</p><p>Local repository ：指定Maven的本地仓库的路径 (如果指定了settings.xml, 这个目录会自动读取出来, 可以不用手动指定)</p></blockquote><p>3、配置工程的编译版本为11</p><ul><li>Maven默认使用的编译版本为5（版本过低）</li></ul><p><img src="https://bu.dusays.com/2024/05/05/6637a99d4d275.png" alt="image-20221201093737128.png"> </p><p>上述配置的maven环境，只是针对于当前工程的，如果我们再创建一个project，又恢复成默认的配置了。 要解决这个问题， 我们就需要配置全局的maven环境。</p><h4 id="3-1-2-全局设置"><a href="#3-1-2-全局设置" class="headerlink" title="3.1.2 全局设置"></a>3.1.2 全局设置</h4><p>1、进入到IDEA欢迎页面</p><ul><li>选择 IDEA中 File  &#x3D;&gt;  close project</li></ul><p><img src="https://bu.dusays.com/2024/05/05/6637a9950c640.gif" alt="4.gif"></p><p><img src="https://bu.dusays.com/2024/05/05/6637a997c4a74.png" alt="image-20220616104338612.png"></p><p>2、打开 All settings , 选择 Build,Execution,Deployment  &#x3D;&gt;  Build Tools  &#x3D;&gt;  Maven</p><p><img src="https://bu.dusays.com/2024/05/05/6637a997ef5a9.png" alt="image-20220616104517726.png"></p><p>3、配置工程的编译版本为11</p><p><img src="https://bu.dusays.com/2024/05/05/6637a99d4d275.png" alt="image-20221201093737128.png"></p><p>这里所设置的maven的环境信息，并未指定任何一个project，此时设置的信息就属于全局配置信息。 以后，我们再创建project，默认就是使用我们全局配置的信息。</p><h3 id="3-2-Maven项目"><a href="#3-2-Maven项目" class="headerlink" title="3.2 Maven项目"></a>3.2 Maven项目</h3><h4 id="3-2-1-创建Maven项目"><a href="#3-2-1-创建Maven项目" class="headerlink" title="3.2.1 创建Maven项目"></a>3.2.1 创建Maven项目</h4><p>1、创建一个空项目 </p><p><img src="https://bu.dusays.com/2024/05/05/6637a99da8d20.png" alt="image-20221201095621738.png"></p><p><img src="https://bu.dusays.com/2024/05/05/6637a99d685b6.png" alt="image-20221201095600057.png"></p><p>2、创建模块，选择Maven，点击Next</p><p><img src="https://bu.dusays.com/2024/05/05/6637a99e05a40.png" alt="image-20221201095831320.png"></p><p><img src="https://bu.dusays.com/2024/05/05/6637a99e61b62.png" alt="image-20221201100011799.png"></p><p>3、填写模块名称，坐标信息，点击finish，创建完成</p><p><img src="https://bu.dusays.com/2024/05/05/6637a99e88ae2.png" alt="image-20221201100502234.png"> </p><p>4、在Maven工程下，创建HelloWorld类</p><p><img src="https://bu.dusays.com/2024/05/05/6637a99eb1b8a.png" alt="image-20221201101603397.png"></p><p><img src="https://bu.dusays.com/2024/05/05/6637a99ebd85e.png" alt="image-20221201101643427.png"></p><blockquote><ul><li><p>Maven项目的目录结构:</p><p>maven-project01<br>|—  src  (源代码目录和测试代码目录)<br>        |—  main (源代码目录)<br>                   |— java (源代码java文件目录)<br>                   |— resources (源代码配置文件目录)<br>        |—  test (测试代码目录)<br>                   |— java (测试代码java目录)<br>                   |— resources (测试代码配置文件目录)<br>|— target (编译、打包生成文件存放目录)</p></li></ul></blockquote><p>5、编写 HelloWorld，并运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello Maven ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-2-POM配置详解"><a href="#3-2-2-POM配置详解" class="headerlink" title="3.2.2 POM配置详解"></a>3.2.2 POM配置详解</h4><p>POM (Project Object Model) ：指的是项目对象模型，用来描述当前的maven项目。</p><ul><li>使用pom.xml文件来实现</li></ul><p>pom.xml文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- POM模型版本 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 当前项目坐标 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_project1<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 打包方式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>pom文件详解：</p><ul><li><project> ：pom文件的根标签，表示当前maven项目</li><li><modelVersion> ：声明项目描述遵循哪一个POM模型版本<ul><li>虽然模型本身的版本很少改变，但它仍然是必不可少的。目前POM模型版本是4.0.0</li></ul></li><li>坐标 ：<groupId>、<artifactId>、<version><ul><li>定位项目在本地仓库中的位置，由以上三个标签组成一个坐标</li></ul></li><li><packaging> ：maven项目的打包方式，通常设置为jar或war（默认值：jar）</li></ul><h4 id="3-2-3-Maven坐标详解"><a href="#3-2-3-Maven坐标详解" class="headerlink" title="3.2.3 Maven坐标详解"></a>3.2.3 Maven坐标详解</h4><p>什么是坐标？</p><ul><li>Maven中的坐标是&#x3D;&#x3D;资源的唯一标识&#x3D;&#x3D; , 通过该坐标可以唯一定位资源位置</li><li>使用坐标来定义项目或引入项目中需要的依赖</li></ul><p>Maven坐标主要组成</p><ul><li>groupId：定义当前Maven项目隶属组织名称（通常是域名反写，例如：com.itheima）</li><li>artifactId：定义当前Maven项目名称（通常是模块名称，例如 order-service、goods-service）</li><li>version：定义当前项目版本号</li></ul><p>如下图就是使用坐标表示一个项目：</p><p><img src="https://bu.dusays.com/2024/05/05/6637a997eeec9.png" alt="image-20220616111031057.png"> </p><blockquote><p><strong>注意：</strong></p><ul><li>上面所说的资源可以是插件、依赖、当前项目。</li><li>我们的项目如果被其他的项目依赖时，也是需要坐标来引入的。</li></ul></blockquote><h3 id="3-3-导入Maven项目"><a href="#3-3-导入Maven项目" class="headerlink" title="3.3 导入Maven项目"></a>3.3 导入Maven项目</h3><ul><li><strong>方式1：使用Maven面板，快速导入项目</strong></li></ul><p>打开IDEA，选择右侧Maven面板，点击 + 号，选中对应项目的pom.xml文件，双击即可</p><p><img src="https://bu.dusays.com/2024/05/05/6637a99f01b9d.png" alt="image-20221201104320521.png"></p><p><img src="https://bu.dusays.com/2024/05/05/6637a99f18d9c.png" alt="image-20221201104906754.png"> </p><blockquote><p>说明：如果没有Maven面板，选择 View  &#x3D;&gt;  Appearance  &#x3D;&gt;  Tool Window Bars</p><p><img src="https://bu.dusays.com/2024/05/05/6637a99842083.png" alt="image-20220616111937679.png"> </p></blockquote><ul><li><strong>方式2：使用idea导入模块项目</strong></li></ul><p>File  &#x3D;&gt;  Project Structure  &#x3D;&gt;  Modules  &#x3D;&gt;  +  &#x3D;&gt;  Import Module</p><p><img src="https://bu.dusays.com/2024/05/05/6637a99987879.png" alt="image-20220823161727718.png"></p><p>找到要导入工程的pom.xml</p><p><img src="https://bu.dusays.com/2024/05/05/6637a99f34eff.png" alt="image-20221201105532909.png"></p><p><img src="https://bu.dusays.com/2024/05/05/6637a99f66c79.png" alt="image-20221201105845872.png"></p><h2 id="04-依赖管理"><a href="#04-依赖管理" class="headerlink" title="04. 依赖管理"></a>04. 依赖管理</h2><h3 id="4-1-依赖配置"><a href="#4-1-依赖配置" class="headerlink" title="4.1 依赖配置"></a>4.1 依赖配置</h3><p>依赖：指当前项目运行所需要的jar包。一个项目中可以引入多个依赖：</p><p>例如：在当前工程中，我们需要用到logback来记录日志，此时就可以在maven工程的pom.xml文件中，引入logback的依赖。具体步骤如下：</p><ol><li><p>在pom.xml中编写<dependencies>标签</p></li><li><p>在<dependencies>标签中使用<dependency>引入坐标</p></li><li><p>定义坐标的 groupId、artifactId、version</p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 第1个依赖 : logback --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 第2个依赖 : junit --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>点击刷新按钮，引入最新加入的坐标<ul><li>刷新依赖：保证每一次引入新的依赖，或者修改现有的依赖配置，都可以加入最新的坐标</li></ul></li></ol><p><img src="https://bu.dusays.com/2024/05/05/6637a99b44ae8.png" alt="image-20221130184402805.png">  </p><blockquote><p>注意事项：</p><ol><li>如果引入的依赖，在本地仓库中不存在，将会连接远程仓库 &#x2F; 中央仓库，然后下载依赖（这个过程会比较耗时，耐心等待）</li><li>如果不知道依赖的坐标信息，可以到mvn的中央仓库（<a href="https://mvnrepository.com/%EF%BC%89%E4%B8%AD%E6%90%9C%E7%B4%A2">https://mvnrepository.com/）中搜索</a></li></ol></blockquote><p><strong>添加依赖的几种方式：</strong></p><ol><li><p>利用中央仓库搜索的依赖坐标</p><p><img src="https://bu.dusays.com/2024/05/05/6637a99699534.gif" alt="5.gif"></p></li><li><p>利用IDEA工具搜索依赖</p><p><img src="https://bu.dusays.com/2024/05/05/6637a9960bbde.gif" alt="6.gif"></p></li><li><p>熟练上手maven后，快速导入依赖</p><p><img src="https://bu.dusays.com/2024/05/05/6637a995ca4d8.gif" alt="7.gif"></p></li></ol><h3 id="4-2-依赖传递"><a href="#4-2-依赖传递" class="headerlink" title="4.2 依赖传递"></a>4.2 依赖传递</h3><h4 id="4-2-1-依赖具有传递性"><a href="#4-2-1-依赖具有传递性" class="headerlink" title="4.2.1 依赖具有传递性"></a>4.2.1 依赖具有传递性</h4><p>早期我们没有使用maven时，向项目中添加依赖的jar包，需要把所有的jar包都复制到项目工程下。如下图所示，需要logback-classic时，由于logback-classic又依赖了logback-core和slf4j，所以必须把这3个jar包全部复制到项目工程下</p><p><img src="https://bu.dusays.com/2024/05/05/6637a9a04ace3.png" alt="image-20221201120514644.png"></p><p>我们现在使用了maven，当项目中需要使用logback-classic时，只需要在pom.xml配置文件中，添加logback-classic的依赖坐标即可。</p><p><img src="https://bu.dusays.com/2024/05/05/6637a99fd27a2.png" alt="image-20221201113659400.png"></p><p>在pom.xml文件中只添加了logback-classic依赖，但由于maven的依赖具有传递性，所以会自动把所依赖的其他jar包也一起导入。</p><p>依赖传递可以分为：</p><ol><li><p>直接依赖：在当前项目中通过依赖配置建立的依赖关系</p></li><li><p>间接依赖：被依赖的资源如果依赖其他资源，当前项目间接依赖其他资源</p></li></ol><p><img src="https://bu.dusays.com/2024/05/05/6637a99842080.png" alt="image-20220616115445812.png"> </p><p>比如以上图中：</p><ul><li>projectA依赖了projectB。对于projectA 来说，projectB 就是直接依赖。</li><li>而projectB依赖了projectC及其他jar包。 那么此时，在projectA中也会将projectC的依赖传递下来。对于projectA 来说，projectC就是间接依赖。</li></ul><p><img src="https://bu.dusays.com/2024/05/05/6637a9a0407c7.png" alt="image-20221201115801806.png"></p><h4 id="4-2-2-排除依赖"><a href="#4-2-2-排除依赖" class="headerlink" title="4.2.2 排除依赖"></a>4.2.2 排除依赖</h4><p>问题：之前我们讲了依赖具有传递性。那么A依赖B，B依赖C，如果A不想将C依赖进来，是否可以做到？ </p><p>答案：在maven项目中，我们可以通过排除依赖来实现。</p><p>什么是排除依赖？</p><ul><li>排除依赖：指主动断开依赖的资源。（被排除的资源无需指定版本）</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-projectB<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">&lt;!--排除依赖, 主动断开依赖的资源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>依赖排除示例：</p><ul><li>maven-projectA依赖了maven-projectB，maven-projectB依赖了Junit。基于依赖的传递性，所以maven-projectA也依赖了Junit</li></ul><p><img src="https://bu.dusays.com/2024/05/05/6637a9a0dfb92.png" alt="image-20221201141929240.png"></p><ul><li>使用排除依赖后</li></ul><p><img src="https://bu.dusays.com/2024/05/05/6637a9a10e014.png" alt="image-20221201142501556.png"></p><h3 id="4-3-依赖范围"><a href="#4-3-依赖范围" class="headerlink" title="4.3 依赖范围"></a>4.3 依赖范围</h3><p>在项目中导入依赖的jar包后，默认情况下，可以在任何地方使用。</p><p><img src="https://bu.dusays.com/2024/05/05/6637a9a0a14eb.png" alt="image-20221201135142706.png"></p><p>如果希望限制依赖的使用范围，可以通过<scope>标签设置其作用范围。</p><p><img src="https://bu.dusays.com/2024/05/05/6637a99843ad6.png" alt="image-20220616123806894.png"> </p><p>作用范围：</p><ol><li><p>主程序范围有效（main文件夹范围内）</p></li><li><p>测试程序范围有效（test文件夹范围内）</p></li><li><p>是否参与打包运行（package指令范围内）</p></li></ol><p><img src="https://bu.dusays.com/2024/05/05/6637a9a0bc13a.png" alt="image-20221201140140947.png"></p><p>如上图所示，给junit依赖通过scope标签指定依赖的作用范围。 那么这个依赖就只能作用在测试环境，其他环境下不能使用。</p><p>scope标签的取值范围：</p><table><thead><tr><th><strong>scope</strong>值</th><th><strong>主程序</strong></th><th><strong>测试程序</strong></th><th><strong>打包（运行）</strong></th><th><strong>范例</strong></th></tr></thead><tbody><tr><td>compile（默认）</td><td>Y</td><td>Y</td><td>Y</td><td>log4j</td></tr><tr><td>test</td><td>-</td><td>Y</td><td>-</td><td>junit</td></tr><tr><td>provided</td><td>Y</td><td>Y</td><td>-</td><td>servlet-api</td></tr><tr><td>runtime</td><td>-</td><td>Y</td><td>Y</td><td>jdbc驱动</td></tr></tbody></table><h3 id="4-4-生命周期"><a href="#4-4-生命周期" class="headerlink" title="4.4 生命周期"></a>4.4 生命周期</h3><h4 id="4-4-1-介绍"><a href="#4-4-1-介绍" class="headerlink" title="4.4.1 介绍"></a>4.4.1 介绍</h4><p>Maven的生命周期就是为了对所有的构建过程进行抽象和统一。 描述了一次项目构建，经历哪些阶段。</p><p>在Maven出现之前，项目构建的生命周期就已经存在，软件开发人员每天都在对项目进行清理，编译，测试及部署。虽然大家都在不停地做构建工作，但公司和公司间、项目和项目间，往往使用不同的方式做类似的工作。</p><p>Maven从大量项目和构建工具中学习和反思，然后总结了一套高度完美的，易扩展的项目构建生命周期。这个生命周期包含了项目的清理，初始化，编译，测试，打包，集成测试，验证，部署和站点生成等几乎所有构建步骤。</p><p>Maven对项目构建的生命周期划分为3套（相互独立）：</p><p><img src="https://bu.dusays.com/2024/05/05/6637a998a3fca.png" alt="image-20220616124015567.png"></p><ul><li><p>clean：清理工作。</p></li><li><p>default：核心工作。如：编译、测试、打包、安装、部署等。</p></li><li><p>site：生成报告、发布站点等。</p></li></ul><p>三套生命周期又包含哪些具体的阶段呢, 我们来看下面这幅图:</p><p><img src="https://bu.dusays.com/2024/05/05/6637a998ec845.png" alt="image-20220616124348972.png"> </p><p>我们看到这三套生命周期，里面有很多很多的阶段，这么多生命周期阶段，其实我们常用的并不多，主要关注以下几个：</p><p>• clean：移除上一次构建生成的文件</p><p>• compile：编译项目源代码</p><p>• test：使用合适的单元测试框架运行测试(junit)</p><p>• package：将编译后的文件打包，如：jar、war等</p><p>• install：安装项目到本地仓库</p><p>Maven的生命周期是抽象的，这意味着生命周期本身不做任何实际工作。<strong>在Maven的设计中，实际任务（如源代码编译）都交由插件来完成。</strong></p><p><img src="https://bu.dusays.com/2024/05/05/6637a99c636d5.png" alt="image-20221130142100703.png"></p><p>IDEA工具为了方便程序员使用maven生命周期，在右侧的maven工具栏中，已给出快速访问通道</p><p><img src="https://bu.dusays.com/2024/05/05/6637a9a16327e.png" alt="image-20221201151340340.png"></p><p>生命周期的顺序是：clean –&gt; validate –&gt; compile –&gt; test –&gt; package –&gt; verify –&gt; install –&gt; site –&gt; deploy </p><p>我们需要关注的就是：clean –&gt;  compile –&gt; test –&gt; package  –&gt; install </p><blockquote><p>说明：在同一套生命周期中，我们在执行后面的生命周期时，前面的生命周期都会执行。</p></blockquote><blockquote><p> 思考：当运行package生命周期时，clean、compile生命周期会不会运行？</p><p> ​clean不会运行，compile会运行。  因为compile与package属于同一套生命周期，而clean与package不属于同一套生命周期。</p></blockquote><h4 id="4-4-2-执行"><a href="#4-4-2-执行" class="headerlink" title="4.4.2 执行"></a>4.4.2 执行</h4><p>在日常开发中，当我们要执行指定的生命周期时，有两种执行方式：</p><ol><li>在idea工具右侧的maven工具栏中，选择对应的生命周期，双击执行</li><li>在DOS命令行中，通过maven命令执行</li></ol><p><strong>方式一：在idea中执行生命周期</strong></p><ul><li>选择对应的生命周期，双击执行</li></ul><p><img src="https://bu.dusays.com/2024/05/05/6637a9a15c81a.png" alt="image-20221201161957301.png"> </p><p>compile：</p><p><img src="https://bu.dusays.com/2024/05/05/6637a9a1ae861.png" alt="image-20221201163711835.png"></p><p>test：</p><p><img src="https://bu.dusays.com/2024/05/05/6637a9a1f1bfd.png" alt="image-20221201164627403.png"></p><p>package：</p><p><img src="https://bu.dusays.com/2024/05/05/6637a9a230763.png" alt="image-20221201165801341.png"></p><p>install：</p><p><img src="https://bu.dusays.com/2024/05/05/6637a9a288ecf.png" alt="image-20221201170830837.png"></p><p>clean：</p><p><img src="https://bu.dusays.com/2024/05/05/6637a9a2a2e21.png" alt="image-20221201171529382.png"></p><p><strong>方式二：在命令行中执行生命周期</strong></p><ol><li>进入到DOS命令行</li></ol><p><img src="https://bu.dusays.com/2024/05/05/6637a9a299c8c.png" alt="image-20221201172210253.png"></p><p><img src="https://bu.dusays.com/2024/05/05/6637a9a2d07da.png" alt="image-20221201172914648.png"> </p><h2 id="05-附录"><a href="#05-附录" class="headerlink" title="05. 附录"></a>05. 附录</h2><h3 id="5-1-更新依赖索引"><a href="#5-1-更新依赖索引" class="headerlink" title="5.1 更新依赖索引"></a>5.1 更新依赖索引</h3><p>有时候给idea配置完maven仓库信息后，在idea中依然搜索不到仓库中的jar包。这是因为仓库中的jar包索引尚未更新到idea中。这个时候我们就需要更新idea中maven的索引了，具体做法如下：</p><p> 打开设置—-搜索maven—-Repositories—-选中本地仓库—–点击Update</p><p><img src="https://bu.dusays.com/2024/05/05/6637a99481af2.png" alt="1537786634456-1582625518984.png"></p><h3 id="5-2-清理maven仓库"><a href="#5-2-清理maven仓库" class="headerlink" title="5.2 清理maven仓库"></a>5.2 清理maven仓库</h3><p>初始情况下，我们的本地仓库是没有任何jar包的，此时会从私服去下载（如果没有配置，就直接从中央仓库去下载），可能由于网络的原因，jar包下载不完全，这些不完整的jar包都是以lastUpdated结尾。此时，maven不会再重新帮你下载，需要你删除这些以lastUpdated结尾的文件，然后maven才会再次自动下载这些jar包。</p><p><img src="https://bu.dusays.com/2024/05/05/6637a9a36d260.png" alt="lastUpdated-1582625518983.png"></p><p>如果本地仓库中有很多这样的以lastUpadted结尾的文件，可以定义一个批处理文件，在其中编写如下脚本来删除： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set REPOSITORY_PATH=E:\develop\apache-maven-3.6.1\mvn_repo</span><br><span class="line">rem 正在搜索...</span><br><span class="line"></span><br><span class="line">del /s /q %REPOSITORY_PATH%\*.lastUpdated</span><br><span class="line"></span><br><span class="line">rem 搜索完毕</span><br><span class="line">pause</span><br></pre></td></tr></table></figure><p>操作步骤如下：</p><p>1). 定义批处理文件del_lastUpdated.bat  (直接创建一个文本文件，命名为del_lastUpdated，后缀名直接改为bat即可 )</p><p><img src="https://bu.dusays.com/2024/05/05/6637a9a32ce33.png" alt="image-20221214154949482.png"> </p><p>2). 在上面的bat文件上<strong>右键—》编辑</strong> 。修改文件：</p><p><img src="https://bu.dusays.com/2024/05/05/6637a9a3199ba.png" alt="image-20221214154559817.png"> </p><p>修改完毕后，双击运行即可删除maven仓库中的残留文件。</p>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript-Vue简述</title>
      <link href="/posts/9f572938.html"/>
      <url>/posts/9f572938.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-JavaScript"><a href="#1-JavaScript" class="headerlink" title="1 JavaScript"></a>1 JavaScript</h1><p>html完成了架子，css做了美化，但是网页是死的，我们需要给他注入灵魂，所以接下来我们需要学习JavaScript，这门语言会让我们的页面能够和用户进行交互。</p><h2 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h2><p>通过<strong>代码&#x2F;js效果演示</strong>提供资料进行效果演示，通过浏览器打开，我们点击主题5按钮，页面的主题发生了变化，所以js可以让我们的页面更加的智能，让页面和用户进行交互。</p><p><img src="https://bu.dusays.com/2024/04/29/662f1cbeecc99.png" alt="1667964998343"> </p><h2 id="1-2-引入方式"><a href="#1-2-引入方式" class="headerlink" title="1.2 引入方式"></a>1.2 引入方式</h2><p>同样，js代码也是书写在html中的，那么html中如何引入js代码呢？主要通过下面的2种引入方式：</p><p><strong>第一种方式：</strong>内部脚本，将JS代码定义在HTML页面中</p><ul><li>JavaScript代码必须位于&lt;script&gt;&lt;&#x2F;script&gt;标签之间</li><li>在HTML文档中，可以在任意地方，放置任意数量的&lt;script&gt;</li><li>一般会把脚本置于&lt;body&gt;元素的底部，可改善显示速度</li></ul><p>例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="string">&quot;Hello JavaScript&quot;</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>第二种方式：</strong>外部脚本将， JS代码定义在外部 JS文件中，然后引入到 HTML页面中</p><ul><li>外部JS文件中，只包含JS代码，不包含&amp;ltscript&gt;标签</li><li>引入外部js的&lt;script&gt;标签，必须是双标签</li></ul><p>例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/demo.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：demo.js中只有js代码，没有&lt;script&gt;标签</p><p>接下来，我们通过VS Code来编写代码，演示html中2种引入js的方式</p><p>第一步：在VS Code中创建名为 10.JS-引入方式.html 的文件</p><p>第二步：按照上述第一种内部脚本的方式引入js，编写如下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS-引入方式<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 内部脚本 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(<span class="string">&#x27;Hello JS&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第三步：浏览器打开效果如图所示：</p><p><img src="https://bu.dusays.com/2024/04/29/662f237351a7e.png" alt="1668020985363"> </p><p>第四步：接下来演示外部脚本，注释掉内部脚本，然后在css目录同级创建js目录，然后创建一个名为demo.js的文件：</p><p><img src="https://bu.dusays.com/2024/04/29/662f1cbeab114.png" alt="1668021080890"> </p><p>第五步：在demo.js中编写如下js内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(&#x27;Hello JS2&#x27;);</span><br></pre></td></tr></table></figure><p>第六步：注释掉之前的内部脚本代码，添加&lt;script&gt;标签来引入外部demo.js文件,具体代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS-引入方式<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 内部脚本 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;script&gt;</span></span><br><span class="line"><span class="comment">        alert(&#x27;Hello JS&#x27;);</span></span><br><span class="line"><span class="comment">    &lt;/script&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 外部脚本 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/demo.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第七步：浏览器刷新效果如图：</p><p><img src="https://bu.dusays.com/2024/04/30/663076bd1208e.png" alt="04.png"> </p><h2 id="1-3-基础语法"><a href="#1-3-基础语法" class="headerlink" title="1.3 基础语法"></a>1.3 基础语法</h2><h3 id="1-3-1-书写语法"><a href="#1-3-1-书写语法" class="headerlink" title="1.3.1 书写语法"></a>1.3.1 书写语法</h3><p>掌握了js的引入方式，那么接下来我们需要学习js的书写了，首先需要掌握的是js的书写语法，语法规则如下：</p><ul><li><p>区分大小写：与 Java 一样，变量名、函数名以及其他一切东西都是区分大小写的</p></li><li><p>每行结尾的分号可有可无</p></li><li><p>大括号表示代码块</p></li><li><p>注释：</p><ul><li><p>单行注释：&#x2F;&#x2F; 注释内容</p></li><li><p>多行注释：&#x2F;* 注释内容 *&#x2F;</p></li></ul></li></ul><p>我们需要借助js中3钟输出语句，来演示书写语法</p><table><thead><tr><th>api</th><th>描述</th></tr></thead><tbody><tr><td>window.alert()</td><td>警告框</td></tr><tr><td>document.write()</td><td>在HTML 输出内容</td></tr><tr><td>console.log()</td><td>写入浏览器控制台</td></tr></tbody></table><p>接下来我们选用通过VS Code，接触3种输入语句，来演示js的书写语法</p><p>第一步：在VS Code中创建名为 11.JS-基础语法-输出语句.html的文件</p><p>第二步：按照基本语法规则，编写3种输出语句的代码，并且添加注释，具体代码如下；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS-基本语法<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">/* alert(&quot;JS&quot;); */</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//方式一: 弹出警告框</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="title function_">alert</span>(<span class="string">&quot;hello js&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>浏览器打开如图所示效果：</p><p><img src="https://bu.dusays.com/2024/04/29/662f237351a7e.png" alt="02.png"> </p><p>我们注释掉上述代码，添加代码 document.write(“hello js”); 来输出内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS-基本语法<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">/* alert(&quot;JS&quot;); */</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//方式一: 弹出警告框</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// window.alert(&quot;hello js&quot;);</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//方式二: 写入html页面中</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;hello js&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>刷新浏览器，效果如图所示：</p><p><img src="https://bu.dusays.com/2024/04/29/662f1cbeb538f.png" alt="1668101718354"> </p><p>最后我们使用console.log(“hello js”); 写入到控制台，并且注释掉之前的代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS-基本语法<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">/* alert(&quot;JS&quot;); */</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//方式一: 弹出警告框</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// window.alert(&quot;hello js&quot;);</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// //方式二: 写入html页面中</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// document.write(&quot;hello js&quot;);</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//方式三: 控制台输出</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello js&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>浏览器f12抓包，去控制台页面，如图所示：</p><p><img src="https://bu.dusays.com/2024/04/29/662f1cbec5eff.png" alt="1668101840992"></p><h3 id="1-3-2-变量"><a href="#1-3-2-变量" class="headerlink" title="1.3.2 变量"></a>1.3.2 变量</h3><p>书写语法会了，变量是一门编程语言比不可少的，所以接下来我们需要学习js中变量的声明，在js中，变量的声明和java中还是不同的。首先js中主要通过如下3个关键字来声明变量的：</p><table><thead><tr><th>关键字</th><th>解释</th></tr></thead><tbody><tr><td>var</td><td>早期ECMAScript5中用于变量声明的关键字</td></tr><tr><td>let</td><td>ECMAScript6中新增的用于变量声明的关键字，相比较var，let只在代码块内生效</td></tr><tr><td>const</td><td>声明常量的，常量一旦声明，不能修改</td></tr></tbody></table><p>在js中声明变量还需要注意如下几点：</p><ul><li>JavaScript 是一门弱类型语言，变量可以存放不同类型的值 。</li><li>变量名需要遵循如下规则：<ul><li>组成字符可以是任何字母、数字、下划线（_）或美元符号（$）</li><li>数字不能开头</li><li>建议使用驼峰命名</li></ul></li></ul><p>接下来我们需要通过VS Code编写代码来演示js中变量的定义</p><p>第一步：在VS Code中创建名为 12.JS-基础语法-变量.html的文件：</p><p>第二步：编写代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS-基础语法<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//var定义变量</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> a = <span class="number">10</span>;</span></span><br><span class="line"><span class="language-javascript">    a = <span class="string">&quot;张三&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(a);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到浏览器弹出张三</p><p><img src="https://bu.dusays.com/2024/04/29/662f1cbeb69cb.png" alt="1668101996370"> </p><p>在js中，我们var声明的变量可以接受任何数据类型的值。并且var声明的变量的作用于是全局的，注释掉之前的代码，添加如下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//var定义变量</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// var a = 10;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// a = &quot;张三&quot;;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// alert(a);</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//特点1 : 作用域比较大, 全局变量</span></span></span><br><span class="line"><span class="language-javascript">    &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> x = <span class="number">1</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(x);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>浏览器照样成功弹出：</p><p><img src="https://bu.dusays.com/2024/04/29/662f1cbeb286e.png" alt="1668102183766"> </p><p>而且var关键字声明的变量可以重复定义，修改代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">var</span> x = <span class="string">&quot;A&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">alert</span>(x);</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>浏览器弹出内容是A</p><p><img src="https://bu.dusays.com/2024/04/29/662f1cbeb712e.png" alt="1668102256305"> </p><p>所以在ECMAScript 6 新增了 <strong>let</strong>关键字来定义变量，它的用法类似于 var，但是所声明的变量，只在 let关键字所在的代码块内有效，且不允许重复声明。注释掉之前的代码，添加代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//var定义变量</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// var a = 10;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// a = &quot;张三&quot;;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// alert(a);</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//特点1 : 作用域比较大, 全局变量</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//特点2 : 可以重复定义的</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// &#123;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//     var x = 1;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//     var x = &quot;A&quot;;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// &#125;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// alert(x);</span></span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//let : 局部变量 ; 不能重复定义 </span></span></span><br><span class="line"><span class="language-javascript">    &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> x = <span class="number">1</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(x);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>浏览器打开，f12抓包，来到控制台页面，发现报错，变量没有定义，说明let声明的变量在代码块外不生效</p><p><img src="https://bu.dusays.com/2024/04/29/662f1cc0f3848.png" alt="1668102426953"></p><p>接着我们使用let重复定义变量，代码修改如下：发现idea直接帮我们报错了，说明let声明的变量不能重复定义</p><p><img src="https://bu.dusays.com/2024/04/29/662f1cc10f57a.png" alt="1668102527993"> </p><p>在ECMAScript6中，还新增了const关键字用来声明常量，但是一旦声明，常量的值是无法更改的。注释之前的内容，添加如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pi = <span class="number">3.14</span>;</span><br><span class="line">pi = <span class="number">3.15</span>;</span><br><span class="line"><span class="title function_">alert</span>(pi);</span><br></pre></td></tr></table></figure><p>浏览器f12抓包，来到控制台页面发现直接报错了，</p><p><img src="https://bu.dusays.com/2024/04/29/662f1cc13a621.png" alt="1668102736759"> </p><p>关于变量的讲解我们就此结束，完整代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS-基础语法<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//var定义变量</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// var a = 10;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// a = &quot;张三&quot;;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// alert(a);</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//特点1 : 作用域比较大, 全局变量</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//特点2 : 可以重复定义的</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// &#123;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//     var x = 1;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//     var x = &quot;A&quot;;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// &#125;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// alert(x);</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//let : 局部变量 ; 不能重复定义 </span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// &#123;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//     let x = 1;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//     alert(x);</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// &#125;</span></span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//const: 常量 , 不能给改变的.</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> pi = <span class="number">3.14</span>;</span></span><br><span class="line"><span class="language-javascript">    pi = <span class="number">3.15</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(pi);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-3-3-数据类型和运算符"><a href="#1-3-3-数据类型和运算符" class="headerlink" title="1.3.3 数据类型和运算符"></a>1.3.3 数据类型和运算符</h3><p>虽然js是弱数据类型的语言，但是js中也存在数据类型，js中的数据类型分为 ：原始类型 和 引用类型，具体有如下类型</p><table><thead><tr><th>数据类型</th><th>描述</th></tr></thead><tbody><tr><td>number</td><td>数字（整数、小数、NaN(Not a Number)）</td></tr><tr><td>string</td><td>字符串，单双引皆可</td></tr><tr><td>boolean</td><td>布尔。true，false</td></tr><tr><td>null</td><td>对象为空</td></tr><tr><td>undefined</td><td>当声明的变量未初始化时，该变量的默认值是 undefined</td></tr></tbody></table><p>使用typeof函数可以返回变量的数据类型，接下来我们需要通过书写代码来演示js中的数据类型</p><p>第一步：在VS Code中创建名为13. JS-基础语法-数据类型.html的文件</p><p>第二步：编写如下代码，然后直接挨个观察数据类型：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS-数据类型<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//原始数据类型</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="keyword">typeof</span> <span class="number">3</span>); <span class="comment">//number</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="keyword">typeof</span> <span class="number">3.14</span>); <span class="comment">//number</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="keyword">typeof</span> <span class="string">&quot;A&quot;</span>); <span class="comment">//string</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="keyword">typeof</span> <span class="string">&#x27;Hello&#x27;</span>);<span class="comment">//string</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="keyword">typeof</span> <span class="literal">true</span>); <span class="comment">//boolean</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="keyword">typeof</span> <span class="literal">false</span>);<span class="comment">//boolean</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="keyword">typeof</span> <span class="literal">null</span>); <span class="comment">//object </span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> a ;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="keyword">typeof</span> a); <span class="comment">//undefined</span></span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>熟悉了js的数据类型了，那么我们需要学习js中的运算法，js中的运算规则绝大多数还是和java中一致的，具体运算符如下：</p><table><thead><tr><th>运算规则</th><th>运算符</th></tr></thead><tbody><tr><td>算术运算符</td><td>+ , - , * , &#x2F; , % , ++ , –</td></tr><tr><td>赋值运算符</td><td>&#x3D; , +&#x3D; , -&#x3D; , *&#x3D; , &#x2F;&#x3D; , %&#x3D;</td></tr><tr><td>比较运算符</td><td>&gt; , &lt; , &gt;&#x3D; , &lt;&#x3D; , !&#x3D; , &#x3D;&#x3D; , &#x3D;&#x3D;&#x3D;   注意     &#x3D;&#x3D; 会进行类型转换，&#x3D;&#x3D;&#x3D; 不会进行类型转换</td></tr><tr><td>逻辑运算符</td><td>&amp;&amp; , || , !</td></tr><tr><td>三元运算符</td><td>条件表达式 ? true_value: false_value</td></tr></tbody></table><p>接下来我们通过代码来演示js中的运算法，主要记忆js中和java中不一致的地方</p><p>第一步：在VS Code中创建名为14. JS-基础语法-运算符.html的文件</p><p>第二步：编写代码</p><p>在js中，绝大多数的运算规则和java中是保持一致的，但是js中的=&#x3D;和&#x3D;&#x3D;&#x3D;是有区别的。</p><ul><li>=&#x3D;：只比较值是否相等，不区分数据类型，哪怕类型不一致，&#x3D;&#x3D;也会自动转换类型进行值得比较</li><li>&#x3D;&#x3D;&#x3D;：不光比较值，还要比较类型，如果类型不一致，直接返回false</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS-运算符<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">     <span class="keyword">var</span> age = <span class="number">20</span>;</span></span><br><span class="line"><span class="language-javascript">     <span class="keyword">var</span> _age = <span class="string">&quot;20&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">     <span class="keyword">var</span> $age = <span class="number">20</span>;</span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript">     <span class="title function_">alert</span>(age == _age);<span class="comment">//true ，只比较值</span></span></span><br><span class="line"><span class="language-javascript">     <span class="title function_">alert</span>(age === _age);<span class="comment">//false ，类型不一样</span></span></span><br><span class="line"><span class="language-javascript">     <span class="title function_">alert</span>(age === $age);<span class="comment">//true ，类型一样，值一样</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在js中，虽然不区分数据类型，但是有时候涉及到数值计算，还是需要进行类型转换的，js中可以通过parseInt()函数来进行将其他类型转换成数值类型。注释之前的代码，添加代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型转换 - 其他类型转为数字</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="built_in">parseInt</span>(<span class="string">&quot;12&quot;</span>)); <span class="comment">//12</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="built_in">parseInt</span>(<span class="string">&quot;12A45&quot;</span>)); <span class="comment">//12</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="built_in">parseInt</span>(<span class="string">&quot;A45&quot;</span>));<span class="comment">//NaN (not a number)</span></span><br></pre></td></tr></table></figure><p>除此之外，在js中，还有非常重要的一点是：0,null,undefined,””,NaN理解成false,反之理解成true。注释掉之前的代码，添加如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="number">0</span>)&#123; <span class="comment">//false</span></span><br><span class="line">   <span class="title function_">alert</span>(<span class="string">&quot;0 转换为false&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>浏览器刷新页面，发现没有任何弹框，因为0理解成false，所以条件不成立。注释掉上述代码，添加如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="number">1</span>)&#123; <span class="comment">//true</span></span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;除0和NaN其他数字都转为 true&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>浏览器刷新，因为1理解成true，条件成立，所以浏览器效果如下；</p><p><img src="https://bu.dusays.com/2024/04/29/662f1cc154458.png" alt="1668103531260"> </p><p>其他情况可以一一演示，完整演示代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if(0)&#123; //false</span></span><br><span class="line"><span class="comment">//     alert(&quot;0 转换为false&quot;);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// if(NaN)&#123;//false</span></span><br><span class="line"><span class="comment">//     alert(&quot;NaN 转换为false&quot;);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">if</span>(<span class="number">1</span>)&#123; <span class="comment">//true</span></span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;除0和NaN其他数字都转为 true&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if(&quot;&quot;)&#123; //false</span></span><br><span class="line"><span class="comment">//     alert(&quot;空字符串为 false, 其他都是true&quot;);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// if(null)&#123; //false</span></span><br><span class="line"><span class="comment">//     alert(&quot;null 转化为false&quot;);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// if(undefined)&#123; //false</span></span><br><span class="line"><span class="comment">//     alert(&quot;undefined 转化为false&quot;);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>流程控制语句if，switch，for等和java保持一致，此处不再演示</p><p><strong>需要注意的是：</strong>在js中，0,null,undefined,””,NaN理解成false,反之理解成true</p><h2 id="1-4-函数"><a href="#1-4-函数" class="headerlink" title="1.4 函数"></a>1.4 函数</h2><p>在java中我们为了提高代码的复用性，可以使用方法。同样，在JavaScript中可以使用函数来完成相同的事情。JavaScript中的函数被设计为执行特定任务的代码块，通过关键字function来定义。接下来我们学习一下JavaScript中定义函数的2种语法</p><h3 id="1-4-1-第一种定义格式"><a href="#1-4-1-第一种定义格式" class="headerlink" title="1.4.1 第一种定义格式"></a>1.4.1 第一种定义格式</h3><p>第一种定义格式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> 函数名(参数<span class="number">1</span>,参数<span class="number">2.</span>.)&#123;</span><br><span class="line">    要执行的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为JavaScript是弱数据类型的语言，所以有如下几点需要注意：</p><ul><li>形式参数不需要声明类型，并且JavaScript中不管什么类型都是let或者var去声明，加上也没有意义。</li><li>返回值也不需要声明类型，直接return即可</li></ul><p>如下示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们需要在VS Code中编写代码来演示</p><p>第一步：新建名为js的文件夹，创建名为01. JS-函数的html文件，然后在&lt;script&gt;中定义上述示例的函数：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">     <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a,b</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span>  a + b;</span></span><br><span class="line"><span class="language-javascript">     &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是上述只是定义函数，<strong>函数需要被调用才能执行！</strong>所以接下来我们需要调用函数</p><p>第二步：因为定义的add函数有返回值，所以我们可以接受返回值，并且输出到浏览器上，添加如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="title function_">add</span>(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line"><span class="title function_">alert</span>(result);</span><br></pre></td></tr></table></figure><p>查看浏览器运行结果：浏览器弹框内容如下图所示：</p><p><img src="https://bu.dusays.com/2024/04/29/662f1cc174d5e.png" alt="1668584359136"> </p><h3 id="1-4-2-第二种定义格式"><a href="#1-4-2-第二种定义格式" class="headerlink" title="1.4.2 第二种定义格式"></a>1.4.2 第二种定义格式</h3><p>第二种可以通过var去定义函数的名字，具体格式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> functionName = <span class="keyword">function</span> (<span class="params">参数<span class="number">1</span>,参数<span class="number">2.</span>.</span>)&#123;   </span><br><span class="line"><span class="comment">//要执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们按照上述的格式，修改代码如下：只需要将第一种定义方式注释掉，替换成第二种定义方式即可，函数的调用不变</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//定义函数-1</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// function add(a,b)&#123;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//    return  a + b;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// &#125;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//定义函数-2</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> add = <span class="keyword">function</span>(<span class="params">a,b</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span>  a + b;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//函数调用</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> result = <span class="title function_">add</span>(<span class="number">10</span>,<span class="number">20</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(result);</span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>浏览器弹框效果和上述一致</p><p><img src="https://bu.dusays.com/2024/04/29/662f1cc174d5e.png" alt="1668584359136"> </p><p>我们在调用add函数时，再添加2个参数，修改代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="title function_">add</span>(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>);</span><br></pre></td></tr></table></figure><p>浏览器打开，发现没有错误，并且依然弹出30，这是为什么呢？</p><p>因为在JavaScript中，函数的调用只需要名称正确即可，参数列表不管的。如上述案例，10传递给了变量a，20传递给了变量b,而30和40没有变量接受，但是不影响函数的正常调用。</p><h2 id="1-5-JavaScript对象"><a href="#1-5-JavaScript对象" class="headerlink" title="1.5 JavaScript对象"></a>1.5 JavaScript对象</h2><p>JavaScript中的对象有很多，主要可以分为如下3大类，我们可以打开<a href="https://www.w3school.com.cn/">W3school在线学习文档</a>，来到首页，在左侧栏找到浏览器脚本下的JavaScript，如下图所示：</p><p><img src="https://bu.dusays.com/2024/04/29/662f1cc26db0f.png" alt="1668587524509"></p><p>然后进入到如下界面，点击右侧的参考书</p><p><img src="https://bu.dusays.com/2024/04/29/662f1cc2a35af.png" alt="1668587661914"> </p><p>然后进入到如下页面，此页面列举出了JavaScript中的所有对象</p><p><img src="https://bu.dusays.com/2024/04/29/662f1cc2d6529.png" alt="19.png"></p><p>可以大体分页3大类：</p><p>第一类：基本对象,我们主要学习Array和JSON和String</p><p><img src="https://bu.dusays.com/2024/04/29/662f1cc2cbdfd.png" alt="20.png"> </p><p>第二类：BOM对象,主要是和浏览器相关的几个对象</p><p><img src="https://bu.dusays.com/2024/04/29/662f1cc308a98.png" alt="22.png"> </p><p>第三类：DOM对象，JavaScript中将html的每一个标签都封装成一个对象</p><p><img src="https://bu.dusays.com/2024/04/29/662f1cc329235.png" alt="23.png"> </p><p>我们先来学习基本对象种的Array对象</p><h3 id="1-5-1-基本对象"><a href="#1-5-1-基本对象" class="headerlink" title="1.5.1 基本对象"></a>1.5.1 基本对象</h3><h4 id="1-5-1-1-Array对象"><a href="#1-5-1-1-Array对象" class="headerlink" title="1.5.1.1 Array对象"></a>1.5.1.1 Array对象</h4><h5 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h5><p>Array对象时用来定义数组的。常用语法格式有如下2种：</p><p>方式1：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 = <span class="keyword">new</span> <span class="title class_">Array</span>(元素列表); </span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>); <span class="comment">//1,2,3,4 是存储在数组中的数据（元素）</span></span><br></pre></td></tr></table></figure><p>方式2：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 = [ 元素列表 ]; </span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]; <span class="comment">//1,2,3,4 是存储在数组中的数据（元素）</span></span><br></pre></td></tr></table></figure><p>数组定义好了，那么我们该如何获取数组中的值呢？和java中一样，需要通过索引来获取数组中的值。语法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr[索引] = 值;</span><br></pre></td></tr></table></figure><p>接下来，我们在VS Code中创建名为02. JS-对象-Array.html的文件，按照上述的语法定义数组，并且通过索引来获取数组中的值。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//定义数组</span></span></span><br><span class="line"><span class="language-javascript">     <span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span></span><br><span class="line"><span class="language-javascript">     <span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span></span><br><span class="line"><span class="language-javascript"><span class="comment">//获取数组中的值，索引从0开始计数</span></span></span><br><span class="line"><span class="language-javascript">     <span class="variable language_">console</span>.<span class="title function_">log</span>(arr[<span class="number">0</span>]);</span></span><br><span class="line"><span class="language-javascript">     <span class="variable language_">console</span>.<span class="title function_">log</span>(arr[<span class="number">1</span>]);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>浏览器控制台观察的效果如下：输出1和2</p><p><img src="https://bu.dusays.com/2024/04/29/662f1cc42341c.png" alt="27.png"> </p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><p>与java中不一样的是，JavaScript中数组相当于java中的集合，数组的长度是可以变化的。而且JavaScript是弱数据类型的语言，所以数组中可以存储任意数据类型的值。接下来我们通过代码来演示上述特点。</p><p>注释掉之前的代码，添加如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//特点: 长度可变 类型可变</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">arr[<span class="number">10</span>] = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr[<span class="number">10</span>]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr[<span class="number">9</span>]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr[<span class="number">8</span>]);</span><br></pre></td></tr></table></figure><p>上述代码定义的arr变量中，数组的长度是4，但是我们直接再索引10的位置直接添加了数据10，并且输出索引为10的位置的元素，浏览器控制台数据结果如下：</p><p><img src="https://bu.dusays.com/2024/04/29/662f1cc3c41d0.png" alt="26.png"> </p><p>因为索引8和9的位置没有值，所以输出内容undefined,当然，我们也可以给数组添加其他类型的值，添加代码如下：注释掉之前控制台输出的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//特点: 长度可变 类型可变</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">arr[<span class="number">10</span>] = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(arr[10]);</span></span><br><span class="line"><span class="comment">// console.log(arr[9]);</span></span><br><span class="line"><span class="comment">// console.log(arr[8]);</span></span><br><span class="line"></span><br><span class="line">arr[<span class="number">9</span>] = <span class="string">&quot;A&quot;</span>;</span><br><span class="line">arr[<span class="number">8</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);</span><br></pre></td></tr></table></figure><p>浏览器控制台输出结果如下：</p><p><img src="https://bu.dusays.com/2024/04/29/662f1cc48fbb8.png" alt="28.png"> </p><h5 id="属性和方法"><a href="#属性和方法" class="headerlink" title="属性和方法"></a>属性和方法</h5><p>Array作为一个对象，那么对象是有属性和方法的，所以接下来我们介绍一下Array对象的属性和方法</p><p>官方文档中提供了Array的很多属性和方法，但是我们只学习常用的属性和方法，如下图所示：</p><p>属性：</p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">length</td><td align="left">设置或返回数组中元素的数量。</td></tr></tbody></table><p>方法：</p><table><thead><tr><th align="left">方法方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">forEach()</td><td align="left">遍历数组中的每个有值得元素，并调用一次传入的函数</td></tr><tr><td align="left">push()</td><td align="left">将新元素添加到数组的末尾，并返回新的长度</td></tr><tr><td align="left">splice()</td><td align="left">从数组中删除元素</td></tr></tbody></table><ul><li><p>length属性：</p><p>length属性可以用来获取数组的长度，所以我们可以借助这个属性，来遍历数组中的元素，添加如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">arr[<span class="number">10</span>] = <span class="number">50</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>浏览器控制台输出结果如图所示：</p><p><img src="https://bu.dusays.com/2024/04/29/662f1cc4d96e5.png" alt="30.png"> </p></li><li><p>forEach()函数</p><p>首先我们学习forEach()方法，顾名思义，这是用来遍历的，那么遍历做什么事呢？所以这个方法的参数，需要传递一个函数，而且这个函数接受一个参数，就是遍历时数组的值。修改之前的遍历代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//e是形参，接受的是数组遍历时的值</span></span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当然了，在ES6中，引入箭头函数的写法，语法类似java中lambda表达式，修改上述代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure><p>浏览器输出结果如下：注意的是，没有元素的内容是不会输出的，因为forEach只会遍历有值的元素 </p><p><img src="https://bu.dusays.com/2024/04/29/662f1cc51dcce.png" alt="32.png">  </p></li><li><p>push()函数</p><p>push()函数是用于向数组的末尾添加元素的，其中函数的参数就是需要添加的元素，编写如下代码：向数组的末尾添加3个元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//push: 添加元素到数组末尾</span></span><br><span class="line">arr.<span class="title function_">push</span>(<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);</span><br></pre></td></tr></table></figure><p>浏览器输出结果如下：</p><p><img src="https://bu.dusays.com/2024/04/29/662f1cc53e27e.png" alt="33.png"> </p></li><li><p>splice()函数</p><p>splice()函数用来数组中的元素，函数中填入2个参数。</p><p>参数1：表示从哪个索引位置删除</p><p>参数2：表示删除元素的个数</p><p>如下代码表示：从索引2的位置开始删，删除2个元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//splice: 删除元素</span></span><br><span class="line">arr.<span class="title function_">splice</span>(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);</span><br></pre></td></tr></table></figure><p>浏览器执行效果如下：元素3和4被删除了，元素3是索引2</p><p><img src="https://bu.dusays.com/2024/04/29/662f1cc5631e9.png" alt="34.png"></p></li></ul><p>Array数组的完整代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS-对象-Array<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//定义数组</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// var arr = new Array(1,2,3,4);</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// var arr = [1,2,3,4];</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// console.log(arr[0]);</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// console.log(arr[1]);</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//特点: 长度可变 类型可变</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// var arr = [1,2,3,4];</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// arr[10] = 50;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// console.log(arr[10]);</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// console.log(arr[9]);</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// console.log(arr[8]);</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// arr[9] = &quot;A&quot;;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// arr[8] = true;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// console.log(arr);</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span></span><br><span class="line"><span class="language-javascript">    arr[<span class="number">10</span>] = <span class="number">50</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// for (let i = 0; i &lt; arr.length; i++) &#123;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//     console.log(arr[i]);</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// &#125;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// console.log(&quot;==================&quot;);</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//forEach: 遍历数组中有值的元素</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// arr.forEach(function(e)&#123;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//     console.log(e);</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// &#125;)</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// //ES6 箭头函数: (...) =&gt; &#123;...&#125; -- 简化函数定义</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// arr.forEach((e) =&gt; &#123;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//     console.log(e);</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// &#125;) </span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//push: 添加元素到数组末尾</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// arr.push(7,8,9);</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// console.log(arr);</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//splice: 删除元素</span></span></span><br><span class="line"><span class="language-javascript">    arr.<span class="title function_">splice</span>(<span class="number">2</span>,<span class="number">2</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arr);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="1-5-1-2-String对象"><a href="#1-5-1-2-String对象" class="headerlink" title="1.5.1.2 String对象"></a>1.5.1.2 String对象</h4><h5 id="语法格式-1"><a href="#语法格式-1" class="headerlink" title="语法格式"></a>语法格式</h5><p>String对象的创建方式有2种：</p><p>方式1：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;…&quot;</span>) ; <span class="comment">//方式一</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello String&quot;</span>);</span><br></pre></td></tr></table></figure><p>方式2：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 = <span class="string">&quot;…&quot;</span> ; <span class="comment">//方式二</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;Hello String&#x27;</span>;</span><br></pre></td></tr></table></figure><p>按照上述的格式，在VS Code中创建为名03. JS-对象-String.html的文件，编写代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//创建字符串对象</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//var str = new String(&quot;Hello String&quot;);</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> str = <span class="string">&quot;  Hello String    &quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(str);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>浏览器控制台输出结果如下：</p><p><img src="https://bu.dusays.com/2024/04/29/662f1cc586d1f.png" alt="35.png"> </p><h5 id="属性和方法-1"><a href="#属性和方法-1" class="headerlink" title="属性和方法"></a>属性和方法</h5><p>String对象也提供了一些常用的属性和方法，如下表格所示：</p><p>属性：</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>length</td><td>字符串的长度。</td></tr></tbody></table><p>方法：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>charAt()</td><td>返回在指定位置的字符。</td></tr><tr><td>indexOf()</td><td>检索字符串。</td></tr><tr><td>trim()</td><td>去除字符串两边的空格</td></tr><tr><td>substring()</td><td>提取字符串中两个指定的索引号之间的字符。</td></tr></tbody></table><ul><li><p>length属性：</p><p>length属性可以用于返回字符串的长度，添加如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//length</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="property">length</span>);</span><br></pre></td></tr></table></figure></li><li><p>charAt()函数：</p><p>charAt()函数用于返回在指定索引位置的字符，函数的参数就是索引。添加如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">charAt</span>(<span class="number">4</span>));</span><br></pre></td></tr></table></figure></li><li><p>indexOf()函数</p><p>indexOf()函数用于检索指定内容在字符串中的索引位置的，返回值是索引，参数是指定的内容。添加如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">indexOf</span>(<span class="string">&quot;lo&quot;</span>));</span><br></pre></td></tr></table></figure></li><li><p>trim()函数</p><p>trim()函数用于去除字符串两边的空格的。添加如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = str.<span class="title function_">trim</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="property">length</span>);</span><br></pre></td></tr></table></figure></li><li><p>substring()函数</p><p>substring()函数用于截取字符串的，函数有2个参数。</p><p>参数1：表示从那个索引位置开始截取。包含</p><p>参数2：表示到那个索引位置结束。不包含</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="title function_">substring</span>(<span class="number">0</span>,<span class="number">5</span>));</span><br></pre></td></tr></table></figure></li></ul><p>整体代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS-对象-String<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//创建字符串对象</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//var str = new String(&quot;Hello String&quot;);</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> str = <span class="string">&quot;  Hello String    &quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(str);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//length</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="property">length</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//charAt</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">charAt</span>(<span class="number">4</span>));</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//indexOf</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">indexOf</span>(<span class="string">&quot;lo&quot;</span>));</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//trim</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> s = str.<span class="title function_">trim</span>();</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="property">length</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//substring(start,end) --- 开始索引, 结束索引 (含头不含尾)</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="title function_">substring</span>(<span class="number">0</span>,<span class="number">5</span>));</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>浏览器执行效果如图所示：</p><p><img src="https://bu.dusays.com/2024/04/29/662f1cc5a1ac7.png" alt="36.png"> </p><h4 id="1-5-1-3-JSON对象"><a href="#1-5-1-3-JSON对象" class="headerlink" title="1.5.1.3 JSON对象"></a>1.5.1.3 JSON对象</h4><h5 id="自定义对象"><a href="#自定义对象" class="headerlink" title="自定义对象"></a>自定义对象</h5><p>在 JavaScript 中自定义对象特别简单，其语法格式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 对象名 = &#123;</span><br><span class="line">    属性名<span class="number">1</span>: 属性值<span class="number">1</span>, </span><br><span class="line">    属性名<span class="number">2</span>: 属性值<span class="number">2</span>,</span><br><span class="line">    属性名<span class="number">3</span>: 属性值<span class="number">3</span>,</span><br><span class="line">    函数名称: <span class="keyword">function</span>(<span class="params">形参列表</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们可以通过如下语法调用属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象名.属性名</span><br></pre></td></tr></table></figure><p>通过如下语法调用函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象名.函数名()</span><br></pre></td></tr></table></figure><p>接下来，我们再VS Code中创建名为04. JS-对象-JSON.html的文件演示自定义对象</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//自定义对象</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> user = &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">name</span>: <span class="string">&quot;Tom&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">age</span>: <span class="number">10</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">gender</span>: <span class="string">&quot;male&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">eat</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">             <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;用膳~&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">         &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(user.<span class="property">name</span>);</span></span><br><span class="line"><span class="language-javascript">    user.<span class="title function_">eat</span>();</span></span><br><span class="line"><span class="language-javascript">&lt;script&gt;</span></span><br></pre></td></tr></table></figure><p>浏览器控制台结果如下：</p><p><img src="https://bu.dusays.com/2024/04/29/662f1cc5d1d4d.png" alt="37.png"></p><p>其中上述函数定义的语法可以简化成如下格式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Tom&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&quot;male&quot;</span>,</span><br><span class="line">    <span class="comment">// eat: function()&#123;</span></span><br><span class="line">    <span class="comment">//      console.log(&quot;用膳~&quot;);</span></span><br><span class="line">    <span class="comment">//  &#125;</span></span><br><span class="line">    <span class="title function_">eat</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;用膳~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="json对象"><a href="#json对象" class="headerlink" title="json对象"></a>json对象</h5><p>JSON对象：<strong>J</strong>ava<strong>S</strong>cript <strong>O</strong>bject <strong>N</strong>otation，JavaScript对象标记法。是通过JavaScript标记法书写的文本。其格式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;key&quot;</span>:value,</span><br><span class="line">    <span class="string">&quot;key&quot;</span>:value,</span><br><span class="line">    <span class="string">&quot;key&quot;</span>:value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<strong>key必须使用引号并且是双引号标记，value可以是任意数据类型。</strong></p><p>例如我们可以直接百度搜索“json在线解析”，随便挑一个进入，然后编写内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;name&quot;</span>: <span class="string">&quot;李传播&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://bu.dusays.com/2024/04/29/662f1cc6622eb.png" alt="38.png"> </p><p>但是当我们将双引号切换成单引号，再次校验，则报错，如下图所示：</p><p><img src="https://bu.dusays.com/2024/04/29/662f1cc692d1b.png" alt="39.png"></p><p>那么json这种数据格式的文本到底应用在企业开发的什么地方呢？– 经常用来作为前后台交互的数据载体</p><p>如下图所示：前后台交互时，我们需要传输数据，但是java中的对象我们该怎么去描述呢？我们可以使用如图所示的xml格式，可以清晰的描述java中需要传递给前端的java对象。</p><p><img src="https://bu.dusays.com/2024/04/29/662f1cc6b68cd.png" alt="40.png"> </p><p>但是xml格式存在如下问题：</p><ul><li>标签需要编写双份，占用带宽，浪费资源</li><li>解析繁琐</li></ul><p>所以我们可以使用json来替代，如下图所示：</p><p><img src="https://bu.dusays.com/2024/04/29/662f1cc6f2608.png" alt="42.png"> </p><p>接下来我们通过代码来演示json对象：注释掉之前的代码，编写代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonstr = <span class="string">&#x27;&#123;&quot;name&quot;:&quot;Tom&quot;, &quot;age&quot;:18, &quot;addr&quot;:[&quot;北京&quot;,&quot;上海&quot;,&quot;西安&quot;]&#125;&#x27;</span>;</span><br><span class="line"><span class="title function_">alert</span>(jsonstr.<span class="property">name</span>);</span><br></pre></td></tr></table></figure><p>浏览器输出结果如下：</p><p><img src="https://bu.dusays.com/2024/04/29/662f1cc7367fa.png" alt="44.png"> </p><p>为什么呢？<strong>因为上述是一个json字符串，不是json对象，所以我们需要借助如下函数来进行json字符串和json对象的转换。</strong>添加代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(jsonstr);</span><br><span class="line"><span class="title function_">alert</span>(obj.<span class="property">name</span>);</span><br></pre></td></tr></table></figure><p>此时浏览器输出结果如下：</p><p><img src="https://bu.dusays.com/2024/04/29/662f1cc78e1e9.png" alt="46.png"> </p><p>当然了，我们也可以通过如下函数将json对象再次转换成json字符串。添加如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj));</span><br></pre></td></tr></table></figure><p>浏览器输出结果如图所示：</p><p><img src="https://bu.dusays.com/2024/04/29/662f1cc7b1dd3.png" alt="47.png"> </p><p>整体全部代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS-对象-JSON<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//自定义对象</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// var user = &#123;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//     name: &quot;Tom&quot;,</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//     age: 10,</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//     gender: &quot;male&quot;,</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//     // eat: function()&#123;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//     //      console.log(&quot;用膳~&quot;);</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//     //  &#125;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//     eat()&#123;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//         console.log(&quot;用膳~&quot;);</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//     &#125;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// &#125;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// console.log(user.name);</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// user.eat();</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// //定义json</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> jsonstr = <span class="string">&#x27;&#123;&quot;name&quot;:&quot;Tom&quot;, &quot;age&quot;:18, &quot;addr&quot;:[&quot;北京&quot;,&quot;上海&quot;,&quot;西安&quot;]&#125;&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//alert(jsonstr.name);</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// //json字符串--js对象</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> obj = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(jsonstr);</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//alert(obj.name);</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// //js对象--json字符串</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj));</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-5-2-BOM对象"><a href="#1-5-2-BOM对象" class="headerlink" title="1.5.2 BOM对象"></a>1.5.2 BOM对象</h3><p>接下来我们学习BOM对象，BOM的全称是Browser Object Model,翻译过来是浏览器对象模型。也就是JavaScript将浏览器的各个组成部分封装成了对象。我们要操作浏览器的部分功能，可以通过操作BOM对象的相关属性或者函数来完成。例如：我们想要将浏览器的地址改为<code>http://www.baidu.com</code>,我们就可以通过BOM中提供的location对象的href属性来完成，代码如下：<code>location.href=&#39;http://www.baidu.com&#39;</code></p><p>BOM中提供了如下5个对象：</p><table><thead><tr><th align="left">对象名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">Window</td><td align="left">浏览器窗口对象</td></tr><tr><td align="left">Navigator</td><td align="left">浏览器对象</td></tr><tr><td align="left">Screen</td><td align="left">屏幕对象</td></tr><tr><td align="left">History</td><td align="left">历史记录对象</td></tr><tr><td align="left">Location</td><td align="left">d地址栏对象</td></tr></tbody></table><p>上述5个对象与浏览器各组成对应的关系如下图所示：</p><p><img src="https://bu.dusays.com/2024/04/29/662f1cc0d60c5.png" alt="103.png"> </p><p>对于上述5个对象，我们重点学习的是Window对象、Location对象这2个。</p><h4 id="1-5-2-1-Window对象"><a href="#1-5-2-1-Window对象" class="headerlink" title="1.5.2.1 Window对象"></a>1.5.2.1 Window对象</h4><p>window对象指的是浏览器窗口对象，是JavaScript的全部对象，所以对于window对象，我们可以直接使用，并且对于window对象的方法和属性，我们可以省略window.例如：我们之前学习的alert()函数其实是属于window对象的,其完整的代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.alert(&#x27;hello&#x27;);</span><br></pre></td></tr></table></figure><p>其可以省略window.  所以可以简写成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(&#x27;hello&#x27;)</span><br></pre></td></tr></table></figure><p>所以对于window对象的属性和方法，我们都是采用简写的方式。window提供了很多属性和方法，下表列出了常用属性和方法</p><p>window对象提供了获取其他BOM对象的属性：</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>history</td><td>用于获取history对象</td></tr><tr><td>location</td><td>用于获取location对象</td></tr><tr><td>Navigator</td><td>用于获取Navigator对象</td></tr><tr><td>Screen</td><td>用于获取Screen对象</td></tr></tbody></table><p>也就是说我们要使用location对象，只需要通过代码<code>window.location</code>或者简写<code>location</code>即可使用</p><p>window也提供了一些常用的函数，如下表格所示：</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>alert()</td><td>显示带有一段消息和一个确认按钮的警告框。</td></tr><tr><td>comfirm()</td><td>显示带有一段消息以及确认按钮和取消按钮的对话框。</td></tr><tr><td>setInterval()</td><td>按照指定的周期（以毫秒计）来调用函数或计算表达式。</td></tr><tr><td>setTimeout()</td><td>在指定的毫秒数后调用函数或计算表达式。</td></tr></tbody></table><p>接下来，我们通过VS Code中创建名为05. JS-对象-BOM.html文件来编写代码来演示上述函数：</p><ul><li><p>alert()函数：弹出警告框，函数的内容就是警告框的内容</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//window对象是全局对象，window对象的属性和方法在调用时可以省略window.</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="title function_">alert</span>(<span class="string">&quot;Hello BOM&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="string">&quot;Hello BOM Window&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>浏览器打开，依次弹框，此处只截图一张</p><p><img src="https://bu.dusays.com/2024/04/29/662f1cc86b21b.png" alt="49.png"> </p></li><li><p>confirm()函数：弹出确认框，并且提供用户2个按钮，分别是确认和取消。</p><p>添加如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">confirm</span>(<span class="string">&quot;您确认删除该记录吗?&quot;</span>);</span><br></pre></td></tr></table></figure><p>浏览器打开效果如图所示：</p><p><img src="https://bu.dusays.com/2024/04/29/662f1cc8aeeb2.png" alt="51.png"> </p><p>但是我们怎么知道用户点击了确认还是取消呢？所以这个函数有一个返回值，当用户点击确认时，返回true，点击取消时，返回false。我们根据返回值来决定是否执行后续操作。修改代码如下：再次运行，可以查看返回值true或者false</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> flag = <span class="title function_">confirm</span>(<span class="string">&quot;您确认删除该记录吗?&quot;</span>);</span><br><span class="line"><span class="title function_">alert</span>(flag);</span><br></pre></td></tr></table></figure></li><li><p>setInterval(fn,毫秒值)：定时器，用于周期性的执行某个功能，并且是<strong>循环执行</strong>。该函数需要传递2个参数：</p><p>fn:函数，需要周期性执行的功能代码</p><p>毫秒值：间隔时间</p><p>注释掉之前的代码，添加代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定时器 - setInterval -- 周期性的执行某一个函数</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">     i++;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;定时器执行了&quot;</span>+i+<span class="string">&quot;次&quot;</span>);</span><br><span class="line">&#125;,<span class="number">2000</span>);</span><br></pre></td></tr></table></figure><p>刷新页面，浏览器每个一段时间都会在控制台输出，结果如下：</p><p><img src="https://bu.dusays.com/2024/04/29/662f1cc9012b6.png" alt="53.png"> </p></li><li><p>setTimeout(fn,毫秒值) ：定时器，只会在一段时间后<strong>执行一次功能</strong>。参数和上述setInterval一致</p><p>注释掉之前的代码，添加代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定时器 - setTimeout -- 延迟指定时间执行一次 </span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;JS&quot;</span>);</span><br><span class="line">&#125;,<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>浏览器打开，3s后弹框，关闭弹框，发现再也不会弹框了。</p></li></ul><h4 id="1-5-2-2-Location对象"><a href="#1-5-2-2-Location对象" class="headerlink" title="1.5.2.2 Location对象"></a>1.5.2.2 Location对象</h4><p>location是指代浏览器的地址栏对象，对于这个对象，我们常用的是href属性，用于获取或者设置浏览器的地址信息，添加如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取浏览器地址栏信息</span></span><br><span class="line"><span class="title function_">alert</span>(location.<span class="property">href</span>);</span><br><span class="line"><span class="comment">//设置浏览器地址栏信息</span></span><br><span class="line">location.<span class="property">href</span> = <span class="string">&quot;https://www.itcast.cn&quot;</span>;</span><br></pre></td></tr></table></figure><p>浏览器效果如下：首先弹框展示浏览器地址栏信息，</p><p><img src="https://bu.dusays.com/2024/04/29/662f1cc944a9b.png" alt="55.png"> </p><p>然后点击确定后，因为我们设置了地址栏信息，所以浏览器跳转到传智首页</p><p>完整代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS-对象-BOM<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//获取</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// window.alert(&quot;Hello BOM&quot;);</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// alert(&quot;Hello BOM Window&quot;);</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//方法</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//confirm - 对话框 -- 确认: true , 取消: false</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// var flag = confirm(&quot;您确认删除该记录吗?&quot;);</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// alert(flag);</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//定时器 - setInterval -- 周期性的执行某一个函数</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// var i = 0;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// setInterval(function()&#123;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//     i++;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//     console.log(&quot;定时器执行了&quot;+i+&quot;次&quot;);</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// &#125;,2000);</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//定时器 - setTimeout -- 延迟指定时间执行一次 </span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// setTimeout(function()&#123;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//     alert(&quot;JS&quot;);</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// &#125;,3000);</span></span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//location</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(location.<span class="property">href</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    location.<span class="property">href</span> = <span class="string">&quot;https://www.itcast.cn&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-5-3-DOM对象"><a href="#1-5-3-DOM对象" class="headerlink" title="1.5.3 DOM对象"></a>1.5.3 DOM对象</h3><h4 id="1-5-3-1-DOM介绍"><a href="#1-5-3-1-DOM介绍" class="headerlink" title="1.5.3.1 DOM介绍"></a>1.5.3.1 DOM介绍</h4><p>DOM：Document Object Model 文档对象模型。也就是 JavaScript 将 HTML 文档的各个组成部分封装为对象。</p><p>DOM 其实我们并不陌生，之前在学习 XML 就接触过，只不过 XML 文档中的标签需要我们写代码解析，而 HTML 文档是浏览器解析。封装的对象分为</p><ul><li>Document：整个文档对象</li><li>Element：元素对象</li><li>Attribute：属性对象</li><li>Text：文本对象</li><li>Comment：注释对象</li></ul><p>如下图，左边是 HTML 文档内容，右边是 DOM 树</p><p><img src="https://bu.dusays.com/2024/04/29/662f1cc97d2ac.png" alt="56.png"> </p><p>那么我们学习DOM技术有什么用呢？主要作用如下：</p><ul><li>改变 HTML 元素的内容</li><li>改变 HTML 元素的样式（CSS）</li><li>对 HTML DOM 事件作出反应</li><li>添加和删除 HTML 元素</li></ul><p>总而达到动态改变页面效果目的，具体我们可以查看代码中提供的06. JS-对象-DOM-演示.html来体会DOM的效果。</p><h4 id="1-5-3-2-获取DOM对象"><a href="#1-5-3-2-获取DOM对象" class="headerlink" title="1.5.3.2 获取DOM对象"></a>1.5.3.2 获取DOM对象</h4><p>我们知道DOM的作用是通过修改HTML元素的内容和样式等来实现页面的各种动态效果，但是我们要操作DOM对象的前提是先获取元素对象，然后才能操作。所以学习DOM,主要的核心就是学习如下2点：</p><ul><li>如何获取DOM中的元素对象（Element对象 ，也就是标签）</li><li>如何操作Element对象的属性,也就是标签的属性。</li></ul><p>接下来我们先来学习如何获取DOM中的元素对象。</p><p>HTML中的Element对象可以通过Document对象获取，而Document对象是通过window对象获取的。document对象提供的用于获取Element元素对象的api如下表所示：</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>document.getElementById()</td><td>根据id属性值获取，返回单个Element对象</td></tr><tr><td>document.getElementsByTagName()</td><td>根据标签名称获取，返回Element对象数组</td></tr><tr><td>document.getElementsByName()</td><td>根据name属性值获取，返回Element对象数组</td></tr><tr><td>document.getElementsByClassName()</td><td>根据class属性值获取，返回Element对象数组</td></tr></tbody></table><p>接下来我们通过VS Code中创建名为07. JS-对象-DOM-获取元素.html的文件来演示上述api，首先在准备如下页面代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS-对象-DOM<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">&quot;h1&quot;</span> <span class="attr">src</span>=<span class="string">&quot;img/off.gif&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cls&quot;</span>&gt;</span>传智教育<span class="tag">&lt;/<span class="name">div</span>&gt;</span>   <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cls&quot;</span>&gt;</span>黑马程序员<span class="tag">&lt;/<span class="name">div</span>&gt;</span>  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span>&gt;</span> 电影</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span>&gt;</span> 旅游</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span>&gt;</span> 游戏</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>document.getElementById()： 根据标签的id属性获取标签对象，id是唯一的，所以获取到是单个标签对象。</p><p>添加如下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">//1. 获取Element元素</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">//1.1 获取元素-根据ID获取</span></span></span><br><span class="line"><span class="language-javascript"> <span class="keyword">var</span> img = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;h1&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"> <span class="title function_">alert</span>(img);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>浏览器打开，效果如图所示：从弹出的结果能够看出，这是一个图片标签对象</p><p><img src="https://bu.dusays.com/2024/04/29/662f1cc9876b9.png" alt="57.png"> </p></li><li><p>document.getElementsByTagName() :  根据标签的名字获取标签对象，同名的标签有很多，所以返回值是数组。</p><p>添加如下代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.2 获取元素-根据标签获取 - div</span></span><br><span class="line"><span class="keyword">var</span> divs = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; divs.<span class="property">length</span>; i++) &#123;</span><br><span class="line">     <span class="title function_">alert</span>(divs[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>浏览器输出2次如下所示的弹框</p><p><img src="https://bu.dusays.com/2024/04/29/662f1cca11f08.png" alt="58.png"> </p></li><li><p>document.getElementsByName() ：根据标签的name的属性值获取标签对象，name属性值可以重复，所以返回值是一个数组。</p><p>添加如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.3 获取元素-根据name属性获取</span></span><br><span class="line"><span class="keyword">var</span> ins = <span class="variable language_">document</span>.<span class="title function_">getElementsByName</span>(<span class="string">&#x27;hobby&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; ins.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(ins[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>浏览器会有3次如下图所示的弹框：</p><p><img src="https://bu.dusays.com/2024/04/29/662f1cca2c0b8.png" alt="59.png">  </p></li><li><p>document.getElementsByClassName() : 根据标签的class属性值获取标签对象，class属性值也可以重复，返回值是数组。</p><p>添加如下图所示的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.4 获取元素-根据class属性获取</span></span><br><span class="line"><span class="keyword">var</span> divs = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;cls&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; divs.<span class="property">length</span>; i++) &#123;</span><br><span class="line">     <span class="title function_">alert</span>(divs[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>浏览器会弹框2次，都是div标签对象</p><p><img src="https://bu.dusays.com/2024/04/29/662f1cca6ce43.png" alt="60.png"> </p></li><li><p>操作属性</p><p>那么获取到标签了，我们如何操作标签的属性呢？通过查询文档资料，如下图所示：</p><p><img src="https://bu.dusays.com/2024/04/29/662f1ccac0aa5.png" alt="61.png"> </p><p>得出我们可以通过div标签对象的innerHTML属性来修改标签的内容。此时我们想把页面中的<strong>传智教育替换成传智教育666</strong>，所以要获取2个div中的第一个，所以可以通过下标0获取数组中的第一个div，注释之前的代码，编写如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> divs = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;cls&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> div1 = divs[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">div1.<span class="property">innerHTML</span> = <span class="string">&quot;传智教育666&quot;</span>;</span><br></pre></td></tr></table></figure><p>浏览器刷新页面，展示效果如下图所示：</p><p><img src="https://bu.dusays.com/2024/04/29/662f1ccabc371.png" alt="62.png"> </p><p>发现页面内容变成了传智教育666</p></li></ul><p>完整代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS-对象-DOM<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">&quot;h1&quot;</span> <span class="attr">src</span>=<span class="string">&quot;img/off.gif&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cls&quot;</span>&gt;</span>传智教育<span class="tag">&lt;/<span class="name">div</span>&gt;</span>   <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cls&quot;</span>&gt;</span>黑马程序员<span class="tag">&lt;/<span class="name">div</span>&gt;</span>  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span>&gt;</span> 电影</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span>&gt;</span> 旅游</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span>&gt;</span> 游戏</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//1. 获取Element元素</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//1.1 获取元素-根据ID获取</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// var img = document.getElementById(&#x27;h1&#x27;);</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// alert(img);</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//1.2 获取元素-根据标签获取 - div</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// var divs = document.getElementsByTagName(&#x27;div&#x27;);</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// for (let i = 0; i &lt; divs.length; i++) &#123;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//     alert(divs[i]);</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// &#125;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//1.3 获取元素-根据name属性获取</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// var ins = document.getElementsByName(&#x27;hobby&#x27;);</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// for (let i = 0; i &lt; ins.length; i++) &#123;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//     alert(ins[i]);</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// &#125;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//1.4 获取元素-根据class属性获取</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// var divs = document.getElementsByClassName(&#x27;cls&#x27;);</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// for (let i = 0; i &lt; divs.length; i++) &#123;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//     alert(divs[i]);</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// &#125;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//2. 查询参考手册, 属性、方法</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> divs = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;cls&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> div1 = divs[<span class="number">0</span>];</span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript">    div1.<span class="property">innerHTML</span> = <span class="string">&quot;传智教育666&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-5-4-案例"><a href="#1-5-4-案例" class="headerlink" title="1.5.4 案例"></a>1.5.4 案例</h3><h4 id="1-5-4-1-需求说明"><a href="#1-5-4-1-需求说明" class="headerlink" title="1.5.4.1 需求说明"></a>1.5.4.1 需求说明</h4><p>鲁迅说的好，光说不练假把式,光练不说傻把式。所以接下来我们需要通过案例来加强对于上述DOM知识的掌握。需求如下3个：</p><ul><li>点亮灯泡</li><li>将所有的div标签的标签体内容后面加上：very good</li><li>使所有的复选框呈现被选中的状态</li></ul><p>效果如下所示：</p><p><img src="https://bu.dusays.com/2024/04/29/662f1ccaec78a.png" alt="63.png"> </p><h4 id="1-5-4-2-资料准备"><a href="#1-5-4-2-资料准备" class="headerlink" title="1.5.4.2 资料准备"></a>1.5.4.2 资料准备</h4><p>在JS目录下，也就是用于存放html文件的同级创建img文件下，然后将<code>资料/图片素材</code>中提供的2张图片拷贝到img文件夹中，最终整体结果如下图所示：</p><p><img src="https://bu.dusays.com/2024/04/29/662f1ccbb4364.png" alt="68.png"> </p><p>在VS Code中创建名为08. JS-对象-DOM-案例.html的文件，然后准备如下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS-对象-DOM-案例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">&quot;h1&quot;</span> <span class="attr">src</span>=<span class="string">&quot;img/off.gif&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cls&quot;</span>&gt;</span>传智教育<span class="tag">&lt;/<span class="name">div</span>&gt;</span>   <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cls&quot;</span>&gt;</span>黑马程序员<span class="tag">&lt;/<span class="name">div</span>&gt;</span>  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span>&gt;</span> 电影</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span>&gt;</span> 旅游</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span>&gt;</span> 游戏</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>浏览器打开此时效果如图所示：</p><p><img src="https://bu.dusays.com/2024/04/29/662f1ccb2ecf3.png" alt="65.png"> </p><h4 id="1-5-4-3-需求1"><a href="#1-5-4-3-需求1" class="headerlink" title="1.5.4.3 需求1"></a>1.5.4.3 需求1</h4><ul><li><p>需求</p><p>点亮灯泡</p></li><li><p>分析</p><p>此时我们需要把灯泡点亮，其实就是换一张图片。那么我们需要切换图片，就需要操作图片的src属性。要操作图片的src属性，就需要先来获取img标签对象。</p></li><li><p>步骤</p><ul><li>首先获取img标签对象</li><li>然后修改img标签对象的src属性值，进行图片的切换</li></ul></li><li><p>代码实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 点亮灯泡 : src 属性值</span></span><br><span class="line"><span class="comment">//首先获取img标签对象</span></span><br><span class="line"><span class="keyword">var</span> img = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;h1&#x27;</span>);</span><br><span class="line"><span class="comment">//然后修改img标签对象的src属性值，进行图片的切换</span></span><br><span class="line">img.<span class="property">src</span> = <span class="string">&quot;img/on.gif&quot;</span>;</span><br></pre></td></tr></table></figure></li></ul><p>浏览器打开，效果如图所示：</p><p><img src="https://bu.dusays.com/2024/04/29/662f1ccc31186.png" alt="70.png"> </p><h4 id="1-5-4-4-需求2"><a href="#1-5-4-4-需求2" class="headerlink" title="1.5.4.4 需求2"></a>1.5.4.4 需求2</h4><ul><li><p>需求</p><p>将所有的div标签的标签体内容后面加上：very good  </p><p>并且very good是红色字体</p></li><li><p>分析</p><p>我们需要在原有内容后面追加红色的very good.所以我们首先需要获取原有内容，然后再进行内容的追加。但是如何保证very good是红色的呢？所以我们可以通过之前html中学过的&lt;font&gt;标签和属性来完整。如何进行内容的替换呢？之前我们学习过innerHTML属性。需要替换2个div的内容，所以我们需要获取2个div，并且遍历进行替换。</p></li><li><p>步骤</p><ul><li>通过标签的名字div获取所有的div标签</li><li>遍历所有的div标签</li><li>获取div标签的原有内容，然后追加&lt;font color&#x3D;’red’&gt;very good&lt;&#x2F;font&gt;,并且替原内容</li></ul></li><li><p>代码实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2. 将所有div标签的内容后面加上: very good (红色字体) -- &lt;font color=&#x27;red&#x27;&gt;&lt;/font&gt;</span></span><br><span class="line"><span class="keyword">var</span> divs = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; divs.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> div = divs[i];</span><br><span class="line">    div.<span class="property">innerHTML</span> += <span class="string">&quot;&lt;font color=&#x27;red&#x27;&gt;very good&lt;/font&gt;&quot;</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>浏览器打开效果如图所示：</p><p><img src="https://bu.dusays.com/2024/04/29/662f1ccc89e94.png" alt="71.png"> </p><h4 id="1-5-4-5-需求3"><a href="#1-5-4-5-需求3" class="headerlink" title="1.5.4.5 需求3"></a>1.5.4.5 需求3</h4><ul><li><p>需求</p><p>使所有的复选框呈现被选中的状态</p></li><li><p>分析</p><p>要让复选框处于选中状态，那么什么属性或者方法可以使复选框选中？可以查询资料得出checkbox标签对象的checked属性设置为true，可以改变checkbox为选中状态。那么需要设置所有的checkbox，那么我们需要获取所有的checkbox并且遍历</p></li><li><p>步骤</p><ul><li>可以通过name属性值获取所有的checkbox标签</li><li>遍历所有的checkbox标签，</li><li>设置每个checkbox标签的</li></ul></li><li><p>代码实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// //3. 使所有的复选框呈现选中状态</span></span><br><span class="line"><span class="keyword">var</span> ins = <span class="variable language_">document</span>.<span class="title function_">getElementsByName</span>(<span class="string">&#x27;hobby&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; ins.<span class="property">length</span>; i++) &#123;</span><br><span class="line"><span class="keyword">const</span> check = ins[i];</span><br><span class="line">check.<span class="property">checked</span> = <span class="literal">true</span>;<span class="comment">//选中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>浏览器刷新，效果如图所示:</p><p><img src="https://bu.dusays.com/2024/04/29/662f1cccac230.png" alt="72.png"> </p><h4 id="1-5-4-6-完整代码"><a href="#1-5-4-6-完整代码" class="headerlink" title="1.5.4.6 完整代码"></a>1.5.4.6 完整代码</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS-对象-DOM-案例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">&quot;h1&quot;</span> <span class="attr">src</span>=<span class="string">&quot;img/off.gif&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cls&quot;</span>&gt;</span>传智教育<span class="tag">&lt;/<span class="name">div</span>&gt;</span>   <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cls&quot;</span>&gt;</span>黑马程序员<span class="tag">&lt;/<span class="name">div</span>&gt;</span>  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span>&gt;</span> 电影</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span>&gt;</span> 旅游</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span>&gt;</span> 游戏</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//1. 点亮灯泡 : src 属性值</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> img = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;h1&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    img.<span class="property">src</span> = <span class="string">&quot;img/on.gif&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//2. 将所有div标签的内容后面加上: very good (红色字体) -- &lt;font color=&#x27;red&#x27;&gt;&lt;/font&gt;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> divs = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;div&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; divs.<span class="property">length</span>; i++) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> div = divs[i];</span></span><br><span class="line"><span class="language-javascript">        div.<span class="property">innerHTML</span> += <span class="string">&quot;&lt;font color=&#x27;red&#x27;&gt;very good&lt;/font&gt;&quot;</span>; </span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// //3. 使所有的复选框呈现选中状态</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> ins = <span class="variable language_">document</span>.<span class="title function_">getElementsByName</span>(<span class="string">&#x27;hobby&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; ins.<span class="property">length</span>; i++) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> check = ins[i];</span></span><br><span class="line"><span class="language-javascript">        check.<span class="property">checked</span> = <span class="literal">true</span>;<span class="comment">//选中</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="1-6-JavaScript事件"><a href="#1-6-JavaScript事件" class="headerlink" title="1.6 JavaScript事件"></a>1.6 JavaScript事件</h2><h3 id="1-6-1-事件介绍"><a href="#1-6-1-事件介绍" class="headerlink" title="1.6.1 事件介绍"></a>1.6.1 事件介绍</h3><p>如下图所示的百度注册页面，当我们用户输入完内容，百度可以自动的提示我们用户名已经存在还是可以使用。那么百度是怎么知道我们用户名输入完了呢？这就需要用到JavaScript中的事件了。</p><p><img src="https://bu.dusays.com/2024/04/29/662f1ccd14e84.png" alt="74.png"> </p><p>什么是事件呢？HTML事件是发生在HTML元素上的 “事情”，例如：</p><ul><li>按钮被点击</li><li>鼠标移到元素上</li><li>输入框失去焦点</li><li>……..</li></ul><p>而我们可以给这些事件绑定函数，当事件触发时，可以自动的完成对应的功能。这就是事件监听。例如：对于我们所说的百度注册页面，我们给用户名输入框的失去焦点事件绑定函数，当我们用户输入完内容，在标签外点击了鼠标，对于用户名输入框来说，失去焦点，然后执行绑定的函数，函数进行用户名内容的校验等操作。JavaScript事件是js非常重要的一部分，接下来我们进行事件的学习。那么我们对于JavaScript事件需要学习哪些内容呢？我们得知道有哪些常用事件，然后我们得学会如何给事件绑定函数。所以主要围绕2点来学习：</p><ul><li>事件绑定</li><li>常用事件</li></ul><h3 id="1-6-2-事件绑定"><a href="#1-6-2-事件绑定" class="headerlink" title="1.6.2 事件绑定"></a>1.6.2 事件绑定</h3><p>JavaScript对于事件的绑定提供了2种方式：</p><ul><li><p>方式1：通过html标签中的事件属性进行绑定</p><p>例如一个按钮，我们对于按钮可以绑定单机事件，可以借助标签的onclick属性，属性值指向一个函数。</p><p>在VS Code中创建名为09. JS-事件-事件绑定.html，添加如下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&quot;btn1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;事件绑定1&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;on()&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>很明显没有on函数，所以我们需要创建该函数，代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">on</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(<span class="string">&quot;按钮1被点击了...&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>浏览器打开，然后点击按钮，弹框如下：</p><p><img src="https://bu.dusays.com/2024/04/29/662f1ccd1b168.png" alt="75.png"> </p></li><li><p>方式2：通过DOM中Element元素的事件属性进行绑定</p><p>依据我们学习过得DOM的知识点，我们知道html中的标签被加载成element对象，所以我们也可以通过element对象的属性来操作标签的属性。此时我们再次添加一个按钮，代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&quot;btn2&quot;</span> <span class="attr">value</span>=<span class="string">&quot;事件绑定2&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们可以先通过id属性获取按钮对象，然后操作对象的onclick属性来绑定事件，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn2&#x27;</span>).<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;按钮2被点击了...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>浏览器刷新页面，点击第二个按钮，弹框如下：</p><p><img src="https://bu.dusays.com/2024/04/29/662f1ccd3ccbe.png" alt="76.png"> </p><p><strong>需要注意的是：事件绑定的函数，只有在事件被触发时，函数才会被调用。</strong></p><p>整体代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS-事件-事件绑定<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&quot;btn1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;事件绑定1&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;on()&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&quot;btn2&quot;</span> <span class="attr">value</span>=<span class="string">&quot;事件绑定2&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">on</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(<span class="string">&quot;按钮1被点击了...&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn2&#x27;</span>).<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(<span class="string">&quot;按钮2被点击了...&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-6-3-常见事件"><a href="#1-6-3-常见事件" class="headerlink" title="1.6.3 常见事件"></a>1.6.3 常见事件</h3><p>上面案例中使用到了 <code>onclick</code> 事件属性，那都有哪些事件属性供我们使用呢？下面就给大家列举一些比较常用的事件属性</p><table><thead><tr><th>事件属性名</th><th>说明</th></tr></thead><tbody><tr><td>onclick</td><td>鼠标单击事件</td></tr><tr><td>onblur</td><td>元素失去焦点</td></tr><tr><td>onfocus</td><td>元素获得焦点</td></tr><tr><td>onload</td><td>某个页面或图像被完成加载</td></tr><tr><td>onsubmit</td><td>当表单提交时触发该事件</td></tr><tr><td>onmouseover</td><td>鼠标被移到某元素之上</td></tr><tr><td>onmouseout</td><td>鼠标从某元素移开</td></tr></tbody></table><p>在代码中提供了10. JS-事件-常见事件.html的文件，我们可以通过浏览器打开来观察几个常用事件的具体效果：</p><ul><li><p>onfocus:获取焦点事件，鼠标点击输入框，输入框中光标一闪一闪的，就是输入框获取焦点了</p><p><img src="https://bu.dusays.com/2024/04/29/662f1ccda104a.png" alt="78.png"> </p></li><li><p>onblur:失去焦点事件，前提是输入框获取焦点的状态下，在输入框之外的地方点击，光标从输入框中消失了，这就是失去焦点。</p><p><img src="https://bu.dusays.com/2024/04/29/662f1ccdda59e.png" alt="79.png"></p></li></ul><p>其他事件的效果，同学们可以通过提供好的代码去演示，亲身体会事件在什么时候触发。</p><h3 id="1-6-4-案例"><a href="#1-6-4-案例" class="headerlink" title="1.6.4 案例"></a>1.6.4 案例</h3><h4 id="1-6-4-1-需求说明"><a href="#1-6-4-1-需求说明" class="headerlink" title="1.6.4.1 需求说明"></a>1.6.4.1 需求说明</h4><p>接下来我们通过案例来加强所学js知识点的掌握。</p><p>需求如下3个：</p><ol><li>点击 “点亮”按钮 点亮灯泡，点击“熄灭”按钮 熄灭灯泡</li><li>输入框鼠标聚焦后，展示小写；鼠标离焦后，展示大写。</li><li>点击 “全选”按钮使所有的复选框呈现被选中的状态，点击 “反选”按钮使所有的复选框呈现取消勾选的状态。</li></ol><p>效果如图所示：</p><p><img src="https://bu.dusays.com/2024/04/29/662f1cced9082.png" alt="83.png"> </p><h4 id="1-6-4-2-资料准备"><a href="#1-6-4-2-资料准备" class="headerlink" title="1.6.4.2 资料准备"></a>1.6.4.2 资料准备</h4><p>在VS  Code中创建名为11. JS-事件-案例.html的文件，提前准备如下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS-事件-案例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">&quot;light&quot;</span> <span class="attr">src</span>=<span class="string">&quot;img/off.gif&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;点亮&quot;</span> &gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span>  <span class="attr">value</span>=<span class="string">&quot;熄灭&quot;</span> &gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ITCAST&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span>&gt;</span> 电影</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span>&gt;</span> 旅游</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span>&gt;</span> 游戏</span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;全选&quot;</span> &gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;反选&quot;</span> &gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>浏览器打开如图所示：</p><p><img src="https://bu.dusays.com/2024/04/29/662f1ccedcf08.png" alt="84.png"> </p><h4 id="1-6-4-3-需求1"><a href="#1-6-4-3-需求1" class="headerlink" title="1.6.4.3 需求1"></a>1.6.4.3 需求1</h4><ul><li><p>需求：</p><p>点击 “点亮”按钮 点亮灯泡，点击“熄灭”按钮 熄灭灯泡</p></li><li><p>分析：</p><p>点击按钮的时候触发，所以我们需要绑定单击事件。不管是点亮还是熄灭，都是图片的变化，所以我们需要修改图片。但是修改图片我们还需要先获取标签图片标签对象。</p></li><li><p>步骤：</p><ul><li>首先给点亮按钮和熄灭按钮都绑定单击事件。分别绑定函数on()和off（）</li><li>然后在js中定义on()和off()函数</li><li>on()函数中，通过id获取img标签对象，然后通过img标签对象的src属性切换点亮的图片</li><li>off()函数中，通过id获取img标签对象，然后通过img标签对象的src属性切换熄灭的图片</li></ul></li><li><p>代码实现：</p><p>事件绑定</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;点亮&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;on()&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span>  <span class="attr">value</span>=<span class="string">&quot;熄灭&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;off()&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>on()和off()函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 点击 &quot;点亮&quot; 按钮, 点亮灯泡; 点击 &quot;熄灭&quot; 按钮, 熄灭灯泡; -- onclick</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">on</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//a. 获取img元素对象</span></span><br><span class="line">    <span class="keyword">var</span> img = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;light&quot;</span>);</span><br><span class="line">    <span class="comment">//b. 设置src属性</span></span><br><span class="line">    img.<span class="property">src</span> = <span class="string">&quot;img/on.gif&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">off</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//a. 获取img元素对象</span></span><br><span class="line">    <span class="keyword">var</span> img = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;light&quot;</span>);</span><br><span class="line">    <span class="comment">//b. 设置src属性</span></span><br><span class="line">    img.<span class="property">src</span> = <span class="string">&quot;img/off.gif&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-6-4-4-需求2"><a href="#1-6-4-4-需求2" class="headerlink" title="1.6.4.4 需求2"></a>1.6.4.4 需求2</h4><ul><li><p>需求：</p><p>输入框鼠标聚焦后，展示小写；鼠标离焦后，展示大写。</p></li><li><p>分析：</p><p>聚焦和失焦的时候完成功能，所以我们需要给input标签绑定onfocus和onblur事件；我们要切换大小写，那么我们可定要获取原本输入框的内容，通过查询资料，需要使用input标签对象的value属性，然后进行大小写切换；切换完成我们需要重新填入，所以还是通过value属性来设置input标签输入框的内容</p></li><li><p>步骤:</p><ul><li>给input标签的onfocus和onblur事件分别绑定lower()和upper()函数</li><li>然后在js中定义lower()和upper()函数</li><li>对于lower()函数，先通过id获取输入框对象，然后通过输入框的value属性来设置内容，内容的话可以通过字符串的toLowerCase()函数来进行小写转换</li><li>对于upper()函数，先通过id获取输入框对象，然后通过输入框的value属性来设置内容，内容的话可以通过字符串的toupperCase()函数来进行大写转换</li></ul></li><li><p>代码实现：、</p><p>事件绑定：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ITCAST&quot;</span> <span class="attr">onfocus</span>=<span class="string">&quot;lower()&quot;</span> <span class="attr">onblur</span>=<span class="string">&quot;upper()&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>lower()和upper()函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2. 输入框聚焦后, 展示小写; 输入框离焦后, 展示大写; -- onfocus , onblur</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">lower</span>(<span class="params"></span>)&#123;<span class="comment">//小写</span></span><br><span class="line">    <span class="comment">//a. 获取输入框元素对象</span></span><br><span class="line">    <span class="keyword">var</span> input = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//b. 将值转为小写</span></span><br><span class="line">    input.<span class="property">value</span> = input.<span class="property">value</span>.<span class="title function_">toLowerCase</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">upper</span>(<span class="params"></span>)&#123;<span class="comment">//大写</span></span><br><span class="line">    <span class="comment">//a. 获取输入框元素对象</span></span><br><span class="line">    <span class="keyword">var</span> input = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//b. 将值转为大写</span></span><br><span class="line">    input.<span class="property">value</span> = input.<span class="property">value</span>.<span class="title function_">toUpperCase</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-6-4-5-需求3"><a href="#1-6-4-5-需求3" class="headerlink" title="1.6.4.5 需求3"></a>1.6.4.5 需求3</h4><ul><li><p>需求：</p><p>点击 “全选”按钮使所有的复选框呈现被选中的状态，点击 “反选”按钮使所有的复选框呈现取消勾选的状态。</p></li><li><p>分析：</p><p>点击按钮完成功能，所以我们需要给2个按钮绑定单击事件；我们需要设置所有复选框的状态，通过我们之前的案例，我们知道，我们需要获取所有的复选框，然后遍历，可以通过设置checked属性为true，来设置复选框为选中；那么反之，设置checked属性为false，来设置复选框为未选中。</p></li><li><p>步骤：</p><ul><li>给全选和反选按钮绑定单击事件，分别绑定函数checkAll()和reverse()</li><li>在js中定义checkAll()和reverse()函数</li><li>对于checkAll()函数，首先通过name属性值为hobby来获取所有的复选框，然后遍历复选框，设置每个复选框的checked属性为true即可</li><li>对于reverse()函数，首先通过name属性值为hobby来获取所有的复选框，然后遍历复选框，设置每个复选框的checked属性为false即可</li></ul></li><li><p>代码实现：</p><p>事件绑定：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;全选&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;checkAll()&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;反选&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;reverse()&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>checkAll()和reverse()函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//3. 点击 &quot;全选&quot; 按钮使所有的复选框呈现选中状态 ; 点击 &quot;反选&quot; 按钮使所有的复选框呈现取消勾选的状态 ; </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">checkAll</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//a. 获取所有复选框元素对象</span></span><br><span class="line">    <span class="keyword">var</span> hobbys = <span class="variable language_">document</span>.<span class="title function_">getElementsByName</span>(<span class="string">&quot;hobby&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//b. 设置选中状态</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; hobbys.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> element = hobbys[i];</span><br><span class="line">        element.<span class="property">checked</span> = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reverse</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//a. 获取所有复选框元素对象</span></span><br><span class="line">    <span class="keyword">var</span> hobbys = <span class="variable language_">document</span>.<span class="title function_">getElementsByName</span>(<span class="string">&quot;hobby&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//b. 设置未选中状态</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; hobbys.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> element = hobbys[i];</span><br><span class="line">        element.<span class="property">checked</span> = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-6-4-6-完整代码"><a href="#1-6-4-6-完整代码" class="headerlink" title="1.6.4.6 完整代码"></a>1.6.4.6 完整代码</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS-事件-案例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">&quot;light&quot;</span> <span class="attr">src</span>=<span class="string">&quot;img/off.gif&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;点亮&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;on()&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span>  <span class="attr">value</span>=<span class="string">&quot;熄灭&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;off()&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ITCAST&quot;</span> <span class="attr">onfocus</span>=<span class="string">&quot;lower()&quot;</span> <span class="attr">onblur</span>=<span class="string">&quot;upper()&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span>&gt;</span> 电影</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span>&gt;</span> 旅游</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span>&gt;</span> 游戏</span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;全选&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;checkAll()&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;反选&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;reverse()&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//1. 点击 &quot;点亮&quot; 按钮, 点亮灯泡; 点击 &quot;熄灭&quot; 按钮, 熄灭灯泡; -- onclick</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">on</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//a. 获取img元素对象</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> img = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;light&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//b. 设置src属性</span></span></span><br><span class="line"><span class="language-javascript">        img.<span class="property">src</span> = <span class="string">&quot;img/on.gif&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">off</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//a. 获取img元素对象</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> img = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;light&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//b. 设置src属性</span></span></span><br><span class="line"><span class="language-javascript">        img.<span class="property">src</span> = <span class="string">&quot;img/off.gif&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//2. 输入框聚焦后, 展示小写; 输入框离焦后, 展示大写; -- onfocus , onblur</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">lower</span>(<span class="params"></span>)&#123;<span class="comment">//小写</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//a. 获取输入框元素对象</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> input = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;name&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//b. 将值转为小写</span></span></span><br><span class="line"><span class="language-javascript">        input.<span class="property">value</span> = input.<span class="property">value</span>.<span class="title function_">toLowerCase</span>();</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">upper</span>(<span class="params"></span>)&#123;<span class="comment">//大写</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//a. 获取输入框元素对象</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> input = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;name&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//b. 将值转为大写</span></span></span><br><span class="line"><span class="language-javascript">        input.<span class="property">value</span> = input.<span class="property">value</span>.<span class="title function_">toUpperCase</span>();</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//3. 点击 &quot;全选&quot; 按钮使所有的复选框呈现选中状态 ; 点击 &quot;反选&quot; 按钮使所有的复选框呈现取消勾选的状态 ; -- onclick</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">checkAll</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//a. 获取所有复选框元素对象</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> hobbys = <span class="variable language_">document</span>.<span class="title function_">getElementsByName</span>(<span class="string">&quot;hobby&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//b. 设置选中状态</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; hobbys.<span class="property">length</span>; i++) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> element = hobbys[i];</span></span><br><span class="line"><span class="language-javascript">            element.<span class="property">checked</span> = <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">reverse</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//a. 获取所有复选框元素对象</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> hobbys = <span class="variable language_">document</span>.<span class="title function_">getElementsByName</span>(<span class="string">&quot;hobby&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//b. 设置未选中状态</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; hobbys.<span class="property">length</span>; i++) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> element = hobbys[i];</span></span><br><span class="line"><span class="language-javascript">            element.<span class="property">checked</span> = <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="2-Vue"><a href="#2-Vue" class="headerlink" title="2 Vue"></a>2 Vue</h1><h2 id="2-1-Vue概述"><a href="#2-1-Vue概述" class="headerlink" title="2.1 Vue概述"></a>2.1 Vue概述</h2><p>通过我们学习的html+css+js已经能够开发美观的页面了，但是开发的效率还有待提高，那么如何提高呢？我们先来分析下页面的组成。一个完整的html页面包括了视图和数据，数据是通过请求 从后台获取的，那么意味着我们需要将后台获取到的数据呈现到页面上，很明显， 这就需要我们使用DOM操作。正因为这种开发流程，所以我们引入了一种叫做<strong>MVVM(Model-View-ViewModel)的前端开发思想</strong>，即让我们开发者更加关注数据，而非数据绑定到视图这种机械化的操作。那么具体什么是MVVM思想呢？</p><p>MVVM:其实是Model-View-ViewModel的缩写，有3个单词，具体释义如下：</p><ul><li>Model: 数据模型，特指前端中通过请求从后台获取的数据</li><li>View: 视图，用于展示数据的页面，可以理解成我们的html+css搭建的页面，但是没有数据</li><li>ViewModel: 数据绑定到视图，负责将数据（Model）通过JavaScript的DOM技术，将数据展示到视图（View）上</li></ul><p>如图所示就是MVVM开发思想的含义：</p><p><img src="https://bu.dusays.com/2024/04/29/662f1ccf11357.png" alt="85.png"> </p><p>基于上述的MVVM思想，其中的Model我们可以通过Ajax来发起请求从后台获取;对于View部分，我们将来会学习一款ElementUI框架来替代HTML+CSS来更加方便的搭建View;而今天我们要学习的就是侧重于ViewModel部分开发的vue前端框架，用来替代JavaScript的DOM操作，让数据展示到视图的代码开发变得更加的简单。可以简单到什么程度呢？可以参考下图对比：</p><p><img src="https://bu.dusays.com/2024/04/29/662f1ccf360ba.png" alt="86.png"> </p><p>在更加复杂的dom操作中，vue只会变得更加的简单！在上述的代码中，我们看不到之前的DOM操作，因为vue全部帮我们封装好了。</p><p>接下来我们来介绍一下vue。</p><p>Vue.js（读音 &#x2F;vjuː&#x2F;, 类似于 <strong>view</strong>） 是一套构建用户界面的 <strong>渐进式框架</strong>。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，并且非常容易学习，非常容易与其它库或已有项目整合。Vue.js 的目标是通过尽可能简单的 API 实现<strong>响应的数据绑定</strong>和<strong>组合的视图组件</strong>。</p><p>框架即是一个半成品软件，是一套可重用的、通用的、软件基础代码模型。基于框架进行开发，更加快捷、更加高效。</p><h2 id="2-2-快速入门"><a href="#2-2-快速入门" class="headerlink" title="2.2 快速入门"></a>2.2 快速入门</h2><p>接下来我们通过一个vue的快速入门案例，来体验一下vue。</p><p>第一步：在VS Code中创建名为12. Vue-快速入门.html的文件，并且在html文件同级创建js目录，将<strong>资料&#x2F;vue.js文件</strong>目录下得vue.js拷贝到js目录，如下图所示：</p><p><img src="https://bu.dusays.com/2024/04/29/662f1ccf58b94.png" alt="87.png"> </p><p>第二步：然后编写&lt;script&gt;标签来引入vue.js文件，代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第三步：在js代码区域定义vue对象,代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//定义Vue对象</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>, <span class="comment">//vue接管区域</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">message</span>: <span class="string">&quot;Hello Vue&quot;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在创建vue对象时，有几个常用的属性：</p><ul><li>el:  用来指定哪儿些标签受 Vue 管理。 该属性取值 <code>#app</code> 中的 <code>app</code> 需要是受管理的标签的id属性值</li><li>data: 用来定义数据模型</li><li>methods: 用来定义函数。这个我们在后面就会用到</li></ul><p>第四步：在html区域编写视图，其中是插值表达式，用来将vue对象中定义的model展示到页面上的</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span>&gt;</span></span><br><span class="line">        &#123;&#123;message&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>浏览器打开效果如图所示：</p><p><img src="https://bu.dusays.com/2024/04/29/662f1ccfbcafa.png" alt="89.png"> </p><p>整体代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue-快速入门<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span>&gt;</span></span><br><span class="line">        &#123;&#123;message&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//定义Vue对象</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>, <span class="comment">//vue接管区域</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">message</span>: <span class="string">&quot;Hello Vue&quot;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-3-Vue指令"><a href="#2-3-Vue指令" class="headerlink" title="2.3 Vue指令"></a>2.3 Vue指令</h2><p>在上述的快速入门中，我们发现了html中输入了一个没有学过的属性<code>v-model</code>，这个就是vue的<strong>指令</strong>。</p><p><strong>指令：</strong>HTML 标签上带有 v- 前缀的特殊属性，不同指令具有不同含义。例如：v-if，v-for…</p><p>在vue中，通过大量的指令来实现数据绑定到视图的，所以接下来我们需要学习vue的常用指令，如下表所示：</p><table><thead><tr><th><strong>指令</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>v-bind</td><td>为HTML标签绑定属性值，如设置  href , css样式等</td></tr><tr><td>v-model</td><td>在表单元素上创建双向数据绑定</td></tr><tr><td>v-on</td><td>为HTML标签绑定事件</td></tr><tr><td>v-if</td><td>条件性的渲染某元素，判定为true时渲染,否则不渲染</td></tr><tr><td>v-else</td><td></td></tr><tr><td>v-else-if</td><td></td></tr><tr><td>v-show</td><td>根据条件展示某元素，区别在于切换的是display属性的值</td></tr><tr><td>v-for</td><td>列表渲染，遍历容器的元素或者对象的属性</td></tr></tbody></table><h3 id="2-3-1-v-bind和v-model"><a href="#2-3-1-v-bind和v-model" class="headerlink" title="2.3.1 v-bind和v-model"></a>2.3.1 v-bind和v-model</h3><p>我们首先来学习v-bind指令和v-model指令。</p><table><thead><tr><th><strong>指令</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>v-bind</td><td>为HTML标签绑定属性值，如设置  href , css样式等</td></tr><tr><td>v-model</td><td>在表单元素上创建双向数据绑定</td></tr></tbody></table><ul><li><p>v-bind:  为HTML标签绑定属性值，如设置  href , css样式等。当vue对象中的数据模型发生变化时，标签的属性值会随之发生变化。</p><p>接下来我们通过代码来演示。</p><p>首先我们在VS Code中创建名为13. Vue-指令-v-bind和v-model.html的文件，然后准备好如下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue-指令-v-bind<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> &gt;</span>链接1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> &gt;</span>链接2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> &gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//定义Vue对象</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>, <span class="comment">//vue接管区域</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">           <span class="attr">url</span>: <span class="string">&quot;https://www.baidu.com&quot;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上述的代码中，我们需要给&lt;a&gt;标签的href属性赋值，并且值应该来自于vue对象的数据模型中的url变量。所以编写如下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>链接1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上述的代码中，v-bind指令是可以省略的，但是:不能省略，所以第二个超链接的代码编写如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>链接2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>浏览器打开，2个超链接都可以点击，然后跳转到百度去！效果如图所示：</p><p><img src="https://bu.dusays.com/2024/04/29/662f1cd00568e.png" alt="90.png"> </p><p><strong>注意：html属性前面有:表示采用的vue的属性绑定！</strong></p></li><li><p>v-model： 在表单元素上创建双向数据绑定。什么是双向？</p><ul><li>vue对象的data属性中的数据变化，视图展示会一起变化</li><li>视图数据发生变化，vue对象的data属性中的数据也会随着变化。</li></ul><p>data属性中数据变化，我们知道可以通过赋值来改变，但是视图数据为什么会发生变化呢？<strong>只有表单项标签！所以双向绑定一定是使用在表单项标签上的</strong>。编写如下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;url&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>打开浏览器，我们修改表单项标签，发现vue对象data中的数据也发生了变化，如下图所示：</p><p><img src="https://bu.dusays.com/2024/04/29/662f1cd06b535.png" alt="92.png"> </p><p>通过上图我们发现，我们只是改变了表单数据，那么我们之前超链接的绑定的数据值也发生了变化，为什么？</p><p>就是因为我们双向绑定，在视图发生变化时，同时vue的data中的数据模型也会随着变化。那么这个在企业开发的应用场景是什么？</p><p><strong>双向绑定的作用：可以获取表单的数据的值，然后提交给服务器</strong></p><p>整体代码如下:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue-指令-v-bind<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>链接1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>链接2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;url&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//定义Vue对象</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>, <span class="comment">//vue接管区域</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">           <span class="attr">url</span>: <span class="string">&quot;https://www.baidu.com&quot;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-3-2-v-on"><a href="#2-3-2-v-on" class="headerlink" title="2.3.2 v-on"></a>2.3.2 v-on</h3><p>接下来我们学习一下v-on指令。</p><p>v-on: 用来给html标签绑定事件的。<strong>需要注意的是如下2点</strong>：</p><ul><li><p>v-on语法给标签的事件绑定的函数，必须是vue对象种声明的函数</p></li><li><p>v-on语法绑定事件时，事件名相比较js中的事件名，没有on</p><p>例如：在js中，事件绑定demo函数</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">onclick</span>=<span class="string">&quot;demo()&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>vue中，事件绑定demo函数</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:click</span>=<span class="string">&quot;demo()&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>接下来我们通过代码演示。</p><p>首先在VS Code中创建名为14. Vue-指令-v-on.html的文件，提前准备如下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue-指令-v-on<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;点我一下&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;点我一下&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//定义Vue对象</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>, <span class="comment">//vue接管区域</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">           </span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">           </span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后我们需要在vue对象的methods属性中定义事件绑定时需要的handle()函数，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="attr">methods</span>: &#123;</span><br><span class="line">        <span class="attr">handle</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">           <span class="title function_">alert</span>(<span class="string">&quot;你点我了一下...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们给第一个按钮，通过v-on指令绑定单击事件，代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;点我一下&quot;</span> <span class="attr">v-on:click</span>=<span class="string">&quot;handle()&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>同样，v-on也存在简写方式，即v-on: 可以替换成@，所以第二个按钮绑定单击事件的代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;点我一下&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;handle()&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue-指令-v-on<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;点我一下&quot;</span> <span class="attr">v-on:click</span>=<span class="string">&quot;handle()&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;点我一下&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;handle()&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//定义Vue对象</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>, <span class="comment">//vue接管区域</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">           </span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">handle</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">alert</span>(<span class="string">&quot;你点我了一下...&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-3-3-v-if和v-show"><a href="#2-3-3-v-if和v-show" class="headerlink" title="2.3.3 v-if和v-show"></a>2.3.3 v-if和v-show</h3><table><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td>v-if</td><td>条件性的渲染某元素，判定为true时渲染,否则不渲染</td></tr><tr><td>v-if-else</td><td></td></tr><tr><td>v-else</td><td></td></tr><tr><td>v-show</td><td>根据条件展示某元素，区别在于切换的是display属性的值</td></tr></tbody></table><p>我们直接通过代码来演示效果。在VS Code中创建名为15. Vue-指令-v-if和v-show.html的文件，提前准备好如下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue-指令-v-if与v-show<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        年龄<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;age&quot;</span>&gt;</span>经判定,为:</span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>年轻人(35及以下)<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>中年人(35-60)<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>老年人(60及以上)<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//定义Vue对象</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>, <span class="comment">//vue接管区域</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">           <span class="attr">age</span>: <span class="number">20</span></span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            </span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中采用了双向绑定到age属性，意味着我们可以通过表单输入框来改变age的值。</p><p>需求是当我们改变年龄时，需要动态判断年龄的值，呈现对应的年龄的文字描述。年轻人，我们需要使用条件判断<code>age&lt;=35</code>,中年人我们需要使用条件判断<code>age&gt;35 &amp;&amp; age&lt;60</code>,其他情况是老年人。所以通过v-if指令编写如下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">年龄<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;age&quot;</span>&gt;</span>经判定,为:</span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-if</span>=<span class="string">&quot;age &lt;= 35&quot;</span>&gt;</span>年轻人(35及以下)<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-else-if</span>=<span class="string">&quot;age &gt; 35 &amp;&amp; age &lt; 60&quot;</span>&gt;</span>中年人(35-60)<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-else</span>&gt;</span>老年人(60及以上)<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>浏览器打开测试效果如下图：</p><p><img src="https://bu.dusays.com/2024/04/29/662f1cd09d927.png" alt="93.png"> </p><p>v-show和v-if的作用效果是一样的，只是原理不一样。复制上述html代码，修改v-if指令为v-show指令，代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">年龄<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;age&quot;</span>&gt;</span>经判定,为:</span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-show</span>=<span class="string">&quot;age &lt;= 35&quot;</span>&gt;</span>年轻人(35及以下)<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-show</span>=<span class="string">&quot;age &gt; 35 &amp;&amp; age &lt; 60&quot;</span>&gt;</span>中年人(35-60)<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-show</span>=<span class="string">&quot;age &gt;= 60&quot;</span>&gt;</span>老年人(60及以上)<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>打开浏览器，展示效果如下所示：</p><p><img src="https://bu.dusays.com/2024/04/29/662f1cd153e01.png" alt="97.png"> </p><p>可以发现，浏览器呈现的效果是一样的，但是浏览器中html源码不一样。v-if指令，不满足条件的标签代码直接没了，而v-show指令中，不满足条件的代码依然存在，只是添加了css样式来控制标签不去显示。</p><p>完整代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue-指令-v-if与v-show<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        年龄<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;age&quot;</span>&gt;</span>经判定,为:</span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-if</span>=<span class="string">&quot;age &lt;= 35&quot;</span>&gt;</span>年轻人(35及以下)<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-else-if</span>=<span class="string">&quot;age &gt; 35 &amp;&amp; age &lt; 60&quot;</span>&gt;</span>中年人(35-60)<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-else</span>&gt;</span>老年人(60及以上)<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        年龄<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;age&quot;</span>&gt;</span>经判定,为:</span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-show</span>=<span class="string">&quot;age &lt;= 35&quot;</span>&gt;</span>年轻人(35及以下)<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-show</span>=<span class="string">&quot;age &gt; 35 &amp;&amp; age &lt; 60&quot;</span>&gt;</span>中年人(35-60)<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-show</span>=<span class="string">&quot;age &gt;= 60&quot;</span>&gt;</span>老年人(60及以上)<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//定义Vue对象</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>, <span class="comment">//vue接管区域</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">           <span class="attr">age</span>: <span class="number">20</span></span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            </span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-3-4-v-for"><a href="#2-3-4-v-for" class="headerlink" title="2.3.4 v-for"></a>2.3.4 v-for</h3><p>v-for: 从名字我们就能看出，这个指令是用来遍历的。其语法格式如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">标签</span> <span class="attr">v-for</span>=<span class="string">&quot;变量名 in 集合模型数据&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123;变量名&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">标签</span>&gt;</span></span><br></pre></td></tr></table></figure><p>需要注意的是：需要循环那个标签，v-for 指令就写在那个标签上。</p><p>有时我们遍历时需要使用索引，那么v-for指令遍历的语法格式如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">标签</span> <span class="attr">v-for</span>=<span class="string">&quot;(变量名,索引变量) in 集合模型数据&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--索引变量是从0开始，所以要表示序号的话，需要手动的加1--&gt;</span></span><br><span class="line">   &#123;&#123;索引变量 + 1&#125;&#125; &#123;&#123;变量名&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">标签</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来，我们再VS Code中创建名为16. Vue-指令-v-for.html的文件编写代码演示，提前准备如下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue-指令-v-for<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//定义Vue对象</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>, <span class="comment">//vue接管区域</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">           <span class="attr">addrs</span>:[<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>, <span class="string">&quot;西安&quot;</span>, <span class="string">&quot;成都&quot;</span>, <span class="string">&quot;深圳&quot;</span>]</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            </span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后分别编写2种遍历语法，来遍历数组，展示数据，代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;addr in addrs&quot;</span>&gt;</span>&#123;&#123;addr&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;(addr,index) in addrs&quot;</span>&gt;</span>&#123;&#123;index + 1&#125;&#125; : &#123;&#123;addr&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>浏览器打开，呈现如下效果：</p><p><img src="https://bu.dusays.com/2024/04/29/662f1cd19a11c.png" alt="99.png"> </p><h3 id="2-3-5-案例"><a href="#2-3-5-案例" class="headerlink" title="2.3.5 案例"></a>2.3.5 案例</h3><ul><li><p>需求：</p><p><img src="https://bu.dusays.com/2024/04/29/662f1cc0b05a3.png" alt="102.png"> </p><p>如上图所示，我们提供好了数据模型，users是数组集合，提供了多个用户信息。然后我们需要将数据以表格的形式，展示到页面上，其中，性别需要转换成中文男女，等级需要将分数数值转换成对应的等级。</p></li><li><p>分析：</p><p>首先我们肯定需要遍历数组的，所以需要使用v-for标签；然后我们每一条数据对应一行，所以v-for需要添加在tr标签上；其次我们需要将编号，所以需要使用索引的遍历语法；然后我们要将数据展示到表格的单元格中，所以我们需要使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#125;&#125;</span><br></pre></td></tr></table></figure><p>插值表达式；最后，我们需要转换内容，所以我们需要使用v-if指令，进行条件判断和内容的转换</p></li><li><p>步骤：</p><ul><li><p>使用v-for的带索引方式添加到表格的&lt;tr&gt;标签上</p></li><li><p>使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#125;&#125;</span><br></pre></td></tr></table></figure><p>插值表达式展示内容到单元格</p></li><li><p>使用索引+1来作为编号</p></li><li><p>使用v-if来判断，改变性别和等级这2列的值</p></li></ul></li><li><p>代码实现：</p><p>首先创建名为17. Vue-指令-案例.html的文件，提前准备如下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue-指令-案例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span> <span class="attr">cellspacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;60%&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>编号<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>年龄<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>性别<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>成绩<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>等级<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">users</span>: [&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">name</span>: <span class="string">&quot;Tom&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">age</span>: <span class="number">20</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">gender</span>: <span class="number">1</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">score</span>: <span class="number">78</span></span></span><br><span class="line"><span class="language-javascript">            &#125;,&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">name</span>: <span class="string">&quot;Rose&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">age</span>: <span class="number">18</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">gender</span>: <span class="number">2</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">score</span>: <span class="number">86</span></span></span><br><span class="line"><span class="language-javascript">            &#125;,&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">name</span>: <span class="string">&quot;Jerry&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">age</span>: <span class="number">26</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">gender</span>: <span class="number">1</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">score</span>: <span class="number">90</span></span></span><br><span class="line"><span class="language-javascript">            &#125;,&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">name</span>: <span class="string">&quot;Tony&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">age</span>: <span class="number">30</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">gender</span>: <span class="number">1</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">score</span>: <span class="number">52</span></span></span><br><span class="line"><span class="language-javascript">            &#125;]</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            </span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在&lt;tr&gt;上添加v-for进行遍历，以及通过插值表达式和v-if指令来填充内容和改变内容，其代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">tr</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span> <span class="attr">v-for</span>=<span class="string">&quot;(user,index) in users&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;index + 1&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;user.name&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;user.age&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-if</span>=<span class="string">&quot;user.gender == 1&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-if</span>=<span class="string">&quot;user.gender == 2&quot;</span>&gt;</span>女<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;user.score&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-if</span>=<span class="string">&quot;user.score &gt;= 85&quot;</span>&gt;</span>优秀<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-else-if</span>=<span class="string">&quot;user.score &gt;= 60&quot;</span>&gt;</span>及格<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;color: red;&quot;</span> <span class="attr">v-else</span>&gt;</span>不及格<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>其完整代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue-指令-案例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span> <span class="attr">cellspacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;60%&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>编号<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>年龄<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>性别<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>成绩<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>等级<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span> <span class="attr">v-for</span>=<span class="string">&quot;(user,index) in users&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;index + 1&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;user.name&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;user.age&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-if</span>=<span class="string">&quot;user.gender == 1&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-if</span>=<span class="string">&quot;user.gender == 2&quot;</span>&gt;</span>女<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;user.score&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-if</span>=<span class="string">&quot;user.score &gt;= 85&quot;</span>&gt;</span>优秀<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-else-if</span>=<span class="string">&quot;user.score &gt;= 60&quot;</span>&gt;</span>及格<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;color: red;&quot;</span> <span class="attr">v-else</span>&gt;</span>不及格<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">users</span>: [&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">name</span>: <span class="string">&quot;Tom&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">age</span>: <span class="number">20</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">gender</span>: <span class="number">1</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">score</span>: <span class="number">78</span></span></span><br><span class="line"><span class="language-javascript">            &#125;,&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">name</span>: <span class="string">&quot;Rose&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">age</span>: <span class="number">18</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">gender</span>: <span class="number">2</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">score</span>: <span class="number">86</span></span></span><br><span class="line"><span class="language-javascript">            &#125;,&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">name</span>: <span class="string">&quot;Jerry&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">age</span>: <span class="number">26</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">gender</span>: <span class="number">1</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">score</span>: <span class="number">90</span></span></span><br><span class="line"><span class="language-javascript">            &#125;,&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">name</span>: <span class="string">&quot;Tony&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">age</span>: <span class="number">30</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">gender</span>: <span class="number">1</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">score</span>: <span class="number">52</span></span></span><br><span class="line"><span class="language-javascript">            &#125;]</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            </span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-4-生命周期"><a href="#2-4-生命周期" class="headerlink" title="2.4 生命周期"></a>2.4 生命周期</h2><p>vue的生命周期：指的是vue对象从创建到销毁的过程。vue的生命周期包含8个阶段：每触发一个生命周期事件，会自动执行一个生命周期方法，这些生命周期方法也被称为钩子方法。其完整的生命周期如下图所示：</p><table><thead><tr><th>状态</th><th>阶段周期</th></tr></thead><tbody><tr><td>beforeCreate</td><td>创建前</td></tr><tr><td>created</td><td>创建后</td></tr><tr><td>beforeMount</td><td>挂载前</td></tr><tr><td>mounted</td><td>挂载完成</td></tr><tr><td>beforeUpdate</td><td>更新前</td></tr><tr><td>updated</td><td>更新后</td></tr><tr><td>beforeDestroy</td><td>销毁前</td></tr><tr><td>destroyed</td><td>销毁后</td></tr></tbody></table><p>下图是 Vue 官网提供的从创建 Vue 到效果 Vue 对象的整个过程及各个阶段对应的钩子函数：</p><p><img src="https://bu.dusays.com/2024/04/29/662f1cc086ffd.png" alt="100.png"></p><p>其中我们需要重点关注的是**mounted,**其他的我们了解即可。</p><p>mounted：挂载完成，Vue初始化成功，HTML页面渲染成功。<strong>以后我们一般用于页面初始化自动的ajax请求后台数据</strong></p><p>我们在VS Code中创建名为18. Vue-生命周期.html的文件编写代码来演示效果，提前准备如下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue-指令-v-for<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//定义Vue对象</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>, <span class="comment">//vue接管区域</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">           </span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            </span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后我们编写mounted声明周期的钩子函数，与methods同级，代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//定义Vue对象</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>, <span class="comment">//vue接管区域</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">           </span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            </span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        mounted () &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(<span class="string">&quot;vue挂载完成,发送请求到服务端&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>浏览器打开，运行结果如下：我们发现，自动打印了这句话，因为页面加载完成，vue对象创建并且完成了挂在，此时自动触发mounted所绑定的钩子函数，然后自动执行，弹框。</p><p><img src="https://bu.dusays.com/2024/04/29/662f1cc0760a6.png" alt="101.png"> </p>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC</title>
      <link href="/posts/aa55683f.html"/>
      <url>/posts/aa55683f.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-线程状态"><a href="#1-线程状态" class="headerlink" title="1 线程状态"></a>1 线程状态</h1><h2 id="1-1-状态介绍"><a href="#1-1-状态介绍" class="headerlink" title="1.1 状态介绍"></a>1.1 状态介绍</h2><p>当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。线程对象在不同的时期有不同的状态。那么Java中的线程存在哪几种状态呢？Java中的线程</p><p>状态被定义在了java.lang.Thread.State枚举类中，State枚举类的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/* 新建 */</span></span><br><span class="line">        NEW , </span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 可运行状态 */</span></span><br><span class="line">        RUNNABLE , </span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 阻塞状态 */</span></span><br><span class="line">        BLOCKED , </span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 无限等待状态 */</span></span><br><span class="line">        WAITING , </span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 计时等待 */</span></span><br><span class="line">        TIMED_WAITING , </span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 终止 */</span></span><br><span class="line">        TERMINATED;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取当前线程的状态</span></span><br><span class="line">    <span class="keyword">public</span> State <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> jdk.internal.misc.VM.toThreadState(threadStatus);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过源码我们可以看到Java中的线程存在6种状态，每种线程状态的含义如下</p><table><thead><tr><th>线程状态</th><th>具体含义</th></tr></thead><tbody><tr><td>NEW</td><td>一个尚未启动的线程的状态。也称之为初始状态、开始状态。线程刚被创建，但是并未启动。还没调用start方法。MyThread t &#x3D; new MyThread()只有线程象，没有线程特征。</td></tr><tr><td>RUNNABLE</td><td>当我们调用线程对象的start方法，那么此时线程对象进入了RUNNABLE状态。那么此时才是真正的在JVM进程中创建了一个线程，线程一经启动并不是立即得到执行，线程的运行与否要听令与CPU的调度，那么我们把这个中间状态称之为可执行状态(RUNNABLE)也就是说它具备执行的资格，但是并没有真正的执行起来而是在等待CPU的度。</td></tr><tr><td>BLOCKED</td><td>当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态；当该线程持有锁时，该线程将变成Runnable状态。</td></tr><tr><td>WAITING</td><td>一个正在等待的线程的状态。也称之为等待状态。造成线程等待的原因有两种，分别是调用Object.wait()、join()方法。处于等待状态的线程，正在等待其他线程去执行一个特定的操作。例如：因为wait()而等待的线程正在等待另一个线程去调用notify()或notifyAll()；一个因为join()而等待的线程正在等待另一个线程结束。</td></tr><tr><td>TIMED_WAITING</td><td>一个在限定时间内等待的线程的状态。也称之为限时等待状态。造成线程限时等待状态的原因有三种，分别是：Thread.sleep(long)，Object.wait(long)、join(long)。</td></tr><tr><td>TERMINATED</td><td>一个完全运行完成的线程的状态。也称之为终止状态、结束状态</td></tr></tbody></table><p>各个状态的转换，如下图所示：</p><p><img src="/JavaNotes/%E5%A4%9A%E7%BA%BF%E7%A8%8B&juc/assets/1571652681276.png" alt="1571652681276"> </p><h2 id="1-2-案例演示"><a href="#1-2-案例演示" class="headerlink" title="1.2 案例演示"></a>1.2 案例演示</h2><p>为了验证上面论述的状态即状态转换的正确性，也为了加深对线程状态转换的理解，下面通过三个案例演示线程间中的状态转换。</p><h3 id="1-2-1-案例一"><a href="#1-2-1-案例一" class="headerlink" title="1.2.1 案例一"></a>1.2.1 案例一</h3><p>本案例主要演示TIME_WAITING的状态转换。</p><p>需求：编写一段代码，依次显示一个线程的这些状态：NEW -&gt; RUNNABLE -&gt; TIME_WAITING -&gt; RUNNABLE -&gt;  TERMINATED</p><p>为了简化我们的开发，本次我们使用匿名内部类结合lambda表达式的方式使用多线程。</p><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadStateDemo01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个内部线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;2.执行thread.start()之后，线程的状态：&quot;</span> + Thread.currentThread().getState());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//休眠100毫秒</span></span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;4.执行Thread.sleep(long)完成之后，线程的状态：&quot;</span> + Thread.currentThread().getState());</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取start()之前的状态</span></span><br><span class="line">        System.out.println(<span class="string">&quot;1.通过new初始化一个线程，但是还没有start()之前，线程的状态：&quot;</span> + thread.getState());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//休眠50毫秒</span></span><br><span class="line">        Thread.sleep(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//因为thread1需要休眠100毫秒，所以在第50毫秒，thread处于sleep状态</span></span><br><span class="line">        <span class="comment">//用main线程来获取thread1线程的状态，因为thread1线程睡眠时间较长</span></span><br><span class="line">        <span class="comment">//所以当main线程执行的时候，thread1线程还没有睡醒，还处于计时等待状态</span></span><br><span class="line">        System.out.println(<span class="string">&quot;3.执行Thread.sleep(long)时，线程的状态：&quot;</span> + thread.getState());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//thread1和main线程主动休眠150毫秒，所以在第150毫秒,thread早已执行完毕</span></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;5.线程执行完毕之后，线程的状态：&quot;</span> + thread.getState() + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>通过<span class="keyword">new</span>初始化一个线程，但是还没有start()之前，线程的状态：NEW</span><br><span class="line"><span class="number">2.</span>执行thread.start()之后，线程的状态：RUNNABLE</span><br><span class="line"><span class="number">3.</span>执行Thread.sleep(<span class="type">long</span>)时，线程的状态：TIMED_WAITING</span><br><span class="line"><span class="number">4.</span>执行Thread.sleep(<span class="type">long</span>)完成之后，线程的状态：RUNNABLE</span><br><span class="line"><span class="number">5.</span>线程执行完毕之后，线程的状态：TERMINATED</span><br></pre></td></tr></table></figure><h3 id="1-2-2-案例二"><a href="#1-2-2-案例二" class="headerlink" title="1.2.2 案例二"></a>1.2.2 案例二</h3><p>本案例主要演示WAITING的状态转换。</p><p>需求：编写一段代码，依次显示一个线程的这些状态：NEW -&gt; RUNNABLE -&gt; WAITING -&gt; RUNNABLE -&gt; TERMINATED</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadStateDemo02</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个对象，用来加锁和解锁</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个内部线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;2.执行thread.start()之后，线程的状态：&quot;</span> + Thread.currentThread().getState());</span><br><span class="line">            <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//thread1需要休眠100毫秒</span></span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//thread1100毫秒之后，通过wait()方法释放obj对象是锁</span></span><br><span class="line">                    obj.wait();</span><br><span class="line">                    </span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;4.被object.notify()方法唤醒之后，线程的状态：&quot;</span> + Thread.currentThread().getState());</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取start()之前的状态</span></span><br><span class="line">        System.out.println(<span class="string">&quot;1.通过new初始化一个线程，但是还没有start()之前，线程的状态：&quot;</span> + thread1.getState());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        thread1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//main线程休眠150毫秒</span></span><br><span class="line">        Thread.sleep(<span class="number">150</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//因为thread1在第100毫秒进入wait等待状态，所以第150秒肯定可以获取其状态</span></span><br><span class="line">        System.out.println(<span class="string">&quot;3.执行object.wait()时，线程的状态：&quot;</span> + thread1.getState());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明另一个线程进行解锁</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                <span class="comment">//唤醒等待的线程</span></span><br><span class="line">                obj.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//main线程休眠10毫秒等待thread1线程能够苏醒</span></span><br><span class="line">        Thread.sleep(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取thread1运行结束之后的状态</span></span><br><span class="line">        System.out.println(<span class="string">&quot;5.线程执行完毕之后，线程的状态：&quot;</span> + thread1.getState() + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>通过<span class="keyword">new</span>初始化一个线程，但是还没有start()之前，线程的状态：NEW</span><br><span class="line"><span class="number">2.</span>执行thread.start()之后，线程的状态：RUNNABLE</span><br><span class="line"><span class="number">3.</span>执行object.wait()时，线程的状态：WAITING</span><br><span class="line"><span class="number">4.</span>被object.notify()方法唤醒之后，线程的状态：RUNNABLE</span><br><span class="line"><span class="number">5.</span>线程执行完毕之后，线程的状态：TERMINATED</span><br></pre></td></tr></table></figure><h3 id="1-2-3-案例三"><a href="#1-2-3-案例三" class="headerlink" title="1.2.3 案例三"></a>1.2.3 案例三</h3><p>本案例主要演示BLOCKED的状态转换。</p><p>需求：编写一段代码，依次显示一个线程的这些状态：NEW -&gt; RUNNABLE -&gt; BLOCKED -&gt; RUNNABLE -&gt; TERMINATED</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadStateDemo03</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个对象，用来加锁和解锁</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个线程，先抢占了obj2对象的锁</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj2) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);              <span class="comment">//第一个线程要持有锁100毫秒</span></span><br><span class="line">                    obj2.wait();                          <span class="comment">//然后通过wait()方法进行等待状态，并释放obj2的对象锁</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义目标线程，获取等待获取obj2的锁</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;2.执行thread.start()之后，线程的状态：&quot;</span> + Thread.currentThread().getState());</span><br><span class="line">            <span class="keyword">synchronized</span> (obj2) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);              <span class="comment">//thread3要持有对象锁100毫秒</span></span><br><span class="line">                    obj2.notify();                        <span class="comment">//然后通过notify()方法唤醒所有在ojb2上等待的线程继续执行后续操作</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;4.阻塞结束后，线程的状态：&quot;</span> + Thread.currentThread().getState());</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取start()之前的状态</span></span><br><span class="line">        System.out.println(<span class="string">&quot;1.通过new初始化一个线程，但是还没有thread.start()之前，线程的状态：&quot;</span> + thread.getState());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先等100毫秒</span></span><br><span class="line">        Thread.sleep(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一个线程释放锁至少需要100毫秒，所以在第50毫秒时，thread正在因等待obj的对象锁而阻塞</span></span><br><span class="line">        System.out.println(<span class="string">&quot;3.因为等待锁而阻塞时，线程的状态：&quot;</span> + thread.getState());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//再等300毫秒</span></span><br><span class="line">        Thread.sleep(<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//两个线程的执行时间加上之前等待的50毫秒总共是250毫秒，所以第300毫秒，所有的线程都已经执行完毕</span></span><br><span class="line">        System.out.println(<span class="string">&quot;5.线程执行完毕之后，线程的状态：&quot;</span> + thread.getState());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------------代码简化--------------------------------------------</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程开启之后的状态&quot;</span> + Thread.currentThread().getState());</span><br><span class="line">            <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;进入之后的状态&quot;</span> + Thread.currentThread().getState());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;创建线程对象后,但是不调用start方法的状态&quot;</span> + t2.getState());</span><br><span class="line">        t2.start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        System.out.println(t2.getState());</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        System.out.println(t2.getState());</span><br></pre></td></tr></table></figure><p>控制台输出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>通过<span class="keyword">new</span>初始化一个线程，但是还没有thread.start()之前，线程的状态：NEW</span><br><span class="line"><span class="number">2.</span>执行thread.start()之后，线程的状态：RUNNABLE</span><br><span class="line"><span class="number">3.</span>因为等待锁而阻塞时，线程的状态：BLOCKED</span><br><span class="line"><span class="number">4.</span>阻塞结束后，线程的状态：RUNNABLE</span><br><span class="line"><span class="number">5.</span>线程执行完毕之后，线程的状态：TERMINATED</span><br></pre></td></tr></table></figure><p>通过上面3个案例的代码演示，我们可以证明开始章节说所述的线程状态以及线程状态转换都是正确的。</p><h1 id="2-线程池"><a href="#2-线程池" class="headerlink" title="2 线程池"></a>2 线程池</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><p>提到池，大家应该能想到的就是水池。水池就是一个容器，在该容器中存储了很多的水。那么什么是线程池呢？线程池也是可以看做成一个池子，在该池子中存储很多个线程。</p><p>线程池存在的意义：</p><p>系统创建一个线程的成本是比较高的，因为它涉及到与操作系统交互，当程序中需要创建大量生存期很短暂的线程时，频繁的创建和销毁线程对系统的资源消耗有可能大于业务处理是对系</p><p>统资源的消耗，这样就有点”舍本逐末”了。针对这一种情况，为了提高性能，我们就可以采用线程池。线程池在启动的时，会创建大量空闲线程，当我们向线程池提交任务的时，线程池就</p><p>会启动一个线程来执行该任务。等待任务执行完毕以后，线程并不会死亡，而是再次返回到线程池中称为空闲状态。等待下一次任务的执行。</p><h2 id="2-2-自定义线程池"><a href="#2-2-自定义线程池" class="headerlink" title="2.2 自定义线程池"></a>2.2 自定义线程池</h2><h3 id="2-2-1-线程池的设计思路"><a href="#2-2-1-线程池的设计思路" class="headerlink" title="2.2.1 线程池的设计思路"></a>2.2.1 线程池的设计思路</h3><p>线程池的思路和生产者消费者模型是很接近的</p><ol><li>准备一个任务容器</li><li>一次性启动多个(2个)消费者线程</li><li>刚开始任务容器是空的，所以线程都在wait</li><li>直到一个外部线程向这个任务容器中扔了一个”任务”，就会有一个消费者线程被唤醒</li><li>这个消费者线程取出”任务”，并且执行这个任务，执行完毕后，继续等待下一次任务的到来</li></ol><p>在整个过程中，都不需要创建新的线程，而是循环使用这些已经存在的线程。</p><p><img src="/JavaNotes/%E5%A4%9A%E7%BA%BF%E7%A8%8B&juc/assets/1571655104091.png" alt="1571655104091"> </p><h3 id="2-2-2-代码实现"><a href="#2-2-2-代码实现" class="headerlink" title="2.2.2 代码实现"></a>2.2.2 代码实现</h3><p>实现思路：</p><ul><li>创建一个线程池类(ThreadPool)</li><li>在该类中定义两个成员变量poolSize(线程池初始化线程的个数) , BlockingQueue<Runnable>(任务容器)</li><li>通过构造方法来创建两个线程对象(消费者线程)，并且启动</li><li>使用内部类的方式去定义一个线程类(TaskThread),可以提供一个构造方法用来初始化线程名称</li><li>两个消费者线程需要不断的从任务容器中获取任务，如果没有任务，则线程处于阻塞状态。</li><li>提供一个方法(submit)向任务容器中添加任务</li><li>定义测试类进行测试</li></ul><p>线程池类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化线程个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_POOL_SIZE</span> <span class="operator">=</span> <span class="number">2</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在该类中定义两个成员变量poolSize(线程池初始化线程的个数) , BlockingQueue&lt;Runnable&gt;(任务容器)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">poolSize</span> <span class="operator">=</span> DEFAULT_POOL_SIZE ;</span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Runnable&gt; blockingQueue = <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;() ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadPool</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.initThread();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有参构造方法，通过构造方法来创建两个线程对象(消费者线程)，并且启动</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadPool</span><span class="params">(<span class="type">int</span> poolSize)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(poolSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.poolSize = poolSize ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.initThread();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化线程方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initThread</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span> ; x &lt; poolSize ; x++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">TaskThread</span>(<span class="string">&quot;线程---&gt;&quot;</span> + x).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供一个方法(submit)向任务容器中添加任务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">submit</span><span class="params">(Runnable runnable)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            blockingQueue.put(runnable);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用内部类的方式去定义一个线程类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提供一个构造方法，用来初始化线程名称</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">TaskThread</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 两个消费者线程需要不断的从任务容器中获取任务，如果没有任务，则线程处于阻塞状态。</span></span><br><span class="line">                    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> blockingQueue.take();</span><br><span class="line">                    task.run();</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolDemo01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程池对象,无参构造方法创建</span></span><br><span class="line">        <span class="comment">// ThreadPool threadPool = new ThreadPool();</span></span><br><span class="line">        <span class="type">ThreadPool</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPool</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交任务</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span> ; x &lt; <span class="number">10</span> ; x++) &#123;</span><br><span class="line">            threadPool.submit( () -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;----&gt;&gt;&gt;处理了任务&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用无参构造方法创建线程池对象，控制台输出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">线程---&gt;<span class="number">0</span>----&gt;&gt;&gt;处理了任务</span><br><span class="line">线程---&gt;<span class="number">1</span>----&gt;&gt;&gt;处理了任务</span><br><span class="line">线程---&gt;<span class="number">0</span>----&gt;&gt;&gt;处理了任务</span><br><span class="line">线程---&gt;<span class="number">1</span>----&gt;&gt;&gt;处理了任务</span><br><span class="line">线程---&gt;<span class="number">0</span>----&gt;&gt;&gt;处理了任务</span><br><span class="line">线程---&gt;<span class="number">1</span>----&gt;&gt;&gt;处理了任务</span><br><span class="line">线程---&gt;<span class="number">0</span>----&gt;&gt;&gt;处理了任务</span><br><span class="line">线程---&gt;<span class="number">1</span>----&gt;&gt;&gt;处理了任务</span><br><span class="line">线程---&gt;<span class="number">0</span>----&gt;&gt;&gt;处理了任务</span><br><span class="line">线程---&gt;<span class="number">1</span>----&gt;&gt;&gt;处理了任务</span><br></pre></td></tr></table></figure><p>通过控制台的输出，我们可以看到在线程池中存在两个线程，通过这2个线程处理了10个任务。</p><p>使用有参构造方法创建线程池对象，传递的参数是5，控制台输出结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">线程---&gt;3----&gt;&gt;&gt;处理了任务</span><br><span class="line">线程---&gt;4----&gt;&gt;&gt;处理了任务</span><br><span class="line">线程---&gt;2----&gt;&gt;&gt;处理了任务</span><br><span class="line">线程---&gt;0----&gt;&gt;&gt;处理了任务</span><br><span class="line">线程---&gt;2----&gt;&gt;&gt;处理了任务</span><br><span class="line">线程---&gt;4----&gt;&gt;&gt;处理了任务</span><br><span class="line">线程---&gt;3----&gt;&gt;&gt;处理了任务</span><br><span class="line">线程---&gt;1----&gt;&gt;&gt;处理了任务</span><br><span class="line">线程---&gt;2----&gt;&gt;&gt;处理了任务</span><br><span class="line">线程---&gt;0----&gt;&gt;&gt;处理了任务</span><br></pre></td></tr></table></figure><p>通过控制台的输出，我们可以看到在线程池中存在两个线程，通过这5个线程处理了10个任务。</p><h2 id="2-3-JDK中线程池"><a href="#2-3-JDK中线程池" class="headerlink" title="2.3 JDK中线程池"></a>2.3 JDK中线程池</h2><h3 id="2-3-1-Executors"><a href="#2-3-1-Executors" class="headerlink" title="2.3.1 Executors"></a>2.3.1 Executors</h3><p>JDK对线程池也进行了相关的实现，在真实企业开发中我们也很少去自定义线程池，而是使用JDK中自带的线程池。</p><p>我们可以使用Executors中所提供的<strong>静态</strong>方法来创建线程池。</p><p><font color="blue" size="3"><strong>获取线程池的方法</strong></font>：</p><p>&#x2F;&#x2F;通过不同的方法创建出来的线程池具有不同的特点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span>: 创建一个可缓存线程池，可灵活的去创建线程，并且灵活的回收线程，若无可回收，则新建线程。</span><br><span class="line">ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span>: 初始化一个具有固定数量线程的线程池</span><br><span class="line">ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span>: 初始化一个具有一个线程的线程池</span><br><span class="line"><span class="comment">//做完一个，再做一个，不停歇，直到做完，老黄牛性格</span></span><br><span class="line">ScheduledExecutorService <span class="title function_">newSingleThreadScheduledExecutor</span><span class="params">()</span>: 初始化一个具有一个线程的线程池，支持定时及周期性任务执行</span><br><span class="line"><span class="comment">//按照固定的计划去执行线程，一个做完之后按照计划再做另一个</span></span><br></pre></td></tr></table></figure><p>这个方法返回的都是ExecutorService类型的对象(ScheduledExecutorService继承ExecutorService),而ExecutorService可以看做就是一个线程池，那么ExecutorService</p><p>给我们提供了哪些方法供我们使用呢？</p><p><font color="blue" size="3"><strong>ExecutorService中的常见方法</strong></font>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;?&gt; submit(Runnable task)：提交任务方法</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span>：关闭线程池的方法</span><br></pre></td></tr></table></figure><p><font color="blue" size="3"><strong>案例1</strong></font>：演示newCachedThreadPool方法所获取到的线程池的特点</p><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecutorsDemo01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 演示Executors中的newCachedThreadPool返回的线程池的特点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取线程池对象</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交任务</span></span><br><span class="line">        threadPool.submit(() -&gt; &#123;</span><br><span class="line">            System.out.println( Thread.currentThread().getName() + <span class="string">&quot;---执行了任务&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交任务</span></span><br><span class="line">        threadPool.submit(() -&gt; &#123;</span><br><span class="line">            System.out.println( Thread.currentThread().getName() + <span class="string">&quot;---执行了任务&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不使用线程池了，还可以将线程池关闭</span></span><br><span class="line">        threadPool.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>---执行了任务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>---执行了任务</span><br></pre></td></tr></table></figure><p>针对每一个任务，线程池为其分配一个线程去执行，我们可以在第二次提交任务的时候，让主线程休眠一小会儿，看程序的执行结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecutorsDemo02</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 演示Executors中的newCachedThreadPool返回的线程池的特点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取线程池对象</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交任务</span></span><br><span class="line">        threadPool.submit(() -&gt; &#123;</span><br><span class="line">            System.out.println( Thread.currentThread().getName() + <span class="string">&quot;---执行了任务&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程休眠2秒，主线程休眠2秒，此时之前提交的任务应该已经执行完毕</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交任务</span></span><br><span class="line">        threadPool.submit(() -&gt; &#123;</span><br><span class="line">            System.out.println( Thread.currentThread().getName() + <span class="string">&quot;---执行了任务&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不使用线程池了，还可以将线程池关闭</span></span><br><span class="line">        threadPool.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>---执行了任务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>---执行了任务</span><br></pre></td></tr></table></figure><p>我们发现是通过一个线程执行了两个任务。此时就说明线程池中的线程”pool-1-thread-1”被线程池回收了，成为了空闲线程，当我们再次提交任务的时候，该线程就去执行新的任务。</p><p><font color="blue" size="3"><strong>案例2</strong></font>：演示newFixedThreadPool方法所获取到的线程池的特点</p><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecutorsDemo03</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 演示newFixedThreadPool方法所获取到的线程池的特点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取线程池对象,初始化一个具有固定数量线程的线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);  <span class="comment">// 在该线程池中存在3个线程</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交任务</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span> ; x &lt; <span class="number">5</span> ; x++) &#123;</span><br><span class="line">            threadPool.submit( () -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-----&gt;&gt;&gt;执行了任务&quot;</span> );</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>-----&gt;&gt;&gt;执行了任务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>-----&gt;&gt;&gt;执行了任务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>-----&gt;&gt;&gt;执行了任务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>-----&gt;&gt;&gt;执行了任务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>-----&gt;&gt;&gt;执行了任务</span><br></pre></td></tr></table></figure><p>通过控制台的输出结果，我们可以看到5个任务是通过3个线程进行执行的，说明此线程池中存在三个线程对象</p><p><font color="blue" size="3"><strong>案例3</strong></font>：演示newSingleThreadExecutor方法所获取到的线程池的特点</p><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecutorsDemo04</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 演示newSingleThreadExecutor方法所获取到的线程池的特点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取线程池对象,初始化一个具有一个线程的线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交任务</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span> ; x &lt; <span class="number">5</span> ; x++) &#123;</span><br><span class="line">            threadPool.submit(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-----&gt;&gt;&gt;执行了任务&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>-----&gt;&gt;&gt;执行了任务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>-----&gt;&gt;&gt;执行了任务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>-----&gt;&gt;&gt;执行了任务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>-----&gt;&gt;&gt;执行了任务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>-----&gt;&gt;&gt;执行了任务</span><br></pre></td></tr></table></figure><p>通过控制台的输出结果，我们可以看到5个任务是通过1个线程进行执行的,说明此线程池中只存在一个线程对象。</p><p><font color="blue" size="3"><strong>案例4</strong></font>： 演示newSingleThreadScheduledExecutor方法所获取到的线程池的特点(初始化一个具有一个线程的线程池)</p><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecutorsDemo05</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 演示：newSingleThreadScheduledExecutor方法所获取到的线程池的第一个特点(初始化一个具有一个线程的线程池)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取线程池对象</span></span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newSingleThreadScheduledExecutor();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交任务</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span> ; x &lt; <span class="number">5</span> ; x++) &#123;</span><br><span class="line">            threadPool.submit(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;----&gt;&gt;执行了任务&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>----&gt;&gt;执行了任务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>----&gt;&gt;执行了任务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>----&gt;&gt;执行了任务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>----&gt;&gt;执行了任务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>----&gt;&gt;执行了任务</span><br></pre></td></tr></table></figure><p>通过控制台的输出结果，我们可以看到5个任务是通过1个线程进行执行的,说明此线程池中只存在一个线程对象。</p><p><font color="blue" size="3"><strong>案例5</strong></font>： 演示newSingleThreadScheduledExecutor方法所获取到的线程池的特点(支持定时及周期性任务执行)</p><p>ScheduledExecutorService中和定时以及周期性执行相关的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">定时执行</span></span><br><span class="line"><span class="comment">command: 任务类对象</span></span><br><span class="line"><span class="comment">delay  : 延迟多长时间开始执行任务, 任务提交到线程池以后我们需要等待多长时间开始执行这个任务</span></span><br><span class="line"><span class="comment">unit   : 指定时间操作单元</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command,<span class="type">long</span> delay, TimeUnit unit);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">周期性执行</span></span><br><span class="line"><span class="comment">command: 任务类对象</span></span><br><span class="line"><span class="comment">initialDelay: 延迟多长时间开始第一次该执行任务, 任务提交到线程池以后我们需要等待多长时间开始第一次执行这个任务</span></span><br><span class="line"><span class="comment">period:        下一次执行该任务所对应的时间间隔</span></span><br><span class="line"><span class="comment">unit: 指定时间操作单元</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, <span class="type">long</span> initialDelay, <span class="type">long</span> period, TimeUnit unit);</span><br></pre></td></tr></table></figure><p>测试类1(演示定时执行)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecutorsDemo06</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 演示newSingleThreadScheduledExecutor方法所获取到的线程池的特点(支持定时及周期性任务执行)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取线程池对象</span></span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newSingleThreadScheduledExecutor();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交任务,10s以后开始执行该任务</span></span><br><span class="line">        threadPool.schedule( () -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;----&gt;&gt;&gt;执行了该任务&quot;</span>);</span><br><span class="line">        &#125; , <span class="number">10</span> , TimeUnit.SECONDS) ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类2(演示周期性执行)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecutorsDemo07</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 演示newSingleThreadScheduledExecutor方法所获取到的线程池的特点(支持定时及周期性任务执行)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取线程池对象</span></span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newSingleThreadScheduledExecutor();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交任务,10s以后开始第一次执行该任务，然后每隔1秒执行一次</span></span><br><span class="line">        threadPool.scheduleAtFixedRate( () -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;----&gt;&gt;&gt;执行了该任务&quot;</span>);</span><br><span class="line">        &#125; , <span class="number">10</span> ,<span class="number">1</span>, TimeUnit.SECONDS) ;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-2-ThreadPoolExecutor"><a href="#2-3-2-ThreadPoolExecutor" class="headerlink" title="2.3.2 ThreadPoolExecutor"></a>2.3.2 ThreadPoolExecutor</h3><h4 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1) 基本使用"></a>1) 基本使用</h4><p>刚才我们是通过Executors中的静态方法去创建线程池的，通过查看源代码我们发现，其底层都是通过ThreadPoolExecutor构建的。比如：newFixedThreadPool方法的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建了ThreadPoolExecutor对象，然后直接返回</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,<span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么也可以使用ThreadPoolExecutor去创建线程池。</p><p>ThreadPoolExecutor最完整的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                              TimeUnit unit,</span></span><br><span class="line"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                              ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                              RejectedExecutionHandler handler)</span></span><br></pre></td></tr></table></figure><p>参数说明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">corePoolSize：   核心线程的最大值，不能小于<span class="number">0</span></span><br><span class="line">maximumPoolSize：最大线程数，不能小于等于<span class="number">0</span>，maximumPoolSize &gt;= corePoolSize</span><br><span class="line">keepAliveTime：  空闲线程最大存活时间,不能小于<span class="number">0</span></span><br><span class="line">unit：           时间单位</span><br><span class="line">workQueue：      任务队列，不能为<span class="literal">null</span></span><br><span class="line">threadFactory：  创建线程工厂,不能为<span class="literal">null</span>      </span><br><span class="line">handler：        任务的拒绝策略,不能为<span class="literal">null</span>    </span><br></pre></td></tr></table></figure><p>案例演示通过ThreadPoolExecutor创建线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExecutorDemo01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 演示基本使用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过ThreadPoolExecutor创建一个线程池对象</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span> , <span class="number">3</span> , <span class="number">60</span> , TimeUnit.SECONDS ,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;Runnable&gt;(<span class="number">3</span>) , Executors.defaultThreadFactory() , <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy()) ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 以上代码表示的意思是：核心线程池中的线程数量最大为1,整个线程池中最多存在3个线程,空闲线程最大的存活时间为60,时间单位为秒,阻塞队列使用的是有界阻塞队列</span></span><br><span class="line"><span class="comment">         * 容量为3,使用默认的线程工厂;以及默认的任务处理策略</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交任务</span></span><br><span class="line">        threadPoolExecutor.submit( () -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;------&gt;&gt;&gt;执行了任务&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        threadPoolExecutor.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-工作原理"><a href="#2-工作原理" class="headerlink" title="2) 工作原理"></a>2) 工作原理</h4><p>接下来我们就来研究一下线程池的工作原理，如下图所示</p><p><img src="/JavaNotes/%E5%A4%9A%E7%BA%BF%E7%A8%8B&juc/assets/1571732060388.png" alt="1571732060388"> </p><p>当我们通过submit方法向线程池中提交任务的时候，具体的工作流程如下：</p><ol><li>客户端每次提交一个任务，线程池就会在核心线程池中创建一个工作线程来执行这个任务。当核心线程池中的线程已满时，则进入下一步操作。</li><li>把任务试图存储到工作队列中。如果工作队列没有满，则将新提交的任务存储在这个工作队列里，等待核心线程池中的空闲线程执行。如果工作队列满了，则进入下个流程。</li><li>线程池会再次在非核心线程池区域去创建新工作线程来执行任务，直到当前线程池总线程数量超过最大线程数时，就是按照指定的任务处理策略处理多余的任务。</li></ol><p>举例说明：</p><p>假如有一个工厂，工厂里面有10个工人(正式员工)，每个工人同时只能做一件任务。因此只要当10个工人中有工人是空闲的，来了任务就分配给空闲的工人做；当10个工人都有任务在做时，</p><p>如果还来了任务，就把任务进行排队等待；如果说新任务数目增长的速度远远大于工人做任务的速度，那么此时工厂主管可能会想补救措施，比如重新招4个临时工人进来；然后就将任务也分配</p><p>给这4个临时工人做；如果说着14个工人做任务的速度还是不够，此时工厂主管可能就要考虑不再接收新的任务或者抛弃前面的一些任务了。当这14个工人当中有人空闲时，而新任务增长的速度</p><p>又比较缓慢，工厂主管可能就考虑辞掉4个临时工了，只保持原来的10个工人，毕竟请额外的工人是要花钱的。</p><p>这里的工厂可以看做成是一个线程池，每一个工人可以看做成是一个线程。其中10个正式员工，可以看做成是核心线程池中的线程，临时工就是非核心线程池中的线程。当临时工处于空闲状态</p><p>的时候，那么如果空闲的时间超过keepAliveTime所指定的时间，那么就会被销毁。</p><h4 id="3-案例演示"><a href="#3-案例演示" class="headerlink" title="3) 案例演示"></a>3) 案例演示</h4><p>接下来我们就通过一段代码的断点测试，来演示一下线程池的工作原理。</p><p>案例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExecutorDemo01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span> , <span class="number">3</span> , <span class="number">20</span> , TimeUnit.SECONDS ,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1</span>) , Executors.defaultThreadFactory() , <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy()) ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交3个任务，此时会产生一个核心线程,一个临时工线程，队列中会存在一个任务，20s后临时工线程被回收，核心线程不会被回收</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span> ; x &lt; <span class="number">3</span> ; x++) &#123;</span><br><span class="line">            threadPoolExecutor.submit(() -&gt; &#123;<span class="comment">// 断点位置</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;----&gt;&gt; 执行了任务&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初次debug方式启动线程，查看变量值</p><p><img src="/JavaNotes/%E5%A4%9A%E7%BA%BF%E7%A8%8B&juc/assets/1571735388181.png" alt="1571735388181"> </p><p>由于此时还没有提交任务，因此线程池中的线程数量为0，工作队列的任务数量也为0；提交一个任务</p><p><img src="/JavaNotes/%E5%A4%9A%E7%BA%BF%E7%A8%8B&juc/assets/1571735465100.png" alt="1571735465100"> </p><p>再次查看各个值的变化</p><p><img src="/JavaNotes/%E5%A4%9A%E7%BA%BF%E7%A8%8B&juc/assets/1571735607347.png" alt="1571735607347"> </p><p>再次提交一个任务</p><p><img src="/JavaNotes/%E5%A4%9A%E7%BA%BF%E7%A8%8B&juc/assets/1571735465100.png" alt="1571735465100"> </p><p>再次查看各个值的变化</p><p><img src="/JavaNotes/%E5%A4%9A%E7%BA%BF%E7%A8%8B&juc/assets/1571735715977.png" alt="1571735715977"> </p><p>此时会把第二个任务存储到工作队列中，因此工作队列的值为1了。再次提交一个任务</p><p><img src="/JavaNotes/%E5%A4%9A%E7%BA%BF%E7%A8%8B&juc/assets/1571735465100.png" alt="1571735465100"> </p><p>再次查看各个值的变化</p><p><img src="/JavaNotes/%E5%A4%9A%E7%BA%BF%E7%A8%8B&juc/assets/1571735904991.png" alt="1571735904991"> </p><p>此时3个任务都以及提交完毕，断点跳过。经过20s以后，再次查看该进程中的线程。</p><p><img src="/JavaNotes/%E5%A4%9A%E7%BA%BF%E7%A8%8B&juc/assets/1571736824748.png" alt="1571736824748"> </p><p>我们发现非核心线程已经被线程池回收了。</p><h4 id="4-任务拒绝策略"><a href="#4-任务拒绝策略" class="headerlink" title="4) 任务拒绝策略"></a>4) 任务拒绝策略</h4><p>RejectedExecutionHandler是jdk提供的一个任务拒绝策略接口，它下面存在4个子类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor.AbortPolicy:     丢弃任务并抛出RejectedExecutionException异常。是默认的策略。</span><br><span class="line">ThreadPoolExecutor.DiscardPolicy：    丢弃任务，但是不抛出异常 这是不推荐的做法。</span><br><span class="line">ThreadPoolExecutor.DiscardOldestPolicy：    抛弃队列中等待最久的任务 然后把当前任务加入队列中。</span><br><span class="line">ThreadPoolExecutor.CallerRunsPolicy:        调用任务的run()方法绕过线程池直接执行。</span><br></pre></td></tr></table></figure><p>注：明确线程池对多可执行的任务数 &#x3D; 队列容量 + 最大线程数</p><p><font color="blue" size="3"><strong>案例演示1</strong></font>：演示ThreadPoolExecutor.AbortPolicy任务处理策略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExecutorDemo01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span> , <span class="number">3</span> , <span class="number">20</span> , TimeUnit.SECONDS ,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1</span>) , Executors.defaultThreadFactory() , <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy()) ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交5个任务，而该线程池最多可以处理4个任务，当我们使用AbortPolicy这个任务处理策略的时候，就会抛出异常</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span> ; x &lt; <span class="number">5</span> ; x++) &#123;</span><br><span class="line">            threadPoolExecutor.submit(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;----&gt;&gt; 执行了任务&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.util.concurrent.RejectedExecutionException: Task java.util.concurrent.FutureTask@566776ad[Not completed, task = java.util.concurrent.Executors$RunnableAdapter<span class="meta">@edf4efb</span>[<span class="type">Wrapped</span> <span class="variable">task</span> <span class="operator">=</span> com.itheima.javase.thread.pool.demo04.ThreadPoolExecutorDemo01$$Lambda$<span class="number">14</span>/<span class="number">0x0000000100066840</span>@2f7a2457]] rejected from java.util.concurrent.ThreadPoolExecutor@6108b2d7[Running, <span class="type">pool</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">3</span>, <span class="type">active</span> <span class="variable">threads</span> <span class="operator">=</span> <span class="number">3</span>, <span class="type">queued</span> <span class="variable">tasks</span> <span class="operator">=</span> <span class="number">1</span>, <span class="type">completed</span> <span class="variable">tasks</span> <span class="operator">=</span> <span class="number">0</span>]</span><br><span class="line">at java.base/java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:<span class="number">2055</span>)</span><br><span class="line">at java.base/java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:<span class="number">825</span>)</span><br><span class="line">at java.base/java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:<span class="number">1355</span>)</span><br><span class="line">at java.base/java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:<span class="number">118</span>)</span><br><span class="line">at com.itheima.javase.thread.pool.demo04.ThreadPoolExecutorDemo01.main(ThreadPoolExecutorDemo01.java:<span class="number">20</span>)</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>----&gt;&gt; 执行了任务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>----&gt;&gt; 执行了任务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>----&gt;&gt; 执行了任务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>----&gt;&gt; 执行了任务</span><br></pre></td></tr></table></figure><p>控制台报错，仅仅执行了4个任务，有一个任务被丢弃了</p><p><font color="blue" size="3"><strong>案例演示2</strong></font>：演示ThreadPoolExecutor.DiscardPolicy任务处理策略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExecutorDemo02</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span> , <span class="number">3</span> , <span class="number">20</span> , TimeUnit.SECONDS ,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1</span>) , Executors.defaultThreadFactory() , <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.DiscardPolicy()) ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交5个任务，而该线程池最多可以处理4个任务，当我们使用DiscardPolicy这个任务处理策略的时候，控制台不会报错</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span> ; x &lt; <span class="number">5</span> ; x++) &#123;</span><br><span class="line">            threadPoolExecutor.submit(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;----&gt;&gt; 执行了任务&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>----&gt;&gt; 执行了任务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>----&gt;&gt; 执行了任务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>----&gt;&gt; 执行了任务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>----&gt;&gt; 执行了任务</span><br></pre></td></tr></table></figure><p>控制台没有报错，仅仅执行了4个任务，有一个任务被丢弃了</p><p><font color="blue" size="3"><strong>案例演示3</strong></font>：演示ThreadPoolExecutor.DiscardOldestPolicy任务处理策略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExecutorDemo02</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ThreadPoolExecutor threadPoolExecutor;</span><br><span class="line">        threadPoolExecutor = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span> , <span class="number">3</span> , <span class="number">20</span> , TimeUnit.SECONDS ,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1</span>) , Executors.defaultThreadFactory() , <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.DiscardOldestPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交5个任务</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span> ; x &lt; <span class="number">5</span> ; x++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 定义一个变量，来指定指定当前执行的任务;这个变量需要被final修饰</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x ;</span><br><span class="line">            threadPoolExecutor.submit(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;----&gt;&gt; 执行了任务&quot;</span> + y);</span><br><span class="line">            &#125;);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>----&gt;&gt; 执行了任务<span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>----&gt;&gt; 执行了任务<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>----&gt;&gt; 执行了任务<span class="number">3</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>----&gt;&gt; 执行了任务<span class="number">4</span></span><br></pre></td></tr></table></figure><p>由于任务1在线程池中等待时间最长，因此任务1被丢弃。</p><p><font color="blue" size="3"><strong>案例演示4</strong></font>：演示ThreadPoolExecutor.CallerRunsPolicy任务处理策略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExecutorDemo04</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ThreadPoolExecutor threadPoolExecutor;</span><br><span class="line">        threadPoolExecutor = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span> , <span class="number">3</span> , <span class="number">20</span> , TimeUnit.SECONDS ,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1</span>) , Executors.defaultThreadFactory() , <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交5个任务</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span> ; x &lt; <span class="number">5</span> ; x++) &#123;</span><br><span class="line">            threadPoolExecutor.submit(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;----&gt;&gt; 执行了任务&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>----&gt;&gt; 执行了任务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>----&gt;&gt; 执行了任务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>----&gt;&gt; 执行了任务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>----&gt;&gt; 执行了任务</span><br><span class="line">main----&gt;&gt; 执行了任务</span><br></pre></td></tr></table></figure><p>通过控制台的输出，我们可以看到次策略没有通过线程池中的线程执行任务，而是直接调用任务的run()方法绕过线程池直接执行。</p><h1 id="3-volatile关键字"><a href="#3-volatile关键字" class="headerlink" title="3 volatile关键字"></a>3 volatile关键字</h1><h2 id="3-1-看程序说结果"><a href="#3-1-看程序说结果" class="headerlink" title="3.1 看程序说结果"></a>3.1 看程序说结果</h2><p>分析如下程序，说出在控制台的输出结果。</p><p>Thread的子类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义成员变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span> ;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFlag</span><span class="params">()</span> &#123; <span class="keyword">return</span> flag;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程休眠1秒</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将flag的值更改为true</span></span><br><span class="line">        <span class="built_in">this</span>.flag = <span class="literal">true</span> ;</span><br><span class="line">        System.out.println(<span class="string">&quot;flag=&quot;</span> + flag);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileThreadDemo01</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建VolatileThread线程对象</span></span><br><span class="line">        <span class="type">VolatileThread</span> <span class="variable">volatileThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VolatileThread</span>() ;</span><br><span class="line">        volatileThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在main线程中获取开启的线程中flag的值</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;main线程中获取开启的线程中flag的值为&quot;</span> + volatileThread.isFlag());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">前面是<span class="literal">false</span>，过了一段时间之后就变成了<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>按照我们的分析，当我们把volatileThread线程启动起来以后，那么volatileThread线程开始执行。在volatileThread线程的run方法中，线程休眠1s，休眠一秒以后那么flag的值应该为</p><p>true，此时我们在主线程中不停的获取flag的值。发现前面释放false，后面是true</p><p>信息，那么这是为什么呢？要想知道原因，那么我们就需要学习一下JMM。</p><h2 id="3-2-JMM"><a href="#3-2-JMM" class="headerlink" title="3.2 JMM"></a>3.2 JMM</h2><p>概述：JMM(Java Memory Model)Java内存模型,是java虚拟机规范中所定义的一种内存模型。</p><p>Java内存模型(Java Memory Model)描述了Java程序中各种变量(线程共享变量)的访问规则，以及在JVM中将变量存储到内存和从内存中读取变量这样的底层细节。</p><p>特点：</p><ol><li><p>所有的共享变量都存储于主内存(计算机的RAM)这里所说的变量指的是实例变量和类变量。不包含局部变量，因为局部变量是线程私有的，因此不存在竞争问题。</p></li><li><p>每一个线程还存在自己的工作内存，线程的工作内存，保留了被线程使用的变量的工作副本。</p></li><li><p>线程对变量的所有的操作(读，写)都必须在工作内存中完成，而不能直接读写主内存中的变量，不同线程之间也不能直接访问对方工作内存中的变量，线程间变量的值的传递需要通过主</p><p>内存完成。</p></li></ol><p><img src="/JavaNotes/%E5%A4%9A%E7%BA%BF%E7%A8%8B&juc/assets/1571743818653.png" alt="1571743818653"> </p><h2 id="3-3-问题分析"><a href="#3-3-问题分析" class="headerlink" title="3.3 问题分析"></a>3.3 问题分析</h2><p>了解了一下JMM,那么接下来我们就来分析一下上述程序产生问题的原因。</p><p><img src="/JavaNotes/%E5%A4%9A%E7%BA%BF%E7%A8%8B&juc/assets/1571744627663.png" alt="1571744627663">  </p><p>产生问题的流程分析：</p><ol><li><p>VolatileThread线程从主内存读取到数据放入其对应的工作内存</p></li><li><p>将flag的值更改为true，但是这个时候flag的值还没有回写主内存</p></li><li><p>此时main线程读取到了flag的值并将其放入到自己的工作内存中，此时flag的值为false</p></li><li><p>VolatileThread线程将flag的值写回到主内存，但是main函数里面的while(true)调用的是系统比较底层的代码，速度快，快到没有时间再去读取主内存中的值，所以while(true)</p><p>读取到的值一直是false。(如果有一个时刻main线程从主内存中读取到了flag的最新值，那么if语句就可以执行，main线程何时从主内存中读取最新的值，我们无法控制)</p></li></ol><p>我们可以让主线程执行慢一点，执行慢一点以后，在某一个时刻，可能就会读取到主内存中最新的flag的值，那么if语句就可以进行执行。</p><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileThreadDemo02</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建VolatileThread线程对象</span></span><br><span class="line">        <span class="type">VolatileThread</span> <span class="variable">volatileThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VolatileThread</span>() ;</span><br><span class="line">        volatileThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// main方法</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(volatileThread.isFlag()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;执行了======&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 让线程休眠100毫秒</span></span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flag=<span class="literal">true</span></span><br><span class="line">执行了======</span><br><span class="line">执行了======</span><br><span class="line">执行了======</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>此时我们可以看到if语句已经执行了。当然我们在真实开发中可能不能使用这种方式来处理这个问题，那么这个问题应该怎么处理呢？我们就需要学习下一小节的内容。</p><h2 id="3-4-问题处理"><a href="#3-4-问题处理" class="headerlink" title="3.4 问题处理"></a>3.4 问题处理</h2><h3 id="3-4-1-加锁"><a href="#3-4-1-加锁" class="headerlink" title="3.4.1 加锁"></a>3.4.1 加锁</h3><p>第一种处理方案，我们可以通过加锁的方式进行处理。</p><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileThreadDemo03</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建VolatileThread线程对象</span></span><br><span class="line">        <span class="type">VolatileThread</span> <span class="variable">volatileThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VolatileThread</span>() ;</span><br><span class="line">        volatileThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// main方法</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 加锁进行问题处理</span></span><br><span class="line">            <span class="keyword">synchronized</span> (volatileThread) &#123;</span><br><span class="line">                <span class="keyword">if</span>(volatileThread.isFlag()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;执行了======&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flag=<span class="literal">true</span></span><br><span class="line">执行了======</span><br><span class="line">执行了======</span><br><span class="line">执行了======</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>工作原理说明</p><p>对上述代码加锁完毕以后，某一个线程支持该程序的过程如下：</p><p>a.线程获得锁</p><p>b.清空工作内存</p><p>c.从主内存拷贝共享变量最新的值到工作内存成为副本</p><p>d.执行代码</p><p>e.将修改后的副本的值刷新回主内存中</p><p>f.线程释放锁</p><h3 id="3-4-2-volatile关键字"><a href="#3-4-2-volatile关键字" class="headerlink" title="3.4.2 volatile关键字"></a>3.4.2 volatile关键字</h3><p>第二种处理方案，我们可以通过volatile关键字来修饰flag变量。</p><p>线程类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义成员变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span> ;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFlag</span><span class="params">()</span> &#123; <span class="keyword">return</span> flag;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程休眠1秒</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将flag的值更改为true</span></span><br><span class="line">        <span class="built_in">this</span>.flag = <span class="literal">true</span> ;</span><br><span class="line">        System.out.println(<span class="string">&quot;flag=&quot;</span> + flag);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//--------------------------------更新之后的案例-------------------------------------------</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileTest</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!flag) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;stope&quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">VolatileTest</span> <span class="variable">vt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VolatileTest</span>();</span><br><span class="line">        vt.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        vt.flag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flag=<span class="literal">true</span></span><br><span class="line">执行了======</span><br><span class="line">执行了======</span><br><span class="line">执行了======</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>工作原理说明</p><p><img src="/JavaNotes/%E5%A4%9A%E7%BA%BF%E7%A8%8B&juc/assets/1571746088704.png" alt="1571746088704"> </p><p>执行流程分析</p><ol><li>VolatileThread线程从主内存读取到数据放入其对应的工作内存</li><li>将flag的值更改为true，但是这个时候flag的值还没有回写主内存</li><li>此时main线程读取到了flag的值并将其放入到自己的工作内存中，此时flag的值为false</li><li>VolatileThread线程将flag的值写到主内存</li><li>main线程工作内存中的flag变量副本失效</li><li>main线程再次使用flag时，main线程会从主内存读取最新的值，放入到工作内存中，然后在进行使用</li></ol><p>总结： volatile保证不同线程对共享变量操作的可见性，也就是说一个线程修改了volatile修饰的变量，当修改写回主内存时，另外一个线程立即看到最新的值。</p><p>​      但是volatile不保证原子性(关于原子性问题，我们在下面的小节中会介绍)。</p><p>volatile与synchronized的区别：</p><ol><li><p>volatile只能修饰实例变量和类变量，而synchronized可以修饰方法，以及代码块。</p></li><li><p>volatile保证数据的可见性，但是不保证原子性(多线程进行写操作，不保证线程安全);而synchronized是一种排他（互斥）的机制(因此有时我们也将synchronized这种锁称</p><p>之为排他（互斥）锁)，synchronized修饰的代码块，被修饰的代码块称之为同步代码块，无法被中断可以保证原子性，也可以间接的保证可见性。</p></li></ol><h1 id="4-原子性"><a href="#4-原子性" class="headerlink" title="4 原子性"></a>4 原子性</h1><p>概述：所谓的原子性是指在一次操作或者多次操作中，要么所有的操作全部都得到了执行并且不会受到任何因素的干扰而中断，要么所有的操作都不执行，多个操作是一个不可以分割的整体。</p><p>&#x2F;&#x2F;比如说：你喂你女朋友吃冰淇淋，如果没有女朋友，你就假想一下，实在不行，你就喂你旁边的哥们吃一口冰淇淋。这就是一个不可分割的整体，一个是你喂，一个是她吃。这就是一个整体，如果没有她吃，那么你喂就没有意义，如果没有你喂，她吃就没有意义。</p><p>&#x2F;&#x2F;比如：从张三的账户给李四的账户转1000元，这个动作将包含两个基本的操作：从张三的账户扣除1000元，给李四的账户增加1000元。这两个操作必须符合原子性的要求，要么都成功要么</p><p>都失败。</p><h2 id="4-1-看程序说结果"><a href="#4-1-看程序说结果" class="headerlink" title="4.1 看程序说结果"></a>4.1 看程序说结果</h2><p>分析如下程序的执行结果</p><p>线程类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileAtomicThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个int类型的变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对该变量进行++操作，100次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span> ; x &lt; <span class="number">100</span> ; x++) &#123;</span><br><span class="line">            count++ ;</span><br><span class="line">            System.out.println(<span class="string">&quot;冰淇淋的个数 =========&gt;&gt;&gt;&gt; &quot;</span> + count);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileAtomicThreadDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建VolatileAtomicThread对象</span></span><br><span class="line">        <span class="type">VolatileAtomicThread</span> <span class="variable">volatileAtomicThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VolatileAtomicThread</span>() ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开启100个线程对count进行++操作</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span> ; x &lt; <span class="number">100</span> ; x++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(volatileAtomicThread).start();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序分析：我们在主线程中通过for循环启动了100个线程，每一个线程都会对VolatileAtomicThread类中的count加100次。那么直接结果应该是10000。但是真正的执行结果和我们分析</p><p>的是否一样呢？运行程序(多运行几次)，查看控制台输出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">....</span><br><span class="line">count =========&gt;&gt;&gt;&gt; <span class="number">9997</span></span><br><span class="line">count =========&gt;&gt;&gt;&gt; <span class="number">9998</span></span><br><span class="line">count =========&gt;&gt;&gt;&gt; <span class="number">9999</span></span><br></pre></td></tr></table></figure><p>通过控制台的输出，我们可以看到最终count的结果可能并不是10000。接下来我们就来分析一下问题产生的原因。</p><h2 id="4-2-问题分析说明"><a href="#4-2-问题分析说明" class="headerlink" title="4.2 问题分析说明"></a>4.2 问题分析说明</h2><p>以上问题主要是发生在count++操作上：</p><p>count++操作包含3个步骤：</p><ul><li>从主内存中读取数据到工作内存</li><li>对工作内存中的数据进行++操作</li><li>将工作内存中的数据写回到主内存</li></ul><p>count++操作不是一个原子性操作，也就是说在某一个时刻对某一个操作的执行，有可能被其他的线程打断。</p><p><img src="/JavaNotes/%E5%A4%9A%E7%BA%BF%E7%A8%8B&juc/assets/1571794778139.png" alt="1571794778139"> </p><p>产生问题的执行流程分析：</p><ol><li><p>假设此时count的值是100，线程A需要对改变量进行自增1的操作，首先它需要从主内存中读取变量count的值。由于CPU的切换关系，此时CPU的执行权被切换到了B线程。A线程就处</p><p>于就绪状态，B线程处于运行状态。</p></li><li><p>线程B也需要从主内存中读取count变量的值,由于线程A没有对count值做任何修改因此此时B读取到的数据还是100</p></li><li><p>线程B工作内存中对count执行了+1操作，但是未刷新之主内存中</p></li><li><p>此时CPU的执行权切换到了A线程上，由于此时线程B没有将工作内存中的数据刷新到主内存，因此A线程工作内存中的变量值还是100，没有失效。A线程对工作内存中的数据进行了+1操作。</p></li><li><p>线程B将101写入到主内存</p></li><li><p>线程A将101写入到主内存</p></li></ol><p>虽然计算了2次，但是只对A进行了1次修改。</p><h2 id="4-3-volatile原子性测试"><a href="#4-3-volatile原子性测试" class="headerlink" title="4.3 volatile原子性测试"></a>4.3 volatile原子性测试</h2><p>我们刚才说到了volatile在多线程环境下只保证了共享变量在多个线程间的可见性，但是不保证原子性。那么接下来我们就来做一个测试。测试的思想，就是使用volatile修饰count。</p><p>线程类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileAtomicThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个int类型的变量,并且使用volatile修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对该变量进行++操作，100次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span> ; x &lt; <span class="number">100</span> ; x++) &#123;</span><br><span class="line">            count++ ;</span><br><span class="line">            System.out.println(<span class="string">&quot;count =========&gt;&gt;&gt;&gt; &quot;</span> + count);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出结果(需要运行多次)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">count =========&gt;&gt;&gt;&gt; <span class="number">9997</span></span><br><span class="line">count =========&gt;&gt;&gt;&gt; <span class="number">9998</span></span><br><span class="line">count =========&gt;&gt;&gt;&gt; <span class="number">9999</span></span><br></pre></td></tr></table></figure><p>通过控制台结果的输出，我们可以看到程序还是会出现问题。因此也就证明volatile关键字是不保证原子性的。</p><h2 id="4-4-volatile使用场景"><a href="#4-4-volatile使用场景" class="headerlink" title="4.4 volatile使用场景"></a>4.4 volatile使用场景</h2><p>volatile关键字不保证原子性操作，那么同学们可能会存在一些疑问，volatile关键字在什么情况下进行使用呢？这里我们举两个基本的使用场景。</p><h3 id="4-4-1-状态标志"><a href="#4-4-1-状态标志" class="headerlink" title="4.4.1 状态标志"></a>4.4.1 状态标志</h3><p>比如现在存在一个线程不断向控制台输出一段话”传智播客中国IT教育的标杆….”,当这个线程执行5秒以后，将该线程结束。</p><p>实现思路：定义一个boolean类型的变量，这个变量就相当于一个标志。当这个变量的值为true的时候，线程一直执行，10秒以后我们把这个变量的值更改为false，此时结束该线程的执行。</p><p>为了保证一个线程对这个变量的修改，另外一个线程立马可以看到，这个变量就需要通过volatile关键字进行修饰。</p><p>线程类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileUseThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义标志变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">shutdown</span> <span class="operator">=</span> <span class="literal">false</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!shutdown) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;传智播客中国IT教育的标杆....&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.shutdown = <span class="literal">true</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileUseThreadDemo01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程任务类对象</span></span><br><span class="line">        <span class="type">VolatileUseThread</span> <span class="variable">volatileUseThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VolatileUseThread</span>() ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(volatileUseThread);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程休眠</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程</span></span><br><span class="line">        volatileUseThread.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察控制台输出，volatileUseThread线程执行5秒以后程序结束。</p><h3 id="4-4-2-独立观察"><a href="#4-4-2-独立观察" class="headerlink" title="4.4.2 独立观察"></a>4.4.2 独立观察</h3><p>&#x2F;&#x2F;AI养猪。。。。</p><p>&#x2F;&#x2F;设备区测量温度</p><p>&#x2F;&#x2F;当温度高了。。。需要给猪开空调。。。加冰棍。。。加喝的水。。。</p><p>volatile的另一种简单使用场景是：定期”发布”观察结果供程序内部使用。例如，假设有一种环境传感器能够感觉环境温度。一个后台线程可能会每隔几秒读取一次该传感器数据，并更新包</p><p>含这个volatile变量的值。然后，其他线程可以读取这个变量，从而随时能够看到最新的温度值。这种使用就是多个线程操作共享变量，但是是有一个线程对其进行写操作，其他的线程都是读。</p><p>我们可以设计一个程序，模拟上面的温度传感器案例。</p><p>实现步说明</p><ol><li><p>定义一个温度传感器(TemperatureSensor)的类,在该类中定义两个成员变量(temperature(温度值)，type(传感器的类型))，temperature变量需要被volatile修饰</p></li><li><p>定义一个读取温度传感器的线程的任务类(ReadTemperatureRunnable)，该类需要定义一个TemperatureSensor类型的成员变量(该线程需要读取温度传感器的数据)</p></li><li><p>定义一个定时采集温度的线程任务类(GatherTemperatureRunnable)，该类需要定义一个TemperatureSensor类型的成员变量(该线程需要将读到的温度设置给传感器)</p></li><li><p>创建测试类(TemperatureSensorDemo)</p><ol><li>创建TemperatureSensor对象</li><li>创建ReadTemperatureRunnable类对象，把TemperatureSensor作为构造方法的参数传递过来</li><li>创建GatherTemperatureRunnable类对象，把TemperatureSensor作为构造方法的参数传递过来</li><li>创建2个Thread对象，并启动，把第二步所创建的对象作为构造方法参数传递过来，这两个线程负责读取TemperatureSensor中的温度数据</li><li>创建1个Thread对象，并启动，把第三步所创建的对象作为构造方法参数传递过来，这个线程负责读取定时采集数据中的温度数据</li></ol></li></ol><p>TemperatureSensor类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TemperatureSensor</span> &#123;        <span class="comment">// 温度传感器类</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> temperature ;  <span class="comment">// 温度值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String type ;               <span class="comment">// 传感器的类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getTemperature</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> temperature;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTemperature</span><span class="params">(<span class="type">int</span> temperature)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.temperature = temperature;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setType</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReadTemperatureRunnable类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadTemperatureRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 温度传感器</span></span><br><span class="line">    <span class="keyword">private</span> TemperatureSensor temperatureSensor ;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReadTemperatureRunnable</span><span class="params">(TemperatureSensor temperatureSensor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.temperatureSensor = temperatureSensor ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不断的读取温度传感器中的数据</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 读取数据</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---读取到的温度数据为------&gt;&gt;&gt; &quot;</span> + temperatureSensor.getTemperature());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 让线程休眠100毫秒，便于观察</span></span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GatherTemperatureRunnable类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GatherTemperatureRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 温度传感器</span></span><br><span class="line">    <span class="keyword">private</span> TemperatureSensor temperatureSensor ;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GatherTemperatureRunnable</span><span class="params">(TemperatureSensor temperatureSensor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.temperatureSensor = temperatureSensor ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义一个变量，表示环境初始温度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temperature</span> <span class="operator">=</span> <span class="number">23</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不断进行数据采集</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将采集到的数据设置给温度传感器</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-----采集到的数据为-----&gt;&gt;&gt; &quot;</span> + temperature);</span><br><span class="line">            temperatureSensor.setTemperature(temperature);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 线程休眠2秒,模拟每隔两秒采集一次数据</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 环境温度改变</span></span><br><span class="line">            temperature += <span class="number">2</span> ;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TemperatureSensorDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建TemperatureSensor对象</span></span><br><span class="line">        <span class="type">TemperatureSensor</span> <span class="variable">temperatureSensor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemperatureSensor</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建ReadTemperatureRunnable类对象</span></span><br><span class="line">        <span class="type">ReadTemperatureRunnable</span> <span class="variable">readTemperatureRunnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReadTemperatureRunnable</span>(temperatureSensor) ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建GatherTemperatureRunnable类对象</span></span><br><span class="line">        <span class="type">GatherTemperatureRunnable</span> <span class="variable">gatherTemperatureRunnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GatherTemperatureRunnable</span>(temperatureSensor) ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建2个Thread对象，并启动; 这两个线程负责读取TemperatureSensor中的温度数据</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span> ; x &lt; <span class="number">2</span> ; x++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(readTemperatureRunnable).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建1个Thread对象，并启动，这个线程负责读取定时采集数据中的温度数据</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">gatherThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(gatherTemperatureRunnable);</span><br><span class="line">        gatherThread.setName(<span class="string">&quot;温度采集线程&quot;</span>);</span><br><span class="line">        gatherThread.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">温度采集线程-----采集到的数据为-----&gt;&gt;&gt; <span class="number">23</span></span><br><span class="line">Thread-<span class="number">0</span>---读取到的温度数据为------&gt;&gt;&gt; <span class="number">23</span></span><br><span class="line">...</span><br><span class="line">温度采集线程-----采集到的数据为-----&gt;&gt;&gt; <span class="number">25</span></span><br><span class="line">Thread-<span class="number">1</span>---读取到的温度数据为------&gt;&gt;&gt; <span class="number">25</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>通过控制台的输出，我们可以看到当温度采集线程刚采集到环境温度以后，那么此时两个温度读取线程就可以立即感知到环境温度的变化。</p><h2 id="4-5-问题处理"><a href="#4-5-问题处理" class="headerlink" title="4.5 问题处理"></a>4.5 问题处理</h2><p>接下来我们就来讲解一下我们上述案例(引入原子性问题的案例)的解决方案。</p><h3 id="4-5-1-锁机制"><a href="#4-5-1-锁机制" class="headerlink" title="4.5.1 锁机制"></a>4.5.1 锁机制</h3><p>我们可以给count++操作添加锁，那么count++操作就是临界区中的代码，临界区中的代码一次只能被一个线程去执行，所以count++就变成了原子操作。</p><p>线程任务类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileAtomicThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个int类型的变量,</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个Object类型的变量，该变量将作为同步代码块的锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对该变量进行++操作，100次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span> ; x &lt; <span class="number">100</span> ; x++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                count++ ;</span><br><span class="line">                System.out.println(<span class="string">&quot;count =========&gt;&gt;&gt;&gt; &quot;</span> + count);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">count =========&gt;&gt;&gt;&gt; <span class="number">9998</span></span><br><span class="line">count =========&gt;&gt;&gt;&gt; <span class="number">9999</span></span><br><span class="line">count =========&gt;&gt;&gt;&gt; <span class="number">10000</span></span><br></pre></td></tr></table></figure><h3 id="4-5-2-原子类"><a href="#4-5-2-原子类" class="headerlink" title="4.5.2 原子类"></a>4.5.2 原子类</h3><h4 id="1-AtomicInteger"><a href="#1-AtomicInteger" class="headerlink" title="1) AtomicInteger"></a>1) AtomicInteger</h4><p>概述：java从JDK1.5开始提供了java.util.concurrent.atomic包(简称Atomic包)，这个包中的原子操作类提供了一种用法简单，性能高效，线程安全地更新一个变量的方式。因为变</p><p>量的类型有很多种，所以在Atomic包里一共提供了13个类，属于4种类型的原子更新方式，分别是原子更新基本类型、原子更新数组、原子更新引用和原子更新属性(字段)。本次我们只讲解</p><p>使用原子的方式更新基本类型，使用原子的方式更新基本类型Atomic包提供了以下3个类：</p><p>AtomicBoolean： 原子更新布尔类型</p><p>AtomicInteger： 原子更新整型</p><p>AtomicLong：原子更新长整型</p><p>以上3个类提供的方法几乎一模一样，所以本节仅以AtomicInteger为例进行讲解，AtomicInteger的常用方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">AtomicInteger</span><span class="params">()</span>：   初始化一个默认值为<span class="number">0</span>的原子型Integer</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">AtomicInteger</span><span class="params">(<span class="type">int</span> initialValue)</span>： 初始化一个指定值的原子型Integer</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">get</span><span class="params">()</span>:     获取值</span><br><span class="line"><span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span>:       以原子方式将当前值加<span class="number">1</span>，注意，这里返回的是自增前的值。</span><br><span class="line"><span class="type">int</span> <span class="title function_">incrementAndGet</span><span class="params">()</span>:      以原子方式将当前值加<span class="number">1</span>，注意，这里返回的是自增后的值。</span><br><span class="line"><span class="type">int</span> <span class="title function_">addAndGet</span><span class="params">(<span class="type">int</span> data)</span>: 以原子方式将输入的数值与实例中的值（AtomicInteger里的value）相加，并返回结果。</span><br><span class="line"><span class="type">int</span> <span class="title function_">getAndSet</span><span class="params">(<span class="type">int</span> value)</span>:    以原子方式设置为newValue的值，并返回旧值。</span><br></pre></td></tr></table></figure><p>案例演示AtomicInteger的基本使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicIntegerDemo01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原子型Integer</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造方法</span></span><br><span class="line">        <span class="comment">// public AtomicInteger()：初始化一个默认值为0的原子型Integer</span></span><br><span class="line">        <span class="comment">// AtomicInteger atomicInteger = new AtomicInteger() ;</span></span><br><span class="line">        <span class="comment">// System.out.println(atomicInteger);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// public AtomicInteger(int initialValue)： 初始化一个指定值的原子型Integer</span></span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">5</span>) ;</span><br><span class="line">        System.out.println(atomicInteger);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取值</span></span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以原子方式将当前值加1，这里返回的是自增前的值</span></span><br><span class="line">        System.out.println(atomicInteger.getAndIncrement());</span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以原子方式将当前值加1，这里返回的是自增后的值</span></span><br><span class="line">        System.out.println(atomicInteger.incrementAndGet());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以原子方式将输入的数值与实例中的值（AtomicInteger里的value）相加，并返回结果</span></span><br><span class="line">        System.out.println(atomicInteger.addAndGet(<span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以原子方式设置为newValue的值，并返回旧值</span></span><br><span class="line">        System.out.println(atomicInteger.getAndSet(<span class="number">20</span>));</span><br><span class="line">        System.out.println(atomicInteger.get());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-案例改造"><a href="#2-案例改造" class="headerlink" title="2) 案例改造"></a>2) 案例改造</h4><p>使用AtomicInteger对案例进行改造。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileAtomicThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个int类型的变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>() ;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对该变量进行++操作，100次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span> ; x &lt; <span class="number">100</span> ; x++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> atomicInteger.incrementAndGet();</span><br><span class="line">            System.out.println(<span class="string">&quot;count =========&gt;&gt;&gt;&gt; &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">count =========&gt;&gt;&gt;&gt; <span class="number">9998</span></span><br><span class="line">count =========&gt;&gt;&gt;&gt; <span class="number">9999</span></span><br><span class="line">count =========&gt;&gt;&gt;&gt; <span class="number">10000</span></span><br></pre></td></tr></table></figure><p>通过控制台的执行结果，我们可以看到最终得到的结果就是10000，因此也就证明AtomicInteger所提供的方法是原子性操作方法。</p><h2 id="4-6-AtomicInteger原理"><a href="#4-6-AtomicInteger原理" class="headerlink" title="4.6 AtomicInteger原理"></a>4.6 AtomicInteger原理</h2><h3 id="4-6-1-原理介绍"><a href="#4-6-1-原理介绍" class="headerlink" title="4.6.1 原理介绍"></a>4.6.1 原理介绍</h3><p>AtomicInteger的本质：自旋锁 + CAS算法</p><p>CAS的全成是： Compare And Swap(比较再交换); 是现代CPU广泛支持的一种对内存中的共享数据进行操作的一种特殊指令。CAS可以将read-modify-write转换为原子操作，这个原子操作</p><p>直接由处理器保证。CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当旧预期值A和内存值V相同时，将内存值V修改为B并返回true，否则什么都不做，并返回false。</p><p>举例说明：</p><ol><li>在内存值V当中，存储着值为10的变量。</li></ol><p><img src="/JavaNotes/%E5%A4%9A%E7%BA%BF%E7%A8%8B&juc/assets/1571817059527.png" alt="1571817059527">  </p><ol start="2"><li>此时线程1想要把变量的值增加1。对线程1来说，旧的预期值 A &#x3D; 10 ，要修改的新值 B &#x3D; 11。</li></ol><p><img src="/JavaNotes/%E5%A4%9A%E7%BA%BF%E7%A8%8B&juc/assets/1571817085047.png" alt="1571817085047"> </p><ol start="3"><li>在线程1要提交更新之前，另一个线程2抢先一步，把内存值V中的变量值率先更新成了11。</li></ol><p><img src="/JavaNotes/%E5%A4%9A%E7%BA%BF%E7%A8%8B&juc/assets/1571817628904.png" alt="1571817628904"> </p><ol start="4"><li>线程1开始提交更新，首先进行A和内存值V的实际值比较（Compare），发现A不等于V的值，提交失败。</li></ol><p><img src="/JavaNotes/%E5%A4%9A%E7%BA%BF%E7%A8%8B&juc/assets/1571818176635.png" alt="1571818176635"> </p><ol start="5"><li>线程1重新获取内存值V作为当前A的值，并重新计算想要修改的新值。此时对线程1来说，A &#x3D; 11，B &#x3D; 12。这个重新尝试的过程被称为<font color="red" size="4"><strong>自旋</strong></font>。</li></ol><p><img src="/JavaNotes/%E5%A4%9A%E7%BA%BF%E7%A8%8B&juc/assets/1571818465276.png" alt="1571818465276"> </p><ol start="6"><li>这一次比较幸运，没有其他线程改变V的值。线程1进行Compare，发现A和V的值是相等的。</li></ol><p><img src="/JavaNotes/%E5%A4%9A%E7%BA%BF%E7%A8%8B&juc/assets/1571818597998.png" alt="1571818597998"> </p><ol start="7"><li>线程1进行SWAP，把内存V的值替换为B，也就是12。</li></ol><p><img src="/JavaNotes/%E5%A4%9A%E7%BA%BF%E7%A8%8B&juc/assets/1571818747880.png" alt="1571818747880"> </p><p>举例说明：这好比春节的时候抢火车票，下手快的会抢先买到票，而下手慢的可以再次尝试，直到买到票。</p><h3 id="4-6-2-源码分析"><a href="#4-6-2-源码分析" class="headerlink" title="4.6.2 源码分析"></a>4.6.2 源码分析</h3><p>那么接下来我们就来查看一下AtomicInteger类中incrementAndGet方法的源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicInteger</span> <span class="keyword">extends</span> <span class="title class_">Number</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// cas算法的实现类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> jdk.internal.misc.<span class="type">Unsafe</span> <span class="variable">U</span> <span class="operator">=</span> jdk.internal.misc.Unsafe.getUnsafe();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 表示变量值在内存中的偏移量地址，unsafe类就是根据内存偏移量地址获取数据值。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">VALUE</span> <span class="operator">=</span> U.objectFieldOffset(AtomicInteger.class, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 以原子方式将当前值加1，这里返回的是自增后的值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">incrementAndGet</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* this表示当前AtomicInteger对象 ，1表示要增加的值 */</span></span><br><span class="line">        <span class="keyword">return</span> U.getAndAddInt(<span class="built_in">this</span>, VALUE, <span class="number">1</span>) + <span class="number">1</span>;<span class="comment">// 调用Unsafe类中的getAndAddInt方法</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UnSafe类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Unsafe</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Unsafe类中的getAndAddInt方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAddInt</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">int</span> delta)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> v;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// do...while就是自旋操作,当CAS成功以后，循环结束</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 获取AtomicInteger类中所封装的int类型的值，就相当于旧的预期值A</span></span><br><span class="line">            v = getIntVolatile(o, offset); </span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 调用本类的weakCompareAndSetInt方法实现比较在交换； o: AtomicInteger对象, v: 相当于旧的预期值A, v + delta：新值B</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (!weakCompareAndSetInt(o, offset, v, v + delta));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Unsafe类中的weakCompareAndSetInt方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">weakCompareAndSetInt</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">int</span> expected, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> compareAndSetInt(o, offset, expected, x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 本地方法，调用CPU指令实现CAS</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSetInt</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">int</span> expected, <span class="type">int</span> x)</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-7-CAS与Synchronized"><a href="#4-7-CAS与Synchronized" class="headerlink" title="4.7 CAS与Synchronized"></a>4.7 CAS与Synchronized</h2><p>CAS和Synchronized都可以保证多线程环境下共享数据的安全性。那么他们两者有什么区别？</p><p>Synchronized是从悲观的角度出发：</p><p>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（<strong>共享资源每次只给一个线程使用，其它线</strong></p><p><strong>程阻塞，用完后再把资源转让给其它线程</strong>）。因此Synchronized我们也将其称之为悲观锁。jdk中的ReentrantLock也是一种悲观锁。</p><p>CAS是从乐观的角度出发:</p><p>总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据。CAS这种机制我们也可以将其称之为乐观锁。</p><h1 id="5-并发工具类"><a href="#5-并发工具类" class="headerlink" title="5 并发工具类"></a>5 并发工具类</h1><p>在JDK的并发包里提供了几个非常有用的并发容器和并发工具类。供我们在多线程开发中进行使用。</p><h2 id="5-1-ConcurrentHashMap"><a href="#5-1-ConcurrentHashMap" class="headerlink" title="5.1 ConcurrentHashMap"></a>5.1 ConcurrentHashMap</h2><h3 id="5-1-1-概述以及基本使用"><a href="#5-1-1-概述以及基本使用" class="headerlink" title="5.1.1 概述以及基本使用"></a>5.1.1 概述以及基本使用</h3><p>在集合类中HashMap是比较常用的集合对象，但是HashMap是线程不安全的(多线程环境下可能会存在问题)。为了保证数据的安全性我们可以使用Hashtable，但是Hashtable的效率低下。</p><p>基于以上两个原因我们可以使用JDK1.5以后所提供的ConcurrentHashMap。</p><p><font color="blue" size="3"><strong>案例1</strong></font>：演示HashMap线程不安全</p><p>实现步骤</p><ol><li>创建一个HashMap集合对象</li><li>创建两个线程对象，第一个线程对象向集合中添加元素(1-24),第二个线程对象向集合中添加元素(25-50);</li><li>主线程休眠1秒，以便让其他两个线程将数据填装完毕</li><li>从集合中找出键和值不相同的数据</li></ol><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapDemo01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个HashMap集合对象</span></span><br><span class="line">        HashMap&lt;String , String&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String , String&gt;() ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建两个线程对象,我们本次使用匿名内部类的方式去常见线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 第一个线程对象向集合中添加元素(1-24)</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span> ; x &lt; <span class="number">25</span> ; x++) &#123;</span><br><span class="line">                    hashMap.put(String.valueOf(x) , String.valueOf(x)) ;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程t2</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 第二个线程对象向集合中添加元素(25-50)</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">25</span> ; x &lt; <span class="number">51</span> ; x++) &#123;</span><br><span class="line">                    hashMap.put(String.valueOf(x) , String.valueOf(x)) ;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 主线程休眠2s，以便让其他两个线程将数据填装完毕</span></span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从集合中找出键和值不相同的数据</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span> ; x &lt; <span class="number">51</span> ; x++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// HashMap中的键就是当前循环变量的x这个数据的字符串表现形式 ， 根据键找到值，然后在进行判断</span></span><br><span class="line">            <span class="keyword">if</span>( !String.valueOf(x).equals( hashMap.get(String.valueOf(x)) ) ) &#123;</span><br><span class="line">                System.out.println(String.valueOf(x) + <span class="string">&quot;:&quot;</span> + hashMap.get(String.valueOf(x)));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------------------------------</span><br><span class="line"><span class="number">5</span>:<span class="literal">null</span></span><br></pre></td></tr></table></figure><p>通过控制台的输出结果，我们可以看到在多线程操作HashMap的时候，可能会出现线程安全问题。</p><blockquote><p>注1：需要多次运行才可以看到具体的效果; 可以使用循环将代码进行改造，以便让问题方便的暴露出来！</p></blockquote><p><font color="blue" size="3"><strong>案例2</strong></font>：演示Hashtable线程安全</p><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashtableDemo01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个Hashtable集合对象</span></span><br><span class="line">        Hashtable&lt;String , String&gt; hashtable = <span class="keyword">new</span> <span class="title class_">Hashtable</span>&lt;String , String&gt;() ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建两个线程对象,我们本次使用匿名内部类的方式去常见线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 第一个线程对象向集合中添加元素(1-24)</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span> ; x &lt; <span class="number">25</span> ; x++) &#123;</span><br><span class="line">                    hashtable.put(String.valueOf(x) , String.valueOf(x)) ;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程t2</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 第二个线程对象向集合中添加元素(25-50)</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">25</span> ; x &lt; <span class="number">51</span> ; x++) &#123;</span><br><span class="line">                    hashtable.put(String.valueOf(x) , String.valueOf(x)) ;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 主线程休眠2s，以便让其他两个线程将数据填装完毕</span></span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从集合中找出键和值不相同的数据</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span> ; x &lt; <span class="number">51</span> ; x++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Hashtable中的键就是当前循环变量的x这个数据的字符串表现形式 ， 根据键找到值，然后在进行判断</span></span><br><span class="line">            <span class="keyword">if</span>( !String.valueOf(x).equals( hashtable.get(String.valueOf(x)) ) ) &#123;</span><br><span class="line">                System.out.println(String.valueOf(x) + <span class="string">&quot;:&quot;</span> + hashtable.get(String.valueOf(x)));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不论该程序运行多少次，都不会产生数据问题。因此也就证明Hashtable是线程安全的。</p><p><font color="blue" size="3"><strong>Hashtable保证线程安全的原理</strong></font>：</p><p>查看Hashtable的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hashtable</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Dictionary</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, java.io.Serializable &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Entry数组，一个Entry就相当于一个元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;?,?&gt;[] table;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Entry类的定义</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> hash;<span class="comment">// 当前key的hash码值</span></span><br><span class="line">        <span class="keyword">final</span> K key;<span class="comment">// 键</span></span><br><span class="line">        V value;<span class="comment">// 值</span></span><br><span class="line">        Entry&lt;K,V&gt; next;<span class="comment">// 下一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存储数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span>&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">get</span><span class="params">(Object key)</span>&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取长度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的结构如下图所示</p><p><img src="/JavaNotes/%E5%A4%9A%E7%BA%BF%E7%A8%8B&juc/assets/1571905221097.png" alt="1571905221097"> </p><p>Hashtable保证线程安全性的是使用方法全局锁进行实现的。在线程竞争激烈的情况下HashTable的效率非常低下。因为当一个线程访问HashTable的同步方法，其他线程也访问HashTable</p><p>的同步方法时，会进入阻塞状态。如线程1使用put进行元素添加，线程2不但不能使用put方法添加元素，也不能使用get方法来获取元素，所以竞争越激烈效率越低。</p><p><font color="blue" size="3"><strong>案例3</strong></font>：演示ConcurrentHashMap线程安全</p><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcurrentHashMapDemo01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个ConcurrentHashMap集合对象</span></span><br><span class="line">        ConcurrentHashMap&lt;String , String&gt; concurrentHashMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;String , String&gt;() ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建两个线程对象,我们本次使用匿名内部类的方式去常见线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 第一个线程对象向集合中添加元素(1-24)</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span> ; x &lt; <span class="number">25</span> ; x++) &#123;</span><br><span class="line">                    concurrentHashMap.put(String.valueOf(x) , String.valueOf(x)) ;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程t2</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 第二个线程对象向集合中添加元素(25-50)</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">25</span> ; x &lt; <span class="number">51</span> ; x++) &#123;</span><br><span class="line">                    concurrentHashMap.put(String.valueOf(x) , String.valueOf(x)) ;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 主线程休眠2s，以便让其他两个线程将数据填装完毕</span></span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从集合中找出键和值不相同的数据</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span> ; x &lt; <span class="number">51</span> ; x++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// concurrentHashMap中的键就是当前循环变量的x这个数据的字符串表现形式 ， 根据键找到值，然后在进行判断</span></span><br><span class="line">            <span class="keyword">if</span>( !String.valueOf(x).equals( concurrentHashMap.get(String.valueOf(x)) ) ) &#123;</span><br><span class="line">                System.out.println(String.valueOf(x) + <span class="string">&quot;:&quot;</span> + concurrentHashMap.get(String.valueOf(x)));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不论该程序运行多少次，都不会产生数据问题。因此也就证明ConcurrentHashMap是线程安全的。</p><h3 id="5-1-2-源码分析"><a href="#5-1-2-源码分析" class="headerlink" title="5.1.2 源码分析"></a>5.1.2 源码分析</h3><p>由于ConcurrentHashMap在jdk1.7和jdk1.8的时候实现原理不太相同，因此需要分别来讲解一下两个不同版本的实现原理。</p><h4 id="1-jdk1-7版本"><a href="#1-jdk1-7版本" class="headerlink" title="1) jdk1.7版本"></a>1) jdk1.7版本</h4><p><font color="blue" size="3"><strong>ConcurrentHashMap中的重要成员变量</strong></font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcurrentHashMap</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K, V&gt; <span class="keyword">implements</span> <span class="title class_">ConcurrentMap</span>&lt;K, V&gt;, Serializable &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Segment翻译中文为&quot;段&quot; , 段数组对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Segment是一种可重入锁（ReentrantLock），在ConcurrentHashMap里扮演锁的角色，将一个大的table分割成多个小的table进行加锁。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Segment</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> count;    <span class="comment">// Segment中元素的数量，由volatile修饰，支持内存可见性；</span></span><br><span class="line">        <span class="keyword">transient</span> <span class="type">int</span> modCount; <span class="comment">// 对table的大小造成影响的操作的数量（比如put或者remove操作）;</span></span><br><span class="line">        <span class="keyword">transient</span> <span class="type">int</span> threshold; <span class="comment">// 扩容阈值;</span></span><br><span class="line">        <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;  <span class="comment">// 链表数组，数组中的每一个元素代表了一个链表的头部;</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">float</span> loadFactor; <span class="comment">// 负载因子 </span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Segment中的元素是以HashEntry的形式存放在数组中的，其结构与普通HashMap的HashEntry基本一致，不同的是Segment的HashEntry，其value由     // volatile修饰，以支持内存可见性，即写操作对其他读线程即时可见。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">HashEntry</span>&lt;K,V&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> hash;<span class="comment">// 当前节点key对应的哈希码值</span></span><br><span class="line">        <span class="keyword">final</span> K key;<span class="comment">// 存储键</span></span><br><span class="line">        <span class="keyword">volatile</span> V value;<span class="comment">// 存储值</span></span><br><span class="line">        <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next;<span class="comment">// 下一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的结构如下图所示</p><p><img src="/JavaNotes/%E5%A4%9A%E7%BA%BF%E7%A8%8B&juc/assets/1571880094854.png" alt="1571880094854">  </p><p>简单来讲，就是ConcurrentHashMap比HashMap多了一次hash过程，第1次hash定位到Segment，第2次hash定位到HashEntry，然后链表搜索找到指定节点。在进行写操作时，只需锁住写</p><p>元素所在的Segment即可(这种锁被称为<font size="3" color="red"><strong>分段锁</strong></font>)，其他Segment无需加锁，从而产生锁竞争的概率大大减小，提高了并发读写的效率。该种实现方式的缺点是hash过程比普通的HashMap要长</p><p>(因为需要进行两次hash操作)。</p><p><font color="blue" size="3"><strong>ConcurrentHashMap的put方法源码分析</strong></font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcurrentHashMap</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K, V&gt; <span class="keyword">implements</span> <span class="title class_">ConcurrentMap</span>&lt;K, V&gt;, Serializable &#123; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定义一个Segment对象</span></span><br><span class="line">        Segment&lt;K,V&gt; s;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果value的值为空，那么抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// hash函数获取key的hashCode，然后做了一些处理</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通过key的hashCode定位segment</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对定位的Segment进行判断，如果Segment为空，调用ensureSegment进行初始化操作(第一次hash定位)</span></span><br><span class="line">        <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject(segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="literal">null</span>) </span><br><span class="line">            s = ensureSegment(j);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用Segment对象的put方法添加元素</span></span><br><span class="line">        <span class="keyword">return</span> s.put(key, hash, value, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Segment是一种可ReentrantLock，在ConcurrentHashMap里扮演锁的角色，将一个大的table分割成多个小的table进行加锁。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Segment</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 添加元素</span></span><br><span class="line">        <span class="keyword">final</span> V <span class="title function_">put</span><span class="params">(K key, <span class="type">int</span> hash, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 尝试对该段进行加锁,如果加锁失败，则调用scanAndLockForPut方法;在该方法中就要进行再次尝试或者进行自旋等待</span></span><br><span class="line">            HashEntry&lt;K,V&gt; node = tryLock() ? <span class="literal">null</span> : scanAndLockForPut(key, hash, value);</span><br><span class="line">            V oldValue;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 获取HashEntry数组对象</span></span><br><span class="line">                HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 根据key的hashCode值计算索引(第二次hash定位)</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">                HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) </span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 若不为null</span></span><br><span class="line">                    <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                        K k;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 判读当前节点的key是否和链表头节点的key相同(依赖于hashCode方法和equals方法) </span></span><br><span class="line">                        <span class="comment">// 如果相同，值进行更新</span></span><br><span class="line">                        <span class="keyword">if</span> ((k = e.key) == key || (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                            oldValue = e.value;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                                e.value = value;</span><br><span class="line">                                ++modCount;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        </span><br><span class="line">                        e = e.next;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 若头结点为null</span></span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 将新节点添加到链表中</span></span><br><span class="line">                        <span class="keyword">if</span> (node != <span class="literal">null</span>) </span><br><span class="line">                            node.setNext(first);</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            node = <span class="keyword">new</span> <span class="title class_">HashEntry</span>&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> count + <span class="number">1</span>;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 如果超过阈值，则进行rehash操作</span></span><br><span class="line">                        <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                            rehash(node);</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            setEntryAt(tab, index, node);</span><br><span class="line">                        ++modCount;</span><br><span class="line">                        count = c;</span><br><span class="line">                        oldValue = <span class="literal">null</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>注：源代码进行简单讲解即可(核心：进行了两次哈希定位以及加锁过程)</p></blockquote><h4 id="2-jdk1-8版本"><a href="#2-jdk1-8版本" class="headerlink" title="2) jdk1.8版本"></a>2) jdk1.8版本</h4><p>在JDK1.8中为了进一步优化ConcurrentHashMap的性能，去掉了Segment分段锁的设计。在数据结构方面，则是跟HashMap一样，使用一个哈希表table数组。(数组 + 链表 + 红黑树) </p><p>而线程安全方面是结合CAS机制 + 局部锁实现的，减低锁的粒度，提高性能。同时在HashMap的基础上，对哈希表table数组和链表节点的value，next指针等使用volatile来修饰，从而</p><p>实现线程可见性。</p><p><font color="blue" size="3"><strong>ConcurrentHashMap中的重要成员变量</strong></font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcurrentHashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">ConcurrentMap</span>&lt;K,V&gt;, Serializable &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Node数组</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Node类的定义</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> hash;<span class="comment">// 当前key的hashCode值</span></span><br><span class="line">        <span class="keyword">final</span> K key;<span class="comment">// 键</span></span><br><span class="line">        <span class="keyword">volatile</span> V val;<span class="comment">// 值</span></span><br><span class="line">        <span class="keyword">volatile</span> Node&lt;K,V&gt; next;<span class="comment">// 下一个节点</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// TreeNode类的定义</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;K,V&gt; &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; parent;  <span class="comment">// 父节点</span></span><br><span class="line">        TreeNode&lt;K,V&gt; left;   <span class="comment">// 左子节点</span></span><br><span class="line">        TreeNode&lt;K,V&gt; right;   <span class="comment">// 右子节点</span></span><br><span class="line">        TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">        <span class="type">boolean</span> red;   <span class="comment">// 节点的颜色状态</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的结构如下图</p><p><img src="/JavaNotes/%E5%A4%9A%E7%BA%BF%E7%A8%8B&juc/assets/1571901607504.png" alt="1571901607504"> </p><p><font color="blue" size="3"><strong>ConcurrentHashMap的put方法源码分析</strong></font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcurrentHashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">ConcurrentMap</span>&lt;K,V&gt;, Serializable &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加元素</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// putVal方法定义</span></span><br><span class="line">    <span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// key为null直接抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算key所对应的hashCode值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">        <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 哈希表如果不存在，那么此时初始化哈希表</span></span><br><span class="line">            <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">                tab = initTable();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 通过hash值计算key在table表中的索引，将其值赋值给变量i,然后根据索引找到对应的Node，如果Node为null,做出处理</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 新增链表头结点，cas方式添加到哈希表table</span></span><br><span class="line">                <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>))) <span class="keyword">break</span>;                   </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">                tab = helpTransfer(tab, f);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// f为链表头结点，使用synchronized加锁</span></span><br><span class="line">                <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            binCount = <span class="number">1</span>;</span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                                K ek;</span><br><span class="line">                                </span><br><span class="line">                                <span class="comment">// 节点已经存在，更新value即可</span></span><br><span class="line">                                <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                    oldVal = e.val;</span><br><span class="line">                                    <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                        e.val = value;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                </span><br><span class="line">                                <span class="comment">// 该key对应的节点不存在,则新增节点并添加到该链表的末尾</span></span><br><span class="line">                                Node&lt;K,V&gt; pred = e;</span><br><span class="line">                                <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                                    pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                </span><br><span class="line">                            &#125;</span><br><span class="line">                            </span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123; <span class="comment">// 红黑树节点，则往该红黑树更新或添加该节点即可</span></span><br><span class="line">                            Node&lt;K,V&gt; p;</span><br><span class="line">                            binCount = <span class="number">2</span>;</span><br><span class="line">                            <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                                oldVal = p.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    p.val = value;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 判断是否需要将链表转为红黑树</span></span><br><span class="line">                <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                        treeifyBin(tab, i);</span><br><span class="line">                    <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">                        <span class="keyword">return</span> oldVal;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// CAS算法的核心类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe U;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            U = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 原子获取链表节点</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; Node&lt;K,V&gt; <span class="title function_">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="type">long</span>)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// CAS更新或新增链表节点</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="type">boolean</span> <span class="title function_">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> i, Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="type">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单总结：</p><ol><li><p>如果当前需要put的key对应的链表在哈希表table中还不存在，即还没添加过该key的hash值对应的链表，则调用casTabAt方法，基于CAS机制来实现添加该链表头结点到哈希表</p><p>table中，避免该线程在添加该链表头结的时候，其他线程也在添加的并发问题；如果CAS失败，则进行自旋，通过继续第2步的操作；</p></li><li><p>如果需要添加的链表已经存在哈希表table中，则通过tabAt方法，基于volatile机制，获取当前最新的链表头结点f，由于f指向的是ConcurrentHashMap的哈希表table的某条</p><p>链表的头结点，故虽然f是临时变量，由于是引用共享的该链表头结点，所以可以使用synchronized关键字来同步多个线程对该链表的访问。在synchronized(f)同步块里面则是与</p><p>HashMap一样遍历该链表，如果该key对应的链表节点已经存在，则更新，否则在链表的末尾新增该key对应的链表节点。</p></li></ol><h2 id="5-2-CountDownLatch"><a href="#5-2-CountDownLatch" class="headerlink" title="5.2 CountDownLatch"></a>5.2 CountDownLatch</h2><p>CountDownLatch允许一个或多个线程等待其他线程完成操作以后，再执行当前线程；比如我们在主线程需要开启2个其他线程，当其他的线程执行完毕以后我们再去执行主线程，针对这</p><p>个需求我们就可以使用CountDownLatch来进行实现。CountDownLatch中count down是倒着数数的意思；CountDownLatch是通过一个计数器来实现的，每当一个线程完成了自己的</p><p>任务后，可以调用countDown()方法让计数器-1，当计数器到达0时，调用CountDownLatch的await()方法的线程阻塞状态解除，继续执行。</p><p>CountDownLatch的相关方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CountDownLatch</span><span class="params">(<span class="type">int</span> count)</span><span class="comment">// 初始化一个指定计数器的CountDownLatch对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException<span class="comment">// 让当前线程等待</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countDown</span><span class="params">()</span><span class="comment">// 计数器进行减1</span></span><br></pre></td></tr></table></figure><p>案例演示：使用CountDownLatch完成上述需求(我们在主线程需要开启2个其他线程，当其他的线程执行完毕以后我们再去执行主线程)</p><p>实现思路：在main方法中创建一个CountDownLatch对象，把这个对象作为作为参数传递给其他的两个任务线程</p><p>线程任务类1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchThread01</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CountDownLatch类型成员变量</span></span><br><span class="line">    <span class="keyword">private</span> CountDownLatch countDownLatch ;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CountDownLatchThread01</span><span class="params">(CountDownLatch countDownLatch)</span> &#123;      <span class="comment">// 构造方法的作用：接收CountDownLatch对象</span></span><br><span class="line">        <span class="built_in">this</span>.countDownLatch = countDownLatch ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;10秒以后执行了CountDownLatchThread01......&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用CountDownLatch对象的countDown方法对计数器进行-1操作</span></span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程任务类2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchThread02</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CountDownLatch类型成员变量</span></span><br><span class="line">    <span class="keyword">private</span> CountDownLatch countDownLatch ;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CountDownLatchThread02</span><span class="params">(CountDownLatch countDownLatch)</span> &#123;      <span class="comment">// 构造方法的作用：接收CountDownLatch对象</span></span><br><span class="line">        <span class="built_in">this</span>.countDownLatch = countDownLatch ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;3秒以后执行了CountDownLatchThread02......&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用CountDownLatch对象的countDown方法对计数器进行-1操作</span></span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchDemo01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  1. 创建一个CountDownLatch对象</span></span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">2</span>) ;                 <span class="comment">// CountDownLatch中的计数器的默认值就是2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//  2. 创建线程任务类对象，并且把这个CountDownLatch对象作为构造方法的参数进行传递</span></span><br><span class="line">        <span class="type">CountDownLatchThread01</span> <span class="variable">countDownLatchThread01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatchThread01</span>(countDownLatch) ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  3. 创建线程任务类对象，并且把这个CountDownLatch对象作为构造方法的参数进行传递</span></span><br><span class="line">        <span class="type">CountDownLatchThread02</span> <span class="variable">countDownLatchThread02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatchThread02</span>(countDownLatch) ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  4. 创建线程对象，并启动线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(countDownLatchThread01);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(countDownLatchThread02);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  5. 在主线程中调用 CountDownLatch中的await让主线程处于阻塞状态</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  6. 程序结束的输出</span></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程执行了.... 程序结束了......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>秒以后执行了CountDownLatchThread02......</span><br><span class="line"><span class="number">10</span>秒以后执行了CountDownLatchThread01......</span><br><span class="line">主线程执行了.... 程序结束了......</span><br></pre></td></tr></table></figure><p>CountDownLatchThread02线程先执行完毕，此时计数器-1；CountDownLatchThread01线程执行完毕，此时计数器-1；当计数器的值为0的时候，主线程阻塞状态接触，主线程向下执行。</p><h2 id="5-3-CyclicBarrier"><a href="#5-3-CyclicBarrier" class="headerlink" title="5.3 CyclicBarrier"></a>5.3 CyclicBarrier</h2><h3 id="5-3-1-概述以及基本使用"><a href="#5-3-1-概述以及基本使用" class="headerlink" title="5.3.1 概述以及基本使用"></a>5.3.1 概述以及基本使用</h3><p>CyclicBarrier的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障</p><p>才会开门，所有被屏障拦截的线程才会继续运行。</p><p>例如：公司召集5名员工开会，等5名员工都到了，会议开始。我们创建5个员工线程，1个开会线程，几乎同时启动，使用CyclicBarrier保证5名员工线程全部执行后，再执行开会线程。</p><p>CyclicBarrier的相关方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CyclicBarrier</span><span class="params">(<span class="type">int</span> parties, Runnable barrierAction)</span>   <span class="comment">// 用于在线程到达屏障时，优先执行barrierAction，方便处理更复杂的业务场景</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">await</span><span class="params">()</span><span class="comment">// 每个线程调用await方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞</span></span><br></pre></td></tr></table></figure><p>案例演示：模拟员工开会</p><p>实现步骤：</p><ol><li>创建一个员工线程类(EmployeeThread),该线程类中需要定义一个CyclicBarrier类型的形式参数</li><li>创建一个开会线程类(MettingThread)</li><li>测试类<ol><li>创建CyclicBarrier对象</li><li>创建5个EmployeeThread线程对象，把第一步创建的CyclicBarrier对象作为构造方法参数传递过来</li><li>启动5个员工线程</li></ol></li></ol><p>员工线程类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmployeeThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CyclicBarrier类型的成员变量</span></span><br><span class="line">    <span class="keyword">private</span> CyclicBarrier cyclicBarrier ;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EmployeeThread</span><span class="params">(CyclicBarrier cyclicBarrier)</span> &#123;        <span class="comment">// 使用构造方法对CyclicBarrier进行初始化</span></span><br><span class="line">        <span class="built_in">this</span>.cyclicBarrier = cyclicBarrier ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 模拟开会人员的随机到场</span></span><br><span class="line">            Thread.sleep((<span class="type">int</span>) (Math.random() * <span class="number">1000</span>));</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 到了! &quot;</span>);</span><br><span class="line">            cyclicBarrier.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开会线程类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MettingThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;好了，人都到了，开始开会......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierDemo01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建CyclicBarrier对象</span></span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">5</span> , <span class="keyword">new</span> <span class="title class_">MettingThread</span>()) ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建5个EmployeeThread线程对象，把第一步创建的CyclicBarrier对象作为构造方法参数传递过来</span></span><br><span class="line">        <span class="type">EmployeeThread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmployeeThread</span>(cyclicBarrier) ;</span><br><span class="line">        <span class="type">EmployeeThread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmployeeThread</span>(cyclicBarrier) ;</span><br><span class="line">        <span class="type">EmployeeThread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmployeeThread</span>(cyclicBarrier) ;</span><br><span class="line">        <span class="type">EmployeeThread</span> <span class="variable">thread4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmployeeThread</span>(cyclicBarrier) ;</span><br><span class="line">        <span class="type">EmployeeThread</span> <span class="variable">thread5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmployeeThread</span>(cyclicBarrier) ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动5个员工线程</span></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">        thread4.start();</span><br><span class="line">        thread5.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-2-使用场景"><a href="#5-3-2-使用场景" class="headerlink" title="5.3.2 使用场景"></a>5.3.2 使用场景</h3><p>使用场景：CyclicBarrier可以用于多线程计算数据，最后合并计算结果的场景。</p><p>比如：现在存在两个文件，这个两个文件中存储的是某一个员工两年的工资信息(一年一个文件)，现需要对这两个文件中的数据进行汇总；使用两个线程读取2个文件中的数据，当两个文</p><p>件中的数据都读取完毕以后，进行数据的汇总操作。</p><p>分析：要想在两个线程读取数据完毕以后进行数据的汇总，那么我们就需要定义一个任务类(该类需要实现Runnable接口)；两个线程读取完数据以后再进行数据的汇总，那么我们可以将</p><p>​ 两个线程读取到的数据先存储到一个集合中，而多线程环境下最常见的线程集合类就是ConcurrentHashMap，而这个集合需要被两个线程都可以进行使用，那么我们可以将这个集</p><p>​ 合作为我们任务类的成员变量，然后我们在这个任务类中去定义一个CyclicBarrier对象，然后在定义一个方法(count)，当调用这个count方法的时候需要去开启两个线程对象，</p><p>​ 使用这两个线程对象读取数据，把读取到的数据存储到ConcurrentHashMap对象，当一个线程读取数据完毕以后，调用CyclicBarrier的awit方法(告诉CyclicBarrier我已经</p><p>​ 到达了屏障)，然后在任务类的run方法对ConcurrentHashMap的数据进行汇总操作；</p><p>实现步骤:</p><ol><li>定义一个任务类CyclicBarrierThreadUse(实现了Runnable接口)</li><li>定义成员变量：CyclicBarrier ，ConcurrentHashMap</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">2</span> , <span class="built_in">this</span>) ;</span><br><span class="line"><span class="keyword">private</span> ConcurrentHashMap&lt;Integer , String&gt; concurrentHashMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;Integer , String&gt;() ;</span><br></pre></td></tr></table></figure><ol start="3"><li>定义一个方法count方法，在count方法中开启两个线程对象(可以使用匿名内部类的方式实现)</li><li>在run方法中对ConcurrentHashMap中的数据进行汇总</li><li>编写测试类CyclicBarrierThreadUseDemo</li><li>创建CyclicBarrierThreadUse对象，调用count方法</li></ol><p>任务类代代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierThreadUse</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前我们两个线程到达了屏障点以后，我们需要立即对数据进行汇总, 因此我们需要使用第二个构造方法</span></span><br><span class="line">    <span class="comment">// 并且我们当前这个类就是一个任务类，因此我们可以直接传递参数this</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">2</span> , <span class="built_in">this</span>) ;</span><br><span class="line">    <span class="keyword">private</span> ConcurrentHashMap&lt;Integer , String&gt; concurrentHashMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;Integer , String&gt;() ;  <span class="comment">// 存储两个线程所读取的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">count</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义一个方法count方法，在count方法中开启两个线程对象(可以使用匿名内部类的方式实现)</span></span><br><span class="line">        <span class="comment">// 线程1</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 读取数据</span></span><br><span class="line">                <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="literal">null</span> ;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    bufferedReader = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;D:\\salary\\2017-salary.txt&quot;</span>)) ;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span> ;</span><br><span class="line">                    <span class="keyword">while</span>((line = bufferedReader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                        concurrentHashMap.put(Integer.parseInt(line) , <span class="string">&quot;&quot;</span>) ;            <span class="comment">// 小的问题，工资信息不能重复</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(bufferedReader != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            bufferedReader.close();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 模拟任务的执行时间</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">5</span>) ;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---------------------线程读取数据完毕....&quot;</span>);</span><br><span class="line">                    cyclicBarrier.await() ;         <span class="comment">//通知cyclicBarrier当前线程已经到达了屏障点</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程2</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 读取数据</span></span><br><span class="line">                <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="literal">null</span> ;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    bufferedReader = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;D:\\salary\\2019-salary.txt&quot;</span>)) ;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span> ;</span><br><span class="line">                    <span class="keyword">while</span>((line = bufferedReader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                        concurrentHashMap.put(Integer.parseInt(line) , <span class="string">&quot;&quot;</span>) ;            <span class="comment">// 小的问题，工资信息不能重复</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(bufferedReader != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            bufferedReader.close();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 模拟任务的执行时间</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">10</span>) ;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---------------------线程读取数据完毕....&quot;</span>);</span><br><span class="line">                    cyclicBarrier.await() ;         <span class="comment">//通知cyclicBarrier当前线程已经到达了屏障点</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取concurrentHashMap中的数据进行汇总</span></span><br><span class="line">        Enumeration&lt;Integer&gt; enumeration = concurrentHashMap.keys();        <span class="comment">// 获取concurrentHashMap中所有的键</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这个Enumeration的使用和我们之前所学习过的迭代器类似</span></span><br><span class="line"><span class="comment">         * boolean hasMoreElements(); 判断集合中是否存在下一个元素</span></span><br><span class="line"><span class="comment">         * E nextElement();           获取元素</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">while</span>(enumeration.hasMoreElements()) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> enumeration.nextElement();</span><br><span class="line">            result += integer ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出</span></span><br><span class="line">        System.out.println(result);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierThreadUseDemo01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建任务类的对象</span></span><br><span class="line">        <span class="type">CyclicBarrierThreadUse</span> <span class="variable">cyclicBarrierThreadUse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrierThreadUse</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用count方法进行数据汇总</span></span><br><span class="line">        cyclicBarrierThreadUse.count();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-4-Semaphore"><a href="#5-4-Semaphore" class="headerlink" title="5.4 Semaphore"></a>5.4 Semaphore</h2><p>Semaphore字面意思是信号量的意思，它的作用是控制访问特定资源的线程数目。</p><p>举例：现在有一个十字路口，有多辆汽车需要进经过这个十字路口，但是我们规定同时只能有两辆汽车经过。其他汽车处于等待状态，只要某一个汽车经过了这个十字路口，其他的汽车才可以经</p><p>过，但是同时只能有两个汽车经过。如何限定经过这个十字路口车辆数目呢? 我们就可以使用Semaphore。</p><p>Semaphore的常用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> <span class="keyword">permits</span>)</span><span class="keyword">permits</span> 表示许可线程的数量</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException表示获取许可</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">()</span>表示释放许可</span><br></pre></td></tr></table></figure><p>案例演示：模拟汽车通过十字路口</p><p>实现步骤：</p><ol><li>创建一个汽车的线程任务类(CarThreadRunnable),在该类中定义一个Semaphore类型的成员变量</li><li>创建测试类<ol><li>创建线程任务类对象</li><li>创建5个线程对象，并启动。(5个线程对象，相当于5辆汽车)</li></ol></li></ol><p>CarThreadRunnable类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CarThreadRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个Semaphore对象,限制只允许2个线程获取到许可证</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">2</span>) ;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;                         <span class="comment">// 这个run只允许2个线程同时执行</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取许可证</span></span><br><span class="line">            semaphore.acquire();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-----&gt;&gt;正在经过十字路口&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 模拟车辆经过十字路口所需要的时间</span></span><br><span class="line">            <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextInt</span> <span class="operator">=</span> random.nextInt(<span class="number">7</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(nextInt);</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;-----&gt;&gt;驶出十字路口&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 释放许可证</span></span><br><span class="line">            semaphore.release();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreDemo01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程任务类对象</span></span><br><span class="line">        <span class="type">CarThreadRunnable</span> <span class="variable">carThreadRunnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CarThreadRunnable</span>() ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建5个线程对象，并启动。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span> ; x &lt; <span class="number">5</span> ; x++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(carThreadRunnable).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">0</span>-----&gt;&gt;正在经过十字路口</span><br><span class="line">Thread-<span class="number">1</span>-----&gt;&gt;正在经过十字路口</span><br><span class="line">Thread-<span class="number">1</span>-----&gt;&gt;驶出十字路口</span><br><span class="line">Thread-<span class="number">2</span>-----&gt;&gt;正在经过十字路口</span><br><span class="line">Thread-<span class="number">0</span>-----&gt;&gt;驶出十字路口</span><br><span class="line">Thread-<span class="number">3</span>-----&gt;&gt;正在经过十字路口</span><br><span class="line">Thread-<span class="number">2</span>-----&gt;&gt;驶出十字路口</span><br><span class="line">Thread-<span class="number">4</span>-----&gt;&gt;正在经过十字路口</span><br><span class="line">Thread-<span class="number">4</span>-----&gt;&gt;驶出十字路口</span><br><span class="line">Thread-<span class="number">3</span>-----&gt;&gt;驶出十字路口</span><br></pre></td></tr></table></figure><p>通过控制台输出，我们可以看到当某一个汽车”驶出”十字路口以后，就会有一个汽车立马驶入。</p><h2 id="5-5-Exchanger"><a href="#5-5-Exchanger" class="headerlink" title="5.5 Exchanger"></a>5.5 Exchanger</h2><h3 id="5-5-1-概述以及基本使用"><a href="#5-5-1-概述以及基本使用" class="headerlink" title="5.5.1 概述以及基本使用"></a>5.5.1 概述以及基本使用</h3><p>Exchanger（交换者）是一个用于线程间协作的工具类。Exchanger用于进行线程间的数据交换。</p><p>举例：比如男女双方结婚的时候，需要进行交换结婚戒指。</p><p>Exchanger常用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Exchanger</span><span class="params">()</span><span class="comment">// 构造方法</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">exchange</span><span class="params">(V x)</span><span class="comment">// 进行交换数据的方法，参数x表示本方数据 ，返回值v表示对方数据</span></span><br></pre></td></tr></table></figure><p>这两个线程通过exchange方法交换数据，如果第一个线程先执行exchange()方法，它会一直等待第二个线程也执行exchange方法，当两个线程都到达同步点时，这两个线程就可以交换数据，</p><p>将本线程生产出来的数据传递给对方。</p><p>案例演示：模拟交互结婚戒指</p><p>实现步骤：</p><ol><li>创建一个男方的线程类(ManThread),定义一个Exchanger类型的成员变量</li><li>创建一个女方的线程类(WomanThread),定义一个Exchanger类型的成员变量</li><li>测试类<ol><li>创建一个Exchanger对象</li><li>创建一个ManThread对象，把第一步所创建的Exchanger作为构造方法参数传递过来</li><li>创建一个WomanThread对象，把第一步所创建的Exchanger作为构造方法参数传递过来</li><li>启动两个线程</li></ol></li></ol><p>ManThread类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ManThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义Exchanger类型的变量</span></span><br><span class="line">    <span class="keyword">private</span> Exchanger&lt;String&gt; exchanger ;</span><br><span class="line">    <span class="keyword">private</span> String name ;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ManThread</span><span class="params">(Exchange&lt;String&gt; exchanger , String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.name = name ;</span><br><span class="line">        <span class="built_in">this</span>.exchanger = exchanger ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> exchanger.exchange(<span class="string">&quot;钻戒&quot;</span>);</span><br><span class="line">            System.out.println(name + <span class="string">&quot;----&gt;&gt;把钻戒给媳妇&quot;</span>);</span><br><span class="line">            System.out.println(name + <span class="string">&quot;----&gt;&gt;得到媳妇给的&quot;</span> + result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WomanThread类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WomanThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义Exchanger类型的变量</span></span><br><span class="line">    <span class="keyword">private</span> Exchanger&lt;String&gt; exchanger ;</span><br><span class="line">    <span class="keyword">private</span> String name ;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WomanThread</span><span class="params">(Exchanger&lt;String&gt; exchanger , String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name) ;</span><br><span class="line">        <span class="built_in">this</span>.name = name ;</span><br><span class="line">        <span class="built_in">this</span>.exchanger = exchanger ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> exchanger.exchange(<span class="string">&quot;铝戒&quot;</span>);</span><br><span class="line">            System.out.println(name + <span class="string">&quot;----&gt;&gt;把铝戒给老公&quot;</span>);</span><br><span class="line">            System.out.println(name + <span class="string">&quot;----&gt;&gt;得到老公给的&quot;</span> + result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExchangerDemo01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个Exchanger对象</span></span><br><span class="line">        Exchanger&lt;String&gt; exchanger = <span class="keyword">new</span> <span class="title class_">Exchanger</span>&lt;String&gt;() ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个ManThread对象</span></span><br><span class="line">        <span class="type">ManThread</span> <span class="variable">manThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ManThread</span>(exchanger , <span class="string">&quot;杨过&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个WomanThread对象</span></span><br><span class="line">        <span class="type">WomanThread</span> <span class="variable">womanThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WomanThread</span>(exchanger , <span class="string">&quot;小龙女&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        manThread.start();</span><br><span class="line">        womanThread.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-5-2-使用场景"><a href="#5-5-2-使用场景" class="headerlink" title="5.5.2 使用场景"></a>5.5.2 使用场景</h3><p>使用场景：可以做数据校对工作</p><p>比如: 现在存在一个文件，该文件中存储的是某一个员工一年的工资信息，现需要将这个员工的工资信息录入到系统中，采用AB岗两人进行录入，录入到两个文件中，系统需要加载这两</p><p>个文件，并对两个文件数据进行校对，看看是否录入一致，</p><p>实现步骤：</p><ol><li>创建一个测试类(ExchangerUseDemo)</li><li>通过匿名内部类的方法创建两个线程对象</li><li>两个线程分别读取文件中的数据，然后将数据存储到各自的集合中</li><li>当每一个线程读取完数据以后，就将数据交换给对方</li><li>然后每个线程使用对方传递过来的数据与自己所录入的数据进行比对</li></ol><p>ExchangerUseDemo类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExchangerUseDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 创建Exchanger对象</span></span><br><span class="line">        Exchanger&lt;ArrayList&lt;String&gt;&gt; exchanger = <span class="keyword">new</span> <span class="title class_">Exchanger</span>&lt;ArrayList&lt;String&gt;&gt;() ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 通过匿名内部类的方法创建两个线程对象</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 读取文件中的数据，然后将其存储到集合中</span></span><br><span class="line">                    ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;() ;</span><br><span class="line">                    <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;D:\\salary\\2017-salary.txt&quot;</span>)) ;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span> ;</span><br><span class="line">                    <span class="keyword">while</span>((line = bufferedReader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                        arrayList.add(line) ;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// arrayList.add(&quot;90000&quot;) ;</span></span><br><span class="line">                    <span class="comment">// arrayList.set(0 , &quot;90000&quot;) ;</span></span><br><span class="line">                    arrayList.remove(<span class="number">0</span>) ;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 调用Exchanger中的exchange方法完成数据的交换</span></span><br><span class="line">                    ArrayList&lt;String&gt; exchange = exchanger.exchange(arrayList);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 先比对长度</span></span><br><span class="line">                    <span class="keyword">if</span>(arrayList.size() == exchange.size()) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 然后使用对方线程所传递过来的数据和自己线程所读取到的数据进行比对</span></span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span> ; x &lt; arrayList.size() ; x++) &#123;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 本方数据</span></span><br><span class="line">                            <span class="type">String</span> <span class="variable">benfangElement</span> <span class="operator">=</span> arrayList.get(x);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 对方数据</span></span><br><span class="line">                            <span class="type">String</span> <span class="variable">duifangElement</span> <span class="operator">=</span> exchange.get(x);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 比对</span></span><br><span class="line">                            <span class="keyword">if</span>(!benfangElement.equals(duifangElement)) &#123;</span><br><span class="line">                                System.out.println(<span class="string">&quot;数据存在问题.....&quot;</span>);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;<span class="keyword">else</span>  &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;数据存在问题.....&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程2</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 读取文件中的数据，然后将其存储到集合中</span></span><br><span class="line">                    ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;() ;</span><br><span class="line">                    <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;D:\\salary\\2017-salary.txt&quot;</span>)) ;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span> ;</span><br><span class="line">                    <span class="keyword">while</span>((line = bufferedReader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                        arrayList.add(line) ;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 调用Exchanger中的exchange方法完成数据的交换</span></span><br><span class="line">                    ArrayList&lt;String&gt; exchange = exchanger.exchange(arrayList);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 先比对长度</span></span><br><span class="line">                    <span class="keyword">if</span>(arrayList.size() == exchange.size()) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 然后使用对方线程所传递过来的数据和自己线程所读取到的数据进行比对</span></span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span> ; x &lt; arrayList.size() ; x++) &#123;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 本方数据</span></span><br><span class="line">                            <span class="type">String</span> <span class="variable">benfangElement</span> <span class="operator">=</span> arrayList.get(x);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 对方数据</span></span><br><span class="line">                            <span class="type">String</span> <span class="variable">duifangElement</span> <span class="operator">=</span> exchange.get(x);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 比对</span></span><br><span class="line">                            <span class="keyword">if</span>(!benfangElement.equals(duifangElement)) &#123;</span><br><span class="line">                                System.out.println(<span class="string">&quot;数据存在问题.....&quot;</span>);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;<span class="keyword">else</span>  &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;数据存在问题.....&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>泛型&amp;Set&amp;数据结构</title>
      <link href="/posts/47de4be2.html"/>
      <url>/posts/47de4be2.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-泛型"><a href="#1-泛型" class="headerlink" title="1.泛型"></a>1.泛型</h2><h3 id="1-1泛型概述"><a href="#1-1泛型概述" class="headerlink" title="1.1泛型概述"></a>1.1泛型概述</h3><ul><li><p>泛型的介绍</p><p>​泛型是JDK5中引入的特性，它提供了编译时类型安全检测机制</p></li><li><p>泛型的好处</p><ol><li>把运行时期的问题提前到了编译期间</li><li>避免了强制类型转换</li></ol></li><li><p>泛型的定义格式</p><ul><li>&lt;类型&gt;: 指定一种类型的格式.尖括号里面可以任意书写,一般只写一个字母.例如: <E> <T></li><li>&lt;类型1,类型2…&gt;: 指定多种类型的格式,多种类型之间用逗号隔开.例如: &lt;E,T&gt; &lt;K,V&gt;</li></ul></li></ul><h2 id="2-Set集合"><a href="#2-Set集合" class="headerlink" title="2.Set集合"></a>2.Set集合</h2><h3 id="2-1Set集合概述和特点【应用】"><a href="#2-1Set集合概述和特点【应用】" class="headerlink" title="2.1Set集合概述和特点【应用】"></a>2.1Set集合概述和特点【应用】</h3><ul><li>不可以存储重复元素</li><li>没有索引,不能使用普通for循环遍历</li></ul><h3 id="2-2Set集合的使用【应用】"><a href="#2-2Set集合的使用【应用】" class="headerlink" title="2.2Set集合的使用【应用】"></a>2.2Set集合的使用【应用】</h3><p>存储字符串并遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySet1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="comment">//创建集合对象</span></span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">      <span class="comment">//添加元素</span></span><br><span class="line">        set.add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        for (int i = 0; i &lt; set.size(); i++) &#123;</span></span><br><span class="line"><span class="comment">//            //Set集合是没有索引的，所以不能使用通过索引获取元素的方法</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">//遍历集合</span></span><br><span class="line">        Iterator&lt;String&gt; it = set.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> it.next();</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------------------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : set) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-TreeSet集合"><a href="#3-TreeSet集合" class="headerlink" title="3.TreeSet集合"></a>3.TreeSet集合</h2><h3 id="3-1TreeSet集合概述和特点【应用】"><a href="#3-1TreeSet集合概述和特点【应用】" class="headerlink" title="3.1TreeSet集合概述和特点【应用】"></a>3.1TreeSet集合概述和特点【应用】</h3><ul><li>不可以存储重复元素</li><li>没有索引</li><li>可以将元素按照规则进行排序<ul><li>TreeSet()：根据其元素的自然排序进行排序</li><li>TreeSet(Comparator comparator) ：根据指定的比较器进行排序</li></ul></li></ul><h3 id="3-2TreeSet集合基本使用【应用】"><a href="#3-2TreeSet集合基本使用【应用】" class="headerlink" title="3.2TreeSet集合基本使用【应用】"></a>3.2TreeSet集合基本使用【应用】</h3><p>存储Integer类型的整数并遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeSetDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建集合对象</span></span><br><span class="line">        TreeSet&lt;Integer&gt; ts = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        ts.add(<span class="number">10</span>);</span><br><span class="line">        ts.add(<span class="number">40</span>);</span><br><span class="line">        ts.add(<span class="number">30</span>);</span><br><span class="line">        ts.add(<span class="number">50</span>);</span><br><span class="line">        ts.add(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        ts.add(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历集合</span></span><br><span class="line">        <span class="keyword">for</span>(Integer i : ts) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3自然排序Comparable的使用【应用】"><a href="#3-3自然排序Comparable的使用【应用】" class="headerlink" title="3.3自然排序Comparable的使用【应用】"></a>3.3自然排序Comparable的使用【应用】</h3><ul><li><p>案例需求</p><ul><li>存储学生对象并遍历，创建TreeSet集合使用无参构造方法</li><li>要求：按照年龄从小到大排序，年龄相同时，按照姓名的字母顺序排序</li></ul></li><li><p>实现步骤</p><ol><li>使用空参构造创建TreeSet集合<ul><li>用TreeSet集合存储自定义对象，无参构造方法使用的是自然排序对元素进行排序的</li></ul></li><li>自定义的Student类实现Comparable接口<ul><li>自然排序，就是让元素所属的类实现Comparable接口，重写compareTo(T o)方法</li></ul></li><li>重写接口中的compareTo方法<ul><li>重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写</li></ul></li></ol></li><li><p>代码实现</p><p>学生类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Student&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student o)</span> &#123;</span><br><span class="line">        <span class="comment">//按照对象的年龄进行排序</span></span><br><span class="line">        <span class="comment">//主要判断条件: 按照年龄从小到大排序</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="built_in">this</span>.age - o.age;</span><br><span class="line">        <span class="comment">//次要判断条件: 年龄相同时，按照姓名的字母顺序排序</span></span><br><span class="line">        result = result == <span class="number">0</span> ? <span class="built_in">this</span>.name.compareTo(o.getName()) : result;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTreeSet2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建集合对象</span></span><br><span class="line">        TreeSet&lt;Student&gt; ts = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//创建学生对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;zhangsan&quot;</span>,<span class="number">28</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;lisi&quot;</span>,<span class="number">27</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;wangwu&quot;</span>,<span class="number">29</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;zhaoliu&quot;</span>,<span class="number">28</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;qianqi&quot;</span>,<span class="number">30</span>);</span><br><span class="line"><span class="comment">//把学生添加到集合</span></span><br><span class="line">        ts.add(s1);</span><br><span class="line">        ts.add(s2);</span><br><span class="line">        ts.add(s3);</span><br><span class="line">        ts.add(s4);</span><br><span class="line">        ts.add(s5);</span><br><span class="line"><span class="comment">//遍历集合</span></span><br><span class="line">        <span class="keyword">for</span> (Student student : ts) &#123;</span><br><span class="line">            System.out.println(student);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-4比较器排序Comparator的使用【应用】"><a href="#3-4比较器排序Comparator的使用【应用】" class="headerlink" title="3.4比较器排序Comparator的使用【应用】"></a>3.4比较器排序Comparator的使用【应用】</h3><ul><li><p>案例需求</p><ul><li>存储老师对象并遍历，创建TreeSet集合使用带参构造方法</li><li>要求：按照年龄从小到大排序，年龄相同时，按照姓名的字母顺序排序</li></ul></li><li><p>实现步骤</p><ul><li>用TreeSet集合存储自定义对象，带参构造方法使用的是比较器排序对元素进行排序的</li><li>比较器排序，就是让集合构造方法接收Comparator的实现类对象，重写compare(T o1,T o2)方法</li><li>重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写</li></ul></li><li><p>代码实现</p><p>老师类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Teacher</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Teacher</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Teacher&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTreeSet4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="comment">//创建集合对象</span></span><br><span class="line">        TreeSet&lt;Teacher&gt; ts = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Teacher&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Teacher o1, Teacher o2)</span> &#123;</span><br><span class="line">                <span class="comment">//o1表示现在要存入的那个元素</span></span><br><span class="line">                <span class="comment">//o2表示已经存入到集合中的元素</span></span><br><span class="line">              </span><br><span class="line">                <span class="comment">//主要条件</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> o1.getAge() - o2.getAge();</span><br><span class="line">                <span class="comment">//次要条件</span></span><br><span class="line">                result = result == <span class="number">0</span> ? o1.getName().compareTo(o2.getName()) : result;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">//创建老师对象</span></span><br><span class="line">        <span class="type">Teacher</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>(<span class="string">&quot;zhangsan&quot;</span>,<span class="number">23</span>);</span><br><span class="line">        <span class="type">Teacher</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>(<span class="string">&quot;lisi&quot;</span>,<span class="number">22</span>);</span><br><span class="line">        <span class="type">Teacher</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>(<span class="string">&quot;wangwu&quot;</span>,<span class="number">24</span>);</span><br><span class="line">        <span class="type">Teacher</span> <span class="variable">t4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>(<span class="string">&quot;zhaoliu&quot;</span>,<span class="number">24</span>);</span><br><span class="line"><span class="comment">//把老师添加到集合</span></span><br><span class="line">        ts.add(t1);</span><br><span class="line">        ts.add(t2);</span><br><span class="line">        ts.add(t3);</span><br><span class="line">        ts.add(t4);</span><br><span class="line"><span class="comment">//遍历集合</span></span><br><span class="line">        <span class="keyword">for</span> (Teacher teacher : ts) &#123;</span><br><span class="line">            System.out.println(teacher);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-5两种比较方式总结【理解】"><a href="#3-5两种比较方式总结【理解】" class="headerlink" title="3.5两种比较方式总结【理解】"></a>3.5两种比较方式总结【理解】</h3><ul><li>两种比较方式小结<ul><li>自然排序: 自定义类实现Comparable接口,重写compareTo方法,根据返回值进行排序</li><li>比较器排序: 创建TreeSet对象的时候传递Comparator的实现类对象,重写compare方法,根据返回值进行排序</li><li>在使用的时候,默认使用自然排序,当自然排序不满足现在的需求时,必须使用比较器排序</li></ul></li><li>两种方式中关于返回值的规则<ul><li>如果返回值为负数，表示当前存入的元素是较小值，存左边</li><li>如果返回值为0，表示当前存入的元素跟集合中元素重复了，不存</li><li>如果返回值为正数，表示当前存入的元素是较大值，存右边</li></ul></li></ul><h2 id="4-数据结构"><a href="#4-数据结构" class="headerlink" title="4.数据结构"></a>4.数据结构</h2><h3 id="4-1二叉树【理解】"><a href="#4-1二叉树【理解】" class="headerlink" title="4.1二叉树【理解】"></a>4.1二叉树【理解】</h3><ul><li><p>二叉树的特点</p><ul><li>二叉树中,任意一个节点的度要小于等于2<ul><li>节点: 在树结构中,每一个元素称之为节点</li><li>度: 每一个节点的子节点数量称之为度</li></ul></li></ul></li><li><p>二叉树结构图</p><p><img src="/JavaNotes/dataStructure/img/01_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="01_二叉树结构图"></p></li></ul><h3 id="4-2二叉查找树【理解】"><a href="#4-2二叉查找树【理解】" class="headerlink" title="4.2二叉查找树【理解】"></a>4.2二叉查找树【理解】</h3><ul><li><p>二叉查找树的特点</p><ul><li>二叉查找树,又称二叉排序树或者二叉搜索树</li><li>每一个节点上最多有两个子节点</li><li>左子树上所有节点的值都小于根节点的值</li><li>右子树上所有节点的值都大于根节点的值</li></ul></li><li><p>二叉查找树结构图</p><p><img src="/JavaNotes/dataStructure/img/02_%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="02_二叉查找树结构图"></p></li><li><p>二叉查找树和二叉树对比结构图</p><p><img src="/JavaNotes/dataStructure/img/03_%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AF%B9%E6%AF%94%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="03_二叉查找树和二叉树对比结构图"></p></li><li><p>二叉查找树添加节点规则</p><ul><li>小的存左边</li><li>大的存右边</li><li>一样的不存</li></ul><p><img src="/JavaNotes/dataStructure/img/04_%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E6%B7%BB%E5%8A%A0%E8%8A%82%E7%82%B9%E8%A7%84%E5%88%99.png" alt="04_二叉查找树添加节点规则"></p></li></ul><h3 id="4-3平衡二叉树【理解】"><a href="#4-3平衡二叉树【理解】" class="headerlink" title="4.3平衡二叉树【理解】"></a>4.3平衡二叉树【理解】</h3><ul><li><p>平衡二叉树的特点</p><ul><li>二叉树左右两个子树的高度差不超过1</li><li>任意节点的左右两个子树都是一颗平衡二叉树</li></ul></li><li><p>平衡二叉树旋转</p><ul><li><p>旋转触发时机</p><ul><li>当添加一个节点之后,该树不再是一颗平衡二叉树</li></ul></li><li><p>左旋</p><ul><li>就是将根节点的右侧往左拉,原先的右子节点变成新的父节点,并把多余的左子节点出让,给已经降级的根节点当右子节点</li></ul><p><img src="/JavaNotes/dataStructure/img/05_%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B7%A6%E6%97%8B01.png" alt="05_平衡二叉树左旋01"></p><p><img src="/JavaNotes/dataStructure/img/05_%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B7%A6%E6%97%8B02.png" alt="05_平衡二叉树左旋02"></p></li><li><p>右旋</p><ul><li><p>就是将根节点的左侧往右拉,左子节点变成了新的父节点,并把多余的右子节点出让,给已经降级根节点当左子节点</p><p><img src="/JavaNotes/dataStructure/img/06_%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%B3%E6%97%8B01.png" alt="06_平衡二叉树右旋01"></p><p><img src="/JavaNotes/dataStructure/img/06_%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%B3%E6%97%8B02.png" alt="06_平衡二叉树右旋02"></p></li></ul></li></ul></li><li><p>平衡二叉树和二叉查找树对比结构图</p><p><img src="/JavaNotes/dataStructure/img/07_%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E5%AF%B9%E6%AF%94%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="07_平衡二叉树和二叉查找树对比结构图"></p></li><li><p>平衡二叉树旋转的四种情况</p><ul><li><p>左左</p><ul><li><p>左左: 当根节点左子树的左子树有节点插入,导致二叉树不平衡</p></li><li><p>如何旋转: 直接对整体进行右旋即可</p><p><img src="/JavaNotes/dataStructure/img/08_%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B7%A6%E5%B7%A6.png" alt="08_平衡二叉树左左"></p></li></ul></li><li><p>左右</p><ul><li><p>左右: 当根节点左子树的右子树有节点插入,导致二叉树不平衡</p></li><li><p>如何旋转: 先在左子树对应的节点位置进行左旋,在对整体进行右旋</p><p><img src="/JavaNotes/dataStructure/img/09_%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B7%A6%E5%8F%B3.png" alt="09_平衡二叉树左右"></p></li></ul></li><li><p>右右</p><ul><li><p>右右: 当根节点右子树的右子树有节点插入,导致二叉树不平衡</p></li><li><p>如何旋转: 直接对整体进行左旋即可</p><p><img src="/JavaNotes/dataStructure/img/10_%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%B3%E5%8F%B3.png" alt="10_平衡二叉树右右"></p></li></ul></li><li><p>右左</p><ul><li><p>右左:当根节点右子树的左子树有节点插入,导致二叉树不平衡</p></li><li><p>如何旋转: 先在右子树对应的节点位置进行右旋,在对整体进行左旋</p><p><img src="/JavaNotes/dataStructure/img/11_%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%B3%E5%B7%A6.png" alt="11_平衡二叉树右左"></p></li></ul></li></ul></li></ul><h3 id="4-3红黑树【理解】"><a href="#4-3红黑树【理解】" class="headerlink" title="4.3红黑树【理解】"></a>4.3红黑树【理解】</h3><ul><li><p>红黑树的特点</p><ul><li>平衡二叉B树</li><li>每一个节点可以是红或者黑</li><li>红黑树不是高度平衡的,它的平衡是通过”自己的红黑规则”进行实现的</li></ul></li><li><p>红黑树的红黑规则有哪些</p><ol><li><p>每一个节点或是红色的,或者是黑色的</p></li><li><p>根节点必须是黑色</p></li><li><p>如果一个节点没有子节点或者父节点,则该节点相应的指针属性值为Nil,这些Nil视为叶节点,每个叶节点(Nil)是黑色的</p></li><li><p>如果某一个节点是红色,那么它的子节点必须是黑色(不能出现两个红色节点相连 的情况)</p></li><li><p>对每一个节点,从该节点到其所有后代叶节点的简单路径上,均包含相同数目的黑色节点</p><p><img src="/JavaNotes/dataStructure/img/12_%E7%BA%A2%E9%BB%91%E6%A0%91%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="12_红黑树结构图"></p></li></ol></li><li><p>红黑树添加节点的默认颜色</p><ul><li><p>添加节点时,默认为红色,效率高</p><p><img src="/JavaNotes/dataStructure/img/13_%E7%BA%A2%E9%BB%91%E6%A0%91%E6%B7%BB%E5%8A%A0%E8%8A%82%E7%82%B9%E9%A2%9C%E8%89%B2.png" alt="13_红黑树添加节点颜色"></p></li></ul></li><li><p>红黑树添加节点后如何保持红黑规则</p><ul><li>根节点位置<ul><li>直接变为黑色</li></ul></li><li>非根节点位置<ul><li>父节点为黑色<ul><li>不需要任何操作,默认红色即可</li></ul></li><li>父节点为红色<ul><li>叔叔节点为红色<ol><li>将”父节点”设为黑色,将”叔叔节点”设为黑色</li><li>将”祖父节点”设为红色</li><li>如果”祖父节点”为根节点,则将根节点再次变成黑色</li></ol></li><li>叔叔节点为黑色<ol><li>将”父节点”设为黑色</li><li>将”祖父节点”设为红色</li><li>以”祖父节点”为支点进行旋转</li></ol></li></ul></li></ul></li></ul></li></ul><p><img src="/JavaNotes/dataStructure/img/rules.jpg"></p><p>##5.HashSet集合</p><h3 id="5-1HashSet集合概述和特点【应用】"><a href="#5-1HashSet集合概述和特点【应用】" class="headerlink" title="5.1HashSet集合概述和特点【应用】"></a>5.1HashSet集合概述和特点【应用】</h3><ul><li>底层数据结构是哈希表</li><li>存取无序</li><li>不可以存储重复元素</li><li>没有索引,不能使用普通for循环遍历</li></ul><h3 id="5-2HashSet集合的基本应用【应用】"><a href="#5-2HashSet集合的基本应用【应用】" class="headerlink" title="5.2HashSet集合的基本应用【应用】"></a>5.2HashSet集合的基本应用【应用】</h3><p>存储字符串并遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSetDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建集合对象</span></span><br><span class="line">        HashSet&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        set.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">        <span class="comment">//不包含重复元素的集合</span></span><br><span class="line">        set.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">for</span>(String s : set) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3哈希值【理解】"><a href="#5-3哈希值【理解】" class="headerlink" title="5.3哈希值【理解】"></a>5.3哈希值【理解】</h3><ul><li><p>哈希值简介</p><p>​是JDK根据对象的地址或者字符串或者数字算出来的int类型的数值</p></li><li><p>如何获取哈希值</p><p>​Object类中的public int hashCode()：返回对象的哈希码值</p></li><li><p>哈希值的特点</p><ul><li>同一个对象多次调用hashCode()方法返回的哈希值是相同的</li><li>默认情况下，不同对象的哈希值是不同的。而重写hashCode()方法，可以实现让不同对象的哈希值相同</li></ul></li></ul><h3 id="5-4哈希表结构【理解】"><a href="#5-4哈希表结构【理解】" class="headerlink" title="5.4哈希表结构【理解】"></a>5.4哈希表结构【理解】</h3><ul><li><p>JDK1.8以前</p><p>​数组 + 链表</p><p><img src="/JavaNotes/dataStructure/img/14_JKD8%E4%BB%A5%E5%89%8D%E5%93%88%E5%B8%8C%E8%A1%A8.png"></p></li><li><p>JDK1.8以后</p><ul><li><p>节点个数少于等于8个</p><p>​数组 + 链表</p></li><li><p>节点个数多于8个</p><p>​数组 + 红黑树</p></li></ul><p><img src="/JavaNotes/dataStructure/img/15_JKD8%E4%BB%A5%E5%90%8E%E5%93%88%E5%B8%8C%E8%A1%A8.png"></p></li></ul><h3 id="5-5HashSet集合存储学生对象并遍历【应用】"><a href="#5-5HashSet集合存储学生对象并遍历【应用】" class="headerlink" title="5.5HashSet集合存储学生对象并遍历【应用】"></a>5.5HashSet集合存储学生对象并遍历【应用】</h3><ul><li><p>案例需求</p><ul><li>创建一个存储学生对象的集合，存储多个学生对象，使用程序实现在控制台遍历该集合</li><li>要求：学生对象的成员变量值相同，我们就认为是同一个对象</li></ul></li><li><p>代码实现</p><p>学生类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (age != student.age) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> name != <span class="literal">null</span> ? name.equals(student.name) : student.name == <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> name != <span class="literal">null</span> ? name.hashCode() : <span class="number">0</span>;</span><br><span class="line">        result = <span class="number">31</span> * result + age;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSetDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建HashSet集合对象</span></span><br><span class="line">        HashSet&lt;Student&gt; hs = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Student&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建学生对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;林青霞&quot;</span>, <span class="number">30</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张曼玉&quot;</span>, <span class="number">35</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;王祖贤&quot;</span>, <span class="number">33</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;王祖贤&quot;</span>, <span class="number">33</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把学生添加到集合</span></span><br><span class="line">        hs.add(s1);</span><br><span class="line">        hs.add(s2);</span><br><span class="line">        hs.add(s3);</span><br><span class="line">        hs.add(s4);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历集合(增强for)</span></span><br><span class="line">        <span class="keyword">for</span> (Student s : hs) &#123;</span><br><span class="line">            System.out.println(s.getName() + <span class="string">&quot;,&quot;</span> + s.getAge());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>总结</p><p>​HashSet集合存储自定义类型元素,要想实现元素的唯一,要求必须重写hashCode方法和equals方法</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 红黑树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异常</title>
      <link href="/posts/23a3bd72.html"/>
      <url>/posts/23a3bd72.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-异常"><a href="#1-异常" class="headerlink" title="1. 异常"></a>1. 异常</h1><h2 id="1-1-异常概念"><a href="#1-1-异常概念" class="headerlink" title="1.1 异常概念"></a>1.1 异常概念</h2><p>异常，就是不正常的意思。在生活中:医生说,你的身体某个部位有异常,该部位和正常相比有点不同,该部位的功能将受影响.在程序中的意思就是：</p><ul><li><strong>异常</strong> ：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。</li></ul><p>在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理。</p><blockquote><p>异常指的并不是语法错误,语法错了,编译不通过,不会产生字节码文件,根本不能运行.</p></blockquote><h2 id="1-2-异常体系"><a href="#1-2-异常体系" class="headerlink" title="1.2 异常体系"></a>1.2 异常体系</h2><p>异常机制其实是帮助我们<strong>找到</strong>程序中的问题，异常的根类是<code>java.lang.Throwable</code>，其下有两个子类：<code>java.lang.Error</code>与<code>java.lang.Exception</code>，平常所说的异常指<code>java.lang.Exception</code>。</p><p><img src="/JavaNotes/IO%E5%BC%82%E5%B8%B8/img/%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB.png"></p><p><strong>Throwable体系：</strong></p><ul><li><strong>Error</strong>:严重错误Error，无法通过处理的错误，只能事先避免，好比绝症。</li><li><strong>Exception</strong>:表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的。好比感冒、阑尾炎。</li></ul><p><strong>Throwable中的常用方法：</strong></p><ul><li><p><code>public void printStackTrace()</code>:打印异常的详细信息。</p><p><em>包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。</em></p></li><li><p><code>public String getMessage()</code>:获取发生异常的原因。</p><p><em>提示给用户的时候,就提示错误原因。</em></p></li><li><p><code>public String toString()</code>:获取异常的类型和异常描述信息(不用)。</p></li></ul><p><em><strong>出现异常,不要紧张,把异常的简单类名,拷贝到API中去查。</strong></em></p><p><img src="/JavaNotes/IO%E5%BC%82%E5%B8%B8/img/%E7%AE%80%E5%8D%95%E7%9A%84%E5%BC%82%E5%B8%B8%E6%9F%A5%E7%9C%8B.bmp"></p><h2 id="1-3-异常分类"><a href="#1-3-异常分类" class="headerlink" title="1.3 异常分类"></a>1.3 异常分类</h2><p>我们平常说的异常就是指Exception，因为这类异常一旦出现，我们就要对代码进行更正，修复程序。</p><p><strong>异常(Exception)的分类</strong>:根据在编译时期还是运行时期去检查异常?</p><ul><li><strong>编译时期异常</strong>:checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常)</li><li><strong>运行时期异常</strong>:runtime异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。(如数学异常)</li></ul><p>​    <img src="/JavaNotes/IO%E5%BC%82%E5%B8%B8/img/%E5%BC%82%E5%B8%B8%E7%9A%84%E5%88%86%E7%B1%BB.png"></p><h2 id="1-4-异常的产生过程解析"><a href="#1-4-异常的产生过程解析" class="headerlink" title="1.4 异常的产生过程解析"></a>1.4 异常的产生过程解析</h2><p>先运行下面的程序，程序会产生一个数组索引越界异常ArrayIndexOfBoundsException。我们通过图解来解析下异常产生的过程。</p><p> 工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayTools</span> &#123;</span><br><span class="line">    <span class="comment">// 对给定的数组通过给定的角标获取元素。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getElement</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">element</span> <span class="operator">=</span> arr[index];</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123; <span class="number">34</span>, <span class="number">12</span>, <span class="number">67</span> &#125;;</span><br><span class="line">        intnum = ArrayTools.getElement(arr, <span class="number">4</span>)</span><br><span class="line">        System.out.println(<span class="string">&quot;num=&quot;</span> + num);</span><br><span class="line">        System.out.println(<span class="string">&quot;over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述程序执行过程图解：</p><p> <img src="/JavaNotes/IO%E5%BC%82%E5%B8%B8/img/%E5%BC%82%E5%B8%B8%E4%BA%A7%E7%94%9F%E8%BF%87%E7%A8%8B.png"></p><h2 id="1-5-抛出异常throw"><a href="#1-5-抛出异常throw" class="headerlink" title="1.5 抛出异常throw"></a>1.5 抛出异常throw</h2><p>在编写程序时，我们必须要考虑程序出现问题的情况。比如，在定义方法时，方法需要接受参数。那么，当调用方法使用接受到的参数时，首先需要先对参数数据进行合法的判断，数据若不合法，就应该告诉调用者，传递合法的数据进来。这时需要使用抛出异常的方式来告诉调用者。</p><p>在java中，提供了一个<strong>throw</strong>关键字，它用来抛出一个指定的异常对象。那么，抛出一个异常具体如何操作呢？</p><ol><li><p>创建一个异常对象。封装一些提示信息(信息可以自己编写)。</p></li><li><p>需要将这个异常对象告知给调用者。怎么告知呢？怎么将这个异常对象传递到调用者处呢？通过关键字throw就可以完成。throw 异常对象。</p><p>throw<strong>用在方法内</strong>，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。</p></li></ol><p><strong>使用格式：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throw new 异常类名(参数);</span><br></pre></td></tr></table></figure><p> 例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;要访问的arr数组不存在&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>(<span class="string">&quot;该索引在数组中不存在，已超出范围&quot;</span>);</span><br></pre></td></tr></table></figure><p>学习完抛出异常的格式后，我们通过下面程序演示下throw的使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThrowDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个数组 </span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">52</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="comment">//根据索引找对应的元素 </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">element</span> <span class="operator">=</span> getElement(arr, index);</span><br><span class="line"></span><br><span class="line">        System.out.println(element);</span><br><span class="line">        System.out.println(<span class="string">&quot;over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 根据 索引找到数组中对应的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getElement</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> index)</span>&#123; </span><br><span class="line">       <span class="comment">//判断  索引是否越界</span></span><br><span class="line">        <span class="keyword">if</span>(index&lt;<span class="number">0</span> || index&gt;arr.length-<span class="number">1</span>)&#123;</span><br><span class="line">             <span class="comment">/*</span></span><br><span class="line"><span class="comment">             判断条件如果满足，当执行完throw抛出异常对象后，方法已经无法继续运算。</span></span><br><span class="line"><span class="comment">             这时就会结束当前方法的执行，并将异常告知给调用者。这时就需要通过异常来解决。 </span></span><br><span class="line"><span class="comment">              */</span></span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>(<span class="string">&quot;哥们，角标越界了```&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">element</span> <span class="operator">=</span> arr[index];</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：如果产生了问题，我们就会throw将问题描述类即异常进行抛出，也就是将问题返回给该方法的调用者。</p><p>那么对于调用者来说，该怎么处理呢？一种是进行捕获处理，另一种就是继续讲问题声明出去，使用throws声明处理。</p></blockquote><h2 id="1-6-声明异常throws"><a href="#1-6-声明异常throws" class="headerlink" title="1.6 声明异常throws"></a>1.6 声明异常throws</h2><p><strong>声明异常</strong>：将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理（稍后讲解该方式），那么必须通过throws进行声明，让调用者去处理。</p><p>关键字<strong>throws</strong>运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常(抛出异常).</p><p><strong>声明异常格式：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…&#123;   &#125;</span><br></pre></td></tr></table></figure><p>声明异常的代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThrowsDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        read(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果定义功能时有问题发生需要报告给调用者。可以通过在方法上使用throws关键字进行声明</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">(String path)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="keyword">if</span> (!path.equals(<span class="string">&quot;a.txt&quot;</span>)) &#123;<span class="comment">//如果不是 a.txt这个文件 </span></span><br><span class="line">            <span class="comment">// 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FileNotFoundException</span>(<span class="string">&quot;文件不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>throws用于进行异常类的声明，若该方法可能有多种异常情况产生，那么在throws后面可以写多个异常类，用逗号隔开。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThrowsDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        read(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">(String path)</span><span class="keyword">throws</span> FileNotFoundException, IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (!path.equals(<span class="string">&quot;a.txt&quot;</span>)) &#123;<span class="comment">//如果不是 a.txt这个文件 </span></span><br><span class="line">            <span class="comment">// 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FileNotFoundException</span>(<span class="string">&quot;文件不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!path.equals(<span class="string">&quot;b.txt&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-7-捕获异常try…catch"><a href="#1-7-捕获异常try…catch" class="headerlink" title="1.7 捕获异常try…catch"></a>1.7 捕获异常try…catch</h2><p>如果异常出现的话,会立刻终止程序,所以我们得处理异常:</p><ol><li>该方法不处理,而是声明抛出,由该方法的调用者来处理(throws)。</li><li>在方法中使用try-catch的语句块来处理异常。</li></ol><p><strong>try-catch</strong>的方式就是捕获异常。</p><ul><li><strong>捕获异常</strong>：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。</li></ul><p>捕获异常语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">     编写可能会出现异常的代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型  e)&#123;</span><br><span class="line">     处理异常的代码</span><br><span class="line">     <span class="comment">//记录日志/打印异常信息/继续抛出异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>try：</strong>该代码块中编写可能产生异常的代码。</p><p><strong>catch：</strong>用来进行某种异常的捕获，实现对捕获到的异常进行处理。</p><blockquote><p>注意:try和catch都不能单独使用,必须连用。</p></blockquote><p>演示如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TryCatchDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;<span class="comment">// 当产生异常时，必须有处理方式。要么捕获，要么声明。</span></span><br><span class="line">            read(<span class="string">&quot;b.txt&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;<span class="comment">// 括号中需要定义什么呢？</span></span><br><span class="line">          <span class="comment">//try中抛出的是什么异常，在括号中就定义什么异常类型</span></span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 我们 当前的这个方法中 有异常  有编译期异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">(String path)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="keyword">if</span> (!path.equals(<span class="string">&quot;a.txt&quot;</span>)) &#123;<span class="comment">//如果不是 a.txt这个文件 </span></span><br><span class="line">            <span class="comment">// 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FileNotFoundException</span>(<span class="string">&quot;文件不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何获取异常信息：</p><p>Throwable类中定义了一些查看方法:</p><ul><li><p><code>public String getMessage()</code>:获取异常的描述信息,原因(提示给用户的时候,就提示错误原因。</p></li><li><p><code>public String toString()</code>:获取异常的类型和异常描述信息(不用)。</p></li><li><p><code>public void printStackTrace()</code>:打印异常的跟踪栈信息并输出到控制台。</p></li></ul><p>​            <em>包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。</em></p><p>在开发中呢也可以在catch将编译期异常转换成运行期异常处理。</p><p>多个异常使用捕获又该如何处理呢？</p><ol><li>多个异常分别处理。</li><li>多个异常一次捕获，多次处理。</li><li>多个异常一次捕获一次处理。</li></ol><p>一般我们是使用一次捕获多次处理方式，格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">     编写可能会出现异常的代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型A  e)&#123;  当<span class="keyword">try</span>中出现A类型异常,就用该<span class="keyword">catch</span>来捕获.</span><br><span class="line">     处理异常的代码</span><br><span class="line">     <span class="comment">//记录日志/打印异常信息/继续抛出异常</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型B  e)&#123;  当<span class="keyword">try</span>中出现B类型异常,就用该<span class="keyword">catch</span>来捕获.</span><br><span class="line">     处理异常的代码</span><br><span class="line">     <span class="comment">//记录日志/打印异常信息/继续抛出异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意:这种异常处理方式，要求多个catch中的异常不能相同，并且若catch中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理。</p></blockquote><h2 id="1-8-finally-代码块"><a href="#1-8-finally-代码块" class="headerlink" title="1.8 finally 代码块"></a>1.8 finally 代码块</h2><p><strong>finally</strong>：有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。</p><p>什么时候的代码必须最终执行？</p><p>当我们在try语句块中打开了一些物理资源(磁盘文件&#x2F;网络连接&#x2F;数据库连接等),我们都得在使用完之后,最终关闭打开的资源。</p><p>finally的语法:</p><p> try…catch….finally:自身需要处理异常,最终还得关闭资源。</p><blockquote><p>注意:finally不能单独使用。</p></blockquote><p>比如在我们之后学习的IO流中，当打开了一个关联文件的资源，最后程序不管结果如何，都需要把这个资源关闭掉。</p><p>finally代码参考如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TryCatchDemo4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            read(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">//抓取到的是编译期异常  抛出去的是运行期 </span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;不管程序怎样，这里都将会被执行。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 我们 当前的这个方法中 有异常  有编译期异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">(String path)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="keyword">if</span> (!path.equals(<span class="string">&quot;a.txt&quot;</span>)) &#123;<span class="comment">//如果不是 a.txt这个文件 </span></span><br><span class="line">            <span class="comment">// 我假设  如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常  throw</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FileNotFoundException</span>(<span class="string">&quot;文件不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当只有在try或者catch中调用退出JVM的相关方法,此时finally才不会执行,否则finally永远会执行。</p></blockquote><h2 id="1-9-异常注意事项"><a href="#1-9-异常注意事项" class="headerlink" title="1.9 异常注意事项"></a>1.9 异常注意事项</h2><ul><li>运行时异常被抛出可以不处理。即不捕获也不声明抛出。</li><li>如果父类抛出了多个异常,子类覆盖父类方法时,只能抛出相同的异常或者是他的子集。</li><li>父类方法没有抛出异常，子类覆盖父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出</li><li>当多异常处理时，捕获处理，前边的类不能是后边类的父类</li><li>在try&#x2F;catch后可以追加finally代码块，其中的代码一定会被执行，通常用于资源回收。</li></ul><h2 id="1-10-概述"><a href="#1-10-概述" class="headerlink" title="1.10 概述"></a>1.10 概述</h2><p><strong>为什么需要自定义异常类:</strong></p><p>我们说了Java中不同的异常类,分别表示着某一种具体的异常情况,那么在开发中总是有些异常情况是SUN没有定义好的,此时我们根据自己业务的异常情况来定义异常类。,例如年龄负数问题,考试成绩负数问题。</p><p>在上述代码中，发现这些异常都是JDK内部定义好的，但是实际开发中也会出现很多异常,这些异常很可能在JDK中没有定义过,例如年龄负数问题,考试成绩负数问题.那么能不能自己定义异常呢？</p><p><strong>什么是自定义异常类:</strong></p><p>在开发中根据自己业务的异常情况来定义异常类.</p><p>自定义一个业务逻辑异常: <strong>LoginException</strong>。一个登陆异常类。</p><p><strong>异常类如何定义:</strong></p><ol><li>自定义一个编译期异常: 自定义类 并继承于<code>java.lang.Exception</code>。</li><li>自定义一个运行时期的异常类:自定义类 并继承于<code>java.lang.RuntimeException</code>。</li></ol><h2 id="1-11-自定义异常的练习"><a href="#1-11-自定义异常的练习" class="headerlink" title="1.11 自定义异常的练习"></a>1.11 自定义异常的练习</h2><p>要求：我们模拟登陆操作，如果用户名已存在，则抛出异常并提示：亲，该用户名已经被注册。</p><p>首先定义一个登陆异常类LoginException：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 业务逻辑异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空参构造</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LoginException</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 表示异常提示</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LoginException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模拟登陆操作，使用数组模拟数据库中存储的数据，并提供当前注册账号是否存在方法用于判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="comment">// 模拟数据库中已存在账号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String[] names = &#123;<span class="string">&quot;bill&quot;</span>,<span class="string">&quot;hill&quot;</span>,<span class="string">&quot;jill&quot;</span>&#125;;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;     </span><br><span class="line">        <span class="comment">//调用方法</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 可能出现异常的代码</span></span><br><span class="line">            checkUsername(<span class="string">&quot;nill&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;注册成功&quot;</span>);<span class="comment">//如果没有异常就是注册成功</span></span><br><span class="line">        &#125; <span class="keyword">catch</span>(LoginException e) &#123;</span><br><span class="line">            <span class="comment">//处理异常</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断当前注册账号是否存在</span></span><br><span class="line">    <span class="comment">//因为是编译期异常，又想调用者去处理 所以声明该异常</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkUsername</span><span class="params">(String uname)</span> <span class="keyword">throws</span> LoginException &#123;</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            <span class="keyword">if</span>(name.equals(uname))&#123;<span class="comment">//如果名字在这里面 就抛出登陆异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LoginException</span>(<span class="string">&quot;亲&quot;</span>+name+<span class="string">&quot;已经被注册了！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-File类"><a href="#2-File类" class="headerlink" title="2. File类"></a>2. File类</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><p><code>java.io.File</code> 类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。</p><h2 id="2-2-构造方法"><a href="#2-2-构造方法" class="headerlink" title="2.2 构造方法"></a>2.2 构造方法</h2><ul><li><code>public File(String pathname) </code> ：通过将给定的<strong>路径名字符串</strong>转换为抽象路径名来创建新的 File实例。  </li><li><code>public File(String parent, String child) </code> ：从<strong>父路径名字符串和子路径名字符串</strong>创建新的 File实例。</li><li><code>public File(File parent, String child)</code> ：从<strong>父抽象路径名和子路径名字符串</strong>创建新的 File实例。  </li><li>构造举例，代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件路径名</span></span><br><span class="line"><span class="type">String</span> <span class="variable">pathname</span> <span class="operator">=</span> <span class="string">&quot;D:\\aaa.txt&quot;</span>;</span><br><span class="line"><span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(pathname); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件路径名</span></span><br><span class="line"><span class="type">String</span> <span class="variable">pathname2</span> <span class="operator">=</span> <span class="string">&quot;D:\\aaa\\bbb.txt&quot;</span>;</span><br><span class="line"><span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(pathname2); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过父路径和子路径字符串</span></span><br><span class="line"> <span class="type">String</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="string">&quot;d:\\aaa&quot;</span>;</span><br><span class="line"> <span class="type">String</span> <span class="variable">child</span> <span class="operator">=</span> <span class="string">&quot;bbb.txt&quot;</span>;</span><br><span class="line"> <span class="type">File</span> <span class="variable">file3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(parent, child);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过父级File对象和子路径字符串</span></span><br><span class="line"><span class="type">File</span> <span class="variable">parentDir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\aaa&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">child</span> <span class="operator">=</span> <span class="string">&quot;bbb.txt&quot;</span>;</span><br><span class="line"><span class="type">File</span> <span class="variable">file4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(parentDir, child);</span><br></pre></td></tr></table></figure><blockquote><p>小贴士：</p><ol><li>一个File对象代表硬盘中实际存在的一个文件或者目录。</li><li>无论该路径下是否存在文件或者目录，都不影响File对象的创建。</li></ol></blockquote><h2 id="2-3-常用方法"><a href="#2-3-常用方法" class="headerlink" title="2.3 常用方法"></a>2.3 常用方法</h2><h3 id="获取功能的方法"><a href="#获取功能的方法" class="headerlink" title="获取功能的方法"></a>获取功能的方法</h3><ul><li><p><code>public String getAbsolutePath() </code> ：返回此File的绝对路径名字符串。</p></li><li><p><code>public String getPath()</code> ：将此File转换为路径名字符串。 </p></li><li><p><code>public String getName()</code>  ：返回由此File表示的文件或目录的名称。  </p></li><li><p><code>public long length()</code>  ：返回由此File表示的文件的长度。 </p><p>方法演示，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileGet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/aaa/bbb.java&quot;</span>);     </span><br><span class="line">        System.out.println(<span class="string">&quot;文件绝对路径:&quot;</span>+f.getAbsolutePath());</span><br><span class="line">        System.out.println(<span class="string">&quot;文件构造路径:&quot;</span>+f.getPath());</span><br><span class="line">        System.out.println(<span class="string">&quot;文件名称:&quot;</span>+f.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;文件长度:&quot;</span>+f.length()+<span class="string">&quot;字节&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/aaa&quot;</span>);     </span><br><span class="line">        System.out.println(<span class="string">&quot;目录绝对路径:&quot;</span>+f2.getAbsolutePath());</span><br><span class="line">        System.out.println(<span class="string">&quot;目录构造路径:&quot;</span>+f2.getPath());</span><br><span class="line">        System.out.println(<span class="string">&quot;目录名称:&quot;</span>+f2.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;目录长度:&quot;</span>+f2.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">文件绝对路径:d:\aaa\bbb.java</span><br><span class="line">文件构造路径:d:\aaa\bbb.java</span><br><span class="line">文件名称:bbb.java</span><br><span class="line">文件长度:<span class="number">636</span>字节</span><br><span class="line"></span><br><span class="line">目录绝对路径:d:\aaa</span><br><span class="line">目录构造路径:d:\aaa</span><br><span class="line">目录名称:aaa</span><br><span class="line">目录长度:<span class="number">4096</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>API中说明：length()，表示文件的长度。但是File对象表示目录，则返回值未指定。</p></blockquote><h3 id="绝对路径和相对路径"><a href="#绝对路径和相对路径" class="headerlink" title="绝对路径和相对路径"></a>绝对路径和相对路径</h3><ul><li><strong>绝对路径</strong>：从盘符开始的路径，这是一个完整的路径。</li><li><strong>相对路径</strong>：相对于项目目录的路径，这是一个便捷的路径，开发中经常使用。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilePath</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="comment">// D盘下的bbb.java文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\bbb.java&quot;</span>);</span><br><span class="line">        System.out.println(f.getAbsolutePath());</span><br><span class="line">      </span><br><span class="line"><span class="comment">// 项目下的bbb.java文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;bbb.java&quot;</span>);</span><br><span class="line">        System.out.println(f2.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">D:\bbb.java</span><br><span class="line">D:\idea_project_test4\bbb.java</span><br></pre></td></tr></table></figure><h3 id="判断功能的方法"><a href="#判断功能的方法" class="headerlink" title="判断功能的方法"></a>判断功能的方法</h3><ul><li><code>public boolean exists()</code> ：此File表示的文件或目录是否实际存在。</li><li><code>public boolean isDirectory()</code> ：此File表示的是否为目录。</li><li><code>public boolean isFile()</code> ：此File表示的是否为文件。</li></ul><p>方法演示，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileIs</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\aaa\\bbb.java&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\aaa&quot;</span>);</span><br><span class="line">      <span class="comment">// 判断是否存在</span></span><br><span class="line">        System.out.println(<span class="string">&quot;d:\\aaa\\bbb.java 是否存在:&quot;</span>+f.exists());</span><br><span class="line">        System.out.println(<span class="string">&quot;d:\\aaa 是否存在:&quot;</span>+f2.exists());</span><br><span class="line">      <span class="comment">// 判断是文件还是目录</span></span><br><span class="line">        System.out.println(<span class="string">&quot;d:\\aaa 文件?:&quot;</span>+f2.isFile());</span><br><span class="line">        System.out.println(<span class="string">&quot;d:\\aaa 目录?:&quot;</span>+f2.isDirectory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">d:\aaa\bbb.java 是否存在:<span class="literal">true</span></span><br><span class="line">d:\aaa 是否存在:<span class="literal">true</span></span><br><span class="line">d:\aaa 文件?:<span class="literal">false</span></span><br><span class="line">d:\aaa 目录?:<span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="创建删除功能的方法"><a href="#创建删除功能的方法" class="headerlink" title="创建删除功能的方法"></a>创建删除功能的方法</h3><ul><li><code>public boolean createNewFile()</code> ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。 </li><li><code>public boolean delete()</code> ：删除由此File表示的文件或目录。  </li><li><code>public boolean mkdir()</code> ：创建由此File表示的目录。</li><li><code>public boolean mkdirs()</code> ：创建由此File表示的目录，包括任何必需但不存在的父目录。</li></ul><p>方法演示，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileCreateDelete</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 文件的创建</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;aaa.txt&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;是否存在:&quot;</span>+f.exists()); <span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;是否创建:&quot;</span>+f.createNewFile()); <span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;是否存在:&quot;</span>+f.exists()); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 目录的创建</span></span><br><span class="line">      File f2= <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;newDir&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;是否存在:&quot;</span>+f2.exists());<span class="comment">// false</span></span><br><span class="line">        System.out.println(<span class="string">&quot;是否创建:&quot;</span>+f2.mkdir());<span class="comment">// true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;是否存在:&quot;</span>+f2.exists());<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建多级目录</span></span><br><span class="line">      File f3= <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;newDira\\newDirb&quot;</span>);</span><br><span class="line">        System.out.println(f3.mkdir());<span class="comment">// false</span></span><br><span class="line">        File f4= <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;newDira\\newDirb&quot;</span>);</span><br><span class="line">        System.out.println(f4.mkdirs());<span class="comment">// true</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 文件的删除</span></span><br><span class="line">       System.out.println(f.delete());<span class="comment">// true</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 目录的删除</span></span><br><span class="line">        System.out.println(f2.delete());<span class="comment">// true</span></span><br><span class="line">        System.out.println(f4.delete());<span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>API中说明：delete方法，如果此File表示目录，则目录必须为空才能删除。</p></blockquote><h2 id="2-4-目录的遍历"><a href="#2-4-目录的遍历" class="headerlink" title="2.4 目录的遍历"></a>2.4 目录的遍历</h2><ul><li><code>public String[] list()</code> ：返回一个String数组，表示该File目录中的所有子文件或目录。</li><li><code>public File[] listFiles()</code> ：返回一个File数组，表示该File目录中的所有的子文件或目录。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileFor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\java_code&quot;</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//获取当前目录下的文件以及文件夹的名称。</span></span><br><span class="line">String[] names = dir.list();</span><br><span class="line"><span class="keyword">for</span>(String name : names)&#123;</span><br><span class="line">System.out.println(name);</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//获取当前目录下的文件以及文件夹对象，只要拿到了文件对象，那么就可以获取更多信息</span></span><br><span class="line">        File[] files = dir.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            System.out.println(file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>小贴士：</p><p>调用listFiles方法的File对象，表示的必须是实际存在的目录，否则返回null，无法进行遍历。</p></blockquote><h2 id="2-5-综合练习"><a href="#2-5-综合练习" class="headerlink" title="2.5 综合练习"></a>2.5 综合练习</h2><h4 id="练习1：创建文件夹"><a href="#练习1：创建文件夹" class="headerlink" title="练习1：创建文件夹"></a>练习1：创建文件夹</h4><p>​在当前模块下的aaa文件夹中创建一个a.txt文件</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//需求：在当前模块下的aaa文件夹中创建一个a.txt文件</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.创建a.txt的父级路径</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;myfile\\aaa&quot;</span>);</span><br><span class="line">        <span class="comment">//2.创建父级路径</span></span><br><span class="line">        <span class="comment">//如果aaa是存在的，那么此时创建失败的。</span></span><br><span class="line">        <span class="comment">//如果aaa是不存在的，那么此时创建成功的。</span></span><br><span class="line">        file.mkdirs();</span><br><span class="line">        <span class="comment">//3.拼接父级路径和子级路径</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">src</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(file,<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> src.createNewFile();</span><br><span class="line">        <span class="keyword">if</span>(b)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;创建成功&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;创建失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习2：查找文件（不考虑子文件夹）"><a href="#练习2：查找文件（不考虑子文件夹）" class="headerlink" title="练习2：查找文件（不考虑子文件夹）"></a>练习2：查找文件（不考虑子文件夹）</h4><p>​定义一个方法找某一个文件夹中，是否有以avi结尾的电影（暂时不需要考虑子文件夹）</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*需求：</span></span><br><span class="line"><span class="comment">             定义一个方法找某一个文件夹中，是否有以avi结尾的电影。</span></span><br><span class="line"><span class="comment">        （暂时不需要考虑子文件夹）</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\aaa\\bbb&quot;</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> haveAVI(file);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 作用：用来找某一个文件夹中，是否有以avi结尾的电影</span></span><br><span class="line"><span class="comment">    * 形参：要查找的文件夹</span></span><br><span class="line"><span class="comment">    * 返回值：查找的结果  存在true  不存在false</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">haveAVI</span><span class="params">(File file)</span>&#123;<span class="comment">// D:\\aaa</span></span><br><span class="line">        <span class="comment">//1.进入aaa文件夹，而且要获取里面所有的内容</span></span><br><span class="line">        File[] files = file.listFiles();</span><br><span class="line">        <span class="comment">//2.遍历数组获取里面的每一个元素</span></span><br><span class="line">        <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">            <span class="comment">//f：依次表示aaa文件夹里面每一个文件或者文件夹的路径</span></span><br><span class="line">            <span class="keyword">if</span>(f.isFile() &amp;&amp; f.getName().endsWith(<span class="string">&quot;.avi&quot;</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.如果循环结束之后还没有找到，直接返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习3：（考虑子文件夹）"><a href="#练习3：（考虑子文件夹）" class="headerlink" title="练习3：（考虑子文件夹）"></a>练习3：（考虑子文件夹）</h3><p>​找到电脑中所有以avi结尾的电影。（需要考虑子文件夹）</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/* 需求：</span></span><br><span class="line"><span class="comment">        找到电脑中所有以avi结尾的电影。（需要考虑子文件夹）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        套路：</span></span><br><span class="line"><span class="comment">            1，进入文件夹</span></span><br><span class="line"><span class="comment">            2，遍历数组</span></span><br><span class="line"><span class="comment">            3，判断</span></span><br><span class="line"><span class="comment">            4，判断</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        findAVI();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">findAVI</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//获取本地所有的盘符</span></span><br><span class="line">        File[] arr = File.listRoots();</span><br><span class="line">        <span class="keyword">for</span> (File f : arr) &#123;</span><br><span class="line">            findAVI(f);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">findAVI</span><span class="params">(File src)</span>&#123;<span class="comment">//&quot;C:\\</span></span><br><span class="line">        <span class="comment">//1.进入文件夹src</span></span><br><span class="line">        File[] files = src.listFiles();</span><br><span class="line">        <span class="comment">//2.遍历数组,依次得到src里面每一个文件或者文件夹</span></span><br><span class="line">        <span class="keyword">if</span>(files != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">                <span class="keyword">if</span>(file.isFile())&#123;</span><br><span class="line">                    <span class="comment">//3，判断，如果是文件，就可以执行题目的业务逻辑</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> file.getName();</span><br><span class="line">                    <span class="keyword">if</span>(name.endsWith(<span class="string">&quot;.avi&quot;</span>))&#123;</span><br><span class="line">                        System.out.println(file);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//4，判断，如果是文件夹，就可以递归</span></span><br><span class="line">                    <span class="comment">//细节：再次调用本方法的时候，参数一定要是src的次一级路径</span></span><br><span class="line">                    findAVI(file);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习4：删除多级文件夹"><a href="#练习4：删除多级文件夹" class="headerlink" title="练习4：删除多级文件夹"></a>练习4：删除多级文件夹</h3><p>需求： 如果我们要删除一个有内容的文件夹<br>       1.先删除文件夹里面所有的内容<br>           2.再删除自己</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">           删除一个多级文件夹</span></span><br><span class="line"><span class="comment">           如果我们要删除一个有内容的文件夹</span></span><br><span class="line"><span class="comment">           1.先删除文件夹里面所有的内容</span></span><br><span class="line"><span class="comment">           2.再删除自己</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\aaa\\src&quot;</span>);</span><br><span class="line">        delete(file);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 作用：删除src文件夹</span></span><br><span class="line"><span class="comment">    * 参数：要删除的文件夹</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(File src)</span>&#123;</span><br><span class="line">        <span class="comment">//1.先删除文件夹里面所有的内容</span></span><br><span class="line">        <span class="comment">//进入src</span></span><br><span class="line">        File[] files = src.listFiles();</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            <span class="comment">//判断,如果是文件，删除</span></span><br><span class="line">            <span class="keyword">if</span>(file.isFile())&#123;</span><br><span class="line">                file.delete();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//判断,如果是文件夹，就递归</span></span><br><span class="line">                delete(file);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.再删除自己</span></span><br><span class="line">        src.delete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习5：统计大小"><a href="#练习5：统计大小" class="headerlink" title="练习5：统计大小"></a>练习5：统计大小</h3><p>​需求：统计一个文件夹的总大小</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="comment">/*需求：</span></span><br><span class="line"><span class="comment">            统计一个文件夹的总大小</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\aaa\\src&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">len</span> <span class="operator">=</span> getLen(file);</span><br><span class="line">        System.out.println(len);<span class="comment">//4919189</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 作用：</span></span><br><span class="line"><span class="comment">    *       统计一个文件夹的总大小</span></span><br><span class="line"><span class="comment">    * 参数：</span></span><br><span class="line"><span class="comment">    *       表示要统计的那个文件夹</span></span><br><span class="line"><span class="comment">    * 返回值：</span></span><br><span class="line"><span class="comment">    *       统计之后的结果</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 文件夹的总大小：</span></span><br><span class="line"><span class="comment">    *       说白了，文件夹里面所有文件的大小</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">getLen</span><span class="params">(File src)</span>&#123;</span><br><span class="line">        <span class="comment">//1.定义变量进行累加</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//2.进入src文件夹</span></span><br><span class="line">        File[] files = src.listFiles();</span><br><span class="line">        <span class="comment">//3.遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            <span class="comment">//4.判断</span></span><br><span class="line">            <span class="keyword">if</span>(file.isFile())&#123;</span><br><span class="line">                <span class="comment">//我们就把当前文件的大小累加到len当中</span></span><br><span class="line">                len = len + file.length();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//判断，如果是文件夹就递归</span></span><br><span class="line">                len = len + getLen(file);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习6：统计文件个数"><a href="#练习6：统计文件个数" class="headerlink" title="练习6：统计文件个数"></a>练习6：统计文件个数</h3><p>  需求：统计一个文件夹中每种文件的个数并打印。（考虑子文件夹）<br>            打印格式如下：<br>            txt:3个<br>            doc:4个<br>            jpg:6个</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test6</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            需求：统计一个文件夹中每种文件的个数并打印。（考虑子文件夹）</span></span><br><span class="line"><span class="comment">            打印格式如下：</span></span><br><span class="line"><span class="comment">            txt:3个</span></span><br><span class="line"><span class="comment">            doc:4个</span></span><br><span class="line"><span class="comment">            jpg:6个</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\aaa\\src&quot;</span>);</span><br><span class="line">        HashMap&lt;String, Integer&gt; hm = getCount(file);</span><br><span class="line">        System.out.println(hm);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 作用：</span></span><br><span class="line"><span class="comment">    *       统计一个文件夹中每种文件的个数</span></span><br><span class="line"><span class="comment">    * 参数：</span></span><br><span class="line"><span class="comment">    *       要统计的那个文件夹</span></span><br><span class="line"><span class="comment">    * 返回值：</span></span><br><span class="line"><span class="comment">    *       用来统计map集合</span></span><br><span class="line"><span class="comment">    *       键：后缀名 值：次数</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *       a.txt</span></span><br><span class="line"><span class="comment">    *       a.a.txt</span></span><br><span class="line"><span class="comment">    *       aaa（不需要统计的）</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;String,Integer&gt; <span class="title function_">getCount</span><span class="params">(File src)</span>&#123;</span><br><span class="line">        <span class="comment">//1.定义集合用来统计</span></span><br><span class="line">        HashMap&lt;String,Integer&gt; hm = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//2.进入src文件夹</span></span><br><span class="line">        File[] files = src.listFiles();</span><br><span class="line">        <span class="comment">//3.遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            <span class="comment">//4.判断，如果是文件，统计</span></span><br><span class="line">            <span class="keyword">if</span>(file.isFile())&#123;</span><br><span class="line">                <span class="comment">//a.txt</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> file.getName();</span><br><span class="line">                String[] arr = name.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span>(arr.length &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">endName</span> <span class="operator">=</span> arr[arr.length - <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(hm.containsKey(endName))&#123;</span><br><span class="line">                        <span class="comment">//存在</span></span><br><span class="line">                        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> hm.get(endName);</span><br><span class="line">                        count++;</span><br><span class="line">                        hm.put(endName,count);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">//不存在</span></span><br><span class="line">                        hm.put(endName,<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//5.判断，如果是文件夹，递归</span></span><br><span class="line">                <span class="comment">//sonMap里面是子文件中每一种文件的个数</span></span><br><span class="line">                HashMap&lt;String, Integer&gt; sonMap = getCount(file);</span><br><span class="line">                <span class="comment">//hm:  txt=1  jpg=2  doc=3</span></span><br><span class="line">                <span class="comment">//sonMap: txt=3 jpg=1</span></span><br><span class="line">                <span class="comment">//遍历sonMap把里面的值累加到hm当中</span></span><br><span class="line">                Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = sonMap.entrySet();</span><br><span class="line">                <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : entries) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">                    <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">                    <span class="keyword">if</span>(hm.containsKey(key))&#123;</span><br><span class="line">                        <span class="comment">//存在</span></span><br><span class="line">                        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> hm.get(key);</span><br><span class="line">                        count = count + value;</span><br><span class="line">                        hm.put(key,count);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">//不存在</span></span><br><span class="line">                        hm.put(key,value);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>教育和被教育</title>
      <link href="/posts/6bb1d783.html"/>
      <url>/posts/6bb1d783.html</url>
      
        <content type="html"><![CDATA[<p><img src="/img/jiaoyu.png" alt="Test"></p><p><strong>她说得对，但在某一方面我认为她本人没有意识到的问题：如果有一种力量阻止你获取多重视角，阻止你理解不同的事物，那本身教育的意义就不存在了。我们说这个时候，有一个新的词出现了，正像她说的这个词真正应当是『被教育』，而不是『教育』。我们在『被教育』状态中，接受『被教育』的内容越多，就意味着事情变得不确定性。相反，如果我们自我接受的是『教育』，我们逐渐在研究不确定性中得到近似确定性的产物。不确定性的确是一直存在的，但它相对于『被教育』中，是一定存在且越来越明显的。我们在教育求知的过程中只能确定我们已知的范围，只有未知的范围才是不确定性的。教育的本身就是探索未知的过程，把未知的过程转化为有知的过程，尽管这一步骤过程中还会产生新的未知范围，但我们不能说『教育』让我们的已知范围是不确定的，让已知范围不确定的是『被教育』。『教育』确实会让我们在未知范围内产生不确定性，论人类发展，在未知领域内产生不确定性实属常识，可在一已知领域内也是不确定性的，那只能说明知识被限制，即人所能得到并且接受的乃是『被教育』的状态。举例说明，我们可以说哥白尼是接受了『教育』而非『被教育』，所以他确定了日心说，而不是不确定的；恰巧那过去的人们是『被教育』成——“地球是宇宙的中心”。有人定会说我们难免因为未知范围而在已知范围内犯下错误，例如伽利略比萨斜塔实验就曾颠覆人们已知领域的范畴。的确，我们很有可能在已知范畴内也会犯错，这无法避免，但这不是重点所在，我们必须声明，伽利略接受的乃是『教育』而非『被教育』。『教育』是自由的、容许你质疑的；而『被教育』让人们不要质疑，限制你已知的范围外，还要限制你质疑的范围，更不要提及未知领域的范围。如果没有『教育』和『被教育』的区分，我们就难以衡量事物是确定的真理还是不确定的预测，更何况我们要用『被教育』来讨论偏见和固执。由此可见，固执和偏见是『被教育』的特色，而『教育』不是。所以这一切的讨论的前提都是来源于施加者和被施加者，如果一个人一直接受『被教育』，他宁愿认为自己接受的是『教育』而不是『被教育』，此时我们讨论偏见、固执、确定、不确定、『教育』、『被教育』就变得毫无意义。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>网络编程</title>
      <link href="/posts/f6491cfb.html"/>
      <url>/posts/f6491cfb.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-网络编程入门"><a href="#1-网络编程入门" class="headerlink" title="1. 网络编程入门"></a>1. 网络编程入门</h2><h3 id="1-1-网络编程概述"><a href="#1-1-网络编程概述" class="headerlink" title="1.1 网络编程概述"></a>1.1 网络编程概述</h3><ul><li><p>计算机网络</p><p>是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统</p></li><li><p>网络编程</p><p>在网络通信协议下，不同计算机上运行的程序，可以进行数据传输</p></li></ul><h3 id="1-2-网络编程三要素"><a href="#1-2-网络编程三要素" class="headerlink" title="1.2 网络编程三要素"></a>1.2 网络编程三要素</h3><ul><li><p>IP地址</p><p>要想让网络中的计算机能够互相通信，必须为每台计算机指定一个标识号，通过这个标识号来指定要接收数据的计算机和识别发送的计算机，而IP地址就是这个标识号。也就是设备的标识</p></li><li><p>端口</p><p>网络的通信，本质上是两个应用程序的通信。每台计算机都有很多的应用程序，那么在网络通信时，如何区分这些应用程序呢？如果说IP地址可以唯一标识网络中的设备，那么端口号就可以唯一标识设备中的应用程序了。也就是应用程序的标识</p></li><li><p>协议</p><p>通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。常见的协议有UDP协议和TCP协议</p></li></ul><h3 id="1-3-IP地址"><a href="#1-3-IP地址" class="headerlink" title="1.3 IP地址"></a>1.3 IP地址</h3><p>IP地址：是网络中设备的唯一标识</p><ul><li>IP地址分为两大类<ul><li>IPv4：是给每个连接在网络上的主机分配一个32bit地址。按照TCP&#x2F;IP规定，IP地址用二进制来表示，每个IP地址长32bit，也就是4个字节。例如一个采用二进制形式的IP地址是“11000000 10101000 00000001 01000010”，这么长的地址，处理起来也太费劲了。为了方便使用，IP地址经常被写成十进制的形式，中间使用符号“.”分隔不同的字节。于是，上面的IP地址可以表示为“192.168.1.66”。IP地址的这种表示法叫做“点分十进制表示法”，这显然比1和0容易记忆得多</li><li>IPv6：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得IP的分配越发紧张。为了扩大地址空间，通过IPv6重新定义地址空间，采用128位地址长度，每16个字节一组，分成8组十六进制数，这样就解决了网络地址资源数量不够的问题</li></ul></li><li>DOS常用命令：<ul><li>ipconfig：查看本机IP地址</li><li>ping IP地址：检查网络是否连通</li></ul></li><li>特殊IP地址：<ul><li>127.0.0.1：是回送地址，可以代表本机地址，一般用来测试使用</li></ul></li></ul><h3 id="1-4-InetAddress"><a href="#1-4-InetAddress" class="headerlink" title="1.4 InetAddress"></a>1.4 InetAddress</h3><p>InetAddress：此类表示Internet协议（IP）地址</p><ul><li><p>相关方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>static InetAddress getByName(String host)</td><td>确定主机名称的IP地址。主机名称可以是机器名称，也可以是IP地址</td></tr><tr><td>String getHostName()</td><td>获取此IP地址的主机名</td></tr><tr><td>String getHostAddress()</td><td>返回文本显示中的IP地址字符串</td></tr></tbody></table></li><li><p>代码演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InetAddressDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException &#123;</span><br><span class="line"><span class="comment">//InetAddress address = InetAddress.getByName(&quot;itheima&quot;);</span></span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">address</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;192.168.1.66&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//public String getHostName()：获取此IP地址的主机名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> address.getHostName();</span><br><span class="line">        <span class="comment">//public String getHostAddress()：返回文本显示中的IP地址字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> address.getHostAddress();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主机名：&quot;</span> + name);</span><br><span class="line">        System.out.println(<span class="string">&quot;IP地址：&quot;</span> + ip);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-5-端口和协议"><a href="#1-5-端口和协议" class="headerlink" title="1.5 端口和协议"></a>1.5 端口和协议</h3><ul><li><p>端口</p><ul><li>设备上应用程序的唯一标识</li></ul></li><li><p>端口号</p><ul><li>用两个字节表示的整数，它的取值范围是0<del>65535。其中，0</del>1023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败</li></ul></li><li><p>协议</p><ul><li>计算机网络中，连接和通信的规则被称为网络通信协议</li></ul></li><li><p>UDP协议</p><ul><li>用户数据报协议(User Datagram Protocol)</li><li>UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。</li><li>由于使用UDP协议消耗系统资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输</li><li>例如视频会议通常采用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。但是在使用UDP协议传送数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议</li></ul></li><li><p>TCP协议</p><ul><li><p>传输控制协议 (Transmission Control Protocol)</p></li><li><p>TCP协议是面向连接的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。在TCP连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手”</p></li><li><p>三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠</p><p>第一次握手，客户端向服务器端发出连接请求，等待服务器确认</p><p>第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求</p><p>第三次握手，客户端再次向服务器端发送确认信息，确认连接</p></li><li><p>完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛。例如上传文件、下载文件、浏览网页等</p></li></ul></li></ul><h2 id="2-UDP通信程序"><a href="#2-UDP通信程序" class="headerlink" title="2.UDP通信程序"></a>2.UDP通信程序</h2><h3 id="2-1-UDP发送数据"><a href="#2-1-UDP发送数据" class="headerlink" title="2.1 UDP发送数据"></a>2.1 UDP发送数据</h3><ul><li><p>Java中的UDP通信</p><ul><li>UDP协议是一种不可靠的网络协议，它在通信的两端各建立一个Socket对象，但是这两个Socket只是发送，接收数据的对象，因此对于基于UDP协议的通信双方而言，没有所谓的客户端和服务器的概念</li><li>Java提供了DatagramSocket类作为基于UDP协议的Socket</li></ul></li><li><p>构造方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>DatagramSocket()</td><td>创建数据报套接字并将其绑定到本机地址上的任何可用端口</td></tr><tr><td>DatagramPacket(byte[] buf,int len,InetAddress add,int port)</td><td>创建数据包,发送长度为len的数据包到指定主机的指定端口</td></tr></tbody></table></li><li><p>相关方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>void send(DatagramPacket p)</td><td>发送数据报包</td></tr><tr><td>void close()</td><td>关闭数据报套接字</td></tr><tr><td>void receive(DatagramPacket p)</td><td>从此套接字接受数据报包</td></tr></tbody></table></li><li><p>发送数据的步骤</p><ul><li>创建发送端的Socket对象(DatagramSocket)</li><li>创建数据，并把数据打包</li><li>调用DatagramSocket对象的方法发送数据</li><li>关闭发送端</li></ul></li><li><p>代码演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//创建发送端的Socket对象(DatagramSocket)</span></span><br><span class="line">        <span class="comment">// DatagramSocket() 构造数据报套接字并将其绑定到本地主机上的任何可用端口</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建数据，并把数据打包</span></span><br><span class="line">        <span class="comment">//DatagramPacket(byte[] buf, int length, InetAddress address, int port)</span></span><br><span class="line">        <span class="comment">//构造一个数据包，发送长度为 length的数据包到指定主机上的指定端口号。</span></span><br><span class="line">        <span class="type">byte</span>[] bys = <span class="string">&quot;hello,udp,我来了&quot;</span>.getBytes();</span><br><span class="line"></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bys,bys.length,InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>),<span class="number">10086</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用DatagramSocket对象的方法发送数据</span></span><br><span class="line">        <span class="comment">//void send(DatagramPacket p) 从此套接字发送数据报包</span></span><br><span class="line">        ds.send(dp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭发送端</span></span><br><span class="line">        <span class="comment">//void close() 关闭此数据报套接字</span></span><br><span class="line">        ds.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-2UDP接收数据"><a href="#2-2UDP接收数据" class="headerlink" title="2.2UDP接收数据"></a>2.2UDP接收数据</h3><ul><li><p>接收数据的步骤</p><ul><li>创建接收端的Socket对象(DatagramSocket)</li><li>创建一个数据包，用于接收数据</li><li>调用DatagramSocket对象的方法接收数据</li><li>解析数据包，并把数据在控制台显示</li><li>关闭接收端</li></ul></li><li><p>构造方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>DatagramPacket(byte[] buf, int len)</td><td>创建一个DatagramPacket用于接收长度为len的数据包</td></tr></tbody></table></li><li><p>相关方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>byte[]  getData()</td><td>返回数据缓冲区</td></tr><tr><td>int  getLength()</td><td>返回要发送的数据的长度或接收的数据的长度</td></tr></tbody></table></li><li><p>示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">      <span class="comment">//创建接收端的Socket对象(DatagramSocket)</span></span><br><span class="line">      <span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">12345</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//创建一个数据包，用于接收数据</span></span><br><span class="line">      <span class="type">byte</span>[] bys = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">      <span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bys, bys.length);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//调用DatagramSocket对象的方法接收数据</span></span><br><span class="line">      ds.receive(dp);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//解析数据包，并把数据在控制台显示</span></span><br><span class="line">      System.out.println(<span class="string">&quot;数据是：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(dp.getData(), <span class="number">0</span>,                                             dp.getLength()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-3UDP通信程序练习"><a href="#2-3UDP通信程序练习" class="headerlink" title="2.3UDP通信程序练习"></a>2.3UDP通信程序练习</h3><ul><li><p>案例需求</p><p>UDP发送数据：数据来自于键盘录入，直到输入的数据是886，发送数据结束</p><p>UDP接收数据：因为接收端不知道发送端什么时候停止发送，故采用死循环接收</p></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    UDP发送数据：</span></span><br><span class="line"><span class="comment">        数据来自于键盘录入，直到输入的数据是886，发送数据结束</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//创建发送端的Socket对象(DatagramSocket)</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line">        <span class="comment">//键盘录入数据</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">          <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">            <span class="comment">//输入的数据是886，发送数据结束</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;886&quot;</span>.equals(s)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//创建数据，并把数据打包</span></span><br><span class="line">            <span class="type">byte</span>[] bys = s.getBytes();</span><br><span class="line">            <span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bys, bys.length, InetAddress.getByName(<span class="string">&quot;192.168.1.66&quot;</span>), <span class="number">12345</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//调用DatagramSocket对象的方法发送数据</span></span><br><span class="line">            ds.send(dp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭发送端</span></span><br><span class="line">        ds.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    UDP接收数据：</span></span><br><span class="line"><span class="comment">        因为接收端不知道发送端什么时候停止发送，故采用死循环接收</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//创建接收端的Socket对象(DatagramSocket)</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">12345</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//创建一个数据包，用于接收数据</span></span><br><span class="line">            <span class="type">byte</span>[] bys = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bys, bys.length);</span><br><span class="line">            <span class="comment">//调用DatagramSocket对象的方法接收数据</span></span><br><span class="line">            ds.receive(dp);</span><br><span class="line">            <span class="comment">//解析数据包，并把数据在控制台显示</span></span><br><span class="line">            System.out.println(<span class="string">&quot;数据是：&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(dp.getData(), <span class="number">0</span>, dp.getLength()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭接收端</span></span><br><span class="line"><span class="comment">//        ds.close();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-4UDP三种通讯方式"><a href="#2-4UDP三种通讯方式" class="headerlink" title="2.4UDP三种通讯方式"></a>2.4UDP三种通讯方式</h3><ul><li><p>单播</p><p>单播用于两个主机之间的端对端通信</p></li><li><p>组播</p><p>组播用于对一组特定的主机进行通信</p></li><li><p>广播</p><p>广播用于一个主机对整个局域网上所有主机上的数据通信</p></li></ul><h3 id="2-5UDP组播实现"><a href="#2-5UDP组播实现" class="headerlink" title="2.5UDP组播实现"></a>2.5UDP组播实现</h3><ul><li><p>实现步骤</p><ul><li>发送端<ol><li>创建发送端的Socket对象(DatagramSocket)</li><li>创建数据，并把数据打包(DatagramPacket)</li><li>调用DatagramSocket对象的方法发送数据(在单播中,这里是发给指定IP的电脑但是在组播当中,这里是发给组播地址)</li><li>释放资源</li></ol></li><li>接收端<ol><li>创建接收端Socket对象(MulticastSocket)</li><li>创建一个箱子,用于接收数据</li><li>把当前计算机绑定一个组播地址</li><li>将数据接收到箱子中</li><li>解析数据包,并打印数据</li><li>释放资源</li></ol></li></ul></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClinetDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1. 创建发送端的Socket对象(DatagramSocket)</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hello 组播&quot;</span>;</span><br><span class="line">        <span class="type">byte</span>[] bytes = s.getBytes();</span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">address</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;224.0.1.0&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line">        <span class="comment">// 2. 创建数据，并把数据打包(DatagramPacket)</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes,bytes.length,address,port);</span><br><span class="line">        <span class="comment">// 3. 调用DatagramSocket对象的方法发送数据(在单播中,这里是发给指定IP的电脑但是在组播当中,这里是发给组播地址)</span></span><br><span class="line">        ds.send(dp);</span><br><span class="line">        <span class="comment">// 4. 释放资源</span></span><br><span class="line">        ds.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接收端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1. 创建接收端Socket对象(MulticastSocket)</span></span><br><span class="line">        <span class="type">MulticastSocket</span> <span class="variable">ms</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MulticastSocket</span>(<span class="number">10000</span>);</span><br><span class="line">        <span class="comment">// 2. 创建一个箱子,用于接收数据</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>],<span class="number">1024</span>);</span><br><span class="line">        <span class="comment">// 3. 把当前计算机绑定一个组播地址,表示添加到这一组中.</span></span><br><span class="line">        ms.joinGroup(InetAddress.getByName(<span class="string">&quot;224.0.1.0&quot;</span>));</span><br><span class="line">        <span class="comment">// 4. 将数据接收到箱子中</span></span><br><span class="line">        ms.receive(dp);</span><br><span class="line">        <span class="comment">// 5. 解析数据包,并打印数据</span></span><br><span class="line">        <span class="type">byte</span>[] data = dp.getData();</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> dp.getLength();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(data,<span class="number">0</span>,length));</span><br><span class="line">        <span class="comment">// 6. 释放资源</span></span><br><span class="line">        ms.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-6UDP广播实现"><a href="#2-6UDP广播实现" class="headerlink" title="2.6UDP广播实现"></a>2.6UDP广播实现</h3><ul><li><p>实现步骤</p><ul><li>发送端<ol><li>创建发送端Socket对象(DatagramSocket)</li><li>创建存储数据的箱子,将广播地址封装进去</li><li>发送数据</li><li>释放资源</li></ol></li><li>接收端<ol><li>创建接收端的Socket对象(DatagramSocket)</li><li>创建一个数据包，用于接收数据</li><li>调用DatagramSocket对象的方法接收数据</li><li>解析数据包，并把数据在控制台显示</li><li>关闭接收端</li></ol></li></ul></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">      <span class="comment">// 1. 创建发送端Socket对象(DatagramSocket)</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line"><span class="comment">// 2. 创建存储数据的箱子,将广播地址封装进去</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;广播 hello&quot;</span>;</span><br><span class="line">        <span class="type">byte</span>[] bytes = s.getBytes();</span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">address</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;255.255.255.255&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes,bytes.length,address,port);</span><br><span class="line"><span class="comment">// 3. 发送数据</span></span><br><span class="line">        ds.send(dp);</span><br><span class="line"><span class="comment">// 4. 释放资源</span></span><br><span class="line">        ds.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1. 创建接收端的Socket对象(DatagramSocket)</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">10000</span>);</span><br><span class="line">        <span class="comment">// 2. 创建一个数据包，用于接收数据</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>],<span class="number">1024</span>);</span><br><span class="line">        <span class="comment">// 3. 调用DatagramSocket对象的方法接收数据</span></span><br><span class="line">        ds.receive(dp);</span><br><span class="line">        <span class="comment">// 4. 解析数据包，并把数据在控制台显示</span></span><br><span class="line">        <span class="type">byte</span>[] data = dp.getData();</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> dp.getLength();</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(data,<span class="number">0</span>,length));</span><br><span class="line">        <span class="comment">// 5. 关闭接收端</span></span><br><span class="line">        ds.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>##3. TCP通信程序</p><h3 id="3-1TCP发送数据"><a href="#3-1TCP发送数据" class="headerlink" title="3.1TCP发送数据"></a>3.1TCP发送数据</h3><ul><li><p>Java中的TCP通信</p><ul><li>Java对基于TCP协议的的网络提供了良好的封装，使用Socket对象来代表两端的通信端口，并通过Socket产生IO流来进行网络通信。</li><li>Java为客户端提供了Socket类，为服务器端提供了ServerSocket类</li></ul></li><li><p>构造方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>Socket(InetAddress address,int port)</td><td>创建流套接字并将其连接到指定IP指定端口号</td></tr><tr><td>Socket(String host, int port)</td><td>创建流套接字并将其连接到指定主机上的指定端口号</td></tr></tbody></table></li><li><p>相关方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>InputStream  getInputStream()</td><td>返回此套接字的输入流</td></tr><tr><td>OutputStream getOutputStream()</td><td>返回此套接字的输出流</td></tr></tbody></table></li><li><p>示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//TCP协议，发送数据</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.创建Socket对象</span></span><br><span class="line">        <span class="comment">//细节：在创建对象的同时会连接服务端</span></span><br><span class="line">        <span class="comment">//      如果连接不上，代码会报错</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.可以从连接通道中获取输出流</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="comment">//写出数据</span></span><br><span class="line">        os.write(<span class="string">&quot;aaa&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.释放资源</span></span><br><span class="line">        os.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-2TCP接收数据"><a href="#3-2TCP接收数据" class="headerlink" title="3.2TCP接收数据"></a>3.2TCP接收数据</h3><ul><li><p>构造方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>ServletSocket(int port)</td><td>创建绑定到指定端口的服务器套接字</td></tr></tbody></table></li><li><p>相关方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>Socket accept()</td><td>监听要连接到此的套接字并接受它</td></tr></tbody></table></li><li><p>注意事项</p><ol><li>accept方法是阻塞的,作用就是等待客户端连接</li><li>客户端创建对象并连接服务器,此时是通过三次握手协议,保证跟服务器之间的连接</li><li>针对客户端来讲,是往外写的,所以是输出流<br>针对服务器来讲,是往里读的,所以是输入流</li><li>read方法也是阻塞的</li><li>客户端在关流的时候,还多了一个往服务器写结束标记的动作</li><li>最后一步断开连接,通过四次挥手协议保证连接终止</li></ol></li><li><p>三次握手和四次挥手</p><ul><li><p>三次握手</p><p><img src="/JavaNotes/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/img/07_TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="07_TCP三次握手"></p></li><li><p>四次挥手</p><p><img src="/JavaNotes/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/img/08_TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="08_TCP四次挥手"></p></li></ul></li><li><p>示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//TCP协议，接收数据</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.创建对象ServerSocker</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.监听客户端的链接</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> ss.accept();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.从连接通道中获取输入流读取数据</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">int</span> b;</span><br><span class="line">        <span class="keyword">while</span> ((b = is.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println((<span class="type">char</span>) b);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.释放资源</span></span><br><span class="line">        socket.close();</span><br><span class="line">        ss.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-3TCP程序练习（传输中文）"><a href="#3-3TCP程序练习（传输中文）" class="headerlink" title="3.3TCP程序练习（传输中文）"></a>3.3TCP程序练习（传输中文）</h3><p>发送端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//TCP协议，发送数据</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.创建Socket对象</span></span><br><span class="line">        <span class="comment">//细节：在创建对象的同时会连接服务端</span></span><br><span class="line">        <span class="comment">//      如果连接不上，代码会报错</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.可以从连接通道中获取输出流</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="comment">//写出数据</span></span><br><span class="line">        os.write(<span class="string">&quot;你好你好&quot;</span>.getBytes());<span class="comment">//12字节</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.释放资源</span></span><br><span class="line">        os.close();</span><br><span class="line">        socket.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接收端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//TCP协议，接收数据</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.创建对象ServerSocker</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.监听客户端的链接</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> ss.accept();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.从连接通道中获取输入流读取数据</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is);</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream()));</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> b;</span><br><span class="line">        <span class="keyword">while</span> ((b = br.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>) b);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.释放资源</span></span><br><span class="line">        socket.close();</span><br><span class="line">        ss.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-综合练习"><a href="#4-综合练习" class="headerlink" title="4. 综合练习"></a>4. 综合练习</h2><h3 id="练习一：多发多收"><a href="#练习一：多发多收" class="headerlink" title="练习一：多发多收"></a>练习一：多发多收</h3><p>需求：</p><p>​客户端：多次发送数据</p><p>​服务器：接收多次接收数据，并打印</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//客户端：多次发送数据</span></span><br><span class="line">        <span class="comment">//服务器：接收多次接收数据，并打印</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 创建Socket对象并连接服务端</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.写出数据</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入您要发送的信息&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;886&quot;</span>.equals(str))&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            os.write(str.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.释放资源</span></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//客户端：多次发送数据</span></span><br><span class="line">        <span class="comment">//服务器：接收多次接收数据，并打印</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.创建对象绑定10000端口</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.等待客户端来连接</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> ss.accept();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.读取数据</span></span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream());</span><br><span class="line">        <span class="type">int</span> b;</span><br><span class="line">        <span class="keyword">while</span> ((b = isr.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>)b);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.释放资源</span></span><br><span class="line">        socket.close();</span><br><span class="line">        ss.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习二：接收并反馈"><a href="#练习二：接收并反馈" class="headerlink" title="练习二：接收并反馈"></a>练习二：接收并反馈</h3><ul><li><p>案例需求</p><p>客户端：发送数据，接受服务器反馈</p><p>服务器：收到消息后给出反馈</p></li><li><p>案例分析</p><ul><li>客户端创建对象，使用输出流输出数据</li><li>服务端创建对象，使用输入流接受数据</li><li>服务端使用输出流给出反馈数据</li><li>客户端使用输入流接受反馈数据</li></ul></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        os.write(<span class="string">&quot;hello&quot;</span>.getBytes());</span><br><span class="line">       <span class="comment">// os.close();如果在这里关流,会导致整个socket都无法使用</span></span><br><span class="line">        socket.shutdownOutput();<span class="comment">//仅仅关闭输出流.并写一个结束标记,对socket没有任何影响</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream()));</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span>((line = br.readLine())!=<span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">        br.close();</span><br><span class="line">        os.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 服务器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">accept</span> <span class="operator">=</span> ss.accept();</span><br><span class="line"></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> accept.getInputStream();</span><br><span class="line">        <span class="type">int</span> b;</span><br><span class="line">        <span class="keyword">while</span>((b = is.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println((<span class="type">char</span>) b);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;看看我执行了吗?&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(accept.getOutputStream()));</span><br><span class="line">        bw.write(<span class="string">&quot;你谁啊?&quot;</span>);</span><br><span class="line">        bw.newLine();</span><br><span class="line">        bw.flush();</span><br><span class="line"></span><br><span class="line">        bw.close();</span><br><span class="line">        is.close();</span><br><span class="line">        accept.close();</span><br><span class="line">        ss.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="练习三：上传练习（TCP协议）"><a href="#练习三：上传练习（TCP协议）" class="headerlink" title="练习三：上传练习（TCP协议）"></a>练习三：上传练习（TCP协议）</h3><ul><li><p>案例需求</p><p>客户端：数据来自于本地文件，接收服务器反馈</p><p>服务器：接收到的数据写入本地文件，给出反馈</p></li><li><p>案例分析</p><ul><li>创建客户端对象，创建输入流对象指向文件，每读一次数据就给服务器输出一次数据，输出结束后使用shutdownOutput()方法告知服务端传输结束</li><li>创建服务器对象，创建输出流对象指向文件，每接受一次数据就使用输出流输出到文件中，传输结束后。使用输出流给客户端反馈信息</li><li>客户端接受服务端的回馈信息</li></ul></li><li><p>相关方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>void shutdownInput()</td><td>将此套接字的输入流放置在“流的末尾”</td></tr><tr><td>void shutdownOutput()</td><td>禁止用此套接字的输出流</td></tr></tbody></table></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//客户端：将本地文件上传到服务器。接收服务器的反馈。</span></span><br><span class="line">        <span class="comment">//服务器：接收客户端上传的文件，上传完毕之后给出反馈。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 创建Socket对象，并连接服务器</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.读取本地文件中的数据，并写到服务器当中</span></span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;mysocketnet\\clientdir\\a.jpg&quot;</span>));</span><br><span class="line">        <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(socket.getOutputStream());</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = bis.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            bos.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//往服务器写出结束标记</span></span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.接收服务器的回写数据</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream()));</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">        System.out.println(line);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.释放资源</span></span><br><span class="line">        socket.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//客户端：将本地文件上传到服务器。接收服务器的反馈。</span></span><br><span class="line">        <span class="comment">//服务器：接收客户端上传的文件，上传完毕之后给出反馈。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.创建对象并绑定端口</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.等待客户端来连接</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> ss.accept();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.读取数据并保存到本地文件中</span></span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(socket.getInputStream());</span><br><span class="line">        <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;mysocketnet\\serverdir\\a.jpg&quot;</span>));</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = bis.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            bos.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        bos.close();</span><br><span class="line">        <span class="comment">//4.回写数据</span></span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(socket.getOutputStream()));</span><br><span class="line">        bw.write(<span class="string">&quot;上传成功&quot;</span>);</span><br><span class="line">        bw.newLine();</span><br><span class="line">        bw.flush();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.释放资源</span></span><br><span class="line">        socket.close();</span><br><span class="line">        ss.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="练习四：文件名重复"><a href="#练习四：文件名重复" class="headerlink" title="练习四：文件名重复"></a>练习四：文件名重复</h3><pre><code> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UUIDTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> UUID.randomUUID().toString().replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        System.out.println(str);<span class="comment">//9f15b8c356c54f55bfcb0ee3023fce8a</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//客户端：将本地文件上传到服务器。接收服务器的反馈。</span></span><br><span class="line">        <span class="comment">//服务器：接收客户端上传的文件，上传完毕之后给出反馈。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 创建Socket对象，并连接服务器</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.读取本地文件中的数据，并写到服务器当中</span></span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;mysocketnet\\clientdir\\a.jpg&quot;</span>));</span><br><span class="line">        <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(socket.getOutputStream());</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = bis.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            bos.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//往服务器写出结束标记</span></span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.接收服务器的回写数据</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream()));</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">        System.out.println(line);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.释放资源</span></span><br><span class="line">        socket.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//客户端：将本地文件上传到服务器。接收服务器的反馈。</span></span><br><span class="line">        <span class="comment">//服务器：接收客户端上传的文件，上传完毕之后给出反馈。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.创建对象并绑定端口</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.等待客户端来连接</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> ss.accept();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.读取数据并保存到本地文件中</span></span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(socket.getInputStream());</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> UUID.randomUUID().toString().replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;mysocketnet\\serverdir\\&quot;</span> + name + <span class="string">&quot;.jpg&quot;</span>));</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = bis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        bos.close();</span><br><span class="line">        <span class="comment">//4.回写数据</span></span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(socket.getOutputStream()));</span><br><span class="line">        bw.write(<span class="string">&quot;上传成功&quot;</span>);</span><br><span class="line">        bw.newLine();</span><br><span class="line">        bw.flush();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.释放资源</span></span><br><span class="line">        socket.close();</span><br><span class="line">        ss.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习五：服务器改写为多线程"><a href="#练习五：服务器改写为多线程" class="headerlink" title="练习五：服务器改写为多线程"></a>练习五：服务器改写为多线程</h3><p>服务器只能处理一个客户端请求，接收完一个图片之后，服务器就关闭了。</p><p>优化方案一：</p><p>​使用循环</p><p>弊端：</p><p>​第一个用户正在上传数据，第二个用户就来访问了，此时第二个用户是无法成功上传的。</p><p>​所以，使用多线程改进</p><p>优化方案二：</p><p>​每来一个用户，就开启多线程处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//客户端：将本地文件上传到服务器。接收服务器的反馈。</span></span><br><span class="line">        <span class="comment">//服务器：接收客户端上传的文件，上传完毕之后给出反馈。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 创建Socket对象，并连接服务器</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.读取本地文件中的数据，并写到服务器当中</span></span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;mysocketnet\\clientdir\\a.jpg&quot;</span>));</span><br><span class="line">        <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(socket.getOutputStream());</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = bis.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            bos.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//往服务器写出结束标记</span></span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.接收服务器的回写数据</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream()));</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">        System.out.println(line);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.释放资源</span></span><br><span class="line">        socket.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//客户端：将本地文件上传到服务器。接收服务器的反馈。</span></span><br><span class="line">        <span class="comment">//服务器：接收客户端上传的文件，上传完毕之后给出反馈。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.创建对象并绑定端口</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//2.等待客户端来连接</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> ss.accept();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//开启一条线程</span></span><br><span class="line">            <span class="comment">//一个用户就对应服务端的一条线程</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>(socket)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    Socket socket;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyRunnable</span><span class="params">(Socket socket)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//3.读取数据并保存到本地文件中</span></span><br><span class="line">            <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(socket.getInputStream());</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> UUID.randomUUID().toString().replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;mysocketnet\\serverdir\\&quot;</span> + name + <span class="string">&quot;.jpg&quot;</span>));</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span> ((len = bis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bos.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            bos.close();</span><br><span class="line">            <span class="comment">//4.回写数据</span></span><br><span class="line">            <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(socket.getOutputStream()));</span><br><span class="line">            bw.write(<span class="string">&quot;上传成功&quot;</span>);</span><br><span class="line">            bw.newLine();</span><br><span class="line">            bw.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//5.释放资源</span></span><br><span class="line">           <span class="keyword">if</span>(socket != <span class="literal">null</span>)&#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   socket.close();</span><br><span class="line">               &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习六：线程池改进"><a href="#练习六：线程池改进" class="headerlink" title="练习六：线程池改进"></a>练习六：线程池改进</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//客户端：将本地文件上传到服务器。接收服务器的反馈。</span></span><br><span class="line">        <span class="comment">//服务器：接收客户端上传的文件，上传完毕之后给出反馈。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 创建Socket对象，并连接服务器</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.读取本地文件中的数据，并写到服务器当中</span></span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;mysocketnet\\clientdir\\a.jpg&quot;</span>));</span><br><span class="line">        <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(socket.getOutputStream());</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = bis.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            bos.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//往服务器写出结束标记</span></span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.接收服务器的回写数据</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream()));</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">        System.out.println(line);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.释放资源</span></span><br><span class="line">        socket.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//客户端：将本地文件上传到服务器。接收服务器的反馈。</span></span><br><span class="line">        <span class="comment">//服务器：接收客户端上传的文件，上传完毕之后给出反馈。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建线程池对象</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                <span class="number">3</span>,<span class="comment">//核心线程数量</span></span><br><span class="line">                <span class="number">16</span>,<span class="comment">//线程池总大小</span></span><br><span class="line">                <span class="number">60</span>,<span class="comment">//空闲时间</span></span><br><span class="line">                TimeUnit.SECONDS,<span class="comment">//空闲时间（单位）</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">2</span>),<span class="comment">//队列</span></span><br><span class="line">                Executors.defaultThreadFactory(),<span class="comment">//线程工厂，让线程池如何创建线程对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy()<span class="comment">//阻塞队列</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.创建对象并绑定端口</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//2.等待客户端来连接</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> ss.accept();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//开启一条线程</span></span><br><span class="line">            <span class="comment">//一个用户就对应服务端的一条线程</span></span><br><span class="line">            <span class="comment">//new Thread(new MyRunnable(socket)).start();</span></span><br><span class="line">            pool.submit(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>(socket));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    Socket socket;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyRunnable</span><span class="params">(Socket socket)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//3.读取数据并保存到本地文件中</span></span><br><span class="line">            <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(socket.getInputStream());</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> UUID.randomUUID().toString().replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;mysocketnet\\serverdir\\&quot;</span> + name + <span class="string">&quot;.jpg&quot;</span>));</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span> ((len = bis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bos.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            bos.close();</span><br><span class="line">            <span class="comment">//4.回写数据</span></span><br><span class="line">            <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(socket.getOutputStream()));</span><br><span class="line">            bw.write(<span class="string">&quot;上传成功&quot;</span>);</span><br><span class="line">            bw.newLine();</span><br><span class="line">            bw.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//5.释放资源</span></span><br><span class="line">           <span class="keyword">if</span>(socket != <span class="literal">null</span>)&#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   socket.close();</span><br><span class="line">               &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程</title>
      <link href="/posts/5729df21.html"/>
      <url>/posts/5729df21.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-线程池"><a href="#1-线程池" class="headerlink" title="1. 线程池"></a>1. 线程池</h2><h3 id="1-1-线程状态介绍"><a href="#1-1-线程状态介绍" class="headerlink" title="1.1 线程状态介绍"></a>1.1 线程状态介绍</h3><p>当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。线程对象在不同的时期有不同的状态。那么Java中的线程存在哪几种状态呢？Java中的线程</p><p>状态被定义在了java.lang.Thread.State枚举类中，State枚举类的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/* 新建 */</span></span><br><span class="line">        NEW , </span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 可运行状态 */</span></span><br><span class="line">        RUNNABLE , </span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 阻塞状态 */</span></span><br><span class="line">        BLOCKED , </span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 无限等待状态 */</span></span><br><span class="line">        WAITING , </span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 计时等待 */</span></span><br><span class="line">        TIMED_WAITING , </span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 终止 */</span></span><br><span class="line">        TERMINATED;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取当前线程的状态</span></span><br><span class="line">    <span class="keyword">public</span> State <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> jdk.internal.misc.VM.toThreadState(threadStatus);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过源码我们可以看到Java中的线程存在6种状态，每种线程状态的含义如下</p><table><thead><tr><th>线程状态</th><th>具体含义</th></tr></thead><tbody><tr><td>NEW</td><td>一个尚未启动的线程的状态。也称之为初始状态、开始状态。线程刚被创建，但是并未启动。还没调用start方法。MyThread t &#x3D; new MyThread()只有线程象，没有线程特征。</td></tr><tr><td>RUNNABLE</td><td>当我们调用线程对象的start方法，那么此时线程对象进入了RUNNABLE状态。那么此时才是真正的在JVM进程中创建了一个线程，线程一经启动并不是立即得到执行，线程的运行与否要听令与CPU的调度，那么我们把这个中间状态称之为可执行状态(RUNNABLE)也就是说它具备执行的资格，但是并没有真正的执行起来而是在等待CPU的度。</td></tr><tr><td>BLOCKED</td><td>当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态；当该线程持有锁时，该线程将变成Runnable状态。</td></tr><tr><td>WAITING</td><td>一个正在等待的线程的状态。也称之为等待状态。造成线程等待的原因有两种，分别是调用Object.wait()、join()方法。处于等待状态的线程，正在等待其他线程去执行一个特定的操作。例如：因为wait()而等待的线程正在等待另一个线程去调用notify()或notifyAll()；一个因为join()而等待的线程正在等待另一个线程结束。</td></tr><tr><td>TIMED_WAITING</td><td>一个在限定时间内等待的线程的状态。也称之为限时等待状态。造成线程限时等待状态的原因有三种，分别是：Thread.sleep(long)，Object.wait(long)、join(long)。</td></tr><tr><td>TERMINATED</td><td>一个完全运行完成的线程的状态。也称之为终止状态、结束状态</td></tr></tbody></table><p>各个状态的转换，如下图所示：</p><p><img src="/JavaNotes/%E5%A4%9A%E7%BA%BF%E7%A8%8B&juc/img/1591163781941.png" alt="1591163781941"></p><h3 id="1-2-线程池-基本原理"><a href="#1-2-线程池-基本原理" class="headerlink" title="1.2 线程池-基本原理"></a>1.2 线程池-基本原理</h3><p><strong>概述 :</strong> </p><p>​提到池，大家应该能想到的就是水池。水池就是一个容器，在该容器中存储了很多的水。那么什么是线程池呢？线程池也是可以看做成一个池子，在该池子中存储很多个线程。</p><p>线程池存在的意义：</p><p>​系统创建一个线程的成本是比较高的，因为它涉及到与操作系统交互，当程序中需要创建大量生存期很短暂的线程时，频繁的创建和销毁线程对系统的资源消耗有可能大于业务处理是对系</p><p>​统资源的消耗，这样就有点”舍本逐末”了。针对这一种情况，为了提高性能，我们就可以采用线程池。线程池在启动的时，会创建大量空闲线程，当我们向线程池提交任务的时，线程池就</p><p>​会启动一个线程来执行该任务。等待任务执行完毕以后，线程并不会死亡，而是再次返回到线程池中称为空闲状态。等待下一次任务的执行。</p><p><strong>线程池的设计思路 :</strong></p><ol><li>准备一个任务容器</li><li>一次性启动多个(2个)消费者线程</li><li>刚开始任务容器是空的，所以线程都在wait</li><li>直到一个外部线程向这个任务容器中扔了一个”任务”，就会有一个消费者线程被唤醒</li><li>这个消费者线程取出”任务”，并且执行这个任务，执行完毕后，继续等待下一次任务的到来</li></ol><h3 id="1-3-线程池-Executors默认线程池"><a href="#1-3-线程池-Executors默认线程池" class="headerlink" title="1.3 线程池-Executors默认线程池"></a>1.3 线程池-Executors默认线程池</h3><p>概述 : JDK对线程池也进行了相关的实现，在真实企业开发中我们也很少去自定义线程池，而是使用JDK中自带的线程池。</p><p>我们可以使用Executors中所提供的<strong>静态</strong>方法来创建线程池</p><p>​static ExecutorService newCachedThreadPool()   创建一个默认的线程池<br>​static newFixedThreadPool(int nThreads)    创建一个指定最多线程数量的线程池</p><p><strong>代码实现 :</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mythreadpool;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//static ExecutorService newCachedThreadPool()   创建一个默认的线程池</span></span><br><span class="line"><span class="comment">//static newFixedThreadPool(int nThreads)    创建一个指定最多线程数量的线程池</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadPoolDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1,创建一个默认的线程池对象.池子中默认是空的.默认最多可以容纳int类型的最大值.</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">//Executors --- 可以帮助我们创建线程池对象</span></span><br><span class="line">        <span class="comment">//ExecutorService --- 可以帮助我们控制线程池</span></span><br><span class="line"></span><br><span class="line">        executorService.submit(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;在执行了&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Thread.sleep(2000);</span></span><br><span class="line"></span><br><span class="line">        executorService.submit(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;在执行了&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-4-线程池-Executors创建指定上限的线程池"><a href="#1-4-线程池-Executors创建指定上限的线程池" class="headerlink" title="1.4 线程池-Executors创建指定上限的线程池"></a>1.4 线程池-Executors创建指定上限的线程池</h3><p><strong>使用Executors中所提供的静态方法来创建线程池</strong></p><p>​static ExecutorService newFixedThreadPool(int nThreads) : 创建一个指定最多线程数量的线程池</p><p><strong>代码实现 :</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mythreadpool;</span><br><span class="line"></span><br><span class="line"><span class="comment">//static ExecutorService newFixedThreadPool(int nThreads)</span></span><br><span class="line"><span class="comment">//创建一个指定最多线程数量的线程池</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadPoolDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//参数不是初始值而是最大值</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">pool</span> <span class="operator">=</span> (ThreadPoolExecutor) executorService;</span><br><span class="line">        System.out.println(pool.getPoolSize());<span class="comment">//0</span></span><br><span class="line"></span><br><span class="line">        executorService.submit(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;在执行了&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        executorService.submit(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;在执行了&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(pool.getPoolSize());<span class="comment">//2</span></span><br><span class="line"><span class="comment">//        executorService.shutdown();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-5-线程池-ThreadPoolExecutor"><a href="#1-5-线程池-ThreadPoolExecutor" class="headerlink" title="1.5 线程池-ThreadPoolExecutor"></a>1.5 线程池-ThreadPoolExecutor</h3><p><strong>创建线程池对象 :</strong> </p><p>ThreadPoolExecutor threadPoolExecutor &#x3D; new ThreadPoolExecutor(核心线程数量,最大线程数量,空闲线程最大存活时间,任务队列,创建线程工厂,任务的拒绝策略);</p><p><strong>代码实现 :</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mythreadpool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadPoolDemo3</span> &#123;</span><br><span class="line"><span class="comment">//    参数一：核心线程数量</span></span><br><span class="line"><span class="comment">//    参数二：最大线程数</span></span><br><span class="line"><span class="comment">//    参数三：空闲线程最大存活时间</span></span><br><span class="line"><span class="comment">//    参数四：时间单位</span></span><br><span class="line"><span class="comment">//    参数五：任务队列</span></span><br><span class="line"><span class="comment">//    参数六：创建线程工厂</span></span><br><span class="line"><span class="comment">//    参数七：任务的拒绝策略</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">2</span>,<span class="number">5</span>,<span class="number">2</span>,TimeUnit.SECONDS,<span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10</span>), Executors.defaultThreadFactory(),<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br><span class="line">        pool.submit(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        pool.submit(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line"></span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-6-线程池-参数详解"><a href="#1-6-线程池-参数详解" class="headerlink" title="1.6 线程池-参数详解"></a>1.6 线程池-参数详解</h3><p><img src="/JavaNotes/%E5%A4%9A%E7%BA%BF%E7%A8%8B&juc/img/1591165506516.png" alt="1591165506516"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                              TimeUnit unit,</span></span><br><span class="line"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                              ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                              RejectedExecutionHandler handler)</span></span><br><span class="line">    </span><br><span class="line">corePoolSize：   核心线程的最大值，不能小于<span class="number">0</span></span><br><span class="line">maximumPoolSize：最大线程数，不能小于等于<span class="number">0</span>，maximumPoolSize &gt;= corePoolSize</span><br><span class="line">keepAliveTime：  空闲线程最大存活时间,不能小于<span class="number">0</span></span><br><span class="line">unit：           时间单位</span><br><span class="line">workQueue：      任务队列，不能为<span class="literal">null</span></span><br><span class="line">threadFactory：  创建线程工厂,不能为<span class="literal">null</span>      </span><br><span class="line">handler：        任务的拒绝策略,不能为<span class="literal">null</span>  </span><br></pre></td></tr></table></figure><h3 id="1-7-线程池-非默认任务拒绝策略"><a href="#1-7-线程池-非默认任务拒绝策略" class="headerlink" title="1.7 线程池-非默认任务拒绝策略"></a>1.7 线程池-非默认任务拒绝策略</h3><p>RejectedExecutionHandler是jdk提供的一个任务拒绝策略接口，它下面存在4个子类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor.AbortPolicy:     丢弃任务并抛出RejectedExecutionException异常。是默认的策略。</span><br><span class="line">ThreadPoolExecutor.DiscardPolicy：    丢弃任务，但是不抛出异常 这是不推荐的做法。</span><br><span class="line">ThreadPoolExecutor.DiscardOldestPolicy：    抛弃队列中等待最久的任务 然后把当前任务加入队列中。</span><br><span class="line">ThreadPoolExecutor.CallerRunsPolicy:        调用任务的run()方法绕过线程池直接执行。</span><br></pre></td></tr></table></figure><p>注：明确线程池对多可执行的任务数 &#x3D; 队列容量 + 最大线程数</p><p><strong>案例演示1</strong>：演示ThreadPoolExecutor.AbortPolicy任务处理策略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExecutorDemo01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span> , <span class="number">3</span> , <span class="number">20</span> , TimeUnit.SECONDS ,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1</span>) , Executors.defaultThreadFactory() , <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy()) ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交5个任务，而该线程池最多可以处理4个任务，当我们使用AbortPolicy这个任务处理策略的时候，就会抛出异常</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span> ; x &lt; <span class="number">5</span> ; x++) &#123;</span><br><span class="line">            threadPoolExecutor.submit(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;----&gt;&gt; 执行了任务&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>控制台输出结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>----&gt;&gt; 执行了任务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>----&gt;&gt; 执行了任务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>----&gt;&gt; 执行了任务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>----&gt;&gt; 执行了任务</span><br></pre></td></tr></table></figure><p>控制台报错，仅仅执行了4个任务，有一个任务被丢弃了</p><p><strong>案例演示2</strong>：演示ThreadPoolExecutor.DiscardPolicy任务处理策略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExecutorDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span> , <span class="number">3</span> , <span class="number">20</span> , TimeUnit.SECONDS ,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1</span>) , Executors.defaultThreadFactory() , <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.DiscardPolicy()) ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交5个任务，而该线程池最多可以处理4个任务，当我们使用DiscardPolicy这个任务处理策略的时候，控制台不会报错</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span> ; x &lt; <span class="number">5</span> ; x++) &#123;</span><br><span class="line">            threadPoolExecutor.submit(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;----&gt;&gt; 执行了任务&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>控制台输出结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>----&gt;&gt; 执行了任务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>----&gt;&gt; 执行了任务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>----&gt;&gt; 执行了任务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>----&gt;&gt; 执行了任务</span><br></pre></td></tr></table></figure><p>控制台没有报错，仅仅执行了4个任务，有一个任务被丢弃了</p><p><strong>案例演示3</strong>：演示ThreadPoolExecutor.DiscardOldestPolicy任务处理策略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExecutorDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ThreadPoolExecutor threadPoolExecutor;</span><br><span class="line">        threadPoolExecutor = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span> , <span class="number">3</span> , <span class="number">20</span> , TimeUnit.SECONDS ,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1</span>) , Executors.defaultThreadFactory() , <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.DiscardOldestPolicy());</span><br><span class="line">        <span class="comment">// 提交5个任务</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span> ; x &lt; <span class="number">5</span> ; x++) &#123;</span><br><span class="line">            <span class="comment">// 定义一个变量，来指定指定当前执行的任务;这个变量需要被final修饰</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x ;</span><br><span class="line">            threadPoolExecutor.submit(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;----&gt;&gt; 执行了任务&quot;</span> + y);</span><br><span class="line">            &#125;);     </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>控制台输出结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>----&gt;&gt; 执行了任务<span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>----&gt;&gt; 执行了任务<span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>----&gt;&gt; 执行了任务<span class="number">3</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>----&gt;&gt; 执行了任务<span class="number">4</span></span><br></pre></td></tr></table></figure><p>由于任务1在线程池中等待时间最长，因此任务1被丢弃。</p><p><strong>案例演示4</strong>：演示ThreadPoolExecutor.CallerRunsPolicy任务处理策略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExecutorDemo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ThreadPoolExecutor threadPoolExecutor;</span><br><span class="line">        threadPoolExecutor = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span> , <span class="number">3</span> , <span class="number">20</span> , TimeUnit.SECONDS ,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1</span>) , Executors.defaultThreadFactory() , <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交5个任务</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span> ; x &lt; <span class="number">5</span> ; x++) &#123;</span><br><span class="line">            threadPoolExecutor.submit(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;----&gt;&gt; 执行了任务&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>控制台输出结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>----&gt;&gt; 执行了任务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>----&gt;&gt; 执行了任务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>----&gt;&gt; 执行了任务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>----&gt;&gt; 执行了任务</span><br><span class="line">main----&gt;&gt; 执行了任务</span><br></pre></td></tr></table></figure><p>通过控制台的输出，我们可以看到次策略没有通过线程池中的线程执行任务，而是直接调用任务的run()方法绕过线程池直接执行。</p><h2 id="2-多线程综合练习"><a href="#2-多线程综合练习" class="headerlink" title="2. 多线程综合练习"></a>2. 多线程综合练习</h2><h3 id="练习一：售票"><a href="#练习一：售票" class="headerlink" title="练习一：售票"></a>练习一：售票</h3><p>需求：</p><p>​一共有1000张电影票,可以在两个窗口领取,假设每次领取的时间为3000毫秒,</p><p>​请用多线程模拟卖票过程并打印剩余电影票的数量</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一种方式实现多线程，测试类中MyThread会创建多次，所以需要加static</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1.循环</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//2.同步代码块</span></span><br><span class="line">            <span class="keyword">synchronized</span> (MyThread.class) &#123;</span><br><span class="line">                <span class="comment">//3.判断共享数据（已经到末尾）</span></span><br><span class="line">                <span class="keyword">if</span> (ticket == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//4.判断共享数据（没有到末尾）</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    ticket--;</span><br><span class="line">                    System.out.println(getName() + <span class="string">&quot;在卖票，还剩下&quot;</span> + ticket + <span class="string">&quot;张票!!!&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">            一共有1000张电影票,可以在两个窗口领取,假设每次领取的时间为3000毫秒,</span></span><br><span class="line"><span class="comment">            要求:请用多线程模拟卖票过程并打印剩余电影票的数量</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建线程对象</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//给线程设置名字</span></span><br><span class="line">        t1.setName(<span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开启线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="练习二：赠送礼物"><a href="#练习二：赠送礼物" class="headerlink" title="练习二：赠送礼物"></a>练习二：赠送礼物</h3><p>需求：</p><p>​有100份礼品,两人同时发送，当剩下的礼品小于10份的时候则不再送出。</p><p>​利用多线程模拟该过程并将线程的名字和礼物的剩余数量打印出来.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二种方式实现多线程，测试类中MyRunable只创建一次，所以不需要加static</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1.循环</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//2.同步代码块</span></span><br><span class="line">            <span class="keyword">synchronized</span> (MyThread.class) &#123;</span><br><span class="line">                <span class="comment">//3.判断共享数据（已经到末尾）</span></span><br><span class="line">                <span class="keyword">if</span> (count &lt; <span class="number">10</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;礼物还剩下&quot;</span> + count + <span class="string">&quot;不再赠送&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//4.判断共享数据（没有到末尾）</span></span><br><span class="line">                    count--;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;在赠送礼物，还剩下&quot;</span> + count + <span class="string">&quot;个礼物!!!&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            有100份礼品,两人同时发送，当剩下的礼品小于10份的时候则不再送出，</span></span><br><span class="line"><span class="comment">            利用多线程模拟该过程并将线程的名字和礼物的剩余数量打印出来.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建参数对象</span></span><br><span class="line">        <span class="type">MyRunable</span> <span class="variable">mr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunable</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mr,<span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mr,<span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="练习三：打印数字"><a href="#练习三：打印数字" class="headerlink" title="练习三：打印数字"></a>练习三：打印数字</h3><p>需求：</p><p>​同时开启两个线程，共同获取1-100之间的所有数字。</p><p>​将输出所有的奇数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二种方式实现多线程，测试类中MyRunable只创建一次，所以不需要加static</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1.循环</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//2.同步代码块</span></span><br><span class="line">            <span class="keyword">synchronized</span> (MyThread.class) &#123;</span><br><span class="line">                <span class="comment">//3.判断共享数据（已经到末尾）</span></span><br><span class="line">                <span class="keyword">if</span> (number &gt; <span class="number">100</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//4.判断共享数据（没有到末尾）</span></span><br><span class="line">                    <span class="keyword">if</span>(number % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;打印数字&quot;</span> + number);</span><br><span class="line">                    &#125;</span><br><span class="line">                    number++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">           同时开启两个线程，共同获取1-100之间的所有数字。</span></span><br><span class="line"><span class="comment">           要求：将输出所有的奇数。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建参数对象</span></span><br><span class="line">        <span class="type">MyRunable</span> <span class="variable">mr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunable</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mr,<span class="string">&quot;线程A&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mr,<span class="string">&quot;线程B&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习四：抢红包"><a href="#练习四：抢红包" class="headerlink" title="练习四：抢红包"></a>练习四：抢红包</h3><p>需求：</p><p>​抢红包也用到了多线程。</p><p>​假设：100块，分成了3个包，现在有5个人去抢。</p><p>​其中，红包是共享数据。</p><p>​5个人是5条线程。</p><p>​打印结果如下：</p><p>​  XXX抢到了XXX元</p><p>​  XXX抢到了XXX元</p><pre><code>      XXX抢到了XXX元      XXX没抢到      XXX没抢到</code></pre><p>解决方案一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//共享数据</span></span><br><span class="line">    <span class="comment">//100块，分成了3个包</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">double</span> <span class="variable">money</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最小的中奖金额</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">MIN</span> <span class="operator">=</span> <span class="number">0.01</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//同步代码块</span></span><br><span class="line">        <span class="keyword">synchronized</span> (MyThread.class)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//判断，共享数据是否到了末尾（已经到末尾）</span></span><br><span class="line">                System.out.println(getName() + <span class="string">&quot;没有抢到红包！&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//判断，共享数据是否到了末尾（没有到末尾）</span></span><br><span class="line">                <span class="comment">//定义一个变量，表示中奖的金额</span></span><br><span class="line">                <span class="type">double</span> <span class="variable">prize</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(count == <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="comment">//表示此时是最后一个红包</span></span><br><span class="line">                    <span class="comment">//就无需随机，剩余所有的钱都是中奖金额</span></span><br><span class="line">                    prize = money;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//表示第一次，第二次（随机）</span></span><br><span class="line">                    <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">                    <span class="comment">//100 元   3个包</span></span><br><span class="line">                    <span class="comment">//第一个红包：99.98</span></span><br><span class="line">                    <span class="comment">//100 - (3-1) * 0.01</span></span><br><span class="line">                    <span class="type">double</span> <span class="variable">bounds</span> <span class="operator">=</span> money - (count - <span class="number">1</span>) * MIN;</span><br><span class="line">                    prize = r.nextDouble(bounds);</span><br><span class="line">                    <span class="keyword">if</span>(prize &lt; MIN)&#123;</span><br><span class="line">                        prize = MIN;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//从money当中，去掉当前中奖的金额</span></span><br><span class="line">                money = money - prize;</span><br><span class="line">                <span class="comment">//红包的个数-1</span></span><br><span class="line">                count--;</span><br><span class="line">                <span class="comment">//本次红包的信息进行打印</span></span><br><span class="line">                System.out.println(getName() + <span class="string">&quot;抢到了&quot;</span> + prize + <span class="string">&quot;元&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            微信中的抢红包也用到了多线程。</span></span><br><span class="line"><span class="comment">            假设：100块，分成了3个包，现在有5个人去抢。</span></span><br><span class="line"><span class="comment">            其中，红包是共享数据。</span></span><br><span class="line"><span class="comment">            5个人是5条线程。</span></span><br><span class="line"><span class="comment">            打印结果如下：</span></span><br><span class="line"><span class="comment">            XXX抢到了XXX元</span></span><br><span class="line"><span class="comment">            XXX抢到了XXX元</span></span><br><span class="line"><span class="comment">            XXX抢到了XXX元</span></span><br><span class="line"><span class="comment">            XXX没抢到</span></span><br><span class="line"><span class="comment">            XXX没抢到</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建线程的对象</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//给线程设置名字</span></span><br><span class="line">        t1.setName(<span class="string">&quot;小A&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;小QQ&quot;</span>);</span><br><span class="line">        t3.setName(<span class="string">&quot;小哈哈&quot;</span>);</span><br><span class="line">        t4.setName(<span class="string">&quot;小诗诗&quot;</span>);</span><br><span class="line">        t5.setName(<span class="string">&quot;小丹丹&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">        t4.start();</span><br><span class="line">        t5.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方案二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//总金额</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">BigDecimal</span> <span class="variable">money</span> <span class="operator">=</span> BigDecimal.valueOf(<span class="number">100.0</span>);</span><br><span class="line">    <span class="comment">//个数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="comment">//最小抽奖金额</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">BigDecimal</span> <span class="variable">MIN</span> <span class="operator">=</span> BigDecimal.valueOf(<span class="number">0.01</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (MyThread.class)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(getName() + <span class="string">&quot;没有抢到红包！&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//中奖金额</span></span><br><span class="line">                BigDecimal prize;</span><br><span class="line">                <span class="keyword">if</span>(count == <span class="number">1</span>)&#123;</span><br><span class="line">                    prize = money;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//获取抽奖范围</span></span><br><span class="line">                    <span class="type">double</span> <span class="variable">bounds</span> <span class="operator">=</span> money.subtract(BigDecimal.valueOf(count-<span class="number">1</span>).multiply(MIN)).doubleValue();</span><br><span class="line">                    <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">                    <span class="comment">//抽奖金额</span></span><br><span class="line">                    prize = BigDecimal.valueOf(r.nextDouble(bounds));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//设置抽中红包，小数点保留两位，四舍五入</span></span><br><span class="line">                prize = prize.setScale(<span class="number">2</span>,RoundingMode.HALF_UP);</span><br><span class="line">                <span class="comment">//在总金额中去掉对应的钱</span></span><br><span class="line">                money = money.subtract(prize);</span><br><span class="line">                <span class="comment">//红包少了一个</span></span><br><span class="line">                count--;</span><br><span class="line">                <span class="comment">//输出红包信息</span></span><br><span class="line">                System.out.println(getName() + <span class="string">&quot;抽中了&quot;</span> + prize + <span class="string">&quot;元&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            微信中的抢红包也用到了多线程。</span></span><br><span class="line"><span class="comment">            假设：100块，分成了3个包，现在有5个人去抢。</span></span><br><span class="line"><span class="comment">            其中，红包是共享数据。</span></span><br><span class="line"><span class="comment">            5个人是5条线程。</span></span><br><span class="line"><span class="comment">            打印结果如下：</span></span><br><span class="line"><span class="comment">            XXX抢到了XXX元</span></span><br><span class="line"><span class="comment">            XXX抢到了XXX元</span></span><br><span class="line"><span class="comment">            XXX抢到了XXX元</span></span><br><span class="line"><span class="comment">            XXX没抢到</span></span><br><span class="line"><span class="comment">            XXX没抢到</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line"></span><br><span class="line">        t1.setName(<span class="string">&quot;小A&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;小QQ&quot;</span>);</span><br><span class="line">        t3.setName(<span class="string">&quot;小哈哈&quot;</span>);</span><br><span class="line">        t4.setName(<span class="string">&quot;小诗诗&quot;</span>);</span><br><span class="line">        t5.setName(<span class="string">&quot;小丹丹&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">        t4.start();</span><br><span class="line">        t5.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习五：抽奖箱"><a href="#练习五：抽奖箱" class="headerlink" title="练习五：抽奖箱"></a>练习五：抽奖箱</h3><p>需求：</p><p>​有一个抽奖池,该抽奖池中存放了奖励的金额,该抽奖池中的奖项为 {10,5,20,50,100,200,500,800,2,80,300,700}; </p><p>创建两个抽奖箱(线程)设置线程名称分别为“抽奖箱1”，“抽奖箱2” </p><p>随机从抽奖池中获取奖项元素并打印在控制台上,格式如下:</p><p>​               每次抽出一个奖项就打印一个(随机)</p><p>​抽奖箱1 又产生了一个 10 元大奖</p><pre><code>      抽奖箱1 又产生了一个 100 元大奖        抽奖箱1 又产生了一个 200 元大奖        抽奖箱1 又产生了一个 800 元大奖  </code></pre><p>​抽奖箱2 又产生了一个 700 元大奖  </p><pre><code>      .....</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;Integer&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(ArrayList&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1.循环</span></span><br><span class="line">        <span class="comment">//2.同步代码块</span></span><br><span class="line">        <span class="comment">//3.判断</span></span><br><span class="line">        <span class="comment">//4.判断</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (MyThread.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (list.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//继续抽奖</span></span><br><span class="line">                    Collections.shuffle(list);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">prize</span> <span class="operator">=</span> list.remove(<span class="number">0</span>);</span><br><span class="line">                    System.out.println(getName() + <span class="string">&quot;又产生了一个&quot;</span> + prize + <span class="string">&quot;元大奖&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            有一个抽奖池,该抽奖池中存放了奖励的金额,该抽奖池中的奖项为 &#123;10,5,20,50,100,200,500,800,2,80,300,700&#125;;</span></span><br><span class="line"><span class="comment">            创建两个抽奖箱(线程)设置线程名称分别为“抽奖箱1”，“抽奖箱2”</span></span><br><span class="line"><span class="comment">            随机从抽奖池中获取奖项元素并打印在控制台上,格式如下:</span></span><br><span class="line"><span class="comment">                             每次抽出一个奖项就打印一个(随机)</span></span><br><span class="line"><span class="comment">            抽奖箱1 又产生了一个 10 元大奖</span></span><br><span class="line"><span class="comment">            抽奖箱1 又产生了一个 100 元大奖</span></span><br><span class="line"><span class="comment">            抽奖箱1 又产生了一个 200 元大奖</span></span><br><span class="line"><span class="comment">            抽奖箱1 又产生了一个 800 元大奖</span></span><br><span class="line"><span class="comment">            抽奖箱2 又产生了一个 700 元大奖</span></span><br><span class="line"><span class="comment">            .....</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建奖池</span></span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list,<span class="number">10</span>,<span class="number">5</span>,<span class="number">20</span>,<span class="number">50</span>,<span class="number">100</span>,<span class="number">200</span>,<span class="number">500</span>,<span class="number">800</span>,<span class="number">2</span>,<span class="number">80</span>,<span class="number">300</span>,<span class="number">700</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建线程</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(list);</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置名字</span></span><br><span class="line">        t1.setName(<span class="string">&quot;抽奖箱1&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;抽奖箱2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习六：多线程统计并求最大值"><a href="#练习六：多线程统计并求最大值" class="headerlink" title="练习六：多线程统计并求最大值"></a>练习六：多线程统计并求最大值</h3><p>需求：</p><p>​在上一题基础上继续完成如下需求：</p><p>​     每次抽的过程中，不打印，抽完时一次性打印(随机)</p><p>​     在此次抽奖过程中，抽奖箱1总共产生了6个奖项。</p><p>​              分别为：10,20,100,500,2,300最高奖项为300元，总计额为932元</p><p>​     在此次抽奖过程中，抽奖箱2总共产生了6个奖项。</p><p>​              分别为：5,50,200,800,80,700最高奖项为800元，总计额为1835元</p><p>解决方案一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;Integer&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(ArrayList&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程一</span></span><br><span class="line">    <span class="keyword">static</span> ArrayList&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//线程二</span></span><br><span class="line">    <span class="keyword">static</span> ArrayList&lt;Integer&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (MyThread.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (list.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="string">&quot;抽奖箱1&quot;</span>.equals(getName()))&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;抽奖箱1&quot;</span> + list1);</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;抽奖箱2&quot;</span> + list2);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//继续抽奖</span></span><br><span class="line">                    Collections.shuffle(list);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">prize</span> <span class="operator">=</span> list.remove(<span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span>(<span class="string">&quot;抽奖箱1&quot;</span>.equals(getName()))&#123;</span><br><span class="line">                        list1.add(prize);</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        list2.add(prize);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            有一个抽奖池,该抽奖池中存放了奖励的金额,该抽奖池中的奖项为 &#123;10,5,20,50,100,200,500,800,2,80,300,700&#125;;</span></span><br><span class="line"><span class="comment">            创建两个抽奖箱(线程)设置线程名称分别为“抽奖箱1”，“抽奖箱2”</span></span><br><span class="line"><span class="comment">            随机从抽奖池中获取奖项元素并打印在控制台上,格式如下:</span></span><br><span class="line"><span class="comment">            每次抽的过程中，不打印，抽完时一次性打印(随机)    在此次抽奖过程中，抽奖箱1总共产生了6个奖项。</span></span><br><span class="line"><span class="comment">                分别为：10,20,100,500,2,300最高奖项为300元，总计额为932元</span></span><br><span class="line"><span class="comment">            在此次抽奖过程中，抽奖箱2总共产生了6个奖项。</span></span><br><span class="line"><span class="comment">                分别为：5,50,200,800,80,700最高奖项为800元，总计额为1835元</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建奖池</span></span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list,<span class="number">10</span>,<span class="number">5</span>,<span class="number">20</span>,<span class="number">50</span>,<span class="number">100</span>,<span class="number">200</span>,<span class="number">500</span>,<span class="number">800</span>,<span class="number">2</span>,<span class="number">80</span>,<span class="number">300</span>,<span class="number">700</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建线程</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(list);</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置名字</span></span><br><span class="line">        t1.setName(<span class="string">&quot;抽奖箱1&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;抽奖箱2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>解决方案二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;Integer&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(ArrayList&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; boxList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//1 //2</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (MyThread.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (list.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(getName() + boxList);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//继续抽奖</span></span><br><span class="line">                    Collections.shuffle(list);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">prize</span> <span class="operator">=</span> list.remove(<span class="number">0</span>);</span><br><span class="line">                    boxList.add(prize);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            有一个抽奖池,该抽奖池中存放了奖励的金额,该抽奖池中的奖项为 &#123;10,5,20,50,100,200,500,800,2,80,300,700&#125;;</span></span><br><span class="line"><span class="comment">            创建两个抽奖箱(线程)设置线程名称分别为“抽奖箱1”，“抽奖箱2”</span></span><br><span class="line"><span class="comment">            随机从抽奖池中获取奖项元素并打印在控制台上,格式如下:</span></span><br><span class="line"><span class="comment">            每次抽的过程中，不打印，抽完时一次性打印(随机)    在此次抽奖过程中，抽奖箱1总共产生了6个奖项。</span></span><br><span class="line"><span class="comment">                分别为：10,20,100,500,2,300最高奖项为300元，总计额为932元</span></span><br><span class="line"><span class="comment">            在此次抽奖过程中，抽奖箱2总共产生了6个奖项。</span></span><br><span class="line"><span class="comment">                分别为：5,50,200,800,80,700最高奖项为800元，总计额为1835元</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建奖池</span></span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list,<span class="number">10</span>,<span class="number">5</span>,<span class="number">20</span>,<span class="number">50</span>,<span class="number">100</span>,<span class="number">200</span>,<span class="number">500</span>,<span class="number">800</span>,<span class="number">2</span>,<span class="number">80</span>,<span class="number">300</span>,<span class="number">700</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建线程</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(list);</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(list);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置名字</span></span><br><span class="line">        t1.setName(<span class="string">&quot;抽奖箱1&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;抽奖箱2&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习七：多线程之间的比较"><a href="#练习七：多线程之间的比较" class="headerlink" title="练习七：多线程之间的比较"></a>练习七：多线程之间的比较</h3><p>需求：</p><p>​在上一题基础上继续完成如下需求：</p><p>​在此次抽奖过程中，抽奖箱1总共产生了6个奖项，分别为：10,20,100,500,2,300</p><pre><code>  最高奖项为300元，总计额为932元</code></pre><p>​在此次抽奖过程中，抽奖箱2总共产生了6个奖项，分别为：5,50,200,800,80,700</p><pre><code>  最高奖项为800元，总计额为1835元</code></pre><p>​在此次抽奖过程中,抽奖箱2中产生了最大奖项,该奖项金额为800元</p><p>​以上打印效果只是数据模拟,实际代码运行的效果会有差异</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;Integer&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyCallable</span><span class="params">(ArrayList&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; boxList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//1 //2</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (MyCallable.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (list.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + boxList);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//继续抽奖</span></span><br><span class="line">                    Collections.shuffle(list);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">prize</span> <span class="operator">=</span> list.remove(<span class="number">0</span>);</span><br><span class="line">                    boxList.add(prize);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把集合中的最大值返回</span></span><br><span class="line">        <span class="keyword">if</span>(boxList.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.max(boxList);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.itheima.test7;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            有一个抽奖池,该抽奖池中存放了奖励的金额,该抽奖池中的奖项为 &#123;10,5,20,50,100,200,500,800,2,80,300,700&#125;;</span></span><br><span class="line"><span class="comment">            创建两个抽奖箱(线程)设置线程名称分别为    &quot;抽奖箱1&quot;, &quot;抽奖箱2&quot;</span></span><br><span class="line"><span class="comment">            随机从抽奖池中获取奖项元素并打印在控制台上,格式如下:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            在此次抽奖过程中，抽奖箱1总共产生了6个奖项，分别为：10,20,100,500,2,300</span></span><br><span class="line"><span class="comment">            最高奖项为300元，总计额为932元</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            在此次抽奖过程中，抽奖箱2总共产生了6个奖项，分别为：5,50,200,800,80,700</span></span><br><span class="line"><span class="comment">            最高奖项为800元，总计额为1835元</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            在此次抽奖过程中,抽奖箱2中产生了最大奖项,该奖项金额为800元</span></span><br><span class="line"><span class="comment">            核心逻辑：获取线程抽奖的最大值（看成是线程运行的结果）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            以上打印效果只是数据模拟,实际代码运行的效果会有差异</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建奖池</span></span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list,<span class="number">10</span>,<span class="number">5</span>,<span class="number">20</span>,<span class="number">50</span>,<span class="number">100</span>,<span class="number">200</span>,<span class="number">500</span>,<span class="number">800</span>,<span class="number">2</span>,<span class="number">80</span>,<span class="number">300</span>,<span class="number">700</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建多线程要运行的参数对象</span></span><br><span class="line">        <span class="type">MyCallable</span> <span class="variable">mc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCallable</span>(list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建多线程运行结果的管理者对象</span></span><br><span class="line">        <span class="comment">//线程一</span></span><br><span class="line">        FutureTask&lt;Integer&gt; ft1 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(mc);</span><br><span class="line">        <span class="comment">//线程二</span></span><br><span class="line">        FutureTask&lt;Integer&gt; ft2 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(mc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ft1);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ft2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置名字</span></span><br><span class="line">        t1.setName(<span class="string">&quot;抽奖箱1&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;抽奖箱2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开启线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">max1</span> <span class="operator">=</span> ft1.get();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">max2</span> <span class="operator">=</span> ft2.get();</span><br><span class="line"></span><br><span class="line">        System.out.println(max1);</span><br><span class="line">        System.out.println(max2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在此次抽奖过程中,抽奖箱2中产生了最大奖项,该奖项金额为800元</span></span><br><span class="line">        <span class="keyword">if</span>(max1 == <span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;在此次抽奖过程中,抽奖箱2中产生了最大奖项,该奖项金额为&quot;</span>+max2+<span class="string">&quot;元&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(max2 == <span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;在此次抽奖过程中,抽奖箱1中产生了最大奖项,该奖项金额为&quot;</span>+max1+<span class="string">&quot;元&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(max1 &gt; max2)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;在此次抽奖过程中,抽奖箱1中产生了最大奖项,该奖项金额为&quot;</span>+max1+<span class="string">&quot;元&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(max1 &lt; max2)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;在此次抽奖过程中,抽奖箱2中产生了最大奖项,该奖项金额为&quot;</span>+max2+<span class="string">&quot;元&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;两者的最大奖项是一样的&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-原子性"><a href="#2-原子性" class="headerlink" title="2. 原子性"></a>2. 原子性</h2><h3 id="2-1-volatile-问题"><a href="#2-1-volatile-问题" class="headerlink" title="2.1 volatile-问题"></a>2.1 volatile-问题</h3><p><strong>代码分析 :</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.myvolatile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread1</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread1</span>();</span><br><span class="line">        t1.setName(<span class="string">&quot;小路同学&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">MyThread2</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread2</span>();</span><br><span class="line">        t2.setName(<span class="string">&quot;小皮同学&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.myvolatile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Money</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> <span class="number">100000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.myvolatile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread1</span> <span class="keyword">extends</span>  <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(Money.money == <span class="number">100000</span>)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;结婚基金已经不是十万了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.myvolatile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread2</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Money.money = <span class="number">90000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>程序问题 :</strong>  女孩虽然知道结婚基金是十万，但是当基金的余额发生变化的时候，女孩无法知道最新的余额。</p><h3 id="2-2-volatile解决"><a href="#2-2-volatile解决" class="headerlink" title="2.2 volatile解决"></a>2.2 volatile解决</h3><p><strong>以上案例出现的问题 :</strong></p><p>​当A线程修改了共享数据时，B线程没有及时获取到最新的值，如果还在使用原先的值，就会出现问题 </p><p>​1，堆内存是唯一的，每一个线程都有自己的线程栈。</p><p>​2 ，每一个线程在使用堆里面变量的时候，都会先拷贝一份到变量的副本中。</p><p>​3 ，在线程中，每一次使用是从变量的副本中获取的。</p><p><strong>Volatile关键字 :</strong> 强制线程每次在使用的时候，都会看一下共享区域最新的值</p><p><strong>代码实现 :</strong> <strong>使用volatile关键字解决</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.myvolatile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread1</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread1</span>();</span><br><span class="line">        t1.setName(<span class="string">&quot;小路同学&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">MyThread2</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread2</span>();</span><br><span class="line">        t2.setName(<span class="string">&quot;小皮同学&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.myvolatile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Money</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> <span class="number">100000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.myvolatile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread1</span> <span class="keyword">extends</span>  <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(Money.money == <span class="number">100000</span>)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;结婚基金已经不是十万了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.myvolatile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread2</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Money.money = <span class="number">90000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-3-synchronized解决"><a href="#2-3-synchronized解决" class="headerlink" title="2.3 synchronized解决"></a>2.3 synchronized解决</h3><p><strong>synchronized解决 :</strong> </p><p>​1 ，线程获得锁</p><p>​2 ，清空变量副本</p><p>​3 ，拷贝共享变量最新的值到变量副本中</p><p>​4 ，执行代码</p><p>​5 ，将修改后变量副本中的值赋值给共享数据</p><p>​6 ，释放锁</p><p><strong>代码实现 :</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.myvolatile2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread1</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread1</span>();</span><br><span class="line">        t1.setName(<span class="string">&quot;小路同学&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">MyThread2</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread2</span>();</span><br><span class="line">        t2.setName(<span class="string">&quot;小皮同学&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.myvolatile2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Money</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> <span class="number">100000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.myvolatile2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread1</span> <span class="keyword">extends</span>  <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Money.lock)&#123;</span><br><span class="line">                <span class="keyword">if</span>(Money.money != <span class="number">100000</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;结婚基金已经不是十万了&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.myvolatile2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread2</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Money.lock) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Money.money = <span class="number">90000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-原子性"><a href="#2-4-原子性" class="headerlink" title="2.4 原子性"></a>2.4 原子性</h3><p><strong>概述 :</strong> 所谓的原子性是指在一次操作或者多次操作中，要么所有的操作全部都得到了执行并且不会受到任何因素的干扰而中断，要么所有的操作都不执行，多个操作是一个不可以分割的整体。</p><p><strong>代码实现 :</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.threadatom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyAtomThread</span> <span class="variable">atom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyAtomThread</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(atom).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAtomThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//送冰淇淋的数量</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//1,从共享数据中读取数据到本线程栈中.</span></span><br><span class="line">            <span class="comment">//2,修改本线程栈中变量副本的值</span></span><br><span class="line">            <span class="comment">//3,会把本线程栈中变量副本的值赋值给共享数据.</span></span><br><span class="line">            count++;</span><br><span class="line">            System.out.println(<span class="string">&quot;已经送了&quot;</span> + count + <span class="string">&quot;个冰淇淋&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码总结 :</strong> count++ 不是一个原子性操作, 他在执行的过程中,有可能被其他线程打断</p><h3 id="2-5-volatile关键字不能保证原子性"><a href="#2-5-volatile关键字不能保证原子性" class="headerlink" title="2.5 volatile关键字不能保证原子性"></a>2.5 volatile关键字不能保证原子性</h3><p>解决方案 : 我们可以给count++操作添加锁，那么count++操作就是临界区中的代码，临界区中的代码一次只能被一个线程去执行，所以count++就变成了原子操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.threadatom2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyAtomThread</span> <span class="variable">atom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyAtomThread</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(atom).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAtomThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//送冰淇淋的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//1,从共享数据中读取数据到本线程栈中.</span></span><br><span class="line">            <span class="comment">//2,修改本线程栈中变量副本的值</span></span><br><span class="line">            <span class="comment">//3,会把本线程栈中变量副本的值赋值给共享数据.</span></span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                System.out.println(<span class="string">&quot;已经送了&quot;</span> + count + <span class="string">&quot;个冰淇淋&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-原子性-AtomicInteger"><a href="#2-6-原子性-AtomicInteger" class="headerlink" title="2.6 原子性_AtomicInteger"></a>2.6 原子性_AtomicInteger</h3><p>概述：java从JDK1.5开始提供了java.util.concurrent.atomic包(简称Atomic包)，这个包中的原子操作类提供了一种用法简单，性能高效，线程安全地更新一个变量的方式。因为变</p><p>量的类型有很多种，所以在Atomic包里一共提供了13个类，属于4种类型的原子更新方式，分别是原子更新基本类型、原子更新数组、原子更新引用和原子更新属性(字段)。本次我们只讲解</p><p>使用原子的方式更新基本类型，使用原子的方式更新基本类型Atomic包提供了以下3个类：</p><p>AtomicBoolean： 原子更新布尔类型</p><p>AtomicInteger：   原子更新整型</p><p>AtomicLong：原子更新长整型</p><p>以上3个类提供的方法几乎一模一样，所以本节仅以AtomicInteger为例进行讲解，AtomicInteger的常用方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">AtomicInteger</span><span class="params">()</span>：       初始化一个默认值为<span class="number">0</span>的原子型Integer</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">AtomicInteger</span><span class="params">(<span class="type">int</span> initialValue)</span>：  初始化一个指定值的原子型Integer</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">get</span><span class="params">()</span>:    获取值</span><br><span class="line"><span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span>:       以原子方式将当前值加<span class="number">1</span>，注意，这里返回的是自增前的值。</span><br><span class="line"><span class="type">int</span> <span class="title function_">incrementAndGet</span><span class="params">()</span>:      以原子方式将当前值加<span class="number">1</span>，注意，这里返回的是自增后的值。</span><br><span class="line"><span class="type">int</span> <span class="title function_">addAndGet</span><span class="params">(<span class="type">int</span> data)</span>: 以原子方式将输入的数值与实例中的值（AtomicInteger里的value）相加，并返回结果。</span><br><span class="line"><span class="type">int</span> <span class="title function_">getAndSet</span><span class="params">(<span class="type">int</span> value)</span>:    以原子方式设置为newValue的值，并返回旧值。</span><br></pre></td></tr></table></figure><p><strong>代码实现 :</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.threadatom3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAtomIntergerDemo1</span> &#123;</span><br><span class="line"><span class="comment">//    public AtomicInteger()：               初始化一个默认值为0的原子型Integer</span></span><br><span class="line"><span class="comment">//    public AtomicInteger(int initialValue)： 初始化一个指定值的原子型Integer</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">        System.out.println(ac);</span><br><span class="line"></span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">ac2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">10</span>);</span><br><span class="line">        System.out.println(ac2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.threadatom3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAtomIntergerDemo2</span> &#123;</span><br><span class="line"><span class="comment">//    int get():    获取值</span></span><br><span class="line"><span class="comment">//    int getAndIncrement():     以原子方式将当前值加1，注意，这里返回的是自增前的值。</span></span><br><span class="line"><span class="comment">//    int incrementAndGet():     以原子方式将当前值加1，注意，这里返回的是自增后的值。</span></span><br><span class="line"><span class="comment">//    int addAndGet(int data): 以原子方式将参数与对象中的值相加，并返回结果。</span></span><br><span class="line"><span class="comment">//    int getAndSet(int value):  以原子方式设置为newValue的值，并返回旧值。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        AtomicInteger ac1 = new AtomicInteger(10);</span></span><br><span class="line"><span class="comment">//        System.out.println(ac1.get());</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        AtomicInteger ac2 = new AtomicInteger(10);</span></span><br><span class="line"><span class="comment">//        int andIncrement = ac2.getAndIncrement();</span></span><br><span class="line"><span class="comment">//        System.out.println(andIncrement);</span></span><br><span class="line"><span class="comment">//        System.out.println(ac2.get());</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        AtomicInteger ac3 = new AtomicInteger(10);</span></span><br><span class="line"><span class="comment">//        int i = ac3.incrementAndGet();</span></span><br><span class="line"><span class="comment">//        System.out.println(i);//自增后的值</span></span><br><span class="line"><span class="comment">//        System.out.println(ac3.get());</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        AtomicInteger ac4 = new AtomicInteger(10);</span></span><br><span class="line"><span class="comment">//        int i = ac4.addAndGet(20);</span></span><br><span class="line"><span class="comment">//        System.out.println(i);</span></span><br><span class="line"><span class="comment">//        System.out.println(ac4.get());</span></span><br><span class="line"></span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">ac5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">100</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">andSet</span> <span class="operator">=</span> ac5.getAndSet(<span class="number">20</span>);</span><br><span class="line">        System.out.println(andSet);</span><br><span class="line">        System.out.println(ac5.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-7-AtomicInteger-内存解析"><a href="#2-7-AtomicInteger-内存解析" class="headerlink" title="2.7 AtomicInteger-内存解析"></a>2.7 AtomicInteger-内存解析</h3><p><strong>AtomicInteger原理 :</strong> 自旋锁  + CAS 算法</p><p><strong>CAS算法：</strong></p><p>​有3个操作数（内存值V， 旧的预期值A，要修改的值B）</p><p>​当旧的预期值A &#x3D;&#x3D; 内存值   此时修改成功，将V改为B                 </p><p>​当旧的预期值A！&#x3D;内存值   此时修改失败，不做任何操作                 </p><p>​并重新获取现在的最新值（这个重新获取的动作就是自旋）</p><h3 id="2-8-AtomicInteger-源码解析"><a href="#2-8-AtomicInteger-源码解析" class="headerlink" title="2.8 AtomicInteger-源码解析"></a>2.8 AtomicInteger-源码解析</h3><p><strong>代码实现 :</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.threadatom4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyAtomThread</span> <span class="variable">atom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyAtomThread</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(atom).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.threadatom4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAtomThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">//private volatile int count = 0; //送冰淇淋的数量</span></span><br><span class="line">    <span class="comment">//private Object lock = new Object();</span></span><br><span class="line">    <span class="type">AtomicInteger</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//1,从共享数据中读取数据到本线程栈中.</span></span><br><span class="line">            <span class="comment">//2,修改本线程栈中变量副本的值</span></span><br><span class="line">            <span class="comment">//3,会把本线程栈中变量副本的值赋值给共享数据.</span></span><br><span class="line">            <span class="comment">//synchronized (lock) &#123;</span></span><br><span class="line"><span class="comment">//                count++;</span></span><br><span class="line"><span class="comment">//                ac++;</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> ac.incrementAndGet();</span><br><span class="line">            System.out.println(<span class="string">&quot;已经送了&quot;</span> + count + <span class="string">&quot;个冰淇淋&quot;</span>);</span><br><span class="line">           <span class="comment">// &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>源码解析 :</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先自增，然后获取自增后的结果</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">incrementAndGet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//+ 1 自增后的结果</span></span><br><span class="line">        <span class="comment">//this 就表示当前的atomicInteger（值）</span></span><br><span class="line">        <span class="comment">//1    自增一次</span></span><br><span class="line">        <span class="keyword">return</span> U.getAndAddInt(<span class="built_in">this</span>, VALUE, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAddInt</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">int</span> delta)</span> &#123;</span><br><span class="line">        <span class="comment">//v 旧值</span></span><br><span class="line">        <span class="type">int</span> v;</span><br><span class="line">        <span class="comment">//自旋的过程</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">//不断的获取旧值</span></span><br><span class="line">            v = getIntVolatile(o, offset);</span><br><span class="line">            <span class="comment">//如果这个方法的返回值为false，那么继续自旋</span></span><br><span class="line">            <span class="comment">//如果这个方法的返回值为true，那么自旋结束</span></span><br><span class="line">            <span class="comment">//o 表示的就是内存值</span></span><br><span class="line">            <span class="comment">//v 旧值</span></span><br><span class="line">            <span class="comment">//v + delta 修改后的值</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (!weakCompareAndSetInt(o, offset, v, v + delta));</span><br><span class="line">            <span class="comment">//作用：比较内存中的值，旧值是否相等，如果相等就把修改后的值写到内存中，返回true。表示修改成功。</span></span><br><span class="line">            <span class="comment">//                                 如果不相等，无法把修改后的值写到内存中，返回false。表示修改失败。</span></span><br><span class="line">            <span class="comment">//如果修改失败，那么继续自旋。</span></span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-9-悲观锁和乐观锁"><a href="#2-9-悲观锁和乐观锁" class="headerlink" title="2.9 悲观锁和乐观锁"></a>2.9 悲观锁和乐观锁</h3><p><strong>synchronized和CAS的区别 :</strong> </p><p><strong>相同点：</strong>在多线程情况下，都可以保证共享数据的安全性。</p><p><strong>不同点：</strong>synchronized总是从最坏的角度出发，认为每次获取数据的时候，别人都有可能修改。所以在每                       次操作共享数据之前，都会上锁。（悲观锁）</p><p>​cas是从乐观的角度出发，假设每次获取数据别人都不会修改，所以不会上锁。只不过在修改共享数据的时候，会检查一下，别人有没有修改过这个数据。</p><p>​如果别人修改过，那么我再次获取现在最新的值。            </p><p>​ 如果别人没有修改过，那么我现在直接修改共享数据的值.(乐观锁）</p><h2 id="3-并发工具类"><a href="#3-并发工具类" class="headerlink" title="3. 并发工具类"></a>3. 并发工具类</h2><h3 id="3-1-并发工具类-Hashtable"><a href="#3-1-并发工具类-Hashtable" class="headerlink" title="3.1 并发工具类-Hashtable"></a>3.1 并发工具类-Hashtable</h3><p>​<strong>Hashtable出现的原因 :</strong> 在集合类中HashMap是比较常用的集合对象，但是HashMap是线程不安全的(多线程环境下可能会存在问题)。为了保证数据的安全性我们可以使用Hashtable，但是Hashtable的效率低下。</p><p><strong>代码实现 :</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mymap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyHashtableDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Hashtable&lt;String, String&gt; hm = <span class="keyword">new</span> <span class="title class_">Hashtable</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">25</span>; i++) &#123;</span><br><span class="line">                hm.put(i + <span class="string">&quot;&quot;</span>, i + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">25</span>; i &lt; <span class="number">51</span>; i++) &#123;</span><br><span class="line">                hm.put(i + <span class="string">&quot;&quot;</span>, i + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------&quot;</span>);</span><br><span class="line">        <span class="comment">//为了t1和t2能把数据全部添加完毕</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//0-0 1-1 ..... 50- 50</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">51</span>; i++) &#123;</span><br><span class="line">            System.out.println(hm.get(i + <span class="string">&quot;&quot;</span>));</span><br><span class="line">        &#125;<span class="comment">//0 1 2 3 .... 50</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-并发工具类-ConcurrentHashMap基本使用"><a href="#3-2-并发工具类-ConcurrentHashMap基本使用" class="headerlink" title="3.2 并发工具类-ConcurrentHashMap基本使用"></a>3.2 并发工具类-ConcurrentHashMap基本使用</h3><p>​<strong>ConcurrentHashMap出现的原因 :</strong> 在集合类中HashMap是比较常用的集合对象，但是HashMap是线程不安全的(多线程环境下可能会存在问题)。为了保证数据的安全性我们可以使用Hashtable，但是Hashtable的效率低下。</p><p>基于以上两个原因我们可以使用JDK1.5以后所提供的ConcurrentHashMap。</p><p><strong>体系结构 :</strong> </p><p><img src="/JavaNotes/%E5%A4%9A%E7%BA%BF%E7%A8%8B&juc/img/1591168965857.png" alt="1591168965857"></p><p><strong>总结 :</strong> </p><p>​1 ，HashMap是线程不安全的。多线程环境下会有数据安全问题</p><p>​2 ，Hashtable是线程安全的，但是会将整张表锁起来，效率低下</p><p>​3，ConcurrentHashMap也是线程安全的，效率较高。     在JDK7和JDK8中，底层原理不一样。</p><p><strong>代码实现 :</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mymap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConcurrentHashMapDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        ConcurrentHashMap&lt;String, String&gt; hm = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">25</span>; i++) &#123;</span><br><span class="line">                hm.put(i + <span class="string">&quot;&quot;</span>, i + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">25</span>; i &lt; <span class="number">51</span>; i++) &#123;</span><br><span class="line">                hm.put(i + <span class="string">&quot;&quot;</span>, i + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------&quot;</span>);</span><br><span class="line">        <span class="comment">//为了t1和t2能把数据全部添加完毕</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//0-0 1-1 ..... 50- 50</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">51</span>; i++) &#123;</span><br><span class="line">            System.out.println(hm.get(i + <span class="string">&quot;&quot;</span>));</span><br><span class="line">        &#125;<span class="comment">//0 1 2 3 .... 50</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-并发工具类-ConcurrentHashMap1-7原理"><a href="#3-3-并发工具类-ConcurrentHashMap1-7原理" class="headerlink" title="3.3 并发工具类-ConcurrentHashMap1.7原理"></a>3.3 并发工具类-ConcurrentHashMap1.7原理</h3><p><img src="/JavaNotes/%E5%A4%9A%E7%BA%BF%E7%A8%8B&juc/img/1591169254280.png" alt="1591169254280"></p><h3 id="3-4-并发工具类-ConcurrentHashMap1-8原理"><a href="#3-4-并发工具类-ConcurrentHashMap1-8原理" class="headerlink" title="3.4 并发工具类-ConcurrentHashMap1.8原理"></a>3.4 并发工具类-ConcurrentHashMap1.8原理</h3><p><img src="/JavaNotes/%E5%A4%9A%E7%BA%BF%E7%A8%8B&juc/img/1591169338256.png" alt="1591169338256"></p><p><strong>总结 :</strong> </p><p>​1，如果使用空参构造创建ConcurrentHashMap对象，则什么事情都不做。     在第一次添加元素的时候创建哈希表</p><p>​2，计算当前元素应存入的索引。</p><p>​3，如果该索引位置为null，则利用cas算法，将本结点添加到数组中。</p><p>​4，如果该索引位置不为null，则利用volatile关键字获得当前位置最新的结点地址，挂在他下面，变成链表。</p><p>​5，当链表的长度大于等于8时，自动转换成红黑树6，以链表或者红黑树头结点为锁对象，配合悲观锁保证多线程操作集合时数据的安全性</p><h3 id="3-5-并发工具类-CountDownLatch"><a href="#3-5-并发工具类-CountDownLatch" class="headerlink" title="3.5 并发工具类-CountDownLatch"></a>3.5 并发工具类-CountDownLatch</h3><p><strong>CountDownLatch类 :</strong> </p><table><thead><tr><th>方法</th><th>解释</th></tr></thead><tbody><tr><td>public CountDownLatch(int count)</td><td>参数传递线程数，表示等待线程数量</td></tr><tr><td>public void await()</td><td>让线程等待</td></tr><tr><td>public void countDown()</td><td>当前线程执行完毕</td></tr></tbody></table><p><strong>使用场景：</strong> 让某一条线程等待其他线程执行完毕之后再执行</p><p><strong>代码实现 :</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mycountdownlatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChileThread1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CountDownLatch countDownLatch;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ChileThread1</span><span class="params">(CountDownLatch countDownLatch)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.countDownLatch = countDownLatch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1.吃饺子</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot;在吃第&quot;</span> + i + <span class="string">&quot;个饺子&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.吃完说一声</span></span><br><span class="line">        <span class="comment">//每一次countDown方法的时候，就让计数器-1</span></span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mycountdownlatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChileThread2</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CountDownLatch countDownLatch;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ChileThread2</span><span class="params">(CountDownLatch countDownLatch)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.countDownLatch = countDownLatch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1.吃饺子</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">15</span>; i++) &#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot;在吃第&quot;</span> + i + <span class="string">&quot;个饺子&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.吃完说一声</span></span><br><span class="line">        <span class="comment">//每一次countDown方法的时候，就让计数器-1</span></span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mycountdownlatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChileThread3</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CountDownLatch countDownLatch;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ChileThread3</span><span class="params">(CountDownLatch countDownLatch)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.countDownLatch = countDownLatch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1.吃饺子</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot;在吃第&quot;</span> + i + <span class="string">&quot;个饺子&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.吃完说一声</span></span><br><span class="line">        <span class="comment">//每一次countDown方法的时候，就让计数器-1</span></span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mycountdownlatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MotherThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch countDownLatch;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MotherThread</span><span class="params">(CountDownLatch countDownLatch)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.countDownLatch = countDownLatch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1.等待</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//当计数器变成0的时候，会自动唤醒这里等待的线程。</span></span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.收拾碗筷</span></span><br><span class="line">        System.out.println(<span class="string">&quot;妈妈在收拾碗筷&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mycountdownlatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCountDownLatchDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建CountDownLatch的对象，需要传递给四个线程。</span></span><br><span class="line">        <span class="comment">//在底层就定义了一个计数器，此时计数器的值就是3</span></span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//2.创建四个线程对象并开启他们。</span></span><br><span class="line">        <span class="type">MotherThread</span> <span class="variable">motherThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MotherThread</span>(countDownLatch);</span><br><span class="line">        motherThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">ChileThread1</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChileThread1</span>(countDownLatch);</span><br><span class="line">        t1.setName(<span class="string">&quot;小明&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">ChileThread2</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChileThread2</span>(countDownLatch);</span><br><span class="line">        t2.setName(<span class="string">&quot;小红&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">ChileThread3</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChileThread3</span>(countDownLatch);</span><br><span class="line">        t3.setName(<span class="string">&quot;小刚&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结 :</strong> </p><p>​1. CountDownLatch(int count)：参数写等待线程的数量。并定义了一个计数器。</p><p>​2. await()：让线程等待，当计数器为0时，会唤醒等待的线程</p><p>​3. countDown()： 线程执行完毕时调用，会将计数器-1。</p><h3 id="3-6-并发工具类-Semaphore"><a href="#3-6-并发工具类-Semaphore" class="headerlink" title="3.6 并发工具类-Semaphore"></a>3.6 并发工具类-Semaphore</h3><p><strong>使用场景 :</strong> </p><p>​可以控制访问特定资源的线程数量。</p><p><strong>实现步骤 :</strong> </p><p>​1，需要有人管理这个通道</p><p>​2，当有车进来了，发通行许可证</p><p>​3，当车出去了，收回通行许可证</p><p>​4，如果通行许可证发完了，那么其他车辆只能等着</p><p><strong>代码实现 :</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mysemaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">//1.获得管理员对象，</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//2.获得通行证</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            semaphore.acquire();</span><br><span class="line">            <span class="comment">//3.开始行驶</span></span><br><span class="line">            System.out.println(<span class="string">&quot;获得了通行证开始行驶&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;归还通行证&quot;</span>);</span><br><span class="line">            <span class="comment">//4.归还通行证</span></span><br><span class="line">            semaphore.release();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mysemaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySemaphoreDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyRunnable</span> <span class="variable">mr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(mr).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识多线程</title>
      <link href="/posts/7da19302.html"/>
      <url>/posts/7da19302.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-实现多线程"><a href="#1-实现多线程" class="headerlink" title="1.实现多线程"></a>1.实现多线程</h2><h3 id="1-1简单了解多线程【理解】"><a href="#1-1简单了解多线程【理解】" class="headerlink" title="1.1简单了解多线程【理解】"></a>1.1简单了解多线程【理解】</h3><p>是指从软件或者硬件上实现多个线程并发执行的技术。<br>具有多线程能力的计算机因有硬件支持而能够在同一时间执行多个线程，提升性能。</p><p><img src="/JavaNotes/%E5%A4%9A%E7%BA%BF%E7%A8%8B/img/01_%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B.png" alt="01_简单了解多线程"></p><h3 id="1-2并发和并行【理解】"><a href="#1-2并发和并行【理解】" class="headerlink" title="1.2并发和并行【理解】"></a>1.2并发和并行【理解】</h3><ul><li><p>并行：在同一时刻，有多个指令在多个CPU上同时执行。</p><p><img src="/JavaNotes/%E5%A4%9A%E7%BA%BF%E7%A8%8B/img/02_%E5%B9%B6%E8%A1%8C.png" alt="02_并行"></p></li><li><p>并发：在同一时刻，有多个指令在单个CPU上交替执行。</p><p><img src="/JavaNotes/%E5%A4%9A%E7%BA%BF%E7%A8%8B/img/03_%E5%B9%B6%E5%8F%91.png" alt="03_并发"></p></li></ul><h3 id="1-3进程和线程【理解】"><a href="#1-3进程和线程【理解】" class="headerlink" title="1.3进程和线程【理解】"></a>1.3进程和线程【理解】</h3><ul><li><p>进程：是正在运行的程序</p><p>独立性：进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位<br>动态性：进程的实质是程序的一次执行过程，进程是动态产生，动态消亡的<br>并发性：任何进程都可以同其他进程一起并发执行</p></li><li><p>线程：是进程中的单个顺序控制流，是一条执行路径</p><p>​单线程：一个进程如果只有一条执行路径，则称为单线程程序</p><p>​多线程：一个进程如果有多条执行路径，则称为多线程程序</p><p>​<img src="/JavaNotes/%E5%A4%9A%E7%BA%BF%E7%A8%8B/img/04_%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%A4%BA%E4%BE%8B.png" alt="04_多线程示例"></p></li></ul><h3 id="1-4实现多线程方式一：继承Thread类【应用】"><a href="#1-4实现多线程方式一：继承Thread类【应用】" class="headerlink" title="1.4实现多线程方式一：继承Thread类【应用】"></a>1.4实现多线程方式一：继承Thread类【应用】</h3><ul><li><p>方法介绍</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>void run()</td><td>在线程开启后，此方法将被调用执行</td></tr><tr><td>void start()</td><td>使此线程开始执行，Java虚拟机会调用run方法()</td></tr></tbody></table></li><li><p>实现步骤</p><ul><li>定义一个类MyThread继承Thread类</li><li>在MyThread类中重写run()方法</li><li>创建MyThread类的对象</li><li>启动线程</li></ul></li><li><p>代码演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">my1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">my2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        my1.run();</span></span><br><span class="line"><span class="comment">//        my2.run();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//void start() 导致此线程开始执行; Java虚拟机调用此线程的run方法</span></span><br><span class="line">        my1.start();</span><br><span class="line">        my2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>两个小问题</p><ul><li><p>为什么要重写run()方法？</p><p>因为run()是用来封装被线程执行的代码</p></li><li><p>run()方法和start()方法的区别？</p><p>run()：封装线程执行的代码，直接调用，相当于普通方法的调用</p><p>start()：启动线程；然后由JVM调用此线程的run()方法</p></li></ul></li></ul><h3 id="1-5实现多线程方式二：实现Runnable接口【应用】"><a href="#1-5实现多线程方式二：实现Runnable接口【应用】" class="headerlink" title="1.5实现多线程方式二：实现Runnable接口【应用】"></a>1.5实现多线程方式二：实现Runnable接口【应用】</h3><ul><li><p>Thread构造方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>Thread(Runnable target)</td><td>分配一个新的Thread对象</td></tr><tr><td>Thread(Runnable target, String name)</td><td>分配一个新的Thread对象</td></tr></tbody></table></li><li><p>实现步骤</p><ul><li>定义一个类MyRunnable实现Runnable接口</li><li>在MyRunnable类中重写run()方法</li><li>创建MyRunnable类的对象</li><li>创建Thread类的对象，把MyRunnable对象作为构造方法的参数</li><li>启动线程</li></ul></li><li><p>代码演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnableDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建MyRunnable类的对象</span></span><br><span class="line">        <span class="type">MyRunnable</span> <span class="variable">my</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Thread类的对象，把MyRunnable对象作为构造方法的参数</span></span><br><span class="line">        <span class="comment">//Thread(Runnable target)</span></span><br><span class="line"><span class="comment">//        Thread t1 = new Thread(my);</span></span><br><span class="line"><span class="comment">//        Thread t2 = new Thread(my);</span></span><br><span class="line">        <span class="comment">//Thread(Runnable target, String name)</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(my,<span class="string">&quot;坦克&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(my,<span class="string">&quot;飞机&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-6实现多线程方式三-实现Callable接口【应用】"><a href="#1-6实现多线程方式三-实现Callable接口【应用】" class="headerlink" title="1.6实现多线程方式三: 实现Callable接口【应用】"></a>1.6实现多线程方式三: 实现Callable接口【应用】</h3><ul><li><p>方法介绍</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>V call()</td><td>计算结果，如果无法计算结果，则抛出一个异常</td></tr><tr><td>FutureTask(Callable<V> callable)</td><td>创建一个 FutureTask，一旦运行就执行给定的 Callable</td></tr><tr><td>V get()</td><td>如有必要，等待计算完成，然后获取其结果</td></tr></tbody></table></li><li><p>实现步骤</p><ul><li>定义一个类MyCallable实现Callable接口</li><li>在MyCallable类中重写call()方法</li><li>创建MyCallable类的对象</li><li>创建Future的实现类FutureTask对象，把MyCallable对象作为构造方法的参数</li><li>创建Thread类的对象，把FutureTask对象作为构造方法的参数</li><li>启动线程</li><li>再调用get方法，就可以获取线程结束之后的结果。</li></ul></li><li><p>代码演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;跟女孩表白&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回值就表示线程运行完毕之后的结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;答应&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">//线程开启之后需要执行里面的call方法</span></span><br><span class="line">        <span class="type">MyCallable</span> <span class="variable">mc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCallable</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Thread t1 = new Thread(mc);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//可以获取线程执行完毕之后的结果.也可以作为参数传递给Thread对象</span></span><br><span class="line">        FutureTask&lt;String&gt; ft = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(mc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ft);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> ft.get();</span><br><span class="line">        <span class="comment">//开启线程</span></span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//String s = ft.get();</span></span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>三种实现方式的对比</p><ul><li>实现Runnable、Callable接口<ul><li>好处: 扩展性强，实现该接口的同时还可以继承其他的类</li><li>缺点: 编程相对复杂，不能直接使用Thread类中的方法</li></ul></li><li>继承Thread类<ul><li>好处: 编程比较简单，可以直接使用Thread类中的方法</li><li>缺点: 可以扩展性较差，不能再继承其他的类</li></ul></li></ul></li></ul><h3 id="1-7设置和获取线程名称【应用】"><a href="#1-7设置和获取线程名称【应用】" class="headerlink" title="1.7设置和获取线程名称【应用】"></a>1.7设置和获取线程名称【应用】</h3><ul><li><p>方法介绍</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>void  setName(String name)</td><td>将此线程的名称更改为等于参数name</td></tr><tr><td>String  getName()</td><td>返回此线程的名称</td></tr><tr><td>Thread  currentThread()</td><td>返回对当前正在执行的线程对象的引用</td></tr></tbody></table></li><li><p>代码演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">my1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">my2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//void setName(String name)：将此线程的名称更改为等于参数 name</span></span><br><span class="line">        my1.setName(<span class="string">&quot;高铁&quot;</span>);</span><br><span class="line">        my2.setName(<span class="string">&quot;飞机&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Thread(String name)</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">my1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;高铁&quot;</span>);</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">my2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;飞机&quot;</span>);</span><br><span class="line"></span><br><span class="line">        my1.start();</span><br><span class="line">        my2.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//static Thread currentThread() 返回对当前正在执行的线程对象的引用</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-8线程休眠【应用】"><a href="#1-8线程休眠【应用】" class="headerlink" title="1.8线程休眠【应用】"></a>1.8线程休眠【应用】</h3><ul><li><p>相关方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>static void sleep(long millis)</td><td>使当前正在执行的线程停留（暂停执行）指定的毫秒数</td></tr></tbody></table></li><li><p>代码演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">/*System.out.println(&quot;睡觉前&quot;);</span></span><br><span class="line"><span class="comment">        Thread.sleep(3000);</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;睡醒了&quot;);*/</span></span><br><span class="line"></span><br><span class="line">        <span class="type">MyRunnable</span> <span class="variable">mr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mr);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mr);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-9线程优先级【应用】"><a href="#1-9线程优先级【应用】" class="headerlink" title="1.9线程优先级【应用】"></a>1.9线程优先级【应用】</h3><ul><li><p>线程调度</p><ul><li><p>两种调度方式</p><ul><li>分时调度模型：所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间片</li><li>抢占式调度模型：优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的 CPU 时间片相对多一些</li></ul></li><li><p>Java使用的是抢占式调度模型</p></li><li><p>随机性</p><p>假如计算机只有一个 CPU，那么 CPU 在某一个时刻只能执行一条指令，线程只有得到CPU时间片，也就是使用权，才可以执行指令。所以说多线程程序的执行是有随机性，因为谁抢到CPU的使用权是不一定的</p><p><img src="/JavaNotes/%E5%A4%9A%E7%BA%BF%E7%A8%8B/img/05_%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%A4%BA%E4%BE%8B%E5%9B%BE.png" alt="05_多线程示例图"></p></li></ul></li><li><p>优先级相关方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>final int getPriority()</td><td>返回此线程的优先级</td></tr><tr><td>final void setPriority(int newPriority)</td><td>更改此线程的优先级线程默认优先级是5；线程优先级的范围是：1-10</td></tr></tbody></table></li><li><p>代码演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;线程执行完毕了&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//优先级: 1 - 10 默认值:5</span></span><br><span class="line">        <span class="type">MyCallable</span> <span class="variable">mc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCallable</span>();</span><br><span class="line"></span><br><span class="line">        FutureTask&lt;String&gt; ft = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(mc);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ft);</span><br><span class="line">        t1.setName(<span class="string">&quot;飞机&quot;</span>);</span><br><span class="line">        t1.setPriority(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//System.out.println(t1.getPriority());//5</span></span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">MyCallable</span> <span class="variable">mc2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCallable</span>();</span><br><span class="line"></span><br><span class="line">        FutureTask&lt;String&gt; ft2 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(mc2);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ft2);</span><br><span class="line">        t2.setName(<span class="string">&quot;坦克&quot;</span>);</span><br><span class="line">        t2.setPriority(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//System.out.println(t2.getPriority());//5</span></span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-10守护线程【应用】"><a href="#1-10守护线程【应用】" class="headerlink" title="1.10守护线程【应用】"></a>1.10守护线程【应用】</h3><ul><li><p>相关方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>void setDaemon(boolean on)</td><td>将此线程标记为守护线程，当运行的线程都是守护线程时，Java虚拟机将退出</td></tr></tbody></table></li><li><p>代码演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot;---&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread2</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot;---&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread1</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread1</span>();</span><br><span class="line">        <span class="type">MyThread2</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread2</span>();</span><br><span class="line"></span><br><span class="line">        t1.setName(<span class="string">&quot;女神&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;备胎&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把第二个线程设置为守护线程</span></span><br><span class="line">        <span class="comment">//当普通线程执行完之后,那么守护线程也没有继续运行下去的必要了.</span></span><br><span class="line">        t2.setDaemon(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-线程同步"><a href="#2-线程同步" class="headerlink" title="2.线程同步"></a>2.线程同步</h2><h3 id="2-1卖票【应用】"><a href="#2-1卖票【应用】" class="headerlink" title="2.1卖票【应用】"></a>2.1卖票【应用】</h3><ul><li><p>案例需求</p><p>某电影院目前正在上映国产大片，共有100张票，而它有3个窗口卖票，请设计一个程序模拟该电影院卖票</p></li><li><p>实现步骤</p><ul><li><p>定义一个类SellTicket实现Runnable接口，里面定义一个成员变量：private int tickets &#x3D; 100;</p></li><li><p>在SellTicket类中重写run()方法实现卖票，代码步骤如下</p></li><li><p>判断票数大于0，就卖票，并告知是哪个窗口卖的</p></li><li><p>卖了票之后，总票数要减1</p></li><li><p>票卖没了，线程停止</p></li><li><p>定义一个测试类SellTicketDemo，里面有main方法，代码步骤如下</p></li><li><p>创建SellTicket类的对象</p></li><li><p>创建三个Thread类的对象，把SellTicket对象作为构造方法的参数，并给出对应的窗口名称</p></li><li><p>启动线程</p></li></ul></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTicket</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//在SellTicket类中重写run()方法实现卖票，代码步骤如下</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ticket &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//卖完了</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    ticket--;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;在卖票,还剩下&quot;</span> + ticket + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTicketDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建SellTicket类的对象</span></span><br><span class="line">        <span class="type">SellTicket</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SellTicket</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建三个Thread类的对象，把SellTicket对象作为构造方法的参数，并给出对应的窗口名称</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(st,<span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(st,<span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(st,<span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-2卖票案例的问题【理解】"><a href="#2-2卖票案例的问题【理解】" class="headerlink" title="2.2卖票案例的问题【理解】"></a>2.2卖票案例的问题【理解】</h3><ul><li><p>卖票出现了问题</p><ul><li><p>相同的票出现了多次</p></li><li><p>出现了负数的票</p></li></ul></li><li><p>问题产生原因</p><p>线程执行的随机性导致的,可能在卖票过程中丢失cpu的执行权,导致出现问题</p></li></ul><h3 id="2-3同步代码块解决数据安全问题【应用】"><a href="#2-3同步代码块解决数据安全问题【应用】" class="headerlink" title="2.3同步代码块解决数据安全问题【应用】"></a>2.3同步代码块解决数据安全问题【应用】</h3><ul><li><p>安全问题出现的条件</p><ul><li><p>是多线程环境</p></li><li><p>有共享数据</p></li><li><p>有多条语句操作共享数据</p></li></ul></li><li><p>如何解决多线程安全问题呢?</p><ul><li>基本思想：让程序没有安全问题的环境</li></ul></li><li><p>怎么实现呢?</p><ul><li><p>把多条语句操作共享数据的代码给锁起来，让任意时刻只能有一个线程执行即可</p></li><li><p>Java提供了同步代码块的方式来解决</p></li></ul></li><li><p>同步代码块格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(任意对象) &#123; </span><br><span class="line">多条语句操作共享数据的代码 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>synchronized(任意对象)：就相当于给代码加锁了，任意对象就可以看成是一把锁</p></li><li><p>同步的好处和弊端  </p><ul><li><p>好处：解决了多线程的数据安全问题</p></li><li><p>弊端：当线程很多时，因为每个线程都会去判断同步上的锁，这是很耗费资源的，无形中会降低程序的运行效率</p></li></ul></li><li><p>代码演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTicket</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tickets</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj) &#123; <span class="comment">// 对可能有安全问题的代码加锁,多个线程必须使用同一把锁</span></span><br><span class="line">                <span class="comment">//t1进来后，就会把这段代码给锁起来</span></span><br><span class="line">                <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                        <span class="comment">//t1休息100毫秒</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//窗口1正在出售第100张票</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在出售第&quot;</span> + tickets + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                    tickets--; <span class="comment">//tickets = 99;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//t1出来了，这段代码的锁就被释放了</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTicketDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SellTicket</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SellTicket</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(st, <span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(st, <span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(st, <span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-4同步方法解决数据安全问题【应用】"><a href="#2-4同步方法解决数据安全问题【应用】" class="headerlink" title="2.4同步方法解决数据安全问题【应用】"></a>2.4同步方法解决数据安全问题【应用】</h3><ul><li><p>同步方法的格式</p><p>同步方法：就是把synchronized关键字加到方法上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="keyword">synchronized</span> 返回值类型 方法名(方法参数) &#123; </span><br><span class="line">方法体；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同步方法的锁对象是什么呢?</p><p>​this</p></li><li><p>静态同步方法</p><p>同步静态方法：就是把synchronized关键字加到静态方法上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="keyword">static</span> <span class="keyword">synchronized</span> 返回值类型 方法名(方法参数) &#123; </span><br><span class="line">方法体；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同步静态方法的锁对象是什么呢?</p><p>​类名.class</p></li><li><p>代码演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ticketCount</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;窗口一&quot;</span>.equals(Thread.currentThread().getName()))&#123;</span><br><span class="line">                <span class="comment">//同步方法</span></span><br><span class="line">                <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> synchronizedMthod();</span><br><span class="line">                <span class="keyword">if</span>(result)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;窗口二&quot;</span>.equals(Thread.currentThread().getName()))&#123;</span><br><span class="line">                <span class="comment">//同步代码块</span></span><br><span class="line">                <span class="keyword">synchronized</span> (MyRunnable.class)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(ticketCount == <span class="number">0</span>)&#123;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                        ticketCount--;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;在卖票,还剩下&quot;</span> + ticketCount + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">synchronizedMthod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(ticketCount == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            ticketCount--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;在卖票,还剩下&quot;</span> + ticketCount + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>public class Demo {<br>public static void main(String[] args) {<br>    MyRunnable mr &#x3D; new MyRunnable();<br><br>    Thread t1 &#x3D; new Thread(mr);<br>    Thread t2 &#x3D; new Thread(mr);<br><br>    t1.setName(“窗口一”);<br>    t2.setName(“窗口二”);<br><br>    t1.start();<br>    t2.start();<br>}<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">### 2.5Lock锁【应用】</span><br><span class="line"></span><br><span class="line">虽然我们可以理解同步代码块和同步方法的锁对象问题，但是我们并没有直接看到在哪里加上了锁，在哪里释放了锁，为了更清晰的表达如何加锁和释放锁，JDK5以后提供了一个新的锁对象Lock</span><br><span class="line"></span><br><span class="line">Lock是接口不能直接实例化，这里采用它的实现类ReentrantLock来实例化</span><br><span class="line"></span><br><span class="line">- ReentrantLock构造方法</span><br><span class="line"></span><br><span class="line">  | 方法名             | 说明                   |</span><br><span class="line">  | --------------- | -------------------- |</span><br><span class="line">  | ReentrantLock() | 创建一个ReentrantLock的实例 |</span><br><span class="line"></span><br><span class="line">- 加锁解锁方法</span><br><span class="line"></span><br><span class="line">  | 方法名           | 说明   |</span><br><span class="line">  | ------------- | ---- |</span><br><span class="line">  | void lock()   | 获得锁  |</span><br><span class="line">  | void unlock() | 释放锁  |</span><br><span class="line"></span><br><span class="line">- 代码演示</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  public class Ticket implements Runnable &#123;</span><br><span class="line">      //票的数量</span><br><span class="line">      private int ticket = 100;</span><br><span class="line">      private Object obj = new Object();</span><br><span class="line">      private ReentrantLock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">      @Override</span><br><span class="line">      public void run() &#123;</span><br><span class="line">          while (true) &#123;</span><br><span class="line">              //synchronized (obj)&#123;//多个线程必须使用同一把锁.</span><br><span class="line">              try &#123;</span><br><span class="line">                  lock.lock();</span><br><span class="line">                  if (ticket &lt;= 0) &#123;</span><br><span class="line">                      //卖完了</span><br><span class="line">                      break;</span><br><span class="line">                  &#125; else &#123;</span><br><span class="line">                      Thread.sleep(100);</span><br><span class="line">                      ticket--;</span><br><span class="line">                      System.out.println(Thread.currentThread().getName() + &quot;在卖票,还剩下&quot; + ticket + &quot;张票&quot;);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                  e.printStackTrace();</span><br><span class="line">              &#125; finally &#123;</span><br><span class="line">                  lock.unlock();</span><br><span class="line">              &#125;</span><br><span class="line">              // &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public class Demo &#123;</span><br><span class="line">      public static void main(String[] args) &#123;</span><br><span class="line">          Ticket ticket = new Ticket();</span><br><span class="line"></span><br><span class="line">          Thread t1 = new Thread(ticket);</span><br><span class="line">          Thread t2 = new Thread(ticket);</span><br><span class="line">          Thread t3 = new Thread(ticket);</span><br><span class="line"></span><br><span class="line">          t1.setName(&quot;窗口一&quot;);</span><br><span class="line">          t2.setName(&quot;窗口二&quot;);</span><br><span class="line">          t3.setName(&quot;窗口三&quot;);</span><br><span class="line"></span><br><span class="line">          t1.start();</span><br><span class="line">          t2.start();</span><br><span class="line">          t3.start();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-6死锁【理解】"><a href="#2-6死锁【理解】" class="headerlink" title="2.6死锁【理解】"></a>2.6死锁【理解】</h3><ul><li><p>概述</p><p>线程死锁是指由于两个或者多个线程互相持有对方所需要的资源，导致这些线程处于等待状态，无法前往执行</p></li><li><p>什么情况下会产生死锁</p><ol><li>资源有限</li><li>同步嵌套</li></ol></li><li><p>代码演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">objA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">objB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (objA)&#123;</span><br><span class="line">                    <span class="comment">//线程一</span></span><br><span class="line">                    <span class="keyword">synchronized</span> (objB)&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;小康同学正在走路&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (objB)&#123;</span><br><span class="line">                    <span class="comment">//线程二</span></span><br><span class="line">                    <span class="keyword">synchronized</span> (objA)&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;小薇同学正在走路&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-生产者消费者"><a href="#3-生产者消费者" class="headerlink" title="3.生产者消费者"></a>3.生产者消费者</h2><h3 id="3-1生产者和消费者模式概述【应用】"><a href="#3-1生产者和消费者模式概述【应用】" class="headerlink" title="3.1生产者和消费者模式概述【应用】"></a>3.1生产者和消费者模式概述【应用】</h3><ul><li><p>概述</p><p>生产者消费者模式是一个十分经典的多线程协作的模式，弄懂生产者消费者问题能够让我们对多线程编程的理解更加深刻。</p><p>所谓生产者消费者问题，实际上主要是包含了两类线程：</p><p>​一类是生产者线程用于生产数据</p><p>​一类是消费者线程用于消费数据</p><p>为了解耦生产者和消费者的关系，通常会采用共享的数据区域，就像是一个仓库</p><p>生产者生产数据之后直接放置在共享数据区中，并不需要关心消费者的行为</p><p>消费者只需要从共享数据区中去获取数据，并不需要关心生产者的行为</p></li><li><p>Object类的等待和唤醒方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>void wait()</td><td>导致当前线程等待，直到另一个线程调用该对象的 notify()方法或 notifyAll()方法</td></tr><tr><td>void notify()</td><td>唤醒正在等待对象监视器的单个线程</td></tr><tr><td>void notifyAll()</td><td>唤醒正在等待对象监视器的所有线程</td></tr></tbody></table></li></ul><h3 id="3-2生产者和消费者案例【应用】"><a href="#3-2生产者和消费者案例【应用】" class="headerlink" title="3.2生产者和消费者案例【应用】"></a>3.2生产者和消费者案例【应用】</h3><ul><li><p>案例需求</p><ul><li><p>桌子类(Desk)：定义表示包子数量的变量,定义锁对象变量,定义标记桌子上有无包子的变量</p></li><li><p>生产者类(Cooker)：实现Runnable接口，重写run()方法，设置线程任务</p><p>1.判断是否有包子,决定当前线程是否执行</p><p>2.如果有包子,就进入等待状态,如果没有包子,继续执行,生产包子</p><p>3.生产包子之后,更新桌子上包子状态,唤醒消费者消费包子</p></li><li><p>消费者类(Foodie)：实现Runnable接口，重写run()方法，设置线程任务</p><p>1.判断是否有包子,决定当前线程是否执行</p><p>2.如果没有包子,就进入等待状态,如果有包子,就消费包子</p><p>3.消费包子后,更新桌子上包子状态,唤醒生产者生产包子</p></li><li><p>测试类(Demo)：里面有main方法，main方法中的代码步骤如下</p><p>创建生产者线程和消费者线程对象</p><p>分别开启两个线程</p></li></ul></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Desk</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个标记</span></span><br><span class="line">    <span class="comment">//true 就表示桌子上有汉堡包的,此时允许吃货执行</span></span><br><span class="line">    <span class="comment">//false 就表示桌子上没有汉堡包的,此时允许厨师执行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//汉堡包的总数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//锁对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cooker</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"><span class="comment">//    生产者步骤：</span></span><br><span class="line"><span class="comment">//            1，判断桌子上是否有汉堡包</span></span><br><span class="line"><span class="comment">//    如果有就等待，如果没有才生产。</span></span><br><span class="line"><span class="comment">//            2，把汉堡包放在桌子上。</span></span><br><span class="line"><span class="comment">//            3，叫醒等待的消费者开吃。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Desk.lock)&#123;</span><br><span class="line">                <span class="keyword">if</span>(Desk.count == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!Desk.flag)&#123;</span><br><span class="line">                        <span class="comment">//生产</span></span><br><span class="line">                        System.out.println(<span class="string">&quot;厨师正在生产汉堡包&quot;</span>);</span><br><span class="line">                        Desk.flag = <span class="literal">true</span>;</span><br><span class="line">                        Desk.lock.notifyAll();</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Desk.lock.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Foodie</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//        1，判断桌子上是否有汉堡包。</span></span><br><span class="line"><span class="comment">//        2，如果没有就等待。</span></span><br><span class="line"><span class="comment">//        3，如果有就开吃</span></span><br><span class="line"><span class="comment">//        4，吃完之后，桌子上的汉堡包就没有了</span></span><br><span class="line"><span class="comment">//                叫醒等待的生产者继续生产</span></span><br><span class="line"><span class="comment">//        汉堡包的总数量减一</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//套路:</span></span><br><span class="line">            <span class="comment">//1. while(true)死循环</span></span><br><span class="line">            <span class="comment">//2. synchronized 锁,锁对象要唯一</span></span><br><span class="line">            <span class="comment">//3. 判断,共享数据是否结束. 结束</span></span><br><span class="line">            <span class="comment">//4. 判断,共享数据是否结束. 没有结束</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Desk.lock)&#123;</span><br><span class="line">                <span class="keyword">if</span>(Desk.count == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(Desk.flag)&#123;</span><br><span class="line">                        <span class="comment">//有</span></span><br><span class="line">                        System.out.println(<span class="string">&quot;吃货在吃汉堡包&quot;</span>);</span><br><span class="line">                        Desk.flag = <span class="literal">false</span>;</span><br><span class="line">                        Desk.lock.notifyAll();</span><br><span class="line">                        Desk.count--;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">//没有就等待</span></span><br><span class="line">                        <span class="comment">//使用什么对象当做锁,那么就必须用这个对象去调用等待和唤醒的方法.</span></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Desk.lock.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*消费者步骤：</span></span><br><span class="line"><span class="comment">        1，判断桌子上是否有汉堡包。</span></span><br><span class="line"><span class="comment">        2，如果没有就等待。</span></span><br><span class="line"><span class="comment">        3，如果有就开吃</span></span><br><span class="line"><span class="comment">        4，吃完之后，桌子上的汉堡包就没有了</span></span><br><span class="line"><span class="comment">                叫醒等待的生产者继续生产</span></span><br><span class="line"><span class="comment">        汉堡包的总数量减一*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*生产者步骤：</span></span><br><span class="line"><span class="comment">        1，判断桌子上是否有汉堡包</span></span><br><span class="line"><span class="comment">        如果有就等待，如果没有才生产。</span></span><br><span class="line"><span class="comment">        2，把汉堡包放在桌子上。</span></span><br><span class="line"><span class="comment">        3，叫醒等待的消费者开吃。*/</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Foodie</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Foodie</span>();</span><br><span class="line">        <span class="type">Cooker</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cooker</span>();</span><br><span class="line"></span><br><span class="line">        f.start();</span><br><span class="line">        c.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-3生产者和消费者案例优化【应用】"><a href="#3-3生产者和消费者案例优化【应用】" class="headerlink" title="3.3生产者和消费者案例优化【应用】"></a>3.3生产者和消费者案例优化【应用】</h3><ul><li><p>需求</p><ul><li>将Desk类中的变量,采用面向对象的方式封装起来</li><li>生产者和消费者类中构造方法接收Desk类对象,之后在run方法中进行使用</li><li>创建生产者和消费者线程对象,构造方法中传入Desk类对象</li><li>开启两个线程</li></ul></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Desk</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个标记</span></span><br><span class="line">    <span class="comment">//true 就表示桌子上有汉堡包的,此时允许吃货执行</span></span><br><span class="line">    <span class="comment">//false 就表示桌子上没有汉堡包的,此时允许厨师执行</span></span><br><span class="line">    <span class="comment">//public static boolean flag = false;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> flag;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//汉堡包的总数量</span></span><br><span class="line">    <span class="comment">//public static int count = 10;</span></span><br><span class="line">    <span class="comment">//以后我们在使用这种必须有默认值的变量</span></span><br><span class="line">   <span class="comment">// private int count = 10;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//锁对象</span></span><br><span class="line">    <span class="comment">//public static final Object lock = new Object();</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Desk</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="literal">false</span>,<span class="number">10</span>); <span class="comment">// 在空参内部调用带参,对成员变量进行赋值,之后就可以直接使用成员变量了</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Desk</span><span class="params">(<span class="type">boolean</span> flag, <span class="type">int</span> count)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.flag = flag;</span><br><span class="line">        <span class="built_in">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFlag</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFlag</span><span class="params">(<span class="type">boolean</span> flag)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCount</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Desk&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;flag=&quot;</span> + flag +</span><br><span class="line">                <span class="string">&quot;, count=&quot;</span> + count +</span><br><span class="line">                <span class="string">&quot;, lock=&quot;</span> + lock +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cooker</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Desk desk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cooker</span><span class="params">(Desk desk)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.desk = desk;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    生产者步骤：</span></span><br><span class="line"><span class="comment">//            1，判断桌子上是否有汉堡包</span></span><br><span class="line"><span class="comment">//    如果有就等待，如果没有才生产。</span></span><br><span class="line"><span class="comment">//            2，把汉堡包放在桌子上。</span></span><br><span class="line"><span class="comment">//            3，叫醒等待的消费者开吃。</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (desk.getLock())&#123;</span><br><span class="line">                <span class="keyword">if</span>(desk.getCount() == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//System.out.println(&quot;验证一下是否执行了&quot;);</span></span><br><span class="line">                    <span class="keyword">if</span>(!desk.isFlag())&#123;</span><br><span class="line">                        <span class="comment">//生产</span></span><br><span class="line">                        System.out.println(<span class="string">&quot;厨师正在生产汉堡包&quot;</span>);</span><br><span class="line">                        desk.setFlag(<span class="literal">true</span>);</span><br><span class="line">                        desk.getLock().notifyAll();</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            desk.getLock().wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Foodie</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Desk desk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Foodie</span><span class="params">(Desk desk)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.desk = desk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//        1，判断桌子上是否有汉堡包。</span></span><br><span class="line"><span class="comment">//        2，如果没有就等待。</span></span><br><span class="line"><span class="comment">//        3，如果有就开吃</span></span><br><span class="line"><span class="comment">//        4，吃完之后，桌子上的汉堡包就没有了</span></span><br><span class="line"><span class="comment">//                叫醒等待的生产者继续生产</span></span><br><span class="line"><span class="comment">//        汉堡包的总数量减一</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//套路:</span></span><br><span class="line">            <span class="comment">//1. while(true)死循环</span></span><br><span class="line">            <span class="comment">//2. synchronized 锁,锁对象要唯一</span></span><br><span class="line">            <span class="comment">//3. 判断,共享数据是否结束. 结束</span></span><br><span class="line">            <span class="comment">//4. 判断,共享数据是否结束. 没有结束</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (desk.getLock())&#123;</span><br><span class="line">                <span class="keyword">if</span>(desk.getCount() == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//System.out.println(&quot;验证一下是否执行了&quot;);</span></span><br><span class="line">                    <span class="keyword">if</span>(desk.isFlag())&#123;</span><br><span class="line">                        <span class="comment">//有</span></span><br><span class="line">                        System.out.println(<span class="string">&quot;吃货在吃汉堡包&quot;</span>);</span><br><span class="line">                        desk.setFlag(<span class="literal">false</span>);</span><br><span class="line">                        desk.getLock().notifyAll();</span><br><span class="line">                        desk.setCount(desk.getCount() - <span class="number">1</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">//没有就等待</span></span><br><span class="line">                        <span class="comment">//使用什么对象当做锁,那么就必须用这个对象去调用等待和唤醒的方法.</span></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            desk.getLock().wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*消费者步骤：</span></span><br><span class="line"><span class="comment">        1，判断桌子上是否有汉堡包。</span></span><br><span class="line"><span class="comment">        2，如果没有就等待。</span></span><br><span class="line"><span class="comment">        3，如果有就开吃</span></span><br><span class="line"><span class="comment">        4，吃完之后，桌子上的汉堡包就没有了</span></span><br><span class="line"><span class="comment">                叫醒等待的生产者继续生产</span></span><br><span class="line"><span class="comment">        汉堡包的总数量减一*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*生产者步骤：</span></span><br><span class="line"><span class="comment">        1，判断桌子上是否有汉堡包</span></span><br><span class="line"><span class="comment">        如果有就等待，如果没有才生产。</span></span><br><span class="line"><span class="comment">        2，把汉堡包放在桌子上。</span></span><br><span class="line"><span class="comment">        3，叫醒等待的消费者开吃。*/</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Desk</span> <span class="variable">desk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Desk</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Foodie</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Foodie</span>(desk);</span><br><span class="line">        <span class="type">Cooker</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cooker</span>(desk);</span><br><span class="line"></span><br><span class="line">        f.start();</span><br><span class="line">        c.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-4阻塞队列基本使用【理解】"><a href="#3-4阻塞队列基本使用【理解】" class="headerlink" title="3.4阻塞队列基本使用【理解】"></a>3.4阻塞队列基本使用【理解】</h3><ul><li><p>阻塞队列继承结构</p><p><img src="/JavaNotes/%E5%A4%9A%E7%BA%BF%E7%A8%8B/img/06_%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84.png" alt="06_阻塞队列继承结构"></p></li><li><p>常见BlockingQueue:</p><p>ArrayBlockingQueue: 底层是数组,有界</p><p>LinkedBlockingQueue: 底层是链表,无界.但不是真正的无界,最大为int的最大值</p></li><li><p>BlockingQueue的核心方法:</p><p>put(anObject): 将参数放入队列,如果放不进去会阻塞</p><p>take(): 取出第一个数据,取不到会阻塞</p></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建阻塞队列的对象,容量为 1</span></span><br><span class="line">        ArrayBlockingQueue&lt;String&gt; arrayBlockingQueue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存储元素</span></span><br><span class="line">        arrayBlockingQueue.put(<span class="string">&quot;汉堡包&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取元素</span></span><br><span class="line">        System.out.println(arrayBlockingQueue.take());</span><br><span class="line">        System.out.println(arrayBlockingQueue.take()); <span class="comment">// 取不到会阻塞</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;程序结束了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-5阻塞队列实现等待唤醒机制【理解】"><a href="#3-5阻塞队列实现等待唤醒机制【理解】" class="headerlink" title="3.5阻塞队列实现等待唤醒机制【理解】"></a>3.5阻塞队列实现等待唤醒机制【理解】</h3><ul><li><p>案例需求</p><ul><li><p>生产者类(Cooker)：实现Runnable接口，重写run()方法，设置线程任务</p><p>1.构造方法中接收一个阻塞队列对象</p><p>2.在run方法中循环向阻塞队列中添加包子</p><p>3.打印添加结果</p></li><li><p>消费者类(Foodie)：实现Runnable接口，重写run()方法，设置线程任务</p><p>1.构造方法中接收一个阻塞队列对象</p><p>2.在run方法中循环获取阻塞队列中的包子</p><p>3.打印获取结果</p></li><li><p>测试类(Demo)：里面有main方法，main方法中的代码步骤如下</p><p>创建阻塞队列对象</p><p>创建生产者线程和消费者线程对象,构造方法中传入阻塞队列对象</p><p>分别开启两个线程</p></li></ul></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cooker</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayBlockingQueue&lt;String&gt; bd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cooker</span><span class="params">(ArrayBlockingQueue&lt;String&gt; bd)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bd = bd;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    生产者步骤：</span></span><br><span class="line"><span class="comment">//            1，判断桌子上是否有汉堡包</span></span><br><span class="line"><span class="comment">//    如果有就等待，如果没有才生产。</span></span><br><span class="line"><span class="comment">//            2，把汉堡包放在桌子上。</span></span><br><span class="line"><span class="comment">//            3，叫醒等待的消费者开吃。</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bd.put(<span class="string">&quot;汉堡包&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;厨师放入一个汉堡包&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Foodie</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayBlockingQueue&lt;String&gt; bd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Foodie</span><span class="params">(ArrayBlockingQueue&lt;String&gt; bd)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bd = bd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//        1，判断桌子上是否有汉堡包。</span></span><br><span class="line"><span class="comment">//        2，如果没有就等待。</span></span><br><span class="line"><span class="comment">//        3，如果有就开吃</span></span><br><span class="line"><span class="comment">//        4，吃完之后，桌子上的汉堡包就没有了</span></span><br><span class="line"><span class="comment">//                叫醒等待的生产者继续生产</span></span><br><span class="line"><span class="comment">//        汉堡包的总数量减一</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//套路:</span></span><br><span class="line">        <span class="comment">//1. while(true)死循环</span></span><br><span class="line">        <span class="comment">//2. synchronized 锁,锁对象要唯一</span></span><br><span class="line">        <span class="comment">//3. 判断,共享数据是否结束. 结束</span></span><br><span class="line">        <span class="comment">//4. 判断,共享数据是否结束. 没有结束</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">take</span> <span class="operator">=</span> bd.take();</span><br><span class="line">                System.out.println(<span class="string">&quot;吃货将&quot;</span> + take + <span class="string">&quot;拿出来吃了&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayBlockingQueue&lt;String&gt; bd = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Foodie</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Foodie</span>(bd);</span><br><span class="line">        <span class="type">Cooker</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cooker</span>(bd);</span><br><span class="line"></span><br><span class="line">        f.start();</span><br><span class="line">        c.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Collection集合</title>
      <link href="/posts/999a8fe.html"/>
      <url>/posts/999a8fe.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-Collection集合"><a href="#1-Collection集合" class="headerlink" title="1.Collection集合"></a>1.Collection集合</h2><h3 id="1-1数组和集合的区别【理解】"><a href="#1-1数组和集合的区别【理解】" class="headerlink" title="1.1数组和集合的区别【理解】"></a>1.1数组和集合的区别【理解】</h3><ul><li><p>相同点</p><p>都是容器,可以存储多个数据</p></li><li><p>不同点</p><ul><li><p>数组的长度是不可变的,集合的长度是可变的</p></li><li><p>数组可以存基本数据类型和引用数据类型</p><p>集合只能存引用数据类型,如果要存基本数据类型,需要存对应的包装类</p></li></ul></li></ul><h3 id="1-2集合类体系结构【理解】"><a href="#1-2集合类体系结构【理解】" class="headerlink" title="1.2集合类体系结构【理解】"></a>1.2集合类体系结构【理解】</h3><p><img src="/JavaNotes/%E9%9B%86%E5%90%88List/img/01_%E9%9B%86%E5%90%88%E7%B1%BB%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="01_集合类体系结构图"></p><h3 id="1-3Collection-集合概述和使用【应用】"><a href="#1-3Collection-集合概述和使用【应用】" class="headerlink" title="1.3Collection 集合概述和使用【应用】"></a>1.3Collection 集合概述和使用【应用】</h3><ul><li><p>Collection集合概述</p><ul><li>是单例集合的顶层接口,它表示一组对象,这些对象也称为Collection的元素</li><li>JDK 不提供此接口的任何直接实现.它提供更具体的子接口(如Set和List)实现</li></ul></li><li><p>创建Collection集合的对象</p><ul><li>多态的方式</li><li>具体的实现类ArrayList</li></ul></li><li><p>Collection集合常用方法</p><table><thead><tr><th align="left">方法名</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">boolean add(E e)</td><td align="left">添加元素</td></tr><tr><td align="left">boolean remove(Object o)</td><td align="left">从集合中移除指定的元素</td></tr><tr><td align="left">boolean removeIf(Object o)</td><td align="left">根据条件进行移除</td></tr><tr><td align="left">void   clear()</td><td align="left">清空集合中的元素</td></tr><tr><td align="left">boolean contains(Object o)</td><td align="left">判断集合中是否存在指定的元素</td></tr><tr><td align="left">boolean isEmpty()</td><td align="left">判断集合是否为空</td></tr><tr><td align="left">int   size()</td><td align="left">集合的长度，也就是集合中元素的个数</td></tr></tbody></table></li></ul><h3 id="1-4Collection集合的遍历"><a href="#1-4Collection集合的遍历" class="headerlink" title="1.4Collection集合的遍历"></a>1.4Collection集合的遍历</h3><h4 id="1-4-1-迭代器遍历"><a href="#1-4-1-迭代器遍历" class="headerlink" title="1.4.1 迭代器遍历"></a>1.4.1 迭代器遍历</h4><ul><li><p>迭代器介绍</p><ul><li>迭代器,集合的专用遍历方式</li><li>Iterator<E> iterator(): 返回此集合中元素的迭代器,通过集合对象的iterator()方法得到</li></ul></li><li><p>Iterator中的常用方法</p><p>​boolean hasNext(): 判断当前位置是否有元素可以被取出<br>​E next(): 获取当前位置的元素,将迭代器对象移向下一个索引位置</p></li><li><p>Collection集合的遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IteratorDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建集合对象</span></span><br><span class="line">        Collection&lt;String&gt; c = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        c.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;javaee&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Iterator&lt;E&gt; iterator()：返回此集合中元素的迭代器，通过集合的iterator()方法得到</span></span><br><span class="line">        Iterator&lt;String&gt; it = c.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用while循环改进元素的判断和获取</span></span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> it.next();</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>迭代器中删除的方法</p><p>​void remove(): 删除迭代器对象当前指向的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IteratorDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;d&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> it.next();</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;b&quot;</span>.equals(s))&#123;</span><br><span class="line">                <span class="comment">//指向谁,那么此时就删除谁.</span></span><br><span class="line">                it.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-4-2-增强for"><a href="#1-4-2-增强for" class="headerlink" title="1.4.2 增强for"></a>1.4.2 增强for</h4><ul><li><p>介绍</p><ul><li>它是JDK5之后出现的,其内部原理是一个Iterator迭代器</li><li>实现Iterable接口的类才可以使用迭代器和增强for</li><li>简化数组和Collection集合的遍历</li></ul></li><li><p>格式</p><p>​for(集合&#x2F;数组中元素的数据类型 变量名 :  集合&#x2F;数组名) {</p><p>​&#x2F;&#x2F; 已经将当前遍历到的元素封装到变量中了,直接使用变量即可</p><p>​}</p></li><li><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCollectonDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list =  <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;e&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;f&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1,数据类型一定是集合或者数组中元素的类型</span></span><br><span class="line">        <span class="comment">//2,str仅仅是一个变量名而已,在循环的过程中,依次表示集合或者数组中的每一个元素</span></span><br><span class="line">        <span class="comment">//3,list就是要遍历的集合或者数组</span></span><br><span class="line">        <span class="keyword">for</span>(String str : list)&#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>细节点注意：</p></li></ul><p>1.报错NoSuchElementException       </p><p> 2.迭代器遍历完毕，指针不会复位        </p><p>3.循环中只能用一次next方法        </p><p>4.迭代器遍历时，不能用集合的方法进行增加或者删除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A04_CollectionDemo4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">        迭代器的细节注意点：</span></span><br><span class="line"><span class="comment">            1.报错NoSuchElementException</span></span><br><span class="line"><span class="comment">            2.迭代器遍历完毕，指针不会复位</span></span><br><span class="line"><span class="comment">            3.循环中只能用一次next方法</span></span><br><span class="line"><span class="comment">            4.迭代器遍历时，不能用集合的方法进行增加或者删除</span></span><br><span class="line"><span class="comment">            暂时当做一个结论先行记忆，在今天我们会讲解源码详细的再来分析。</span></span><br><span class="line"><span class="comment">                如果我实在要删除：那么可以用迭代器提供的remove方法进行删除。</span></span><br><span class="line"><span class="comment">                如果我要添加，暂时没有办法。(只是暂时)</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.创建集合并添加元素</span></span><br><span class="line">        Collection&lt;String&gt; coll = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        coll.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;ddd&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取迭代器对象</span></span><br><span class="line">        <span class="comment">//迭代器就好比是一个箭头，默认指向集合的0索引处</span></span><br><span class="line">        Iterator&lt;String&gt; it = coll.iterator();</span><br><span class="line">        <span class="comment">//3.利用循环不断的去获取集合中的每一个元素</span></span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            <span class="comment">//4.next方法的两件事情：获取元素并移动指针</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> it.next();</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当上面循环结束之后，迭代器的指针已经指向了最后没有元素的位置</span></span><br><span class="line">        <span class="comment">//System.out.println(it.next());//NoSuchElementException</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//迭代器遍历完毕，指针不会复位</span></span><br><span class="line">        System.out.println(it.hasNext());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果我们要继续第二次遍历集合，只能再次获取一个新的迭代器对象</span></span><br><span class="line">        Iterator&lt;String&gt; it2 = coll.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it2.hasNext())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> it2.next();</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-3-lambda表达式"><a href="#1-4-3-lambda表达式" class="headerlink" title="1.4.3 lambda表达式"></a>1.4.3 lambda表达式</h4><p>​利用forEach方法，再结合lambda表达式的方式进行遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A07_CollectionDemo7</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="comment">/* </span></span><br><span class="line"><span class="comment">        lambda表达式遍历：</span></span><br><span class="line"><span class="comment">                default void forEach(Consumer&lt;? super T&gt; action):</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.创建集合并添加元素</span></span><br><span class="line">        Collection&lt;String&gt; coll = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        coll.add(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;wangwu&quot;</span>);</span><br><span class="line">        <span class="comment">//2.利用匿名内部类的形式</span></span><br><span class="line">        <span class="comment">//底层原理：</span></span><br><span class="line">        <span class="comment">//其实也会自己遍历集合，依次得到每一个元素</span></span><br><span class="line">        <span class="comment">//把得到的每一个元素，传递给下面的accept方法</span></span><br><span class="line">        <span class="comment">//s依次表示集合中的每一个数据</span></span><br><span class="line">       <span class="comment">/* coll.forEach(new Consumer&lt;String&gt;() &#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public void accept(String s) &#123;</span></span><br><span class="line"><span class="comment">                System.out.println(s);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;);*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//lambda表达式</span></span><br><span class="line">        coll.forEach(s -&gt; System.out.println(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-List集合"><a href="#2-List集合" class="headerlink" title="2.List集合"></a>2.List集合</h2><h3 id="2-1List集合的概述和特点【记忆】"><a href="#2-1List集合的概述和特点【记忆】" class="headerlink" title="2.1List集合的概述和特点【记忆】"></a>2.1List集合的概述和特点【记忆】</h3><ul><li>List集合的概述<ul><li>有序集合,这里的有序指的是存取顺序</li><li>用户可以精确控制列表中每个元素的插入位置,用户可以通过整数索引访问元素,并搜索列表中的元素</li><li>与Set集合不同,列表通常允许重复的元素</li></ul></li><li>List集合的特点<ul><li>存取有序</li><li>可以重复</li><li>有索引</li></ul></li></ul><h3 id="2-2List集合的特有方法【应用】"><a href="#2-2List集合的特有方法【应用】" class="headerlink" title="2.2List集合的特有方法【应用】"></a>2.2List集合的特有方法【应用】</h3><ul><li><p>方法介绍</p><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>void add(int index,E   element)</td><td>在此集合中的指定位置插入指定的元素</td></tr><tr><td>E remove(int   index)</td><td>删除指定索引处的元素，返回被删除的元素</td></tr><tr><td>E set(int index,E   element)</td><td>修改指定索引处的元素，返回被修改的元素</td></tr><tr><td>E get(int   index)</td><td>返回指定索引处的元素</td></tr></tbody></table></li><li><p>示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyListDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">        <span class="comment">//method1(list);</span></span><br><span class="line">        <span class="comment">//method2(list);</span></span><br><span class="line">        <span class="comment">//method3(list);</span></span><br><span class="line">        <span class="comment">//method4(list);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method4</span><span class="params">(List&lt;String&gt; list)</span> &#123;</span><br><span class="line">        <span class="comment">//        E get(int index)返回指定索引处的元素</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">(List&lt;String&gt; list)</span> &#123;</span><br><span class="line">        <span class="comment">//        E set(int index,E element)修改指定索引处的元素，返回被修改的元素</span></span><br><span class="line">        <span class="comment">//被替换的那个元素,在集合中就不存在了.</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> list.set(<span class="number">0</span>, <span class="string">&quot;qqq&quot;</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(List&lt;String&gt; list)</span> &#123;</span><br><span class="line">        <span class="comment">//        E remove(int index)删除指定索引处的元素，返回被删除的元素</span></span><br><span class="line">        <span class="comment">//在List集合中有两个删除的方法</span></span><br><span class="line">        <span class="comment">//第一个 删除指定的元素,返回值表示当前元素是否删除成功</span></span><br><span class="line">        <span class="comment">//第二个 删除指定索引的元素,返回值表示实际删除的元素</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> list.remove(<span class="number">0</span>);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(List&lt;String&gt; list)</span> &#123;</span><br><span class="line">        <span class="comment">//        void add(int index,E element)在此集合中的指定位置插入指定的元素</span></span><br><span class="line">        <span class="comment">//原来位置上的元素往后挪一个索引.</span></span><br><span class="line">        list.add(<span class="number">0</span>,<span class="string">&quot;qqq&quot;</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-3List集合的五种遍历方式【应用】"><a href="#2-3List集合的五种遍历方式【应用】" class="headerlink" title="2.3List集合的五种遍历方式【应用】"></a>2.3List集合的五种遍历方式【应用】</h3><ol><li>迭代器</li><li>列表迭代器</li><li>增强for</li><li>Lambda表达式</li><li>普通for循环</li></ol><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建集合并添加元素</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.迭代器</span></span><br><span class="line"><span class="comment">/*Iterator&lt;String&gt; it = list.iterator();</span></span><br><span class="line"><span class="comment">     while(it.hasNext())&#123;</span></span><br><span class="line"><span class="comment">        String str = it.next();</span></span><br><span class="line"><span class="comment">        System.out.println(str);</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.增强for</span></span><br><span class="line"><span class="comment">//下面的变量s，其实就是一个第三方的变量而已。</span></span><br><span class="line"><span class="comment">//在循环的过程中，依次表示集合中的每一个元素</span></span><br><span class="line"><span class="comment">/* for (String s : list) &#123;</span></span><br><span class="line"><span class="comment">       System.out.println(s);</span></span><br><span class="line"><span class="comment">   &#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.Lambda表达式</span></span><br><span class="line"><span class="comment">//forEach方法的底层其实就是一个循环遍历，依次得到集合中的每一个元素</span></span><br><span class="line"><span class="comment">//并把每一个元素传递给下面的accept方法</span></span><br><span class="line"><span class="comment">//accept方法的形参s，依次表示集合中的每一个元素</span></span><br><span class="line"><span class="comment">//list.forEach(s-&gt;System.out.println(s) );</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.普通for循环</span></span><br><span class="line"><span class="comment">//size方法跟get方法还有循环结合的方式，利用索引获取到集合中的每一个元素</span></span><br><span class="line"><span class="comment">/*for (int i = 0; i &lt; list.size(); i++) &#123;</span></span><br><span class="line"><span class="comment">            //i:依次表示集合中的每一个索引</span></span><br><span class="line"><span class="comment">            String s = list.get(i);</span></span><br><span class="line"><span class="comment">            System.out.println(s);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.列表迭代器</span></span><br><span class="line"><span class="comment">//获取一个列表迭代器的对象，里面的指针默认也是指向0索引的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//额外添加了一个方法：在遍历的过程中，可以添加元素</span></span><br><span class="line">ListIterator&lt;String&gt; it = list.listIterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> it.next();</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;bbb&quot;</span>.equals(str))&#123;</span><br><span class="line">        <span class="comment">//qqq</span></span><br><span class="line">        it.add(<span class="string">&quot;qqq&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure><h3 id="2-4-细节点注意："><a href="#2-4-细节点注意：" class="headerlink" title="2.4 细节点注意："></a>2.4 细节点注意：</h3><p>List系列集合中的两个删除的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>直接删除元素</span><br><span class="line"><span class="number">2.</span>通过索引进行删除</span><br></pre></td></tr></table></figure><p>代码示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//List系列集合中的两个删除的方法</span></span><br><span class="line"><span class="comment">//1.直接删除元素</span></span><br><span class="line"><span class="comment">//2.通过索引进行删除</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.创建集合并添加元素</span></span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.删除元素</span></span><br><span class="line"><span class="comment">//请问：此时删除的是1这个元素，还是1索引上的元素？</span></span><br><span class="line"><span class="comment">//为什么？</span></span><br><span class="line"><span class="comment">//因为在调用方法的时候，如果方法出现了重载现象</span></span><br><span class="line"><span class="comment">//优先调用，实参跟形参类型一致的那个方法。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//list.remove(1);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//手动装箱，手动把基本数据类型的1，变成Integer类型</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> Integer.valueOf(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">list.remove(i);</span><br><span class="line"></span><br><span class="line">System.out.println(list);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-数据结构"><a href="#3-数据结构" class="headerlink" title="3.数据结构"></a>3.数据结构</h2><h3 id="3-1数据结构之栈和队列【记忆】"><a href="#3-1数据结构之栈和队列【记忆】" class="headerlink" title="3.1数据结构之栈和队列【记忆】"></a>3.1数据结构之栈和队列【记忆】</h3><ul><li><p>栈结构</p><p>​先进后出</p></li><li><p>队列结构</p><p>​先进先出</p></li></ul><h3 id="3-2数据结构之数组和链表【记忆】"><a href="#3-2数据结构之数组和链表【记忆】" class="headerlink" title="3.2数据结构之数组和链表【记忆】"></a>3.2数据结构之数组和链表【记忆】</h3><ul><li><p>数组结构</p><p>​查询快、增删慢</p></li><li><p>队列结构</p><p>​查询慢、增删快</p></li></ul><h2 id="4-List集合的实现类"><a href="#4-List集合的实现类" class="headerlink" title="4.List集合的实现类"></a>4.List集合的实现类</h2><h3 id="4-1List集合子类的特点【记忆】"><a href="#4-1List集合子类的特点【记忆】" class="headerlink" title="4.1List集合子类的特点【记忆】"></a>4.1List集合子类的特点【记忆】</h3><ul><li><p>ArrayList集合</p><p>​底层是数组结构实现，查询快、增删慢</p></li><li><p>LinkedList集合</p><p>​底层是链表结构实现，查询慢、增删快</p></li></ul><h3 id="4-2LinkedList集合的特有功能【应用】"><a href="#4-2LinkedList集合的特有功能【应用】" class="headerlink" title="4.2LinkedList集合的特有功能【应用】"></a>4.2LinkedList集合的特有功能【应用】</h3><ul><li><p>特有方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public void addFirst(E e)</td><td>在该列表开头插入指定的元素</td></tr><tr><td>public void addLast(E e)</td><td>将指定的元素追加到此列表的末尾</td></tr><tr><td>public E getFirst()</td><td>返回此列表中的第一个元素</td></tr><tr><td>public   E getLast()</td><td>返回此列表中的最后一个元素</td></tr><tr><td>public E removeFirst()</td><td>从此列表中删除并返回第一个元素</td></tr><tr><td>public   E removeLast()</td><td>从此列表中删除并返回最后一个元素</td></tr></tbody></table></li><li><p>示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyLinkedListDemo4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        LinkedList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line"><span class="comment">//        public void addFirst(E e)在该列表开头插入指定的元素</span></span><br><span class="line">        <span class="comment">//method1(list);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        public void addLast(E e)将指定的元素追加到此列表的末尾</span></span><br><span class="line">        <span class="comment">//method2(list);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        public E getFirst()返回此列表中的第一个元素</span></span><br><span class="line"><span class="comment">//        public E getLast()返回此列表中的最后一个元素</span></span><br><span class="line">        <span class="comment">//method3(list);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        public E removeFirst()从此列表中删除并返回第一个元素</span></span><br><span class="line"><span class="comment">//        public E removeLast()从此列表中删除并返回最后一个元素</span></span><br><span class="line">        <span class="comment">//method4(list);</span></span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method4</span><span class="params">(LinkedList&lt;String&gt; list)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> list.removeFirst();</span><br><span class="line">        System.out.println(first);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">last</span> <span class="operator">=</span> list.removeLast();</span><br><span class="line">        System.out.println(last);</span><br><span class="line"></span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">(LinkedList&lt;String&gt; list)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> list.getFirst();</span><br><span class="line">        <span class="type">String</span> <span class="variable">last</span> <span class="operator">=</span> list.getLast();</span><br><span class="line">        System.out.println(first);</span><br><span class="line">        System.out.println(last);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(LinkedList&lt;String&gt; list)</span> &#123;</span><br><span class="line">        list.addLast(<span class="string">&quot;www&quot;</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(LinkedList&lt;String&gt; list)</span> &#123;</span><br><span class="line">        list.addFirst(<span class="string">&quot;qqq&quot;</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-源码分析"><a href="#5-源码分析" class="headerlink" title="5. 源码分析"></a>5. 源码分析</h2><h3 id="5-1-ArrayList源码分析："><a href="#5-1-ArrayList源码分析：" class="headerlink" title="5.1 ArrayList源码分析："></a>5.1 ArrayList源码分析：</h3><p>核心步骤：</p><ol><li><p>创建ArrayList对象的时候，他在底层先创建了一个长度为0的数组。</p><p>数组名字：elementDate，定义变量size。</p><p>size这个变量有两层含义：<br>①：元素的个数，也就是集合的长度<br>②：下一个元素的存入位置</p></li><li><p>添加元素，添加完毕后，size++</p></li></ol><p>扩容时机一：</p><ol start="3"><li>当存满时候，会创建一个新的数组，新数组的长度，是原来的1.5倍，也就是长度为15.再把所有的元素，全拷贝到新数组中。如果继续添加数据，这个长度为15的数组也满了，那么下次还会继续扩容，还是1.5倍。</li></ol><p>扩容时机二：</p><ol start="4"><li><p>一次性添加多个数据，扩容1.5倍不够，怎么办呀？</p><p>如果一次添加多个元素，1.5倍放不下，那么新创建数组的长度以实际为准。</p></li></ol><p>举个例子：<br>在一开始，如果默认的长度为10的数组已经装满了，在装满的情况下，我一次性要添加100个数据很显然，10扩容1.5倍，变成15，还是不够，</p><p>怎么办？</p><p>此时新数组的长度，就以实际情况为准，就是110</p><p>具体分析过程可以参见视频讲解。</p><p><strong>添加一个元素时的扩容：</strong></p><p><img src="/JavaNotes/%E9%9B%86%E5%90%88List/img/%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE.png" alt="第一次添加数据"></p><p><strong>添加多个元素时的扩容：</strong></p><p><img src="/JavaNotes/%E9%9B%86%E5%90%88List/img/%E7%AC%AC11%E6%AC%A1%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE.png" alt="第11次添加数据"></p><h3 id="5-2-LinkedList源码分析："><a href="#5-2-LinkedList源码分析：" class="headerlink" title="5.2 LinkedList源码分析："></a>5.2 LinkedList源码分析：</h3><p>底层是双向链表结构</p><p>核心步骤如下：</p><ol><li>刚开始创建的时候，底层创建了两个变量：一个记录头结点first，一个记录尾结点last，默认为null</li><li>添加第一个元素时，底层创建一个结点对象，first和last都记录这个结点的地址值</li><li>添加第二个元素时，底层创建一个结点对象，第一个结点会记录第二个结点的地址值，last会记录新结点的地址值</li></ol><p>具体分析过程可以参见视频讲解。</p><p><img src="/JavaNotes/%E9%9B%86%E5%90%88List/img/LinkedList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.png" alt="LinkedList源码分析"></p><h3 id="5-3-迭代器源码分析："><a href="#5-3-迭代器源码分析：" class="headerlink" title="5.3 迭代器源码分析："></a>5.3 迭代器源码分析：</h3><p>迭代器遍历相关的三个方法：</p><ul><li><p>Iterator<E> iterator()  ：获取一个迭代器对象</p></li><li><p>boolean hasNext()       ：判断当前指向的位置是否有元素</p></li><li><p>E next()                ：获取当前指向的元素并移动指针</p></li></ul><p><img src="/JavaNotes/%E9%9B%86%E5%90%88List/img/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.png" alt="迭代器源码分析"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Collection集合 </tag>
            
            <tag> List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抽象类&amp;接口&amp;内部类</title>
      <link href="/posts/fc4c1a2e.html"/>
      <url>/posts/fc4c1a2e.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-抽象类"><a href="#第一章-抽象类" class="headerlink" title="第一章 抽象类"></a>第一章 抽象类</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><h3 id="1-1-1-抽象类引入"><a href="#1-1-1-抽象类引入" class="headerlink" title="1.1.1 抽象类引入"></a>1.1.1 抽象类引入</h3><p>​父类中的方法，被它的子类们重写，子类各自的实现都不尽相同。那么父类的方法声明和方法主体，只有声明还有意义，而方法主体则没有存在的意义了(因为子类对象会调用自己重写的方法)。换句话说，父类可能知道子类应该有哪个功能，但是功能具体怎么实现父类是不清楚的（由子类自己决定），父类只需要提供一个没有方法体的定义即可，具体实现交给子类自己去实现。<strong>我们把没有方法体的方法称为抽象方法。Java语法规定，包含抽象方法的类就是抽象类</strong>。</p><ul><li><strong>抽象方法</strong> ： 没有方法体的方法。</li><li><strong>抽象类</strong>：包含抽象方法的类。</li></ul><h2 id="1-2-abstract使用格式"><a href="#1-2-abstract使用格式" class="headerlink" title="1.2 abstract使用格式"></a>1.2 abstract使用格式</h2><p><strong>abstract是抽象的意思，用于修饰方法方法和类，修饰的方法是抽象方法，修饰的类是抽象类。</strong></p><h3 id="1-2-1-抽象方法"><a href="#1-2-1-抽象方法" class="headerlink" title="1.2.1 抽象方法"></a>1.2.1 抽象方法</h3><p>使用<code>abstract</code> 关键字修饰方法，该方法就成了抽象方法，抽象方法只包含一个方法名，而没有方法体。</p><p>定义格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="keyword">abstract</span> 返回值类型 方法名 (参数列表)；</span><br></pre></td></tr></table></figure><p>代码举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>；</span><br></pre></td></tr></table></figure><h3 id="1-2-2-抽象类"><a href="#1-2-2-抽象类" class="headerlink" title="1.2.2 抽象类"></a>1.2.2 抽象类</h3><p>如果一个类包含抽象方法，那么该类必须是抽象类。<strong>注意：抽象类不一定有抽象方法，但是有抽象方法的类必须定义成抽象类。</strong></p><p>定义格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> class 类名字 &#123; </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-3-抽象类的使用"><a href="#1-2-3-抽象类的使用" class="headerlink" title="1.2.3 抽象类的使用"></a>1.2.3 抽象类的使用</h3><p><strong>要求</strong>：继承抽象类的子类<strong>必须重写父类所有的抽象方法</strong>。否则，该子类也必须声明为抽象类。</p><p>代码举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类,抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line"><span class="keyword">private</span> String id;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="type">double</span> salary;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String id, String name, <span class="type">double</span> salary)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.id = id;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line"><span class="built_in">this</span>.salary = salary;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象方法</span></span><br><span class="line"><span class="comment">// 抽象方法必须要放在抽象类中</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个子类继承抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Manager</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Manager</span><span class="params">(String id, String name, <span class="type">double</span> salary)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>(id, name, salary);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2.重写父类的抽象方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;管理其他人&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个子类继承抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cook</span> <span class="keyword">extends</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Cook</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Cook</span><span class="params">(String id, String name, <span class="type">double</span> salary)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>(id, name, salary);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;厨师炒菜多加点盐...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo10</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">// 创建抽象类,抽象类不能创建对象</span></span><br><span class="line"><span class="comment">// 假设抽象类让我们创建对象,里面的抽象方法没有方法体,无法执行.所以不让我们创建对象</span></span><br><span class="line"><span class="comment">//Employee e = new Employee();</span></span><br><span class="line"><span class="comment">//e.work();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.创建子类</span></span><br><span class="line"><span class="type">Manager</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Manager</span>();</span><br><span class="line">m.work();</span><br><span class="line"></span><br><span class="line"><span class="type">Cook</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cook</span>(<span class="string">&quot;ap002&quot;</span>, <span class="string">&quot;库克&quot;</span>, <span class="number">1</span>);</span><br><span class="line">c.work();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时的方法重写，是子类对父类抽象方法的完成实现，我们将这种方法重写的操作，也叫做<strong>实现方法</strong>。</p><h2 id="1-3-抽象类的特征"><a href="#1-3-抽象类的特征" class="headerlink" title="1.3 抽象类的特征"></a>1.3 抽象类的特征</h2><p>抽象类的特征总结起来可以说是 <strong>有得有失</strong></p><p><strong>有得：抽象类得到了拥有抽象方法的能力。</strong></p><p><strong>有失：抽象类失去了创建对象的能力。</strong></p><p>其他成员（构造方法，实例方法，静态方法等）抽象类都是具备的。</p><h2 id="1-4-抽象类的细节"><a href="#1-4-抽象类的细节" class="headerlink" title="1.4 抽象类的细节"></a>1.4 抽象类的细节</h2><p>不需要背，只要当idea报错之后，知道如何修改即可。</p><p>关于抽象类的使用，以下为语法上要注意的细节，虽然条目较多，但若理解了抽象的本质，无需死记硬背。</p><ol><li><p>抽象类<strong>不能创建对象</strong>，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。</p><blockquote><p>理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。</p></blockquote></li><li><p>抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。</p><blockquote><p>理解：子类的构造方法中，有默认的super()，需要访问父类构造方法。</p></blockquote></li><li><p>抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</p><blockquote><p>理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。</p></blockquote></li><li><p>抽象类的子类，必须重写抽象父类中<strong>所有的</strong>抽象方法，否则子类也必须定义成抽象类，编译无法通过而报错。 </p><blockquote><p>理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。</p></blockquote></li><li><p>抽象类存在的意义是为了被子类继承。</p><blockquote><p>理解：抽象类中已经实现的是模板中确定的成员，抽象类不确定如何实现的定义成抽象方法，交给具体的子类去实现。</p></blockquote></li></ol><h2 id="1-5-抽象类存在的意义"><a href="#1-5-抽象类存在的意义" class="headerlink" title="1.5 抽象类存在的意义"></a>1.5 抽象类存在的意义</h2><p>​抽象类存在的意义是为了被子类继承，否则抽象类将毫无意义。抽象类可以强制让子类，一定要按照规定的格式进行重写。</p><h1 id="第二章-接口"><a href="#第二章-接口" class="headerlink" title="第二章 接口"></a>第二章 接口</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><p>我们已经学完了抽象类，抽象类中可以用抽象方法，也可以有普通方法，构造方法，成员变量等。那么什么是接口呢？<strong>接口是更加彻底的抽象，JDK7之前，包括JDK7，接口中全部是抽象方法。接口同样是不能创建对象的</strong>。</p><h2 id="2-2-定义格式"><a href="#2-2-定义格式" class="headerlink" title="2.2 定义格式"></a>2.2 定义格式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口的定义格式：</span></span><br><span class="line">interface 接口名称&#123;</span><br><span class="line">    <span class="comment">// 抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口的声明：interface</span></span><br><span class="line"><span class="comment">// 接口名称：首字母大写，满足“驼峰模式”</span></span><br></pre></td></tr></table></figure><h2 id="2-3-接口成分的特点"><a href="#2-3-接口成分的特点" class="headerlink" title="2.3 接口成分的特点"></a>2.3 接口成分的特点</h2><p>  在JDK7，包括JDK7之前，接口中的<strong>只有</strong>包含：抽象方法和常量</p><h3 id="2-3-1-抽象方法"><a href="#2-3-1-抽象方法" class="headerlink" title="2.3.1.抽象方法"></a>2.3.1.抽象方法</h3><p>​       注意：接口中的抽象方法默认会自动加上public abstract修饰程序员无需自己手写！！<br>​       按照规范：以后接口中的抽象方法建议不要写上public abstract。因为没有必要啊，默认会加上。</p><h3 id="2-3-2-常量"><a href="#2-3-2-常量" class="headerlink" title="2.3.2 常量"></a>2.3.2 常量</h3><p> 在接口中定义的成员变量默认会加上： public static final修饰。也就是说在接口中定义的成员变量实际上是一个常量。这里是使用public static final修饰后，变量值就不可被修改，并且是静态化的变量可以直接用接口名访问，所以也叫常量。常量必须要给初始值。常量命名规范建议字母全部大写，多个单词用下划线连接。</p><h3 id="2-3-3-案例演示"><a href="#2-3-3-案例演示" class="headerlink" title="2.3.3 案例演示"></a>2.3.3 案例演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InterF</span> &#123;</span><br><span class="line">    <span class="comment">// 抽象方法！</span></span><br><span class="line">    <span class="comment">//    public abstract void run();</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    public abstract String getName();</span></span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    public abstract int add(int a , int b);</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a , <span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 它的最终写法是：</span></span><br><span class="line">    <span class="comment">// public static final int AGE = 12 ;</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">AGE</span>  <span class="operator">=</span> <span class="number">12</span>; <span class="comment">//常量</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">SCHOOL_NAME</span> <span class="operator">=</span> <span class="string">&quot;黑马程序员&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-基本的实现"><a href="#2-4-基本的实现" class="headerlink" title="2.4 基本的实现"></a>2.4 基本的实现</h2><h3 id="2-4-1-实现接口的概述"><a href="#2-4-1-实现接口的概述" class="headerlink" title="2.4.1 实现接口的概述"></a>2.4.1 实现接口的概述</h3><p>类与接口的关系为实现关系，即<strong>类实现接口</strong>，该类可以称为接口的实现类，也可以称为接口的子类。实现的动作类似继承，格式相仿，只是关键字不同，实现使用 <code> implements</code>关键字。</p><h3 id="2-4-2-实现接口的格式"><a href="#2-4-2-实现接口的格式" class="headerlink" title="2.4.2 实现接口的格式"></a>2.4.2 实现接口的格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**接口的实现：</span></span><br><span class="line"><span class="comment">    在Java中接口是被实现的，实现接口的类称为实现类。</span></span><br><span class="line"><span class="comment">    实现类的格式:*/</span></span><br><span class="line">class 类名 implements 接口<span class="number">1</span>,接口<span class="number">2</span>,接口<span class="number">3.</span>..&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面格式可以看出，接口是可以被多实现的。大家可以想一想为什么呢？</p><h3 id="2-4-3-类实现接口的要求和意义"><a href="#2-4-3-类实现接口的要求和意义" class="headerlink" title="2.4.3 类实现接口的要求和意义"></a>2.4.3 类实现接口的要求和意义</h3><ol><li>必须重写实现的全部接口中所有抽象方法。</li><li>如果一个类实现了接口，但是没有重写完全部接口的全部抽象方法，这个类也必须定义成抽象类。</li><li><strong>意义：接口体现的是一种规范，接口对实现类是一种强制性的约束，要么全部完成接口申明的功能，要么自己也定义成抽象类。这正是一种强制性的规范。</strong></li></ol><h3 id="2-4-4-类与接口基本实现案例"><a href="#2-4-4-类与接口基本实现案例" class="headerlink" title="2.4.4  类与接口基本实现案例"></a>2.4.4  类与接口基本实现案例</h3><p>假如我们定义一个运动员的<strong>接口</strong>（规范），代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   接口：接口体现的是规范。</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SportMan</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>; <span class="comment">// 抽象方法，跑步。</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">law</span><span class="params">()</span>; <span class="comment">// 抽象方法，遵守法律。</span></span><br><span class="line">    String <span class="title function_">compittion</span><span class="params">(String project)</span>;  <span class="comment">// 抽象方法，比赛。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来定义一个乒乓球运动员类，实现接口，实现接口的<strong>实现类</strong>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima._03接口的实现;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接口的实现：</span></span><br><span class="line"><span class="comment"> *    在Java中接口是被实现的，实现接口的类称为实现类。</span></span><br><span class="line"><span class="comment"> *    实现类的格式:</span></span><br><span class="line"><span class="comment"> *      class 类名 implements 接口1,接口2,接口3...&#123;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      &#125;</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PingPongMan</span>  <span class="keyword">implements</span> <span class="title class_">SportMan</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;乒乓球运动员稍微跑一下！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">law</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;乒乓球运动员守法！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">compittion</span><span class="params">(String project)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;参加&quot;</span>+project+<span class="string">&quot;得金牌！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMain</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建实现类对象。</span></span><br><span class="line">        <span class="type">PingPongMan</span> <span class="variable">zjk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PingPongMan</span>();</span><br><span class="line">        zjk.run();</span><br><span class="line">        zjk.law();</span><br><span class="line">        System.out.println(zjk.compittion(<span class="string">&quot;全球乒乓球比赛&quot;</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-5-类与接口的多实现案例"><a href="#2-4-5-类与接口的多实现案例" class="headerlink" title="2.4.5 类与接口的多实现案例"></a>2.4.5 类与接口的多实现案例</h3><p><strong>类与接口之间的关系是多实现的，一个类可以同时实现多个接口。</strong></p><p>首先我们先定义两个接口，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 法律规范：接口*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Law</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">rule</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 这一个运动员的规范：接口*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SportMan</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后定义一个实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Java中接口是可以被多实现的：</span></span><br><span class="line"><span class="comment"> *    一个类可以实现多个接口: Law, SportMan</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JumpMan</span> <span class="keyword">implements</span> <span class="title class_">Law</span> ,SportMan &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rule</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;尊长守法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;训练跑步！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面可以看出类与接口之间是可以多实现的，我们可以理解成实现多个规范，这是合理的。</p><h2 id="2-5-接口与接口的多继承"><a href="#2-5-接口与接口的多继承" class="headerlink" title="2.5 接口与接口的多继承"></a>2.5 接口与接口的多继承</h2><p>Java中，接口与接口之间是可以多继承的：也就是一个接口可以同时继承多个接口。大家一定要注意：</p><p><strong>类与接口是实现关系</strong></p><p><strong>接口与接口是继承关系</strong></p><p>接口继承接口就是把其他接口的抽象方法与本接口进行了合并。</p><p>案例演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Abc</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 法律规范：接口*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Law</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">rule</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> *</span><br><span class="line"> *  总结：</span><br><span class="line"> *     接口与类之间是多实现的。</span><br><span class="line"> *     接口与接口之间是多继承的。</span><br><span class="line"> * */</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SportMan</span> <span class="keyword">extends</span> <span class="title class_">Law</span> , Abc &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-6扩展：接口的细节"><a href="#2-6扩展：接口的细节" class="headerlink" title="2.6扩展：接口的细节"></a>2.6扩展：接口的细节</h2><p>不需要背，只要当idea报错之后，知道如何修改即可。</p><p>关于接口的使用，以下为语法上要注意的细节，虽然条目较多，但若理解了抽象的本质，无需死记硬背。</p><ol><li>当两个接口中存在相同抽象方法的时候，该怎么办？</li></ol><blockquote><p>只要重写一次即可。此时重写的方法，既表示重写1接口的，也表示重写2接口的。</p></blockquote><ol start="2"><li>实现类能不能继承A类的时候，同时实现其他接口呢？</li></ol><blockquote><p>继承的父类，就好比是亲爸爸一样<br>实现的接口，就好比是干爹一样<br>可以继承一个类的同时，再实现多个接口，只不过，要把接口里面所有的抽象方法，全部实现。</p></blockquote><ol start="3"><li>实现类能不能继承一个抽象类的时候，同时实现其他接口呢？</li></ol><blockquote><p>实现类可以继承一个抽象类的同时，再实现其他多个接口，只不过要把里面所有的抽象方法全部重写。</p></blockquote><ol start="4"><li>实现类Zi，实现了一个接口，还继承了一个Fu类。假设在接口中有一个方法，父类中也有一个相同的方法。子类如何操作呢？</li></ol><blockquote><p>处理办法一：如果父类中的方法体，能满足当前业务的需求，在子类中可以不用重写。<br>处理办法二：如果父类中的方法体，不能满足当前业务的需求，需要在子类中重写。</p></blockquote><ol start="5"><li>如果一个接口中，有10个抽象方法，但是我在实现类中，只需要用其中一个，该怎么办?</li></ol><blockquote><p>可以在接口跟实现类中间，新建一个中间类（适配器类）<br>让这个适配器类去实现接口，对接口里面的所有的方法做空重写。<br>让子类继承这个适配器类，想要用到哪个方法，就重写哪个方法。<br>因为中间类没有什么实际的意义，所以一般会把中间类定义为抽象的，不让外界创建对象</p></blockquote><h1 id="第三章-内部类"><a href="#第三章-内部类" class="headerlink" title="第三章 内部类"></a>第三章 内部类</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><h3 id="3-1-1-什么是内部类"><a href="#3-1-1-什么是内部类" class="headerlink" title="3.1.1 什么是内部类"></a>3.1.1 什么是内部类</h3><p>将一个类A定义在另一个类B里面，里面的那个类A就称为<strong>内部类</strong>，B则称为<strong>外部类</strong>。可以把内部类理解成寄生，外部类理解成宿主。</p><h3 id="3-1-2-什么时候使用内部类"><a href="#3-1-2-什么时候使用内部类" class="headerlink" title="3.1.2 什么时候使用内部类"></a>3.1.2 什么时候使用内部类</h3><p>一个事物内部还有一个独立的事物，内部的事物脱离外部的事物无法独立使用</p><ol><li>人里面有一颗心脏。</li><li>汽车内部有一个发动机。</li><li>为了实现更好的封装性。</li></ol><h2 id="3-2-内部类的分类"><a href="#3-2-内部类的分类" class="headerlink" title="3.2 内部类的分类"></a>3.2 内部类的分类</h2><p>按定义的位置来分</p><ol><li><strong>成员内部内</strong>，类定义在了成员位置 (类中方法外称为成员位置，无static修饰的内部类)</li><li><strong>静态内部类</strong>，类定义在了成员位置 (类中方法外称为成员位置，有static修饰的内部类)</li><li><strong>局部内部类</strong>，类定义在方法内</li><li><strong>匿名内部类</strong>，没有名字的内部类，可以在方法中，也可以在类中方法外。</li></ol><h2 id="3-3-成员内部类"><a href="#3-3-成员内部类" class="headerlink" title="3.3 成员内部类"></a>3.3 成员内部类</h2><p><strong>成员内部类特点</strong>：</p><ul><li>无static修饰的内部类，属于外部类对象的。</li><li>宿主：外部类对象。</li></ul><p><strong>内部类的使用格式</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">外部类.内部类。 <span class="comment">// 访问内部类的类型都是用 外部类.内部类</span></span><br></pre></td></tr></table></figure><p><strong>获取成员内部类对象的两种方式</strong>：</p><p>方式一：外部直接创建成员内部类的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">外部类.内部类 变量 = <span class="keyword">new</span> 外部类（）.new 内部类（）;</span><br></pre></td></tr></table></figure><p>方式二：在外部类中定义一个方法提供内部类的对象</p><p><strong>案例演示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">方式一：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//  宿主：外部类对象。</span></span><br><span class="line">       <span class="comment">// Outer out = new Outer();</span></span><br><span class="line">        <span class="comment">// 创建内部类对象。</span></span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">oi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>().<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        oi.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="comment">// 成员内部类，属于外部类对象的。</span></span><br><span class="line">    <span class="comment">// 拓展：成员内部类不能定义静态成员。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        <span class="comment">// 这里面的东西与类是完全一样的。</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;内部类中的方法被调用了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">方式二：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Inner <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Outer</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        System.out.println(o.getInstance());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-成员内部类的细节"><a href="#3-4-成员内部类的细节" class="headerlink" title="3.4 成员内部类的细节"></a>3.4 成员内部类的细节</h2><p>编写成员内部类的注意点：</p><ol><li>成员内部类可以被一些修饰符所修饰，比如： private，默认，protected，public，static等</li><li>在成员内部类里面，JDK16之前不能定义静态变量，JDK16开始才可以定义静态变量。</li><li>创建内部类对象时，对象中有一个隐含的Outer.this记录外部类对象的地址值。（请参见3.6节的内存图）</li></ol><p>详解：</p><p>​内部类被private修饰，外界无法直接获取内部类的对象，只能通过3.3节中的方式二获取内部类的对象</p><p>​被其他权限修饰符修饰的内部类一般用3.3节中的方式一直接获取内部类的对象</p><p>​内部类被static修饰是成员内部类中的特殊情况，叫做静态内部类下面单独学习。</p><p>​内部类如果想要访问外部类的成员变量，外部类的变量必须用final修饰，JDK8以前必须手动写final，JDK8之后不需要手动写，JDK默认加上。</p><h2 id="3-5-成员内部类面试题"><a href="#3-5-成员内部类面试题" class="headerlink" title="3.5 成员内部类面试题"></a>3.5 成员内部类面试题</h2><p>请在?地方向上相应代码,以达到输出的内容</p><p>注意：内部类访问外部类对象的格式是：<strong>外部类名.this</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Outer.<span class="type">inner</span> <span class="variable">oi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>().<span class="keyword">new</span> <span class="title class_">inner</span>();</span><br><span class="line">        oi.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;<span class="comment">// 外部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在成员位置定义一个类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">inner</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">            System.out.println(???);<span class="comment">// 10   答案：a</span></span><br><span class="line">            System.out.println(???);<span class="comment">// 20答案：this.a</span></span><br><span class="line">            System.out.println(???);<span class="comment">// 30答案：Outer.this.a</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-6-成员内部类内存图"><a href="#3-6-成员内部类内存图" class="headerlink" title="3.6 成员内部类内存图"></a>3.6 成员内部类内存图</h2><p><img src="/JavaNotes/%E7%B1%BB/img/%E5%86%85%E9%83%A8%E7%B1%BB%E5%86%85%E5%AD%98%E5%9B%BE.png" alt="内部类内存图"></p><h2 id="3-7-静态内部类"><a href="#3-7-静态内部类" class="headerlink" title="3.7 静态内部类"></a>3.7 静态内部类</h2><p><strong>静态内部类特点</strong>：</p><ul><li>静态内部类是一种特殊的成员内部类。</li></ul><ul><li>有static修饰，属于外部类本身的。</li><li>总结：静态内部类与其他类的用法完全一样。只是访问的时候需要加上外部类.内部类。</li><li><strong>拓展1</strong>:静态内部类可以直接访问外部类的静态成员。</li><li><strong>拓展2</strong>:静态内部类不可以直接访问外部类的非静态成员，如果要访问需要创建外部类的对象。</li><li><strong>拓展3</strong>:静态内部类中没有银行的Outer.this。</li></ul><p><strong>内部类的使用格式</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">外部类.内部类。</span><br></pre></td></tr></table></figure><p><strong>静态内部类对象的创建格式</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">外部类.内部类  变量 = <span class="keyword">new</span>  外部类.内部类构造器;</span><br></pre></td></tr></table></figure><p><strong>调用方法的格式：</strong></p><ul><li>调用非静态方法的格式：先创建对象，用对象调用</li><li>调用静态方法的格式：外部类名.内部类名.方法名();</li></ul><p><strong>案例演示</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 外部类：Outer01</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer01</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="type">String</span> <span class="variable">sc_name</span> <span class="operator">=</span> <span class="string">&quot;黑马程序&quot;</span>;</span><br><span class="line">    <span class="comment">// 内部类: Inner01</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner01</span>&#123;</span><br><span class="line">        <span class="comment">// 这里面的东西与类是完全一样的。</span></span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Inner01</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showName</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="built_in">this</span>.name);</span><br><span class="line">            <span class="comment">// 拓展:静态内部类可以直接访问外部类的静态成员。</span></span><br><span class="line">            System.out.println(sc_name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InnerClassDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建静态内部类对象。</span></span><br><span class="line">        <span class="comment">// 外部类.内部类  变量 = new  外部类.内部类构造器;</span></span><br><span class="line">        Outer01.<span class="type">Inner01</span> <span class="variable">in</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer01</span>.Inner01(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        in.showName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-8-局部内部类"><a href="#3-8-局部内部类" class="headerlink" title="3.8 局部内部类"></a>3.8 局部内部类</h2><ul><li><strong>局部内部类</strong> ：定义在<strong>方法中</strong>的类。</li></ul><p>定义格式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class 外部类名 &#123;</span><br><span class="line">数据类型 变量名;</span><br><span class="line"></span><br><span class="line">修饰符 返回值类型 方法名(参数列表) &#123;</span><br><span class="line"><span class="comment">// …</span></span><br><span class="line">class 内部类 &#123;</span><br><span class="line"><span class="comment">// 成员变量</span></span><br><span class="line"><span class="comment">// 成员方法</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-9-匿名内部类【重点】"><a href="#3-9-匿名内部类【重点】" class="headerlink" title="3.9 匿名内部类【重点】"></a>3.9 匿名内部类【重点】</h2><h3 id="3-9-1-概述"><a href="#3-9-1-概述" class="headerlink" title="3.9.1 概述"></a>3.9.1 概述</h3><p><strong>匿名内部类</strong> ：是内部类的简化写法。他是一个隐含了名字的内部类。开发中，最常用到的内部类就是匿名内部类了。</p><h3 id="3-9-2-格式"><a href="#3-9-2-格式" class="headerlink" title="3.9.2 格式"></a>3.9.2 格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名或者接口名() &#123;</span><br><span class="line">     重写方法;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>包含了：</p><ul><li><p>继承或者实现关系</p></li><li><p>方法重写</p></li><li><p>创建对象</p></li></ul><p>所以从语法上来讲，这个整体其实是匿名内部类对象</p><h3 id="3-9-2-什么时候用到匿名内部类"><a href="#3-9-2-什么时候用到匿名内部类" class="headerlink" title="3.9.2 什么时候用到匿名内部类"></a>3.9.2 什么时候用到匿名内部类</h3><p><strong>实际上，如果我们希望定义一个只要使用一次的类，就可考虑使用匿名内部类。匿名内部类的本质作用</strong></p><p><strong>是为了简化代码</strong>。 </p><p>之前我们使用接口时，似乎得做如下几步操作：</p><ol><li>定义子类</li><li>重写接口中的方法</li><li>创建子类对象</li><li>调用重写后的方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Swim</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">swimming</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 定义接口的实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Swim</span> &#123;</span><br><span class="line">    <span class="comment">// 2. 重写抽象方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swimming</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗刨式...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 3. 创建实现类对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="comment">// 4. 调用方法</span></span><br><span class="line">        s.swimming();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的目的，最终只是为了调用方法，那么能不能简化一下，把以上四步合成一步呢？匿名内部类就是做这样的快捷方式。</p><h3 id="3-9-3-匿名内部类前提和格式"><a href="#3-9-3-匿名内部类前提和格式" class="headerlink" title="3.9.3 匿名内部类前提和格式"></a>3.9.3 匿名内部类前提和格式</h3><p>匿名内部类必须<strong>继承一个父类</strong>或者<strong>实现一个父接口</strong>。</p><p><strong>匿名内部类格式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 父类名或者接口名()&#123;</span><br><span class="line">    <span class="comment">// 方法重写</span></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 执行语句</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-9-4-使用方式"><a href="#3-9-4-使用方式" class="headerlink" title="3.9.4 使用方式"></a>3.9.4 使用方式</h3><p>以接口为例，匿名内部类的使用，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Swim</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">swimming</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo07</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用匿名内部类</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Swim</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swimming</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;自由泳...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;.swimming();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接口 变量 = new 实现类(); // 多态,走子类的重写方法</span></span><br><span class="line">        <span class="type">Swim</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Swim</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swimming</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;蛙泳...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        s2.swimming();</span><br><span class="line">        s2.swimming();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-9-5-匿名内部类的特点"><a href="#3-9-5-匿名内部类的特点" class="headerlink" title="3.9.5 匿名内部类的特点"></a>3.9.5 匿名内部类的特点</h3><ol><li>定义一个没有名字的内部类</li><li>这个类实现了父类，或者父类接口</li><li>匿名内部类会创建这个没有名字的类的对象</li></ol><h3 id="3-9-6-匿名内部类的使用场景"><a href="#3-9-6-匿名内部类的使用场景" class="headerlink" title="3.9.6 匿名内部类的使用场景"></a>3.9.6 匿名内部类的使用场景</h3><p>通常在方法的形式参数是接口或者抽象类时，也可以将匿名内部类作为参数传递。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Swim</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">swimming</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo07</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 普通方式传入对象</span></span><br><span class="line">        <span class="comment">// 创建实现类对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        </span><br><span class="line">        goSwimming(s);</span><br><span class="line">        <span class="comment">// 匿名内部类使用场景:作为方法参数传递</span></span><br><span class="line">        <span class="type">Swim</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Swim</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swimming</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;蝶泳...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 传入匿名内部类</span></span><br><span class="line">        goSwimming(s3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 完美方案: 一步到位</span></span><br><span class="line">        goSwimming(<span class="keyword">new</span> <span class="title class_">Swim</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swimming</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;大学生, 蛙泳...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        goSwimming(<span class="keyword">new</span> <span class="title class_">Swim</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swimming</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;小学生, 自由泳...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个方法,模拟请一些人去游泳</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">goSwimming</span><span class="params">(Swim s)</span> &#123;</span><br><span class="line">        s.swimming();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Object Oriented </tag>
            
            <tag> Class </tag>
            
            <tag> Interface </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于计划与路线</title>
      <link href="/posts/c9a945f0.html"/>
      <url>/posts/c9a945f0.html</url>
      
        <content type="html"><![CDATA[<p><strong>那颗种子误以为只要浸润于河流，便能轻松发芽、成长，完全无视了生长的真实挑战。但是，阳光作为知识之源，揭示了真相：真正的成长需要在厚厚的土壤中深根、承受时而暴雨时而酷热的变化，与土中的生物共存，还要面对自然带来的不时之灾，如此，它才可能在将来盛开。然而，阳光虽然是生命的知识来源，但其所照亮的总是片面。在这个世界上，没有任何东西是真正完整的。或许，唯一接近完整的是深沉的黑暗。有些人选择信仰那些看似完整无缺的指引，如某些学校的战略培养或某个培训的路线，误以为它们能提供完美的答案。但往往，那些所谓的“完整”只是表面的，真正的知识与智慧仍需要在众多的光线中自己去探寻。</strong></p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p><strong>相对而言，那些完全依赖河流，似乎过得无忧无虑，因为它们认为只要沿着这一路径就能获得一切。但真相是，河流最后会汇入广阔、深不见底的海洋。那些只依赖河流的种子，最后可能会被石头损伤、被鱼儿捕食或被冲散。即使有些流入了海中，也已失去了自己的能量，最终变成海中的微尘。当它们意识到真正的生长机会已不复存在，那种迷失和无助便将它们困住，最终沦为命运的玩物。</strong></p><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><p><strong>生命的真谛告诉我们，纯粹的依赖与跟随并不能带来真正的收获。想要真正的成果，不如勇敢面对各种挑战，不论您是否面对挑战，它都存在。不是每个人都有勇气扎根于土壤深处，但许多人却渴望随波逐流达到广阔的大海并期望收获，这样的期待是不切实际的。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>API及常用String类</title>
      <link href="/posts/99345e84.html"/>
      <url>/posts/99345e84.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-API"><a href="#1-API" class="headerlink" title="1.API"></a>1.API</h2><h3 id="1-1API概述"><a href="#1-1API概述" class="headerlink" title="1.1API概述"></a>1.1API概述</h3><ul><li><p>什么是API</p><p>​API (Application Programming Interface) ：应用程序编程接口</p></li><li><p>java中的API</p><p>​指的就是 JDK 中提供的各种功能的 Java类，这些类将底层的实现封装了起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用即可，我们可以通过帮助文档来学习这些API如何使用。</p></li></ul><h3 id="1-2如何使用API帮助文档"><a href="#1-2如何使用API帮助文档" class="headerlink" title="1.2如何使用API帮助文档"></a>1.2如何使用API帮助文档</h3><ul><li>打开帮助文档</li></ul><p><img src="/JavaNotes/API/img/01.png" alt="01"></p><ul><li>找到索引选项卡中的输入框</li></ul><p><img src="/JavaNotes/API/img/02.png" alt="02"></p><ul><li>在输入框中输入Random</li></ul><p><img src="/JavaNotes/API/img/03.png" alt="03"></p><ul><li>看类在哪个包下</li></ul><p><img src="/JavaNotes/API/img/04.png" alt="04"></p><ul><li>看类的描述</li></ul><p><img src="/JavaNotes/API/img/05.png" alt="05"></p><ul><li>看构造方法</li></ul><p><img src="/JavaNotes/API/img/06.png" alt="06"></p><ul><li>看成员方法</li></ul><p><img src="/JavaNotes/API/img/07.png" alt="07"></p><h2 id="2-String类"><a href="#2-String类" class="headerlink" title="2.String类"></a>2.String类</h2><h3 id="2-1String类概述"><a href="#2-1String类概述" class="headerlink" title="2.1String类概述"></a>2.1String类概述</h3><p>​String 类代表字符串，Java 程序中的所有字符串文字（例如“abc”）都被实现为此类的实例。也就是说，Java 程序中所有的双引号字符串，都是 String 类的对象。String 类在 java.lang 包下，所以使用的时候不需要导包！</p><h3 id="2-2String类的特点"><a href="#2-2String类的特点" class="headerlink" title="2.2String类的特点"></a>2.2String类的特点</h3><ul><li>字符串不可变，它们的值在创建后不能被更改</li><li>虽然 String 的值是不可变的，但是它们可以被共享</li><li>字符串效果上相当于字符数组( char[] )，但是底层原理是字节数组( byte[] )</li></ul><h3 id="2-3String类的构造方法"><a href="#2-3String类的构造方法" class="headerlink" title="2.3String类的构造方法"></a>2.3String类的构造方法</h3><ul><li><p>常用的构造方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public   String()</td><td>创建一个空白字符串对象，不含有任何内容</td></tr><tr><td>public   String(char[] chs)</td><td>根据字符数组的内容，来创建字符串对象</td></tr><tr><td>public   String(byte[] bys)</td><td>根据字节数组的内容，来创建字符串对象</td></tr><tr><td>String s &#x3D;   “abc”;</td><td>直接赋值的方式创建字符串对象，内容就是abc</td></tr></tbody></table></li><li><p>示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//public String()：创建一个空白字符串对象，不含有任何内容</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;s1:&quot;</span> + s1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//public String(char[] chs)：根据字符数组的内容，来创建字符串对象</span></span><br><span class="line">        <span class="type">char</span>[] chs = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chs);</span><br><span class="line">        System.out.println(<span class="string">&quot;s2:&quot;</span> + s2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//public String(byte[] bys)：根据字节数组的内容，来创建字符串对象</span></span><br><span class="line">        <span class="type">byte</span>[] bys = &#123;<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>&#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bys);</span><br><span class="line">        System.out.println(<span class="string">&quot;s3:&quot;</span> + s3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//String s = “abc”;直接赋值的方式创建字符串对象，内容就是abc</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;s4:&quot;</span> + s4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-4创建字符串对象两种方式的区别"><a href="#2-4创建字符串对象两种方式的区别" class="headerlink" title="2.4创建字符串对象两种方式的区别"></a>2.4创建字符串对象两种方式的区别</h3><ul><li><p>通过构造方法创建</p><p>​通过 new 创建的字符串对象，每一次 new 都会申请一个内存空间，虽然内容相同，但是地址值不同</p></li><li><p>直接赋值方式创建</p><p>​以“”方式给出的字符串，只要字符序列相同(顺序和大小写)，无论在程序代码中出现几次，JVM 都只会建立一个 String 对象，并在字符串池中维护</p></li></ul><h3 id="2-5字符串的比较"><a href="#2-5字符串的比较" class="headerlink" title="2.5字符串的比较"></a>2.5字符串的比较</h3><h4 id="2-5-1-号的作用"><a href="#2-5-1-号的作用" class="headerlink" title="2.5.1&#x3D;&#x3D;号的作用"></a>2.5.1&#x3D;&#x3D;号的作用</h4><ul><li>比较基本数据类型：比较的是具体的值</li><li>比较引用数据类型：比较的是对象地址值</li></ul><h4 id="2-5-2equals方法的作用"><a href="#2-5-2equals方法的作用" class="headerlink" title="2.5.2equals方法的作用"></a>2.5.2equals方法的作用</h4><ul><li><p>方法介绍</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(String s)</span>     比较两个字符串内容是否相同、区分大小写</span><br></pre></td></tr></table></figure></li><li><p>示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//构造方法的方式得到对象</span></span><br><span class="line">        <span class="type">char</span>[] chs = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chs);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//直接赋值的方式得到对象</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//比较字符串对象地址是否相同</span></span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">        System.out.println(s1 == s3);</span><br><span class="line">        System.out.println(s3 == s4);</span><br><span class="line">        System.out.println(<span class="string">&quot;--------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//比较字符串内容是否相同</span></span><br><span class="line">        System.out.println(s1.equals(s2));</span><br><span class="line">        System.out.println(s1.equals(s3));</span><br><span class="line">        System.out.println(s3.equals(s4));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-6用户登录案例"><a href="#2-6用户登录案例" class="headerlink" title="2.6用户登录案例"></a>2.6用户登录案例</h3><h4 id="2-6-1案例需求"><a href="#2-6-1案例需求" class="headerlink" title="2.6.1案例需求"></a>2.6.1案例需求</h4><p>​已知用户名和密码，请用程序实现模拟用户登录。总共给三次机会，登录之后，给出相应的提示</p><h4 id="2-6-2代码实现"><a href="#2-6-2代码实现" class="headerlink" title="2.6.2代码实现"></a>2.6.2代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span>登录案例 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.定义两个变量用来记录正确的用户名和密码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">rightUsername</span> <span class="operator">=</span> <span class="string">&quot;itheima&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">rightPassword</span> <span class="operator">=</span> <span class="string">&quot;1234qwer&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.键盘录入用户名和密码</span></span><br><span class="line">        <span class="comment">//ctrl + alt + T 选择包裹方式</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;<span class="comment">//0 1 2</span></span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入用户名&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> sc.next();</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入密码&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> sc.next();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.判断比较</span></span><br><span class="line">            <span class="keyword">if</span> (username.equals(rightUsername) &amp;&amp; password.equals(rightPassword)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">                <span class="comment">//如果正确，循环结束</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//最后一次机会</span></span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">2</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;账户&quot;</span> + username + <span class="string">&quot;被锁定，请联系黑马程序员官方小姐姐：XXXXXXX&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//不是最后一次机会</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;用户名或密码错误，登录失败,还剩下&quot;</span> + (<span class="number">2</span> - i) + <span class="string">&quot;次机会&quot;</span>);<span class="comment">//2 1 0</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-7遍历字符串案例"><a href="#2-7遍历字符串案例" class="headerlink" title="2.7遍历字符串案例"></a>2.7遍历字符串案例</h3><h4 id="2-7-1案例需求"><a href="#2-7-1案例需求" class="headerlink" title="2.7.1案例需求"></a>2.7.1案例需求</h4><p>​键盘录入一个字符串，使用程序实现在控制台遍历该字符串</p><h4 id="2-7-2直接遍历字符串"><a href="#2-7-2直接遍历字符串" class="headerlink" title="2.7.2直接遍历字符串"></a>2.7.2直接遍历字符串</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span>字符串直接遍历 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//两个方法：</span></span><br><span class="line">        <span class="comment">//charAt()：会根据索引获取对应的字符</span></span><br><span class="line">        <span class="comment">//length(): 会返回字符串的长度</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.键盘录入一个字符串</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入字符串&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sc.next();</span><br><span class="line">        System.out.println(str);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="comment">//i 依次表示字符串的每一个索引</span></span><br><span class="line">            <span class="comment">//索引的范围：0 ~  长度-1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//根据索引获取字符串里面的每一个字符</span></span><br><span class="line">            <span class="comment">//ctrl + alt + V 自动生成左边的接受变量</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> str.charAt(i);</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-8统计字符次数案例"><a href="#2-8统计字符次数案例" class="headerlink" title="2.8统计字符次数案例"></a>2.8统计字符次数案例</h3><h4 id="2-8-1案例需求"><a href="#2-8-1案例需求" class="headerlink" title="2.8.1案例需求"></a>2.8.1案例需求</h4><p>​键盘录入一个字符串，统计该字符串中大写字母字符，小写字母字符，数字字符出现的次数(不考虑其他字符)</p><h4 id="2-8-2代码实现"><a href="#2-8-2代码实现" class="headerlink" title="2.8.2代码实现"></a>2.8.2代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test4</span>统计个数 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//键盘录入一个字符串，统计大写，小写，数字出现的次数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.键盘录入一个字符串</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入一个字符串&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sc.next();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.统计 --- 计数器count</span></span><br><span class="line">        <span class="comment">//此时我要统计的有3样东西，所以要定义3个计数器分别进行统计</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">bigCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">smallCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">numberCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//得到这个字符串里面每一个字符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="comment">//i 表示字符串中的索引</span></span><br><span class="line">            <span class="comment">//c 表示字符串中的每一个字符</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> str.charAt(i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//对c进行判断</span></span><br><span class="line">            <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span>) &#123;</span><br><span class="line">                smallCount++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span>)&#123;</span><br><span class="line">                bigCount++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                numberCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.当循环结束之后，三个变量记录的就是对应的个数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;大写字符有:&quot;</span> + bigCount + <span class="string">&quot;个&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;小写字符有:&quot;</span> + smallCount + <span class="string">&quot;个&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;数字字符有:&quot;</span> + numberCount + <span class="string">&quot;个&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-9字符串拼接案例"><a href="#2-9字符串拼接案例" class="headerlink" title="2.9字符串拼接案例"></a>2.9字符串拼接案例</h3><h4 id="2-9-1案例需求"><a href="#2-9-1案例需求" class="headerlink" title="2.9.1案例需求"></a>2.9.1案例需求</h4><p>​定义一个方法，把 int 数组中的数据按照指定的格式拼接成一个字符串返回，调用该方法，</p><p>​并在控制台输出结果。例如，数组为 int[] arr &#x3D; {1,2,3}; ，执行方法后的输出结果为：[1, 2, 3]</p><h4 id="2-9-2代码实现"><a href="#2-9-2代码实现" class="headerlink" title="2.9.2代码实现"></a>2.9.2代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test5</span>数组拼接成字符串 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//定义一个方法，把 int 数组中的数据按照指定的格式拼接成一个字符串返回，调用该方法，</span></span><br><span class="line">        <span class="comment">//并在控制台输出结果。例如，数组为 int[] arr = &#123;1,2,3&#125;;</span></span><br><span class="line">        <span class="comment">//执行方法后的输出结果为：[1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> arrToString(arr);</span><br><span class="line">        System.out.println(str);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//作用：把一个数组变成字符串</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">arrToString</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">//拼接左括号</span></span><br><span class="line">        s = s + <span class="string">&quot;[&quot;</span>; <span class="comment">//此时是拿着长度为0的字符串，跟[进行拼接，产生一个新的字符串。</span></span><br><span class="line">        <span class="comment">//把新的字符串再赋值给s，此时变量s记录的就是新的字符串&quot;[&quot;的地址值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//下面我想得到数组里面的每一个元素并进行拼接</span></span><br><span class="line">        <span class="comment">//那么就需要遍历数组，得到每一个元素才行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">//假设第一次循环:i = 0 获取的就是0索引上的元素</span></span><br><span class="line">            <span class="comment">//在拼接的时候：&quot;[&quot; + 1 + &quot;, &quot; 拼接完毕之后产生一个新的字符串 &quot;[1, &quot;</span></span><br><span class="line">            <span class="comment">//第二次循环：i = 1 获取的就是1索引上的元素</span></span><br><span class="line">            <span class="comment">//在拼接的时候： 此时s就是第一次循环结束后拼接完毕的结果：&quot;[1, &quot;</span></span><br><span class="line">            <span class="comment">//在拼接的时候：&quot;[1, &quot; + 2 + &quot;, &quot; 拼接完毕之后产生一个新的字符串 &quot;[1, 2, &quot;</span></span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">           <span class="keyword">if</span>(i == arr.length - <span class="number">1</span>)&#123;</span><br><span class="line">               <span class="comment">//如果是最后一个元素，那么不需要拼接逗号空格</span></span><br><span class="line">               s = s + arr[i];</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="comment">//如果不是最后一个元素，需要拼接元素和逗号空格</span></span><br><span class="line">               s = s + arr[i] + <span class="string">&quot;, &quot;</span>;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//等循环结束之后，再拼接最后一个右括号</span></span><br><span class="line">        s = s + <span class="string">&quot;]&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//用来遍历数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printArr</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == arr.length - <span class="number">1</span>) &#123;</span><br><span class="line">                System.out.print(arr[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.print(arr[i] + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;]&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//[1, 2, 3, 4, 5]</span></span><br><span class="line">        <span class="comment">//我们现在要知道，这个最终结果是怎么来的？</span></span><br><span class="line">        <span class="comment">//从到右依次打印得来的。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-10字符串反转案例"><a href="#2-10字符串反转案例" class="headerlink" title="2.10字符串反转案例"></a>2.10字符串反转案例</h3><h4 id="2-10-1案例需求"><a href="#2-10-1案例需求" class="headerlink" title="2.10.1案例需求"></a>2.10.1案例需求</h4><p>​定义一个方法，实现字符串反转。键盘录入一个字符串，调用该方法后，在控制台输出结果</p><p>​例如，键盘录入 abc，输出结果 cba</p><h4 id="2-10-2代码实现"><a href="#2-10-2代码实现" class="headerlink" title="2.10.2代码实现"></a>2.10.2代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test6</span>反转字符串 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*定义一个方法，实现字符串反转。键盘录入一个字符串，调用该方法后，在控制台输出结果</span></span><br><span class="line"><span class="comment">        例如，键盘录入 abc，输出结果 cba*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.定义一个字符串</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入一个字符串&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sc.next();</span><br><span class="line">        <span class="comment">//2.定义一个方法，反转字符串</span></span><br><span class="line">        <span class="comment">//abc  ---&gt;  cba</span></span><br><span class="line">        <span class="comment">//可以把字符串倒着遍历，再拼接</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> reverse(str);</span><br><span class="line">        System.out.println(result);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注释：方法的作用就是反转字符串</span></span><br><span class="line">    <span class="comment">//把传递进来的字符串进行反转</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">reverse</span><span class="params">(String str)</span>&#123;<span class="comment">//abc</span></span><br><span class="line">        <span class="comment">//核心思想：倒着遍历并进行拼接就可以了</span></span><br><span class="line">        <span class="comment">//fori :正着遍历  forr：倒着遍历</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> str.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">//i 依次表示字符串里面的每一个索引（倒着的）</span></span><br><span class="line">            <span class="comment">//我们就可以拿到里面的每一个字符并拼接</span></span><br><span class="line">            s = s + str.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把倒着拼接之后的结果返回即可</span></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-11-金额转换"><a href="#2-11-金额转换" class="headerlink" title="2.11 金额转换"></a>2.11 金额转换</h3><h4 id="2-11-1-案例需求"><a href="#2-11-1-案例需求" class="headerlink" title="2.11.1 案例需求"></a>2.11.1 案例需求</h4><p>​把2135变成：零佰零拾零万贰仟壹佰叁拾伍元 </p><p>​把789变成：零佰零拾零万零仟柒佰捌拾玖元</p><h4 id="2-11-2-代码实现"><a href="#2-11-2-代码实现" class="headerlink" title="2.11.2 代码实现"></a>2.11.2 代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.stringdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringDemo9</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.键盘录入一个金额</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> money;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请录入一个金额&quot;</span>);</span><br><span class="line">            money = sc.nextInt();</span><br><span class="line">            <span class="keyword">if</span> (money &gt;= <span class="number">0</span> &amp;&amp; money &lt;= <span class="number">9999999</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;金额无效&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个变量用来表示钱的大写</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">moneyStr</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.得到money里面的每一位数字,再转成中文</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;<span class="comment">//2135</span></span><br><span class="line">            <span class="comment">//从右往左获取数据，因为右侧是数据的个位</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">ge</span> <span class="operator">=</span> money % <span class="number">10</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">capitalNumber</span> <span class="operator">=</span> getCapitalNumber(ge);</span><br><span class="line">            <span class="comment">//把转换之后的大写拼接到moneyStr当中</span></span><br><span class="line">            moneyStr = capitalNumber + moneyStr;</span><br><span class="line">            <span class="comment">//第一次循环 ： &quot;伍&quot; + &quot;&quot; = &quot;伍&quot;</span></span><br><span class="line">            <span class="comment">//第二次循环 ： &quot;叁&quot; + &quot;伍&quot; = &quot;叁伍&quot;</span></span><br><span class="line">            <span class="comment">//去掉刚刚获取的数据</span></span><br><span class="line">            money = money / <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果数字上的每一位全部获取到了，那么money记录的就是0，此时循环结束</span></span><br><span class="line">            <span class="keyword">if</span> (money == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.在前面补0，补齐7位</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">7</span> - moneyStr.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            moneyStr = <span class="string">&quot;零&quot;</span> + moneyStr;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(moneyStr);<span class="comment">//零零零贰壹叁伍</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.插入单位</span></span><br><span class="line">        <span class="comment">//定义一个数组表示单位</span></span><br><span class="line">        String[] arr = &#123;<span class="string">&quot;佰&quot;</span>,<span class="string">&quot;拾&quot;</span>,<span class="string">&quot;万&quot;</span>,<span class="string">&quot;仟&quot;</span>,<span class="string">&quot;佰&quot;</span>,<span class="string">&quot;拾&quot;</span>,<span class="string">&quot;元&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">//               零    零   零   贰   壹   叁   伍</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历moneyStr，依次得到 零    零   零   贰   壹   叁   伍</span></span><br><span class="line">        <span class="comment">//然后把arr的单位插入进去</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; moneyStr.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> moneyStr.charAt(i);</span><br><span class="line">            <span class="comment">//把大写数字和单位拼接到result当中</span></span><br><span class="line">            result = result + c + arr[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.打印最终结果</span></span><br><span class="line">        System.out.println(result);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个方法把数字变成大写的中文</span></span><br><span class="line">    <span class="comment">//1 -- 壹</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getCapitalNumber</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">        <span class="comment">//定义数组，让数字跟大写的中文产生一个对应关系</span></span><br><span class="line">        String[] arr = &#123;<span class="string">&quot;零&quot;</span>, <span class="string">&quot;壹&quot;</span>, <span class="string">&quot;贰&quot;</span>, <span class="string">&quot;叁&quot;</span>, <span class="string">&quot;肆&quot;</span>, <span class="string">&quot;伍&quot;</span>, <span class="string">&quot;陆&quot;</span>, <span class="string">&quot;柒&quot;</span>, <span class="string">&quot;捌&quot;</span>, <span class="string">&quot;玖&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">//返回结果</span></span><br><span class="line">        <span class="keyword">return</span> arr[number];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-12-手机号屏蔽"><a href="#2-12-手机号屏蔽" class="headerlink" title="2.12 手机号屏蔽"></a>2.12 手机号屏蔽</h3><p>需求：以字符串的形式从键盘接受一个手机号，将中间四位号码屏蔽</p><p>最终效果为：<code>131****9468</code></p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test8</span>手机号屏蔽 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*以字符串的形式从键盘接受一个手机号，将中间四位号码屏蔽</span></span><br><span class="line"><span class="comment">        最终效果为：131****9468*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.键盘录入一个手机号码</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入手机号码&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">phoneNumber</span> <span class="operator">=</span> sc.next();<span class="comment">//13112349408</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.截取手机号码中的前三位</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">star</span> <span class="operator">=</span> phoneNumber.substring(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.截取手机号码中的最后四位</span></span><br><span class="line">        <span class="comment">//此时我用substring方法，是用1个参数的，还是两个参数的？1个参数的会更好</span></span><br><span class="line">        <span class="comment">//因为现在我要截取到最后，所以建议使用1个参数的。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">end</span> <span class="operator">=</span> phoneNumber.substring(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.拼接</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> star + <span class="string">&quot;****&quot;</span> + end;</span><br><span class="line"></span><br><span class="line">        System.out.println(result);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-13-敏感词替换"><a href="#2-13-敏感词替换" class="headerlink" title="2.13 敏感词替换"></a>2.13 敏感词替换</h3><p>需求1：键盘录入一个 字符串，如果字符串中包含（TMD），则使用***替换 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test9</span>敏感词替换 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.定义一个变量表示骂人的话</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">talk</span> <span class="operator">=</span> <span class="string">&quot;后裔你玩什么啊，TMD&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.把这句话中的敏感词进行替换</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> talk.replace(<span class="string">&quot;TMD&quot;</span>, <span class="string">&quot;***&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.打印</span></span><br><span class="line">        System.out.println(talk);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>需求2：如果要替换的敏感词比较多怎么办？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test10</span>多个敏感词替换 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//实际开发中，敏感词会有很多很多</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.先键盘录入要说的话</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入要说的话&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">talk</span> <span class="operator">=</span> sc.next();<span class="comment">//后裔你玩什么啊，TMD,GDX,ctmd,ZZ</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.定义一个数组用来存多个敏感词</span></span><br><span class="line">        String[] arr = &#123;<span class="string">&quot;TMD&quot;</span>,<span class="string">&quot;GDX&quot;</span>,<span class="string">&quot;ctmd&quot;</span>,<span class="string">&quot;ZZ&quot;</span>,<span class="string">&quot;lj&quot;</span>,<span class="string">&quot;FW&quot;</span>,<span class="string">&quot;nt&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.把说的话中所有的敏感词都替换为***</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">//i 索引</span></span><br><span class="line">            <span class="comment">//arr[i] 元素 --- 敏感词</span></span><br><span class="line">            talk = talk.replace(arr[i],<span class="string">&quot;***&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.打印结果</span></span><br><span class="line">        System.out.println(talk);<span class="comment">//后裔你玩什么啊，***,***,***,***</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-14-身份证信息查看"><a href="#2-14-身份证信息查看" class="headerlink" title="2.14 身份证信息查看"></a>2.14 身份证信息查看</h3><p>​身份证的每一位都是有固定的含义：</p><ul><li>1、2位：省份 </li><li>3、4位：城市 </li><li>5、6位：区县 </li><li>7-14位：出生年、月、日 </li><li>15、16位：所在地派出所 </li><li>17位：性别（奇数男性，偶数女性）</li><li>18位：个人信息码（随机产生）</li></ul><p>要求打印内容方式如下：</p><p>​人物信息为：</p><p>​出生年月日：XXXX年X月X日</p><p>​性别为：男&#x2F;女</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.stringdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringDemo11</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.定义一个字符串记录身份证号码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> <span class="string">&quot;321281202001011234&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取出生年月日</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">year</span> <span class="operator">=</span> id.substring(<span class="number">6</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">month</span> <span class="operator">=</span> id.substring(<span class="number">10</span>, <span class="number">12</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">day</span> <span class="operator">=</span> id.substring(<span class="number">12</span>, <span class="number">14</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;人物信息为：&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;出生年月日:&quot;</span> + year + <span class="string">&quot;年&quot;</span> + month + <span class="string">&quot;月&quot;</span> + day + <span class="string">&quot;日&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.获取性别</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">gender</span> <span class="operator">=</span> id.charAt(<span class="number">16</span>);<span class="comment">//&#x27;3&#x27;  ---&gt; 3</span></span><br><span class="line">        <span class="comment">//利用ASCII码表进行转换</span></span><br><span class="line">        <span class="comment">//&#x27;0&#x27; ---&gt;  48</span></span><br><span class="line">        <span class="comment">//&#x27;1&#x27; ---&gt;  49</span></span><br><span class="line">        <span class="comment">//&#x27;2&#x27; ---&gt;  50</span></span><br><span class="line">        <span class="comment">//&#x27;3&#x27; ---&gt;  51</span></span><br><span class="line">        <span class="comment">//&#x27;4&#x27; ---&gt;  52</span></span><br><span class="line">        <span class="comment">//&#x27;5&#x27; ---&gt;  53</span></span><br><span class="line">        <span class="comment">//&#x27;6&#x27; ---&gt;  54</span></span><br><span class="line">        <span class="comment">//&#x27;7&#x27; ---&gt;  55</span></span><br><span class="line">        <span class="comment">//&#x27;8&#x27; ---&gt;  56</span></span><br><span class="line">        <span class="comment">//&#x27;9&#x27; ---&gt;  57</span></span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> gender - <span class="number">48</span>;</span><br><span class="line">        <span class="keyword">if</span>(num % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;性别为:女&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;性别为:男&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-StringBuilder"><a href="#3-StringBuilder" class="headerlink" title="3.StringBuilder"></a>3.StringBuilder</h2><p>StringBuilder 可以看成是一个容器，创建之后里面的内容是可变的。</p><p>当我们在拼接字符串和反转字符串的时候会使用到</p><h3 id="3-1-基本使用"><a href="#3-1-基本使用" class="headerlink" title="3.1 基本使用"></a>3.1 基本使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringBuilderDemo3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建对象</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.添加元素</span></span><br><span class="line">        <span class="comment">/*sb.append(1);</span></span><br><span class="line"><span class="comment">        sb.append(2.3);</span></span><br><span class="line"><span class="comment">        sb.append(true);*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//反转</span></span><br><span class="line">        sb.reverse();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> sb.length();</span><br><span class="line">        System.out.println(len);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印</span></span><br><span class="line">        <span class="comment">//普及：</span></span><br><span class="line">        <span class="comment">//因为StringBuilder是Java已经写好的类</span></span><br><span class="line">        <span class="comment">//java在底层对他做了一些特殊处理。</span></span><br><span class="line">        <span class="comment">//打印对象不是地址值而是属性值。</span></span><br><span class="line">        System.out.println(sb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-链式编程"><a href="#3-2-链式编程" class="headerlink" title="3.2 链式编程"></a>3.2 链式编程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringBuilderDemo4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建对象</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.添加字符串</span></span><br><span class="line">        sb.append(<span class="string">&quot;aaa&quot;</span>).append(<span class="string">&quot;bbb&quot;</span>).append(<span class="string">&quot;ccc&quot;</span>).append(<span class="string">&quot;ddd&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(sb);<span class="comment">//aaabbbcccddd</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.再把StringBuilder变回字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">        System.out.println(str);<span class="comment">//aaabbbcccddd</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-练习1：对称字符串"><a href="#3-3-练习1：对称字符串" class="headerlink" title="3.3 练习1：对称字符串"></a>3.3 练习1：对称字符串</h3><p>需求：</p><p>​键盘接受一个字符串，程序判断出该字符串是否是对称字符串，并在控制台打印是或不是</p><pre><code>  对称字符串：123321、111    非对称字符串：123123</code></pre><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringBuilderDemo6</span> &#123;</span><br><span class="line">    <span class="comment">//使用StringBuilder的场景：</span></span><br><span class="line">    <span class="comment">//1.字符串的拼接</span></span><br><span class="line">    <span class="comment">//2.字符串的反转</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.键盘录入一个字符串</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入一个字符串&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sc.next();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.反转键盘录入的字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>().append(str).reverse().toString();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.比较</span></span><br><span class="line">        <span class="keyword">if</span>(str.equals(result))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前字符串是对称字符串&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前字符串不是对称字符串&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-4-练习2：拼接字符串"><a href="#3-4-练习2：拼接字符串" class="headerlink" title="3.4 练习2：拼接字符串"></a>3.4 练习2：拼接字符串</h3><p>需求：定义一个方法，把 int 数组中的数据按照指定的格式拼接成一个字符串返回。</p><p>​          调用该方法，并在控制台输出结果。</p><p>​          例如：数组为int[] arr &#x3D; {1,2,3}; </p><p>​          执行方法后的输出结果为：[1, 2, 3]</p><p>代码示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.stringbuilderdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringBuilderDemo7</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.定义数组</span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.调用方法把数组变成字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> arrToString(arr);</span><br><span class="line"></span><br><span class="line">        System.out.println(str);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">arrToString</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        sb.append(<span class="string">&quot;[&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == arr.length - <span class="number">1</span>)&#123;</span><br><span class="line">                sb.append(arr[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sb.append(arr[i]).append(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-StringJoiner"><a href="#4-StringJoiner" class="headerlink" title="4. StringJoiner"></a>4. StringJoiner</h2><ul><li>StringJoiner跟StringBuilder一样，也可以看成是一个容器，创建之后里面的内容是可变的。</li><li>作用：提高字符串的操作效率，而且代码编写特别简洁，但是目前市场上很少有人用。 </li><li>JDK8出现的</li></ul><p>基本使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建一个对象，并指定中间的间隔符号</span></span><br><span class="line"><span class="type">StringJoiner</span> <span class="variable">sj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringJoiner</span>(<span class="string">&quot;---&quot;</span>);</span><br><span class="line"><span class="comment">//2.添加元素</span></span><br><span class="line">sj.add(<span class="string">&quot;aaa&quot;</span>).add(<span class="string">&quot;bbb&quot;</span>).add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line"><span class="comment">//3.打印结果</span></span><br><span class="line">System.out.println(sj);<span class="comment">//aaa---bbb---ccc</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建对象</span></span><br><span class="line"><span class="type">StringJoiner</span> <span class="variable">sj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringJoiner</span>(<span class="string">&quot;, &quot;</span>,<span class="string">&quot;[&quot;</span>,<span class="string">&quot;]&quot;</span>);</span><br><span class="line"><span class="comment">//2.添加元素</span></span><br><span class="line">sj.add(<span class="string">&quot;aaa&quot;</span>).add(<span class="string">&quot;bbb&quot;</span>).add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> sj.length();</span><br><span class="line">System.out.println(len);<span class="comment">//15</span></span><br><span class="line"><span class="comment">//3.打印</span></span><br><span class="line">System.out.println(sj);<span class="comment">//[aaa, bbb, ccc]</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sj.toString();</span><br><span class="line">System.out.println(str);<span class="comment">//[aaa, bbb, ccc]</span></span><br></pre></td></tr></table></figure><h2 id="关于字符串的小扩展："><a href="#关于字符串的小扩展：" class="headerlink" title="关于字符串的小扩展："></a>关于字符串的小扩展：</h2><ol><li><p>字符串存储的内存原理</p><p>String s &#x3D; “abc”；直接赋值</p><p>特点：</p><p>​此时字符串abc是存在字符串常量池中的。</p><p>​先检查字符串常量池中有没有字符串abc，如果有，不会创建新的，而是直接复用。如果没有abc，才会创建一个新的。</p><p>所以，直接赋值的方式，代码简单，而且节约内存。</p></li><li><p>new出来的字符串</p><p>看到new关键字，一定是在堆里面开辟了一个小空间。</p><p>String s1 &#x3D; new String（“abc”）；</p><p>String s2 &#x3D; “abc”；</p><p>s1记录的是new出来的，在堆里面的地址值。</p><p>s2是直接赋值的，所以记录的是字符串常量池中的地址值。</p></li><li><p>&#x3D;&#x3D;号比较的到底是什么？</p><p>如果比较的是基本数据类型：比的是具体的数值是否相等。</p><p>如果比较的是引用数据类型：比的是地址值是否相等。</p><p>结论：&#x3D;&#x3D;只能用于比较基本数据类型。不能比较引用数据类型。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
            <tag> API </tag>
            
            <tag> String </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>啊对对对</title>
      <link href="/posts/a42a779d.html"/>
      <url>/posts/a42a779d.html</url>
      
        <content type="html"><![CDATA[<p><strong>越来越觉得《啊对对对》是人生路上不可不熟练掌握的法宝之一。</strong></p><p><img src="/JavaNotes/essayImg/addd.gif"></p><p><strong>假如对方的观点是对的，对方的知识面比你辽阔很多，《啊对对对》是一种态度，（不是一直复读这四个字）你表现出来的受教态度会让对方也感到高兴，这也是聊天进行下去的保障。</strong></p><p><strong>假如对方的观点是错的。首先，你认为对方是错的是基于《自己是对的》来思考的，对方的视角也认为《自己是对的》。开口驳斥，在温和的人之间只是讨论，遇到性子急或缺乏文化修养的人，可能会引发不愉快。而你选择《啊对对对》，能同时保证双方的自尊，也能保证这场对话的和平。你要对对方的观点里正确的那部分表示出些许认同，如果有可能的话旁敲侧击一下（旁敲侧击不是阴阳怪气）。</strong></p><p><strong>退一步说，和不同的人聊天可以采集很多不同的观点，有可能当时你觉得对方是错的，事后你通过查阅资料，或是亲身经历，发现对方才是对的，是你错了。这种时候就更体现出当时《啊对对对》的重要性。</strong><br><strong>如果你当时反驳对方，事后又发现错的是自己，那必然是一段尴尬的回忆。</strong></p><p><strong>《啊对对对》不是要你聊天的时候一直复读这四个字，这是一种温和谦虚乐于接受的态度，这能让你和绝大多数人都保持良好的对话环境，即便你们有着巨大的思想差异。《啊对对对》背后还保留了一种求同存异的思想。</strong><br><strong>至于为什么总惦记着《啊对对对》这四个字，因为我发现和长辈，和出租车师傅，餐馆老板……聊天的时候，“啊……啊（语气变化）”和“对对对”这些字眼确实是最常用的。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
